roSocketAddress
===============

The roSocketAddress is used by the roStreamSocket and roDataGramSocket components for TCP and UDP traffic respectively.

This object is created without any arguments:

`CreateObject("roSocketAddress")`

Methods in [ifSocketAddress](/docs/references/brightscript/interfaces/ifsocketaddress.md "ifSocketAddress") are used to assign an IP address to the object. roSocketAddress currently supports only IPV4 addresses.

Supported interfaces
--------------------

*   [ifSocketAddress](/docs/references/brightscript/interfaces/ifsocketaddress.md "ifSocketAddress")

roXMLElement
============

roXMLElement is used to contain an XML tree.

For instance,

    <tag1>this is some text</tag1>
    

Would parse such that:

        Name = "tag1"
        Attributes = invalid
        Body = roString with "this is some text"
    

**Example**

    <emptytag caveman="barney" /> 
    

Would parse such that:

        Name = "emptytag"
        Attributes = roAssociativeArray, with one entry { caveman: "barney" }
        Body = invalid
    

If the tag contains other tags, body will be of type roXMLList.

To generate XML, create an roXMLElement, then use functions like SetName(), AddAttribute(), SetBody(), AddElementWithBody(), AddElement(), AddBodyElement(), and AddText() functions to build the XML object hierarchy.

Then call GenXML() to return the XML as a string.

GenXML() takes one parameter (boolean) that indicates whether the generated xml should have the <?xml …> tag at the top.

**Example: Subroutine to print out the contents of an roXMLElement tree**

    PrintXML(root, 0)
    
    Sub PrintXML(element As Object, depth As Integer)
        print tab(depth*3);"Name: ";element.GetName()
        if not element.GetAttributes().IsEmpty() then
            print tab(depth*3);"Attributes: ";
            for each a in element.GetAttributes()
                print a;"=";left(element.GetAttributes()[a], 20);
                if element.GetAttributes().IsNext() then print ", ";
            end for
            print
        end if
        if element.GetText()<>invalid then
            print tab(depth*3);"Contains Text: ";left(element.GetText(), 40)
        end if
        if element.GetChildElements()<>invalid
            print tab(depth*3);"Contains roXMLList:"
            for each e in element.GetChildElements()
                PrintXML(e, depth+1)
            end for
        end if
        print
    end sub
    

**Example: Generating XML**

    root.SetName("myroot")
    root.AddAttribute("key1", "value1")
    root.AddAttribute("key2", "value2")
    ne = root.AddBodyElement()
    ne.SetName("sub")
    ne.SetBody("this is the sub1 text")
    ne = root.AddBodyElement()
    ne.SetName("subelement2")
    ne.SetBody("more sub text")
    ne.AddAttribute("k", "v")
    ne = root.AddElement("subelement3")
    ne.SetBody("more sub text 3")
    root.AddElementWithBody("sub", "another sub (#4)")
    PrintXML(root, 0)
    print root.GenXML(false)
    

Supported interfaces
--------------------

*   [ifXMLElement](/docs/references/brightscript/interfaces/ifxmlelement.md "ifXMLElement")

Designing Roku apps
===================

This document highlights Roku's approach to UIs for streaming media, with progressive levels of requirements which are crucial to pass Roku's app certification process, as well as create a well-designed Roku app. While apps that do not implement all best practices may still be deployed on the Roku platform, the practices outlined here are known to improve the user experience, which directly affects the engagement and value of your app on the Roku platform.

This Design section describes the following topics:

*   What to keep in mind when designing for a TV UI.
*   What are the proven design principles and guidelines Roku uses when designing UIs that
    
    *   Are, simple, powerful, useful, and familiar?
    *   Encourage more TV viewing?
    *   Have high customer satisfaction (NPS)?
*   What are the best practices for designing Roku apps?
    
    *   Roku has a developer program comprising of various UI components – how are they expected to be used?
    *   What are the key features that streaming users expect in a good Roku app?
*   What does Roku require for app certification?
    
    *   Some features and UI paradigms are required because the Roku brand represents a certain expectation of quality and usability for the customers.
        
        *   E.g., Require Instant Replay buttons support and specific trick mode features

ifAudioResource
===============

Implemented by
--------------

| Name | Description |
| --- | --- |
| [roAudioResource](/docs/references/brightscript/components/roaudioresource.md "roAudioResource") | The roAudioResouce allows .wav files to be cached to memory and quickly played at any time |

Supported methods
-----------------

### Trigger(volume as Integer) as Void

#### Description

This method triggers the start of the audio resource sound playback. The effect of Trigger(volume) is identical to Trigger(volume, 0).

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| volume | Integer | The volume is a number between 0 and 100 (percentage of full volume). A value of 50 should be used for normal volume. |

### Trigger(volume as Integer, index as Integer) as Void

#### Description

Triggers the start of the audio resource sound playback. This method will interrupt any playing sound when the index is the same. It will mix with any playing sound if the index is different.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| volume | Integer | The volume is a number between 0 and 100 (percentage of full volume). 50 should be used for normal volume. |
| index | Integer | The index is a value between 0 and [MaxSimulStreams()](#maxsimulstreams-as-integer) allowing for multiple sounds to be mixed. |

### IsPlaying() as Boolean

#### Description

Checks whether this audio resource is currently playing.

#### Return Value

A flag indicating whether the calling audio resource is playing.

### Stop() as Void

#### Description

Stops playing the audio resource. If the resource is not currently playing, has no effect.

### MaxSimulStreams() as Integer

#### Description

Returns the device-dependent maximum number of audio streams that can be mixed together and presented simultaneously.

#### Return Value

Typically, 1-2.

### GetMetaData() as Object

#### Description

Returns an [roAssociativeArray](/docs/references/brightscript/components/roassociativearray.md "roAssociativeArray") array containing the indicated metadata parameters about the audio resource.

#### Return Value

An associative array with the following integer values:

*   Length (number of samples)
*   SamplesPerSecond
*   NumChannels
*   BitsPerSample

ifRegion
========

Implemented by
--------------

| Name | Description |
| --- | --- |
| [roRegion](/docs/references/brightscript/components/roregion.md "roRegion") | The roRegion component is used to represent a subsection of a bitmap |

Supported methods
-----------------

### GetBitmap() as Object

#### Description

Returns the roBitmap object of the bitmap to which this region refers. A region is always a section of a bitmap.

#### Return Value

An roBitmap object of the bitmap.

### GetX() as Integer

#### Description

Returns the x coordinate of the region in its bitmap.

#### Return Value

The x coordinate value

### GetY() as Integer

#### Description

Returns the y coordinate of the region in its bitmap.

#### Return Value

The y coordinate value

### GetWidth() as Integer

#### Description

Returns the width of the region.

#### Return Value

The width of the region.

### GetHeight() as Integer

#### Description

Returns the height of the region.

#### Return Value

The height of the region.

### Offset(x as Dynamic, y as Dynamic, w as Dynamic, h as Dynamic) as Void

#### Description

Adds the passed parameters x,y, w, and h to the values of those roRegion fields. Respects the wrap setting when adjusting the fields by the offsets.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| x   | Dynamic | The x-coordinate of the region. |
| y   | Dynamic | The y-coordinate of the region. |
| w   | Dynamic | The width of the region. |
| h   | Dynamic | The height of the region. |

### Set(srcRegion as Object) as Void

#### Description

Initializes the fields of this region to be the same as the values of the fields in the srcRegion.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| srcRegion | Object | An roRegion object. |

### Copy() as Object

#### Description

Returns a newly created copy of the region as a new [roRegion](/docs/references/brightscript/components/roregion.md "roRegion") object.

#### Return Value

An roRegion Object.

### SetWrap(wrap as Boolean) as Void

#### Description

Wraps any part of a region that extends beyond the bounds of its bitmap to the other side of the bitmap and renders it there.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| wrap | Boolean | A flag specifying whether wrapping of the region is enabled. If this flag is set to false, the part of the region beyond the bounds of its bitmap is not rendered. |

### GetWrap() as Boolean

#### Description

Returns if the region can be wrapped.

#### Parameters

A flag indicating whether wrapping of the region is enabled.

### SetTime(time as Integer) as Void

#### Description

Sets the duration of each frame of any animated sprite that uses this region.

#### Parameters

A flag indicating whether wrapping of region is enabled.

| Name | Type | Description |
| --- | --- | --- |
| time | Integer | The "frame hold time" in milliseconds. |

### GetTime() as Integer

| Name | Return Type | Return Value | Description |
| --- | --- | --- | --- |
| GetTime | Integer | Milliseconds - Integer | Returns the "frame hold time" in milliseconds |

### SetPretranslation(x as Integer, y as Integer) as Void

#### Description

Sets the pre-translation for DrawObject, DrawRotatedObject, and DrawScaledObject.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| x   | Integer | The pre-translation x-value. |
| y   | Integer | The pre-translation y-value. |

### GetPretranslationX() as Integer

#### Description

Returns the pre-translation x value.

#### Return Value

The pre-translation x value.

### GetPretranslationY() as Integer

#### Description

Returns the pre-translation y value.

#### Return Value

The pre-translation y value.

### SetScaleMode(mode as Integer) as Void

#### Description

Sets the scaling mode used for DrawScaledObject.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| mode | Integer | The scaling mode, which may be one of the following values:<br><br>*   0 = fast scaling operation (may have jaggies)<br>*   1 = smooth scaling operation (may be slow) |

### GetScaleMode() as Integer

#### Description

Returns the scaling mode.

#### Return Value

The scaling mode, which may be one of the following values:

*   0 = fast scaling operation (may have jaggies)
*   1 = smooth scaling operation (may be slow)

### SetCollisionType(collisiontype as Integer) as Void

#### Description

Sets the type of region to be used for collision tests with this sprite.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| collisiontype | Integer | The collision type, which may be one of the following values:<br><br>*   Type 0– Use the entire defined region of the sprite. Type 0 is the default<br>*   Type 1 – Use the defined rectangular region specified by the SetCollisionRectangle() method<br>*   Type 2 – Use a circular region specified by the SetCollisionCircle() method |

### GetCollisionType() as Integer

#### Description

Returns the collision type.

#### Return Value

The collision type, which may be one of the following values:

*   Type 0– Use the entire defined region of the sprite. Type 0 is the default
*   Type 1 – Use the defined rectangular region specified by the SetCollisionRectangle() method
*   Type 2 – Use a circular region specified by the SetCollisionCircle() method

### SetCollisionRectangle(xOffset as Integer, yOffset as Integer, width as Integer, height as Integer) as Void

#### Description

Sets the collision rectangle used for type-1 collision tests. The upper left corner of the rectangle is the (x,y) position of the sprite plus the specified offsets. The width and height specify the size of the rectangle.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| xOffset | Integer | The offset for the x position of the sprite. |
| yOffset | Integer | The offset for the y position of the sprite. |
| width | Integer | The width of the rectangle. |
| height | Integer | The height of the rectangle. |

### SetCollisionCircle(xOffset as Integer, yOffset as Integer, Radius as Integer) as Void

#### Description

Sets the collision circle used for type-2 collision tests. The center of the circle is the (x,y) position of the sprite plus the specified offsets. The radius specifies the size of the circle.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| xOffset | Integer | The offset for the x position of the sprite. |
| yOffset | Integer | The offset for the y position of the sprite. |
| Radius | Integer | The size of the circle. |

LayoutGroup
===========

Extends [**Group**](/docs/references/scenegraph/layout-group-nodes/group.md "**Group**")

The LayoutGroup node class manages the position of its child nodes by arranging them in a row from left to right (horizontal layout), or in a column from top to bottom (vertical layout). Fields provide options to control the spacing between children, the horizontal and vertical alignment, and the margins around the edges of the group.

Fields
------

FieldTypeDefaultAccess PermissionDescriptionlayoutDirectionstringvertREAD\_WRITEControls the layout direction

| Value | Use |
| --- | --- |
| horiz | Positions the children in a row from left to right |
| vert | Positions the children in a column from top to bottom |

horizAlignmentstringleftREAD\_WRITESpecifies the alignment point in the horizontal direction. The effect of the value set depends on the whether the layoutDirection field value is set to either horiz or vert

| Value | layoutDirection | Use |
| --- | --- | --- |
| left | vert | Aligns the left edges of each child in the column, and sets the LayoutGroup node local x-coordinate origin at the left edge of the children |
| left | horiz | Sets the LayoutGroup node local x-coordinate origin at the left edge of the first child |
| center | vert | Aligns the centers of each child in the column, and sets the LayoutGroup node local x-coordinate origin at the center alignment point |
| center | horiz | Sets the LayoutGroup node local x-coordinate origin at the center of the horizontal row of children |
| right | vert | Aligns the right edges of each child in the column, and sets the **LayoutGroup** node local x-coordinate origin is at the right edge of the children |
| right | horiz | Sets the LayoutGroup node local x-coordinate origin at the right edge of the last child |
| custom | vert | Explicitly set the x translation of each child of the LayoutGroup. If the layoutDirection is "horiz", custom will not be a valid setting. Instead, "left" will be used to do the child layout. |

vertAlignmentstringtopREAD\_WRITESpecifies the alignment point in the vertical direction. The effect of the value set depends on the whether the layoutDirection field value is set to either horiz or vert

| Value | layoutDirection | Use |
| --- | --- | --- |
| top | horiz | Aligns the top edges of each child in the row, and sets the **LayoutGroup** node local y-coordinate origin at the top edge of the children |
| top | vert | Sets the LayoutGroup node local y-coordinate origin at the top edge of the first child |
| center | horiz | Aligns the centers of each child in the row, and sets the LayoutGroup node local y-coordinate origin at the center alignment point |
| center | vert | Sets the **LayoutGroup** node local y-coordinate origin at the center of the vertical column of children |
| bottom | horiz | Aligns the bottom edges of each child in the row, and sets the **LayoutGroup** node local y-coordinate origin at the bottom edge of the children |
| bottom | vert | Sets the LayoutGroup node local y-coordinate origin at the bottom edge of the last child |
| custom | horiz | Explicitly set the y translation of each child of the LayoutGroup. If the layoutDirection is "vert", custom will not be a valid setting. Instead, "top" will be used to do the child layout. |

itemSpacingsarray of floats\[ \]READ\_WRITEControls the spacing before or after each child in the layout direction. By default, no space is added between the childrenaddItemSpacingAfterChildBooleantrueREAD\_WRITEControls how the spaces specified in the itemSpacings field are inserted. By default, the field value is set to true. This causes the specified spaces to be inserted after the child is positioned. If the field value is set to false, the specified item space is inserted before the child is positioned

ifEVPCipher
===========

Implemented by
--------------

| Name | Description |
| --- | --- |
| [roEVPCipher](/docs/references/brightscript/components/roevpcipher.md "roEVPCipher") | The EVP Cipher component provides an interface to the OpenSSL EVP library of symmetric cipher commands |

Supported methods
-----------------

### Setup(encrypt as Boolean, format as String, key as String, iv as String, padding as Integer) as Integer

#### Description

Configures and initializes a new cipher context.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| encrypt | Boolean | True for encryption; false for decryption |
| format | String | Cipher format string, from openssl, listed at roEVPCipher |
| key | String | A hex-encoded key |
| iv  | String | A hex-encoded initialization vector, which can be an empty string |
| padding | Integer | 1 to use standard padding; 0 for no padding) |

#### Return Value

Returns 0 on success or non-zero on failure.

### Reinit() as Integer

#### Description

Reinitializes an existing cipher context. This can be called to reuse an existing [roEVPCipher](/docs/references/brightscript/components/roevpdigest.md "roEVPCipher") object to encrypt new data

#### Return Value

Returns 0 on success or non-zero on failure.

### Process(bytes as Object) as Object

#### Description

Processes the included [roByteArray](/docs/references/brightscript/components/robytearray.md) containing encrypted/decrypted data.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| bytes | Object | An [roByteArray](/docs/references/brightscript/components/robytearray.md) containing data that is encrypted or decrypted. |

#### Return Value

An [roByteArray](/docs/references/brightscript/components/robytearray.md "roByteArray") containing the result.

#### Example

      x = evp.Process(bytes)
    

is equivalent to

      evp.Reinit()
      x = evp.Update(bytes)
      x = x + evp.Final()
    

### Update(bytes as Object) as Object

#### Description

Updates the included [roByteArray](/docs/references/brightscript/components/robytearray.md) containing encrypted/decrypted data.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| bytes | Object | An [roByteArray](/docs/references/brightscript/components/robytearray.md) containing data that is encrypted or decrypted. |

#### Return Value

An [roByteArray](/docs/references/brightscript/components/robytearray.md "roByteArray") containing a subset of the result. Some or all of the result may not be returned until the next call to Update().

### Final() as Object

#### Description

Signals that all data has been submitted by previous calls to Update().

#### Return Value

The last remaining encrypted or decrypted bytes.

First steps
===========

To get started building a Roku app, do the following:

*   **[Create a Roku customer account](https://my.roku.com/signup)**. This enables you to enroll in the Roku developer program. Make sure that the email address you use for your account is one that you actively use and monitor. Roku frequently sends notifications that require you to take action (for example, to maintain your account, keep your app in the Streaming Store, or receive payouts).

*   **[Enroll in the Roku Developer program](https://developer.roku.com/enrollment/standard)**. This provides you with access to the [Roku Developer Dashboard](https://developer.roku.com/developer), which is used for creating, testing, and publishing apps.

*   **[Get a Roku device](https://www.roku.com/products/players)**. You can purchase a Roku device from [Roku.com](http://roku.com/), your local electronics retailer, or a second-hand marketplace.

*   **[Activate developer mode on your device](/docs/developer-program/getting-started/developer-setup.md)**. This enables you run sample apps on your device to help you learn Roku development and being running and testing your own apps.

roUrlEvent
==========

The roUrlTransfer component sends the roUrlEvent with the following methods:

Supported methods
-----------------

### GetInt() as Integer

Returns the type of event, which may be one of the following values:

| Event Type | Description |
| --- | --- |
| 1   | transfer complete |
| 2   | transfer started. Headers are available for suitable protocols. (Not currently implemented) |

### GetResponseCode() as Integer

Returns the protocol response code associated with this event. For a successful HTTP request this will be the HTTP status code 200. For unexpected errors the return value is negative. There are lots of possible negative errors from the CURL library but it's often best just to look at the text version via GetFailureReason().

The following table lists some of the potential errors (not all of them can be generated):

| Status | Name | Description |
| --- | --- | --- |
| \-1 | CURLE\_UNSUPPORTED\_PROTOCOL |     |
| \-2 | CURLE\_FAILED\_INIT |     |
| \-3 | CURLE\_URL\_MALFORMAT |     |
| \-4 | CURLE\_NOT\_BUILT\_IN |     |
| \-5 | CURLE\_COULDNT\_RESOLVE\_PROXY |     |
| \-6 | CURLE\_COULDNT\_RESOLVE\_HOST |     |
| \-7 | CURLE\_COULDNT\_CONNECT |     |
| \-8 | CURLE\_FTP\_WEIRD\_SERVER\_REPLY |     |
| \-9 | CURLE\_REMOTE\_ACCESS\_DENIED | A service was denied by the server due to lack of access - when login fails this is not returned |
| \-11 | CURLE\_FTP\_WEIRD\_PASS\_REPLY |     |
| \-13 | CURLE\_FTP\_WEIRD\_PASV\_REPLY |     |
| \-14 | CURLE\_FTP\_WEIRD\_227\_FORMAT |     |
| \-15 | CURLE\_FTP\_CANT\_GET\_HOST |     |
| \-16 | CURLE\_HTTP2 |     |
| \-17 | CURLE\_FTP\_COULDNT\_SET\_TYPE |     |
| \-18 | CURLE\_PARTIAL\_FILE |     |
| \-19 | CURLE\_FTP\_COULDNT\_RETR\_FILE |     |
| \-21 | CURLE\_QUOTE\_ERROR | Quote command failure |
| \-22 | CURLE\_HTTP\_RETURNED\_ERROR |     |
| \-23 | CURLE\_WRITE\_ERROR |     |
| \-25 | CURLE\_UPLOAD\_FAILED | Failed upload "command" |
| \-26 | CURLE\_READ\_ERROR | Could open/read from file |
| \-27 | CURLE\_OUT\_OF\_MEMORY |     |
| \-28 | CURLE\_OPERATION\_TIMEDOUT | The timeout time was reached |
| \-30 | CURLE\_FTP\_PORT\_FAILED | FTP PORT operation failed |
| \-31 | CURLE\_FTP\_COULDNT\_USE\_REST | The REST command failed |
| \-33 | CURLE\_RANGE\_ERROR | RANGE "command" didn't work |
| \-34 | CURLE\_HTTP\_POST\_ERROR |     |
| \-35 | CURLE\_SSL\_CONNECT\_ERROR | Wrong when connecting with SSL |
| \-36 | CURLE\_BAD\_DOWNLOAD\_RESUME | Couldn't resume download |
| \-37 | CURLE\_FILE\_COULDNT\_READ\_FILE |     |
| \-38 | CURLE\_LDAP\_CANNOT\_BIND |     |
| \-39 | CURLE\_LDAP\_SEARCH\_FAILED |     |
| \-41 | CURLE\_FUNCTION\_NOT\_FOUND |     |
| \-42 | CURLE\_ABORTED\_BY\_CALLBACK |     |
| \-43 | CURLE\_BAD\_FUNCTION\_ARGUMENT |     |
| \-45 | CURLE\_INTERFACE\_FAILED | CURLOPT\_INTERFACE failed |
| \-47 | CURLE\_TOO\_MANY\_REDIRECTS | Catch endless re-direct loops |
| \-48 | CURLE\_UNKNOWN\_TELNET\_OPTION | User specified an unknown option |
| \-49 | CURLE\_TELNET\_OPTION\_SYNTAX | Malformed telnet option |
| \-51 | CURLE\_PEER\_FAILED\_VERIFICATION | Peer's certificate or fingerprint wasn't verified fine |
| \-52 | CURLE\_GOT\_NOTHING | When this is a specific error |
| \-53 | CURLE\_SSL\_ENGINE\_NOTFOUND | SSL crypto engine not found |
| \-54 | CURLE\_SSL\_ENGINE\_SETFAILED | Can not set SSL crypto engine as default |
| \-55 | CURLE\_SEND\_ERROR | Failed sending network data |
| \-56 | CURLE\_RECV\_ERROR | Failure in receiving network data |
| \-58 | CURLE\_SSL\_CERTPROBLEM | Problem with the local certificate |
| \-59 | CURLE\_SSL\_CIPHER | Couldn't use specified cipher |
| \-60 | CURLE\_SSL\_CACERT | Problem with the CA cert (path?) |
| \-61 | CURLE\_BAD\_CONTENT\_ENCODING | Unrecognized transfer encoding |
| \-62 | CURLE\_LDAP\_INVALID\_URL | Invalid LDAP URL |
| \-63 | CURLE\_FILESIZE\_EXCEEDED | Maximum file size exceeded |
| \-64 | CURLE\_USE\_SSL\_FAILED | Requested FTP SSL level failed |
| \-65 | CURLE\_SEND\_FAIL\_REWIND | Sending the data requires a rewind that failed |
| \-66 | CURLE\_SSL\_ENGINE\_INITFAILED | Failed to initialize ENGINE |
| \-67 | CURLE\_LOGIN\_DENIED | User, password or similar was not accepted and we failed to login |
| \-68 | CURLE\_TFTP\_NOTFOUND | File not found on server |
| \-69 | CURLE\_TFTP\_PERM | Permission problem on server |
| \-70 | CURLE\_REMOTE\_DISK\_FULL | Out of disk space on server |
| \-71 | CURLE\_TFTP\_ILLEGAL | Illegal TFTP operation |
| \-72 | CURLE\_TFTP\_UNKNOWNID | Unknown transfer ID |
| \-73 | CURLE\_REMOTE\_FILE\_EXISTS | File already exists |
| \-74 | CURLE\_TFTP\_NOSUCHUSER | No such user |
| \-75 | CURLE\_CONV\_FAILED | Conversion failed |
| \-76 | CURLE\_CONV\_REQD | Caller must register conversion callbacks using curl\_easy\_setopt options CURLOPT\_CONV\_FROM\_NETWORK\_FUNCTION, CURLOPT\_CONV\_TO\_NETWORK\_FUNCTION, and CURLOPT\_CONV\_FROM\_UTF8\_FUNCTION |
| \-77 | CURLE\_SSL\_CACERT\_BADFILE | Could not load CACERT file, missing or wrong format |
| \-78 | CURLE\_REMOTE\_FILE\_NOT\_FOUND | Remote file not found |
| \-79 | CURLE\_SSH | Error from the SSH layer, somewhat generic so the error message will be of interest when this has happened |
| \-80 | CURLE\_SSL\_SHUTDOWN\_FAILED | Failed to shut down the SSL connection |

### GetFailureReason() as String

Returns a description of the failure that occurred.

### GetString() as String

For transfer complete AsyncGetToString, AsyncPostFromString and AsnycPostFromFile requests this will be the actual response body from the server. This method returns the string associated with the event.

### GetSourceIdentity() as Integer

Returns a magic number that can be matched with the value returned by the [roUrlTransfer.GetIdentity()](/docs/references/brightscript/interfaces/ifurltransfer.md#getidentity-as-integer) method to determine the source of the roUrlTransfer event.

### GetResponseHeaders() as Object

Returns an [roAssociativeArray](/docs/references/brightscript/components/roassociativearray.md "roAssociativeArray") containing all the headers returned by the server for appropriate protocols (such as HTTP). Headers are only returned when the status code is greater than or equal to 200 and less than 300

### GetTargetIpAddress() as String

Returns the IP address of the destination.

### GetResponseHeadersArray() as Object

This method returns an [roArray](/docs/references/brightscript/components/roarray.md "roArray") of [roAssociativeArrays](/docs/references/brightscript/components/roassociativearray.md "roAssociativeArray"), where each associative array contains a single header name/value pair. Use this function if you need access to duplicate headers, since GetResponseHeaders() returns only the last name/value pair for a given name. All headers are returned regardless of the status code

Label
=====

Extends [**LabelBase**](/docs/references/scenegraph/label-nodes/label-base.md)

> As of Roku OS 10.5, the Label node inherits most of its functionality from [LabelBase](/docs/references/scenegraph/label-nodes/label-base.md) node class. Developers, however, do not need to update their app code to account for this refactoring.

The Label node class is used to display a string of text.

### Example

The following example shows a text layout derived from the Label node.

![roku815px - label-node-sample](https://image.roku.com/ZHZscHItMTc2/label-node-sample.png "label-node-sample")

The following displays the text string "Application Development Made Easy!" in the medium bold system font near the left top of the display screen.

    <?xml version="1.0" encoding="utf-8" ?>
    
    <!--********** Copyright 2015 Roku Corp.  All Rights Reserved. **********-->
    
    <component name="labeltest" extends="Group" >
    
    <script type="text/brightscript" >
    <![CDATA[
    
      sub init()
        m.top.setFocus(true)
      end sub
    
    ]]>
    </script>
    
    <Label
      id="testLabel"
      height="44"
      width="0"
      font="font:MediumBoldSystemFont"
      text = "Application Development Made Easy!"
      horizAlign = "left"
      vertAlign = "center"
      translation="[318,8]" />
    
    </component>
    

Fields
------

Fields derived from the [Group](/docs/references/scenegraph/layout-group-nodes/group.md#fields "Fields") and [LabelBase](/docs/references/scenegraph/label-nodes/label-base.md#fields) classes can be used.

| Field | Type | Default | Access Permission | Description |
| --- | --- | --- | --- | --- |
| lineSpacing | float |     | READ\_WRITE | If the text is displayed on more than one line, specifies the amount of additional space added between lines |
| truncateOnDelimiter | string |     | READ\_WRITE | If the width field value is greater than zero, provides a set of characters that are used to determine how to truncate the last line of text that is displayed if it extends beyond the specified width. If none of the characters in the last line of text are included in the truncateOnDelimiter field value string, the entire last line is not displayed. When the value is set to a non-empty string, the ellipsizeOnBoundary field value is ignored |
| leadingEllipsis | Boolean | false | READ\_WRITE | Specifies whether to display the end or beginning of text that overflows its available width:  <br><br>*   **true**. The end of the text is shown. For example, "the quick brown fox jumps over the lazy dog" would be truncated to "...jumps over the lazy dog".<br>*   **false**. The start of the text is shown (for example, "the quick brown fox jumps..."). |

Sample app
----------

You can download and install a [sample app](https://github.com/rokudev/samples/tree/master/ux%20components/screen%20elements/renderable%20nodes/LabelExample) that demonstrates how to use the Label node.

KeyboardDialog
==============

> Roku OS 10.0 introduced a new [StandardKeyboardDialog node](/docs/references/scenegraph/standard-dialog-framework-nodes/standard-keyboard-dialog.md "**Standard Keyboard Dialog**"), which features updated graphics, color palette support, and voice entry support. This enables developers to provide a consistent user experience across the keyboard dialogs in their app, and help speed up customer sign-ups and sign-ins. Developers must replace the legacy KeyboardDialog nodes in their app with the new [StandardKeyboardDialog node](/docs/references/scenegraph/standard-dialog-framework-nodes/standard-keyboard-dialog.md "**Standard Keyboard Dialog**").
> 
> To upgrade a legacy keyboard dialog to the standard version, prepend "Standard" to the node type. For example, change `keyboarddialog = createObject("roSGNode", "KeyboardDialog")` to `keyboarddialog = createObject("roSGNode", "StandardKeyboardDialog")`.

Extends [**Dialog**](/docs/references/scenegraph/dialog-nodes/dialog.md "**Dialog**")

The KeyboardDialog node class is a special type of Dialog node that prompts the user to enter an alphanumeric text string. The KeyboardDialog node class includes an interrnal Keyboard node to allow the user to enter the string.

The KeyboardDialog allows you to add a title (by setting the Dialog title field), a help message (by setting the Dialog message field), and a set of action buttons (by setting the Dialog node buttons field). The bulletText and graphicUrl fields of the Dialog node should not be set. If those Dialog node fields are set, the layout of the dialog will likely not look correct.

Also, the KeyboardDialog node class inherits the behavior of the interrnal [Keyboard](/docs/references/scenegraph/widget-nodes/keyboard.md "Keyboard") node when the Options remote key is pressed. The Keyboard node class toggles between uppercase and lowercase letters when the Options remote key is pressed, to speed the entry of mixed-case strings by the user. Therefore, the optionsDialog field of the Dialog node class should not be set to true.

Typically, you will want to set the KeyboardDialog node title field to prompt the user to enter the string, and add "OK" and "Cancel" buttons by setting the Dialog node buttons field to \[ "OK", "Cancel" \], then observe the Dialog node class buttonSelected field to react when the user presses one of those buttons. At any time, the text field can be accessed to obtain the string entered by the user.

Another typical usage of the KeyboardDialog node class adds a "Hide Text" button, with an observer function set up to toggle the secureMode field of the Keyboard node internal TextEditBox node (that is, by toggling the value of the keyboard.textEditBox.secureMode field).

Fields
------

| Field | Type | Default | Access Permission | Description |
| --- | --- | --- | --- | --- |
| text | string | ""  | READ\_WRITE | Can be used to explicitly set the internal Keyboard node text string, as well as to access the string entered by the user |
| keyboard | Keyboard node | system default | READ\_ONLY | Provides access to the internal Keyboard node. The field is read-only, but the fields of the Keyboard node it refers to can be read and written, allowing you to fully customize the Keyboard node appearance and behavior |

Sample app
----------

[KeyboardDialogExample](https://github.com/rokudev/samples/tree/master/ux%20components/dialogs/KeyboardDialogExample) is a sample app demonstrating KeyboardDialog in action.

roCECStatus
===========

The roCECStatus component enables apps to identify the active-source status for set boxes.

Supported interfaces
--------------------

*   [ifCECStatus](/docs/references/brightscript/interfaces/ifcecstatus.md "ifCECstatus")
*   [ifSetMessagePort](/docs/references/brightscript/interfaces/ifsetmessageport.md "ifSetMessagePort")
*   [ifGetMessagePort](/docs/references/brightscript/interfaces/ifgetmessageport.md "ifGetMessagePort ")

Supported events
----------------

*   [roCECStatusEvent](/docs/references/brightscript/events/rocecstatusevent.md "*roCECStatusEvent*")

StdDlgProgressItem
==================

Extends [StdDlgItemBase](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-item-base.md "**StdDlgItemBase**")

The **StdDlgProgressItem** node is used to display a spinning progress indicator in the dialog's content area. It provides the status of a task that takes an indeterminate amount of time. It should only be used as a child of a [**StdDlgContentArea**](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-content-area.md) node.

![roku815px - std-dlg-progress-item](https://image.roku.com/ZHZscHItMTc2/std-dlg-progress-item.jpg)

Fields
------

| Field | Type | Default | Access Permission | Description |
| --- | --- | --- | --- | --- |
| text | string | ""  | READ\_WRITE | Specifies the text to be displayed next to the progress graphic. If the text width does not fit within the width of the content area, the text will wrap onto multiple lines. |

Sample app
----------

You can download and install a [sample app](https://github.com/rokudev/standard-dialog-framework) that demonstrates how to create a custom dialog that uses the progress item.

roSocketEvent
=============

An roStreamSocket or roDataGramSocket object sends the roSocketEvent to indicate a change in the status of the socket. The socket must enable specific event notifications via the notify methods of ifSocketAsync.

Supported methods
-----------------

### GetSocketID() as Integer

Returns the ID of the socket this event is for. The ID of a socket can be obtained from ifSocketAsync.GetID(). Use [ifSocketStatus](/docs/references/brightscript/interfaces/ifsocketstatus.md "ifSocketStatus") or [ifSocketConnectionStatus](/docs/references/brightscript/interfaces/ifsocketconnectionstatus.md "ifSocketConnectionStatus") on the indicated socket to query the new status for the socket.

ifBoolean
=========

Interface equivalent for intrinsic type Boolean.

Implemented by
--------------

| Name | Description |
| --- | --- |
| [roBoolean](/docs/references/brightscript/components/roboolean.md "roBoolean") | Object equivalent for intrinsic type Boolean |

Supported methods
-----------------

### GetBoolean() As Boolean

#### Description

Gets the boolean value stored in the calling boolean object.

#### Return Value

The boolean value stored in the calling boolean object.

### SetBoolean(value As Boolean) As Void

#### Description

Sets the calling boolean object to the specified true/false value.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| value | Boolean | True/false. |

BrightScript language reference
===============================

Roku BrightScript is a powerful scripting language that makes it easy and quick to build media and networked applications for embedded devices. The language has integrated support for BrightScript components, a library of lightweight components. The APIs of the platform BrightScript is running on are all exposed to BrightScript as BrightScript components.

The BrightScript reference specifies the syntax of the language. To write useful applications that implement an app, you should also refer to BrightScript Component Architecture.

BrightScript compiles code into bytecode that is run by an interpreter. This compilation step happens every time a script is loaded and run. There is no separate compile step that results in a binary file being saved. In this way it is similar to JavaScript.

BrightScript statement syntax is not C-like; in this way it is similar to Python, Basic, Ruby or Lua. BrightScript objects and named entry data structures are associative arrays. In this way it is similar to JavaScript or Lua. BrightScript supports dynamic typing (like JavaScript), or declared types (like C or Java). BrightScript uses "interfaces" and "components" for its APIs, similar to ".Net" or Java.

BrightScript is a powerful bytecode-interpreted scripting language optimized for embedded devices. In this way it is unique. For example, BrightScript and the BrightScript component architecture are written in 100% C for speed, efficiency, and portability. BrightScript makes extensive use of the "integer" type (since many embedded processors don't have floating point units). This is different from languages like JavaScript where a number is always a float. BrightScript numbers are only floats when necessary.

BrightScript is optimized to be the "glue" that connects underlying components for network connectivity, media playback, and UI screens into user-friendly applications with minimal programmer effort.

roTextToSpeechEvent
===================

> Please note this component is only available on the following devices: Roku Streaming Stick (3600X), Roku Express (3700X) and Express+ (3710X), Roku Premiere (4620X) and Premiere+ (4630X), Roku Ultra (4640X), and any Roku TV running Roku OS version 7.2 and later.

The [roTextToSpeech](/docs/references/brightscript/components/rotexttospeech.md "roTextToSpeech") component sends the roTextToSpeechEvent with the following predicates that indicate its valid event types.

Supported methods
-----------------

### GetData() as Integer

Returns the description of the speech, which may be one of the following values:

| ID  | Interpretation |
| --- | --- |
| 0   | Started speech |
| 1   | Speech has completed |
| 2   | Speech has been interrupted/flushed |
| 4   | Current language has been changed |
| 5   | Current voice has been changed |
| 6   | Speech rate has been changed |
| 7   | Speech volume has been changed |

### GetInfo() as Object

Returns an associative array with the following key-value pairs, depending the value returned by the [GetData()](/docs/references/brightscript/events/rotexttospeechevent.md#getinfo-as-object "GetData()") method:

| Key | Type | Value |
| --- | --- | --- |
| Enabled | Boolean | If GetData() returned 3, indicates the enabled/disabled status of text to speech |
| Language | String | If GetData() returned 4, indicates the new language |
| Voice | String | If GetData() returned 5, indicates the new voice |
| Rate | Integer | If GetData() returned 6, indicates the new speech rate |
| Volume | Integer | If GetData() returned 7, indicates the new speech volume |

### GetIndex() as Integer

The text to speech service may be shared among any number of clients; therefore, the IDs returned to a given client are not necessarily contiguous. The value is only meaningful if [GetData()](/docs/references/brightscript/events/rotexttospeechevent.md#getinfo-as-object "GetData()") returned 0, 1 or 2; it returns 0 otherwise.

This method returns the ID of the speech as returned by either the [Say()](/docs/references/brightscript/interfaces/iftexttospeech.md#saytext-as-string-as-integer "Say()")" or [Silence()](/docs/references/brightscript/interfaces/iftexttospeech.md#silenceduration-as-integer-as-integer "Silence()") methods of the [ifTextToSpeech](/docs/references/brightscript/interfaces/iftexttospeech.md "ifTextToSpeech") interface.

Development environment overview
================================

Architectural overview
----------------------

![roku815px - Architecture block diagram](https://image.roku.com/ZHZscHItMTc2/devenvironmentarchoverview.png "devenvironmentarchoverview")

The diagram above provides a high-level overview of the main system components for the Roku Streaming Player platform. Developer applications are written using the BrightScript programming language. These applications are designed to be standalone entities that can be deployed to a running system with minimal impact.

BrightScript applications are dynamically loaded at runtime and run within a unique context within the BrightScript virtual machine. They are "sand-boxed" and run protected from other areas of the system. Scripts only have access to platform resources that are exposed to the scripting layer as BrightScript components. Developers have a wide selection of built-in elements from the BrightScript programming language, plus additional platform components to build their applications. See the BrightScript Reference and the Component Reference for additional information.

User interface elements/Object model
------------------------------------

The Roku SDK uses the BrightScript programming language for development and exposes a set of interfaces to platform services through BrightScript Components. These platform SDK services include capabilities such as networking, video playback, user interface, and data management. The objects in the Roku SDK are divided into two primary areas:

*   Core Objects – Fundamental objects that exist on all Roku platforms and are device independent
*   Platform Objects – Objects unique to a specific platform, such as the Roku Streaming Player

Developing an application for the Roku Streaming Player consists of writing a BrightScript application, packaging the application and associated resource files and deploying it to the platform. During development packaging consists of a structured ZIP file. For final deployment, tools are provided to create a signed and encrypted application package. At runtime, the player will enumerate the installed applications and display them on the main menu. When the user selects the application, the script(s) are loaded and control is passed to your application. When the user exits, the script is halted and control is returned to the user interface "shell".

User interface functionality available in the SDK includes:

*   Top-Level Menu (Launch screen for applications with logo art)
*   Poster Screen (Horizontally scrolling list of shows with poster art)
*   Springboard (Detail screen with options for displaying individual shows)
*   Video Player Screen (Video playback support with progress bar and trick mode support)
*   PIN Entry Screen (User entry of PIN for purchase/rental verification)
*   Message/Error Dialog (Dialog for display of errors and other user messages)
*   Filter Widget (Selection widget for filtering content display by type)
*   Rendezvous/Code Registration Screen (Display/validate registration codes)
*   Username/Password Registration Screen
*   Text Screen ( Display formatted text to the user and allow selection of options)
*   Search Screen (Keyword based search with progressive disclosure of results)

Detailed information on all these screens can be found in the [BrightScript Component reference](/docs/references/brightscript/language/component-architecture.md).

Display modes (HD/SD)
---------------------

The user interface has been designed to support both High Definition (HD) and Standard Definition (SD) displays. By default the streaming player starts in SD mode, but allows the user the option to specify their display preferences. Display preferences are handled globally for all applications by selecting the "display type" option in "settings".

There are three possible modes:

*   4:3 standard-definition (480i/p)
*   16:9 anamorphic widescreen (480i/p)
*   HDTV (720p)

The SDK UI objects are SD/HD aware and will automatically display in the correct mode. In some cases, the HD mode will allow the user to see more data on the screen. The SD UI is rendered natively at 480p and the HD UI at 720p. As a developer, no special programming is required to support these display modes. Any artwork used by the application (movie posters, logos, etc.) should be provided in both HD and SD versions and included with the application or downloaded dynamically at runtime. The screen objects will attempt to scale improperly sized artwork, but this could result in a loss of quality or degrade performance. It is strongly recommended that developers provide original artwork in both resolutions.

Top-level menu
--------------

The top-level menu provides a launch point for all applications. Applications must provide HD and SD versions of the application icon artwork for display on the top-level menu. When an application is selected from the top-level menu, the application is loaded and control is transferred to the application. The user may return to the top level at any time by pressing the Home button. Pressing the Home button will always exit the application and unconditionally return control back to the UI application shell.

Entry points
------------

There are several reserved function names that serve as entry points to the app.

### Sub RunUserInterface()

#### Sub RunUserInterface(aa as Object)

RunUserInterface is the normal entry point which is called when a app is selected on the Roku Home Screen. It may take an roAssociativeArray parameter that is passed via the External Control APIs.

### Sub Main()

#### Sub Main(aa as Object)

If there is no RunUserInterface() function in the application, the function Main() will be called as the entry point for the application.

### "Source" parameter

The Main(aa) and RunUserInterface(aa) associative array contains the "source" named parameter. Its value represents the path the app was launched from. The values and their meanings are in the table below.

| Value of "Source" | Launched from |
| --- | --- |
| "homescreen" | "home" section of the main Roku app selection page |
| "homescreen-menu" | Launched from a left-hand menu other than Featured Free or Roku Search |
| "ad" | Banner ads (for example, a home screen ad, mini ad, or screensaver ad) |
| "ad:screensaver" | Roku screensaver ad. This is an ad that is displayed within the Roku system screensaver. |
| "ad:homelist" | Roku mini ad. This is an ad that appears below the left-hand navigation menu on the home screen. |
| "external-control" | ECP protocol (typically from the Deep Link tester or Roku mobile app) |
| "partner-button" | partner button on the Roku remote |
| "other-channel" | another app on the Roku device |
| "auto-run-dev" | sideloaded developer app |
| "debug-server" | debug server on port 8080. |
| "purchase-dialog" | Purchase dialog in the Streaming Store |
| "hs-search" | Roku Search |
| "voice-search" | Roku Voice search command ([Visual Search Results For Roku Voice](/docs/features/engagement/roku-search.md#visual-search-results-for-roku-voice); for example, "Weird") |
| "voice-command" | Roku Voice command ([Direct-to-Play](/docs/features/voice/overview.md#direct-to-play); for example, "Play Weird") |
| "dial" | DIAL protocol |
| "hs-d" | launched from Featured Free page |
| "channel-store" | Tile for app or associated content selected from Streaming Store. |

### "lastExitOrTerminationReason" parameter

Roku OS tracks the last exit code for each app. The last exit code is passed to the **main()** function of a running app in the **lastExitOrTerminationReason** field of the **parameters** associative array.

Exit codes do not persist across system reboots and system resumptions. The last exit code is reset to **EXIT\_UNKNOWN** upon each app launch.

> The Roku OS may add additional exit codes in the future. Any code or tooling that processes exit codes should handle unrecognized codes robustly.

| Exit Code | Description |
| --- | --- |
| EXIT\_UNKNOWN | The default exit code if there was no prior exit (for example, the inital app launch after system boot) or no unusual exit reason noted (for example, a scenario other than a BrightScript crash or system resources issue). |
| EXIT\_POWER\_MODE | The app was exited by the system due to the device being powered off by the user (or by user-scheduled power off). |
| EXIT\_DIAL\_DELETE | The app was exited due to the system receiving a DIAL command (for example from a second screen app controlling the app). |
| EXIT\_OUT\_OF\_MEMORY | The app was exited due to the system being under low memory conditions. |
| EXIT\_IDLE\_AUTO\_EXIT | The app was exited by the system after being detected as idle for a prolonged period of time, per the system policy and/or user settings. |
| EXIT\_BRIGHTSCRIPT\_CRASH | The app was exited due to a BrightScript crash. |
| EXIT\_BRIGHTSCRIPT\_STOP | The app was exited due to a BrightScript STOP command when running in production mode (non-developer sideloaded). The system treats this the same as a BrightScript runtime error. |
| EXIT\_BRIGHTSCRIPT\_UNK\_FUNC | The app was exited by the system due to an runtime function resolution error. |
| EXIT\_BRIGHTSCRIPT\_TIMEOUT | The app was exited due to a BrightScript execution timeout error. A timeout error indicates that the app user interface was unresponsive for a prolonged period of time, such as a program lock-up. |
| EXIT\_USER\_KILL | The app was exited due to either due to user shutdown (for example, from App Options) or by the system due to re-installation, re-configuration, or other shutdown. |
| EXIT\_USER\_NAV | The app was exited by user navigation (such as the Home key or using Back to exit the app). |
| EXIT\_AM\_LOWRESOURCE | The app was exited by the system due to low system resources. This typically applies to background apps only. |
| EXIT\_SYSTEM\_KILL | A default exit code used in case of internal system error during app exit. This should not appear in normal usage. |
| EXIT\_GRAPHICS\_NOT\_RELEASED | A system error occurred while suspending an app related to system graphics resources. This should not appear in normal usage. |
| EXIT\_DECODER\_NOT\_RELEASED | A system error occurred while suspending an app related to system video resources. This should not appear in normal usage. |
| EXIT\_RUNNING\_AFTER\_SUSPEND | A system error occurred while suspending an app. This should not appear in normal usage. |
| EXIT\_NOT\_RESUMED | A system error occurred while resuming an app. This should not appear in normal usage. |
| EXIT\_SIGNAL\_TIMEOUT | A system error occurred while suspending or resuming an app. This should not appear in normal usage. |
| EXIT\_APP\_ERROR | A default exit code used in case of internal system error in app tracking. This should not appear in normal usage. |
| EXIT\_UNLOADED | The app was exited due to the system offloading it due to low storage. This would typically apply only to background apps. |
| EXIT\_GUEST\_MODE\_ENABLED | The app was exited by the system due to the user enabling Guest Mode on the device. |
| EXIT\_GUEST\_MODE\_DISABLED | The app was exited by the system due to the user disabling Guest Mode on the device. |
| EXIT\_GUEST\_CHECKOUT | The app was exited by the system due to the user exiting Guest Mode on the device. |
| EXIT\_OS\_UPDATE | The app was exited by the system while applying a system update. |
| EXIT\_CHANNEL\_UPDATE | The app was exited by the system while applying an app update. |
| EXIT\_CHANNEL\_SIDELOAD | The app was exited due to the user installing a sideloaded app. |
| EXIT\_CHANNEL\_RESTART | The app was exited due to an app-initiated restart. This is typically a reserved function in the system. |
| EXIT\_TILE\_HIDDEN | The app was exited due to the user hiding the Soundbar tile on a Roku TV. |
| EXIT\_SETTINGS\_UPDATE | The app was exited by the system due to a device settings update (for exampe, a theme or resolution change that required restart). |
| EXIT\_CHANNEL\_MEM\_LIMIT\_FG | The app was exited by the system because it exceeded its memory limit while running in the foreground. |
| EXIT\_CHANNEL\_MEM\_LIMIT\_BG | The app was exited by the system because it exceeded its memory limit while running in the background. |
| EXIT\_ADDON\_DEPENDENCY | The app was exited by the system while applying a system dependency update. This should only apply while running in the background. |
| EXIT\_SOFTFAIL | The app was exited by the system because of an incompatibility with the runtime environment. In this case, the system may restart the app automatically after resolving the issue. |

### Sub RunScreenSaver()

RunScreenSaver is called to launch a [screensaver](/docs/developer-program/media-playback/screensavers.md) when the Roku has been idle for the configured idle time. The screensaver to launch is selected by the user on the Screensaver settings page. The Roku box may not start the custom screensaver and will use a default screensaver instead if there is insufficient memory to start a screensaver.

### Sub RunScreenSaverSettings()

RunScreenSaverSettings is called when the user selects “Custom Settings” on the Screensaver settings page.

User interaction/events
-----------------------

Roku SDK UI objects provide an event oriented model for user interaction. Instead of receiving and directly handling all of the IR events received by the application, the UI elements will handle all navigation commands directly and send higher level events to the script as the focus changes or the user makes a selection. Scrolling, trick modes and screen-to-screen navigation is handled by the SDK UI objects and the script generally only needs to interact when there is a change in context or the user highlights or selects new data elements. Refer to the Event Loops section or the Class Interface sections for additional information.

Customization
-------------

The objects in the user interface framework expose a set of screen types which standardize user interaction and make it easy for developers to quickly write and deploy applications. Screen types enforce a user interaction model and ensure consistency between applications. They may be customized to provide a unique, developer specific look-and-feel. Customization is currently focused on "re-skinning" the application and supports the following types of changes:

*   Add an application specific image to the top-level menu
*   Change the text to be displayed on the main menu to identify the application
*   Change the application logo to be displayed in the header area for the screen
*   Change the artwork used on the "overhang" or header area for the screen
*   Change the background color for the screen
*   Change the colors used for font rendering on text, buttons, and screens

Within the application the developer is free to combine the available screen types and controls as needed to implement their application. The hierarchy of screens is unique for an application and depends on the user experience desired. Some applications may be fairly "flat" while others may have a deeper hierarchy.

Sign-in requirements and best practices
=======================================

SVOD and TVOD apps (and other subscription services) participating in Roku Pay can streamline subscriber logins by minimizing the number of screens and keypresses in the on-device sign-in workflow. For example, customers may abandon the sign-in workflow when prompted to enter their email address because it requires too many keypresses.

The following graphic demonstrates the standard Roku on-device sign-in workflow, which includes just a maximum of three screens: the landing page, the request for information (RFI) screen, and the password keyboard dialog/log-in screen.

![roku815px - sign-in-flow-optimal.gif](https://image.roku.com/ZHZscHItMTc2/sign-in-flow-optimal.gif)

> **Certification requirement**: For SVOD and TVOD apps (and other subscription services) to pass certification, they must use an on-device Roku Pay billing flow. The Request for Information (RFI) screen must be displayed during the on-device sign-in flow to enable customers to share the email address and/or phone number in their Roku customer account with apps. Only if the user declines the request, may apps require the customer to manually enter this information.

Implementing this streamlined user experience involves two different aspects: the on-device sign-in UI and the on-device authentication integration, which provides the APIs for the sign-in user experience. This document explains both of these areas.

On-device sign-in UI
--------------------

The on-device sign-in workflow should typically have a maximum of three screens (listed in the recommended order):

1.  **Landing page**. Provides call-to-action for subscribing. Includes entry to the sign-up and sign-in flows.

2.  **RFI screen** (Roku Pay built-in). Enables customers to grant the app access to their Roku account information (email address and/or phone number). This eliminates the need for customers to enter their information in a separate keyboard dialog, which speeds up sign-ins and helps ensure that customers complete the process. The RFI screen is typically overlaid on top of the landing page.

> **Certification requirement**: Apps must display the RFI screen in the sign-in flow to pass certification.

3.  **Password keyboard/log-in screen**. Enables the customer to enter their password. Publishers can display a StandardKeyboardDialog for entering the password via text entry or a voice-enabled keyboard for entering the password via text or voice entry. The password keyboard dialog is typically overlaid on top of the log-in screen. The log-in screen enables customers who didn't grant the app access to their personal information to manually enter their email/phone and navigate to the password keyboard dialog.

On-device authentication
------------------------

For customers who already have a valid subscription for an app, [on-device authentication](/docs/developer-program/authentication/on-device-authentication.md#signing-in-existing-subscribers) enables them to sign in to the app directly on-device. This integration uses the [ChannelStore APIs](/docs/references/scenegraph/control-nodes/channelstore.md#getallpurchases) to manage the on-device sign-in experience through Roku Pay. It includes a complete suite of APIs for implementing the entitlement and authentication workflows.

> **Certification requirement**: All authenticated apps must implement on-device authentication to pass [certification](/docs/developer-program/certification/certification.md#2-purchases). Account sign-ins must be completed on-device, without visiting an external webpage. The sign-in workflow may not include links to off-device promotional or marketing materials, nor may it utilize off-device sign-in mechanisms such as rendezvous linking.

Enrolling in the Roku Partner Payouts Program
=============================================

Publishers must enroll in the [Roku Partner Payouts Program](https://developer.roku.com/payments/) to monetize content in a Roku app. This enables publishers to receive payouts from video ads, subscriptions, one-time purchases, and pay-to-install apps (games and screensavers). Monetized apps cannot be published without enrollment.

> **Entering your payout settings**
> 
> *   If you already have an existing Roku developer account, use those account credentials to log in to the Developer Dashboard and enter your payout settings. Do not create a new developer account.
>     
> *   If you are already monetizing your app on the Roku platform, you must still enter your payout settings to continue receiving payouts.
>     
> *   If an **Enrolled** status tag appears next to the **Payout Settings** title, you must still enter your up-to-date contact, payout, and tax information.
>     

* * *

> **About maximum tax withholding**
> 
> Per IRS guidelines, Roku is required to withhold taxes at rates governed by the tax treaty between the United States and the developer's tax country. For developers in the United States, a valid W-9 is required for zero withholding.
> 
> Without proper tax documentation (W-9 for the United States and applicable W-8 for non-US countries) and a tax treaty between the United States and the developer's tax country, Roku is required to withhold at a maximum rate of 24% for developers in the United States and 30% for developers outside the United States.
> 
> It is the developer’s responsibility to complete payout enrollment which includes providing their latest tax forms. If the developer does not provide this information by **March 31st, 2024**, the maximum tax withholding will be applied to all future payouts.
> 
> Once the developer has provided valid tax documentation, the system will apply the correct withholding tax rate on all future payouts. Any tax withheld from payouts will be deposited by Roku to the IRS. The withheld tax can be re-claimed back by developers from IRS directly when they file taxes at the end of the year by submitting proper documentation. Roku will provide an annual receipt of withheld taxes by January of the following year.

Entering payout settings
------------------------

To enroll in the Roku Partner Payouts Program, enter your payout settings following these steps:

1.  Verify that you have [created a Roku account](https://my.roku.com/signup) and [enrolled in the Roku Developer Program](https://developer.roku.com/enrollment/standard).

2.  In the Developer Dashboard, select [**Payout settings**](https://developer.roku.com/developer/billing). If you are using the Payout Settings workflow for the first time, review the steps and then click **Get started**.
    
    ![roku600px - ](https://image.roku.com/ZHZscHItMTc2/payout-settings-get-started.png)
    

3.  Enter or update the following information:
    
    *   Contact information (name, email, address).
        
    *   Entity and payout method (PayPal, ACH \[in the US only\], or Cross-border wire \[non-US only\]).
        
    *   Tax form (W9, W8-BEN, W8-BEN-E, W–8 ECI, W–8 EXP, W–8 IMY, or form 8233).
        
        ![roku600px - ](https://image.roku.com/ZHZscHItMTc2/payment-settings-enrolled.png)
        

##### Video demo

 <img src='https://image.roku.com/ZHZscHItMTc2/entering-payout-settings.png' alt='Roku Pay: Enrolling in the Roku Partner Payouts Program'

### Contact information

Under **Contact Information**, confirm that the existing information is correct. Select **Edit** to make any updates.

### Entity and payout method

To provide your entity and payout method, follow these steps:

1.  Under **Entity & payout method**, select **Verify entity** and then do the following:

2.  Enter your contact information, and then select **Submit**.
    
    ![roku600px - ](https://image.roku.com/ZHZscHItMTc2/payment-settings-contact-info.png)
    

3.  Enter your **Tax Details**, and then select **Submit**.
    
    ![roku600px - ](https://image.roku.com/ZHZscHItMTc2/payment-settings-tax-info-v2.png)
    

4.  Enter your **Banking Information**, and then select Submit. You can choose one of the following payout methods:
    
    *   **PayPal:** Your PayPal account must be linked to a valid payout method (for example, a bank account). Payouts are subject to PayPal terms.
        
    *   **ACH** (US only): This option is only available to publishers located in the United States. ACH payouts are made in USD only (non-USD transactions are converted to USD using the average foreign exchange rate for the month in which the payment occurs). ACH payouts are subject to additional bank fees. Routing and account numbers must be entered accurately; entering incorrect bank account information will cause payouts to fail.
        
    *   **Cross-border wire** (non-US only; availability varies by region): This option is only available to publishers located outside the United States, and support for this payout method varies based on the region.
        
        ![roku600px - ](https://image.roku.com/ZHZscHItMTc2/payment-settings-paypal-info.jpg)
        

### Tax forms

Once your entity and payout method have been verified, provide your tax forms following these steps:

1.  Select **Complete tax forms** (this button is unavailable until all your information has been completed and validated), and then complete the following steps:
    
    ![roku600px - ](https://image.roku.com/ZHZscHItMTc2/payment-settings-tax-info-start.png)
    

2.  Confirm your source of income, select the confirmation checkbox, and then select **Continue**.
    
    ![roku600px - ](https://image.roku.com/ZHZscHItMTc2/payment-settings-account-holders.png)
    

3.  Record your confirmation code, enter code recovery information, and then select **Continue**.
    
    ![roku600px - ](https://image.roku.com/ZHZscHItMTc2/payment-settings-confirmation-code-2.png)
    

4.  Select the applicable tax form for your region and entity and then select **Continue**.
    
    ![roku600px - ](https://image.roku.com/ZHZscHItMTc2/payment-settings-cert-selection-us.png)
    

> The remaining steps vary based on the selected tax form. The following steps and screenshots are based on the user selecting the W-9.

5.  Select your US federal tax classification (corporation, partnership, LLC, and so on) enter the required information, and then select **Continue**.
    
    ![roku600px - ](https://image.roku.com/ZHZscHItMTc2/payment-settings-select-us-tax-status.png)
    

6.  Enter your exemptions from backup withholding and then select **Continue**.
    
    ![roku600px - ](https://image.roku.com/ZHZscHItMTc2/payment-settings-exemption-withholding.png)
    

7.  Verify your tax identification number (TIN) and then select **Continue**.
    
    ![roku600px - ](https://image.roku.com/ZHZscHItMTc2/payment-settings-tax-identification-number.png)
    

8.  Upload the required supporting documentation (affidavit, certificate of incorporation, withholding/allocation statement, and so on) and any other additional documentation, and then select **Confirm & Continue**.
    
    ![roku600px - ](https://image.roku.com/ZHZscHItMTc2/payment-settings-supporting-docs.png)
    

9.  Select the applicable certification checkboxes and then select **Continue**.
    
    ![roku600px - ](https://image.roku.com/ZHZscHItMTc2/payment-settings-certification-checkbox.png)
    

10.  Electronically sign your form, enter the confirmation code you received in step b, select the declaration acceptance check box, and then select **Submit Electronically**.
    
    ![roku600px - ](https://image.roku.com/ZHZscHItMTc2/payment-settings-certification-2-w9.png)
    

11.  A dialog opens confirming that the withholding certification submission process has been completed. Optionally, you can select Download PDF to receive an electronic copy of the submitted forms.
    
    ![roku600px - ](https://image.roku.com/ZHZscHItMTc2/payment-settings-complete-tax-forms.png)
    

12.  Select **Exit** to return to the Developer Dashboard.

> Once you submit your tax forms, they are reviewed and approved immediately, provided that no manual review is required.
> 
> If your tax forms require a manual review, you will receive an email notification, and it may take 48 to 72 hours for your tax forms to be approved. Manual reviews can result in your tax forms being approved or declined.

Editing payout settings
-----------------------

Once you have entered payout settings, you can update them anytime.

Receiving payouts
-----------------

Once Roku verifies a publisher's bank information and tax documents, the publisher's account will be enrolled in the Roku Partner Payouts Program. The publisher can then publish a monetized app and begin recognizing revenue immediately.

Roku will pay the publisher 80% of all amounts actually received by Roku from your end users in respect of your Application(s) through Roku Pay, after deducting any applicable taxes, credits, refunds and chargebacks, and Roku will retain the remaining 20%.

Payouts from Roku are made no later than 60 days after the end of each month in which Roku received payments through Roku Pay. For subscriptions that are longer than one month, payouts are made on a pro-rata monthly basis (for example, 1/12 of the revenues per month for an annual subscription) no later than 60 days after the end of each month in which Roku receives payments through Roku Pay.

No minimum sum is required to receive payouts from purchases made through Roku Pay. Payouts are made based on the specified interval regardless of the amount of accrued revenue.

For more information on payout terms, see the [Roku Distribution Agreement](https://docs.roku.com/doc/developerdistribution/en-us).

SceneGraph ChannelStore
=======================

The SceneGraph ChannelStore node is used to manage the on-device user experience of the purchase flow through Roku Pay. It includes a complete suite of APIs (referred to as commands) for implementing the on-device purchasing, entitlement, and authentication workflows. This document summarizes these ChannelStore commands.

> See the [On-device authentication guide](/docs/developer-program/authentication/on-device-authentication.md) for the complete steps on using the ChannelStore node to implement the Roku Pay workflow. Refer to the [ChannelStore reference](/docs/references/scenegraph/control-nodes/channelstore.md) for more detailed information on each command.

Purchasing
----------

### getCatalog

The [**getCatalog** command](/docs/references/scenegraph/control-nodes/channelstore.md#getcatalog) gets the [subscription and one-time purchase products](/docs/developer-program/roku-pay/quickstart/in-channel-products.md) in the app's catalog.

This command is used to populate SceneGraph components with products' metadata such as the product name, price, and description.

![roku815px - rsg-channelstore-getcatalog](https://image.roku.com/ZHZscHItMTc2/rsg-channelstore-getcatalog.jpg)

### getUserData

The [**getUserData** command](/docs/references/scenegraph/control-nodes/channelstore.md#getuserdata) gets the customer's Roku account information such as their name, email address, and phone number. This command enables publishers to select which information to return. For example, if only the customer's email address is needed, the command can be configured to only return that information. Only the information needed to create an account should be requested.

When this command is executed, a Request for Information (RFI) screen is displayed. The RFI screen allows customers to grant access to the publisher to their Roku account information. This enables the publisher to create an account in their system without the customer entering any information. This is a critical component in the Roku Pay workflow, which is designed to minimize or completely eliminate the need for customer keypresses in order to reduce friction and maximize conversions.

![roku815px - roku-developers-getUserData](https://image.roku.com/ZHZscHItMTc2/roku-developers-getUserData.jpg)

### doOrder

The [**doOrder** command](/docs/references/scenegraph/control-nodes/channelstore.md#doorder) completes the transaction for the customer's purchase.

When this command is executed, the Roku Pay order confirmation screen is displayed. This publisher-branded screen summarizes the product being purchased, including the price, product name, and any trial period/discount. It enables the customer to confirm their purchase and update their method of payment if neccessary.

![roku815px - img](https://image.roku.com/ZHZscHItMTc2/rsg-channelstore-doorder.jpg)

If the customer requires a PIN for making purchases, the dialog displays a PIN pad for the customer to enter their 4-digit pin and then confirm the order.

![roku815px - img](https://image.roku.com/ZHZscHItMTc2/rsg-channelstore-doorder-pin.jpg?version=1&modificationDate=1600366404000&api=v2)

### requestPartnerOrder

_TVOD only_

The [**requestPartnerOrder** command](/docs/references/scenegraph/control-nodes/channelstore.md#requestpartnerorder) checks whether the customer's billing status is valid. It is used to verify that the customer is eligible to order a movie rental, sporting event, pay-per-view, or other one-time purchase product. See [Creating TVOD channels](/docs/developer-program/roku-pay/implementation/tvod-channel.md) for more information on using this command in the Roku Pay workflow.

### confirmPartnerOrder

_TVOD only_

The [**confirmPartnerOrder** command](/docs/references/scenegraph/control-nodes/channelstore.md#confirmpartnerorder) completes the transaction for the customer's purchase. Similar to the **doOrder** command for subscription purchases, the Roku Pay order confirmation screen is displayed after this command is executed. See [Creating TVOD channels](/docs/developer-program/roku-pay/implementation/tvod-channel.md) for more information on using this command in the Roku Pay workflow.

Entitlements and authentication
-------------------------------

**getPurchases**

The [**getPurchases** command](/docs/references/scenegraph/control-nodes/channelstore.md#getpurchases) gets all of the customer's current active subscriptions. It is used in conjunction with the [Roku Pay **validate-transaction** API](/docs/developer-program/roku-pay/implementation/roku-web-service.md#validate-transaction) to verify that a customer is entitled to a subscription or one-time purchase product.

The **[getAllPurchases](/docs/references/scenegraph/control-nodes/channelstore.md#getallpurchases)** command is similar to **getPurchases**, except that it returns expired and canceled subscription in addition to active ones.

### storeChannelCredData

The [**storeChannelCredData** command](/docs/references/scenegraph/control-nodes/channelstore.md#storechannelcreddata) stores the publisher's access token for an in-channel product in the Roku cloud. This command is used to implement [Automatic Account Link](/docs/developer-program/authentication/universal-authentication-protocol-for-single-sign-on.md), which enables customers to access their entitled content on all the devices linked to their Roku customer account—without requiring any additional authentication.

### getChannelCred

The [**getChannelCred** command](/docs/references/scenegraph/control-nodes/channelstore.md#getchannelcred) retrieves the publisher's access token for an in-channel product from the Roku cloud. It is used to verify whether the customer is entitled to an in-app product.

Testing the ChannelStore implementation
---------------------------------------

The [Roku Pay testing and troubleshooting](/docs/developer-program/roku-pay/testing/testing-roku-pay.md) document lists the steps for testing the purchase and authentication/entitlement workflows. Developers can also [add themselves as a Test User](/docs/developer-program/roku-pay/quickstart/test-users.md) to the app being tested in order to execute ChannelStore purchases without being billed for the transactions, and they can [designate an app for "billing testing"](/docs/developer-program/roku-pay/testing/billing-testing.md) to view the confirmations, error codes, and other transactional metadata related to purchases made with Roku Pay in the debug console.

BIF file creation using the Roku BIF tool
=========================================

Roku provides command-line tools for Mac, Linux, and Windows, enabling you to generate BIF files for your videos.

Mac installation
----------------

### Prerequisites:

*   [Xcode](https://itunes.apple.com/us/app/xcode/id497799835?mt=12)
*   [Homebrew](http://brew.sh/)\*
*   [FFmpeg](https://ffmpeg.org/)

> Homebrew is a command-line package manager for Mac OS X. It is **not required** to use Roku's BIF tool, but it can be used to easily install FFmpeg.

After you have Xcode and Homebrew installed, open your terminal application and run the following:

    $ brew install ffmpeg
    

**Download and unzip: [biftool\_mac](https://github.com/rokudev/samples/tree/master/utilities/bif%20tool/biftool_mac.zip)**

Linux installation
------------------

### Prerequisites:

*   ffmpeg-lib

On RedHat and Fedora Core, you can typically install `ffmpeg-lib` by running this yum command as root: `$ yum install ffmpeg-libs`

**Download and unzip: [biftool\_linux](https://github.com/rokudev/samples/tree/master/utilities/bif%20tool/biftool_linux.zip)**

The executables are compiled for **Linux x86 64-bit machines**. Make sure that the `biftool` and `biftool_processor` executables are in the same directory on the development machine.

Mac and Linux usage
-------------------

The BIF tool will automatically generate three `.bif` files: one for SD, one for HD, and one for FHD.

### Example:

    $ path/to/biftool ~/public_html/Movies/HarryPotter/HLS/600000/*.ts
    Finding candidate frames in 917 files
    Detected stream PTS offset of 10033ms
    Captured 2368 candidate frames in 79s
    Selected 915 BIFs
    Success: ./fileSequence0000-fhd.bif (size=14.096MiB, numImages=915, avgSize=15.767KiB)
    Success: ./fileSequence0000-hd.bif (size=8.528MiB, numImages=915, avgSize=9.535KiB)
    Success: ./fileSequence0000-sd.bif (size=3.920MiB, numImages=915, avgSize=4.378KiB)
    

Windows installation
--------------------

**Download and unzip: [biftool\_windows](https://github.com/rokudev/samples/tree/master/utilities/bif%20tool/biftool_windows.zip)**

### Windows usage

The simplest way to use the command-line tool is to open your favorite terminal application, and drag the biftool executable to its window. After that, just add the path to a video and biftool will generate the BIF files and save them to your current directory.

For example: `$ ./path/to/biftool ./path/to/video-file.mp4`

You can also type `--help` after dragging the biftool executable, and the terminal will display a help message containing more details and options about using the tool.

We recommend generating two `.bif` archives for each piece of content, one for SD and one for HD. Roku devices automatically select which version will be used **depending on the user UI.** That is why it is important to generate HD `.bif` archives even if the content is SD. If there is no HD `.bif` available, the player will fallback to using the SD `.bif`.

#### Example:

    $ mkdir abc-sd abc-hd
    $ ffmpeg -i abc.mp4 -r .1 -s 240x180 abc-sd/08d.jpg
    $ ffmpeg -i abc.mp4 -r .1 -s 320x240 abc-hd/08d.jpg
    $ path/to/biftool -t 10000 abc-sd
    $ path/to/biftool -t 10000 abc-hd
    

This will result in two new files: `abc-sd.bif` and `abc-hd.bif`.

There are two caveats here:

*   FFmpeg generates the JPG files starting with index 1. This means that all the timestamps will be off by 10 seconds. To fix this, use the following command (Make sure you are in the directory containing the `.bif` files):

      $ % j=00000000.jpg; for i in *; do mv ${i} ${j}; j=${i}; done;
    

*   The SD frames should have a width of 240, and the HD frames should have a width of 320. Their height should be specified to coincide with their aspect ratio. The commands above assume a 4x3 aspect ratio. Unfortunately, FFmpeg doesn't let you specify only a width, keeping the original aspect ratio. If your source file is not 4:3, you should calculate the height used in the commands above using the width and the aspect ratio.

Here are some common resolutions:

| Display | Aspect Ratio | Width | Height |
| --- | --- | --- | --- |
| SD  | 4:3 | 240 | 180 |
| HD  | 4:3 | 320 | 240 |
| HD  | 16:9 | 320 | 180 |
| HD  | 2.35 | 320 | 136 |

### Windows 10 usage

1.  Load and install ffmpeg to break mp4 to set of images.
    
2.  Generate preview files:
    

       ffmpeg -i bif\1.mp4 -r .1 -s 320x240 bif\bif_files%08d.jpg
    

3.  Optionally, bulk rename next bat may be used:

       @echo off
       setlocal EnableDelayedExpansion
       set suffix=10000000
          for /F "delims=" %%i in ('dir /B *.jpg') do (
          ren "%%i" "!suffix:~1!.jpg"
          set /A suffix+=1
       )
    

4.  Use biftool to combine these images to bif file:

       biftool.exe -t 10000 bif\bif_files
    

Executable help
---------------

Three types of `<target(s)>` are allowed:

1.  A single `<target>` which is a directory. All files in the directory will be archived into single BIF file with the same name as the directory.
2.  A single `<target>` which is a file with a .bif suffix. Its contents will be extracted into a new directory with the same name as the file. E.g., extracting mymovie-hd.bif will create and populate a directory named mymovie-hd.
3.  One or more `<target(s)>` which are files that do not have a .bif suffix. These files are assumed to be video files, such as .mkv, .mp4 and .ts files. Frames will be extracted from the first video stream in each file, to create a single .bif file with the same base name as the first video file specified. If more than one video file is specified, they are expected to be segments of the same video and must be specified in playback order, based on the presentation timestamps (PTSes) within the files.

Available options:

    --target arg                      The file(s) or directory on which to operate.
    -t [ --timestamp-multiplier ] arg The absolute presentation timestamp (PTS)
                                      in milliseconds is the filename multiplied
                                      by this value.
    -v [ --verbose ]                  Be verbose about activity.
    -h [ --help ]                     Help message.
    

BIF file specification
----------------------

The following specification describes the implementation of the BIF (Base Index Frames) file archive. The BIF archive is used to encapsulate a set of still images for supporting video trick modes (e.g. FF/REW) on the Roku Streaming Player. This format has been optimized for the usage pattern inherent in this model and is well-suited and capable of facilitating those patterns in an efficient manner.

### Requirements and usage patterns

It is important that the file format have the following features:

*   It must be easy to find and interpret the archive metadata.
*   It must be network-access friendly.
*   It must minimize levels of indirection.
*   It must be compact.
*   It must easily accommodate the entire range of possible data.

The format should also be capable of providing future extensions should they be needed.

### Conventions

This specification assumes that all values are stored little-endian.

### File format

All multibyte integers are stored in little-endian format. That is, the first byte is the least significant byte and the last byte is the most significant.

#### Magic number

This is a file identifier. It contains enough information to identify the file type uniquely.

| byte | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| value | `0x89` | `0x42` | `0x49` | `0x46` | `0x0d` | `0x0a` | `0x1a` | `0x0a` |

#### Version

This space is reserved for a revision number. The current specification is file format version 0. The value should be incremented for non-backward-compatible revisions of this document.

| byte | 8 9 10 11 |
| --- | --- |
| value | Version |

#### Number of BIF images

This is an unsigned 32-bit value (N) that represents the number of BIF images in the file. The number of entries in the index will be N+1, including the end-of-data entry.

| byte | 12 13 14 15 |
| --- | --- |
| value | Number of BIF images (N) |

#### Framewise separation

This specifies the denomination of the frame timestamp values. In order to obtain the "real" timestamp (in milliseconds) of a frame, this value is multiplied by the timestamp entry in the BIF index. If this value is 0, the timestamp multiplier shall be 1000 milliseconds.

| byte | 16 17 18 19 |
| --- | --- |
| value | Timestamp Multiplier (in milliseconds) |

#### Reserved

These bytes are reserved for future expansion. They shall be 0.

| byte | 20 ... 63 |
| --- | --- |
| value | 0x00 / / 0x00 |

#### BIF index

This space is used for the BIF index entries. There are N+1 entries. Each entry contains two unsigned 32-bit values.

| byte | 64 65 66 67 | 68 69 70 71 |
| --- | --- | --- |
| index 0 | Frame 0 timestamp | absolute offset of frame |
| index 1 | Frame 1 timestamp | absolute offset of frame |
| index 2 | Frame 2 timestamp | absolute offset of frame |
| ... |     |     |
| index N-1 | Frame N-1 timestamp | absolute offset of frame |
| index N | 0xffffffff | last byte of data + 1 |

Because the size of each BIF is determined by subtracting its offset from the offset of the next entry in the index, the BIFs shall appear in the index in the same order as they appear in the data section, and they shall be adjacent.

The absolute timstamps of the BIF captures can be obtained by multiplying the frame timestamp by the timestamp multiplier.

#### Data section

This section contains the BIF images. It begins after the index, though it is not necessary that the first image appear immediately after the index. Each image in the data section must begin at the offset specified in the BIF index.

    $ path/to/biftool ~/public_html/Movies/HarryPotter/HLS/600000/*.ts
    Finding candidate frames in 917 files
    Detected stream PTS offset of 10033ms
    Captured 2368 candidate frames in 79s
    Selected 915 BIFs
    Success: ./fileSequence0000-fhd.bif (size=14.096MiB, numImages=915, avgSize=15.767KiB)
    Success: ./fileSequence0000-hd.bif (size=8.528MiB, numImages=915, avgSize=9.535KiB)
    Success: ./fileSequence0000-sd.bif (size=3.920MiB, numImages=915, avgSize=4.378KiB)
    $ mkdir abc-sd abc-hd
    $ ffmpeg -i abc.mp4 -r .1 -s 240x180 abc-sd/08d.jpg
    $ ffmpeg -i abc.mp4 -r .1 -s 320x240 abc-hd/08d.jpg
    $ path/to/biftool -t 10000 abc-sd
    $ path/to/biftool -t 10000 abc-hd
    $ % j=00000000.jpg; for i in *; do mv ${i} ${j}; j=${i}; done;
      --target arg                      The file(s) or directory on which to
                                        operate.
      -t [ --timestamp-multiplier ] arg The absolute presentation timestamp (PTS)
                                        in milliseconds is the filename multiplied
                                        by this value.
    -v [ --verbose ]                    Be verbose about activity.
    -h [ --help ].                      Help message.
    

Sample apps
-----------

You can download and install [sample channels](https://github.com/rokudev/trickplay-sample-apps) that demonstrate different ways to incorporate thumbnails from BIF files for trick play purposes.

Receiving secured Roku Pay push notifications
=============================================

Publishers can use signed JSON web tokens (JWT/JWS) to securely receive Roku Pay push notification messages. This enables publishers to verify that the messages received by their push notification endpoint originated from Roku.

When JWT signature authentication is enabled on a push notification endpoint, the HTTP body of the notification messages includes a set of base64url-encoded strings and a JSON Web Signature (JWS). Upon receiving a message, developers can get the contents of the Roku Pay transaction by separating and decoding each string, verifying the JWS signature with the Roku-provided public keys, and then decoding the transaction.

This document details how to receive, decode, and respond to secured Roku Pay push notifications.

> See [Setting up Roku Pay web services](/docs/developer-program/roku-pay/quickstart/setting-up-web-services.md#push-notification-url) for how to add production and test push notification endpoints and enable them to receive secured Roku Pay push notifications.
> 
> See the [Roku Pay push notifications reference](/docs/developer-program/roku-pay/implementation/push-notifications.md) for more information on the contents of the Roku Pay push notification messages.

Request (sent by Roku)
----------------------

Roku Pay push notification HTTP requests have the following format:

![roku815px - img](https://image.roku.com/ZHZscHItMTc2/roku-jose-header-v2.jpg)

### HTTP header

The HTTP body is considered to be plain text; therefore, the header specifies the plain text format. Plain text is used because Roku Pay push notification messages are sent over a TLS-secured link and the critical content elements are already base64url-encoded.

    Content-Type: text/plain
    

### HTTP body

Roku Pay push notifications use the JavaScript Object Signing and Encryption (JOSE) framework, which relies on a JSON Web Token (JWT) to deliver messages securely. The HTTP body of a Roku Pay push notification, which adheres to the [JWS compact serialization specification](https://datatracker.ietf.org/doc/html/rfc7515#section-3.1), includes the following JSON structures:

*   **JOSE header**. Specifies the key ID, which indicates the [public key](#public-keys) to be used to verify the signature and the signing algorithm required to decode the public key.
*   **payload**. A set of JWT claims.
*   **signature**. A JWS generated from the concatenation of the header and the set of JWT claims.

The JOSE header and the set of JWT claims are each base64url-encoded. The two are then concatenated with a period (".") separator and a JWS (also a base64url-encoded string) is then calculated across the resulting string. The JWS is attached to the end of the header/payload string, again separated by a period. The following demonstrates the format of the un-encoded HTTP body:

    ' JOSE header
    {
        "typ":"JWT",  // the signing algorithm to use (RSA 2048 with SHA 256)
        "alg":"RS256",
        "kid":"ROKU-PARTNER-SERVICE-2021-04-29" // the key ID corresponding to the private key used to sign the message (refer to the Public Keys section below)
    }
    
    "."
    
    ' payload (JWT claims)
    {  
        "iss":"Roku, Inc. urn:roku:apps:partner-service.roku.com",   
        "exp":1300819380, // This is set to 24 hours after the token generation
        "nbf":1300818380, // This is set to one hour before the token was generated
        "x-Roku-message":"eyJpc3MiOiJqb2Ui...LA0KICJleHAiOjEz", // base64url(utf8(message))   
        "x-Roku-message-encoding":"base64-utf8",
        "x-Roku-message-key":"some-unique-key-for-the-message", // used to de-duplicate messages 
        "x-Roku-message-type":"roku.rpay.push" //identifies that message is a Roku Pay push notification.
    }
    
    "."
    
    'JWS signature
    {
        "signature bytes"
    }
    

> The URL for the public keys is a fixed value and does not change. Publishers should reject messages if the URL is not **[https://assets.cs.roku.com/keys/partner-jwks.json](https://assets.cs.roku.com/keys/partner-jwks.json)**.
> 
> The URL for the test public key to be used for test push notifications is **[https://assets.cs.roku.com/keys/partner-jwks-test.json](https://assets.cs.roku.com/keys/partner-jwks-test.json)**.
> 
> The JSON format of the JWS signature conforms to the [JWS RFC 7515](https://datatracker.ietf.org/doc/html/rfc7515) standard.

### Encoded HTTP message body

The encoded, period-concatenated JOSE header, payload, and JWS signature form the full HTTP message body:

    eyJ0eXAiOiJKV1QiLA0KICJhbGciOiJIUzI1NiJ9.
    eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFtcGxlLmNvbS9pc19yb290Ijp0cnVlfQ.
    dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk
    

Receiving push notifications
----------------------------

To receive the contents of Roku Pay push notifications, publishers must do the following:

*   Separate the push notification into its three individual strings.
*   Decode each string.
*   Use the [public key](#public-keys) to verify the signature string against the contents of the period-concatenated header and payload strings.
*   [Decode the **x-Roku-message** JWT claim within the payload to get the contents of the notification](#decoding-the-x-roku-message-jwt-claim-to-get-the-push-notification-message).

> Publishers can visit [https://jwt.io](https://jwt.io/), go to the **Debugger** section, and try to decode the push notifications.

### Decoding the x-Roku-message JWT claim to get the push notification message

The **x-Roku-message** field within the JWT claim payload is a base64url-encoded string that contains the contents of the push notification message. The following example demonstrates the decoded **x-Roku-message** field for a [Sale notification message](/docs/developer-program/roku-pay/implementation/push-notifications.md#sale):

    {
        "customerId":"4e5812f5b00b4f5b90f768d22a7de170",
        "transactionType":"Sale",
        "transactionId":"d9dbdfecc5cc41cbb881ab750135029b",
        "channelId":"581251",
        "channelName":"Roku Developers",
        "productCode":"yN4JEfTmjhRP3IpbuWiJ_MonthlySub",
        "productName":"Monthly Subscription",
        "price":9.99,
        "tax":0.0,
        "total":9.99,
        "currency":"usd",
        "isFreeTrial":false,
        "expirationDate":"2020-04-05T18:45:04.3142198Z",
        "originalTransactionId":"d9dbdfec-c5cc-41cb-b881-ab750135029b",
        "comments":"New order processed.",
        "eventDate":"2020-03-05T18:45:04.8762198Z",
        "creditsApplied":0.00,
        "responseKey”:“d4dd12df0c8445afa8860895061e72f9"
    }
    

> See the [Roku Pay push notifications reference](/docs/developer-program/roku-pay/implementation/push-notifications.md) for more information on the contents of the different Roku Pay push notification messages.

Response (required from the publisher)
--------------------------------------

To acknowledge the receipt of a Roku Pay push notification message, send a **200 OK** response.

### Header

    HTTP/1.1 200 OK
    

Public keys
-----------

Publishers must use Roku-provided public keys, which are located [here](https://assets.cs.roku.com/keys/partner-jwks.json), to verify message signatures. The public keys are provided in JSON Web Key (JWK) format and are similar to the example shown below. Select the key that corresponds to the **kid** specified in the [JOSE header](#http-body).

**Public keys in JWK format**

    {
      "keys": [
         {
           "kty":"RSA",
           "n": "0vx7agoebGcQSuuPiLJXZpt...N9nndrQmbXEps2aiAFbWhM78LhWxga",
           "e":"AQAA",
           "alg":"RS256",
           "kid":"ROKU-PARTNER-SERVICE-2021-04-29"
         },
         {
           "kty":"RSA",     
           "n": "0vx7agoebGcQSuuPiLJXZpt...N9nndrQmbXEps2aiAFbWhM78LhWxgb",
           "e":"AQAB",
           "alg":"RS256",
           "kid":"ROKU-PARTNER-SERVICE-2021-05-29"
         }
      ]
    }
    

> Publishers must get the public keys from the [specified URL](https://assets.cs.roku.com/keys/partner-jwks.json). Notifications with a different URL in the JOSE header must be rejected.
> 
> The JSON format above conforms to JWK RFC 7517 ([https://datatracker.ietf.org/doc/html/rfc7517](https://datatracker.ietf.org/doc/html/rfc7517)) and JWA RFC 7518 ([https://datatracker.ietf.org/doc/html/rfc7518](https://datatracker.ietf.org/doc/html/rfc7518)).

Testing
-------

Prior to enabling JWT signature authentication on a production endpoint, publishers can configure a test endpoint in the [Developer Dashboard](https://developer.roku.com/api/settings) and verify whether it can receive and process the JWT/JWS-secured messages. See [Setting up Roku Pay web services](/docs/developer-program/roku-pay/quickstart/setting-up-web-services.md#test-configuration-for-push-notification) for more information.

In addition, publishers can manually send a test JWT/JWS-secured message with a generic payload to the configured test push notification endpoint. This enables publishers to verify that their test endpoint can receive a JWT/JWS-secured message without generating Roku Pay transactions. See [Setting up Roku Pay web services](/docs/developer-program/roku-pay/quickstart/setting-up-web-services.md#notify-test-message-to-partner) for more information.

Sample
------

You can download Roku's [sample application](https://github.com/rokudev/notification-receiver-sample), use it as a template for your implementation, and update it with your custom business logic for processing Roku Pay push notifications. Your backend system application must communicate via HTTPS or leverage an HTTPS reverse proxy.

DynamicPinPad
=============

Extends [DynamicKeyboardBase](/docs/references/scenegraph/dynamic-voice-keyboard-nodes/dynamic-keyboard-base.md "**DynamicKeyboardBase**")

The **DynamicPinPad** node is similar to the [legacy **PinPad** node](/docs/references/scenegraph/widget-nodes/pinpad.md), but with additional voice entry functionality. It enables text and voice entry of numeric characters. It is typically used for entering short numeric PIN codes.

The key layout is fixed based on the node's pre-built Key Definition File.

![roku815px - dynamic-pinpad-voice](https://image.roku.com/ZHZscHItMTc2/dynamic-pinpad-voice.jpg)

Fields
------

The DynamicPinPad node inherits all its fields from its parent [DynamicKeyboardBase](/docs/references/scenegraph/dynamic-voice-keyboard-nodes/dynamic-keyboard-base.md) node class. See the [DynamicKeyboardBase](/docs/references/scenegraph/dynamic-voice-keyboard-nodes/dynamic-keyboard-base.md) and its base classes ([Group](/docs/references/scenegraph/layout-group-nodes/group.md) and [Node](/docs/references/scenegraph/node.md)) for descriptions of the fields that can be configured.

Default VoiceTextEditBox settings
---------------------------------

| Field | Type | Default | Description |
| --- | --- | --- | --- |
| voiceEntryType | string | "numeric" | The type of characters accepted via voice entry. |
| voiceEnabled | boolean | true | Specifies whether voice entry is enabled for the text edit box of the dynamic PIN pad. |
| maxTextLength | integer | 4   | The maximum number of characters that may be entered into the text edit box of the dynamic pinpad. |

Sample app
----------

You can download and install a [sample app](https://github.com/rokudev/dynamic-voice-enabled-keyboards) that demonstrates how to create and configure a dynamic voice-enabled PIN pad.

ifFont
======

Implemented by
--------------

| Name | Description |
| --- | --- |
| [roFont](/docs/references/brightscript/components/rofont.md "roFont") | roFont represents a particular font, from a font-family (eg. Arial), with a particular pixel size (e.g 20), and a particular boldness or italicness |

Supported methods
-----------------

### GetOneLineHeight() as Integer

| Name | Type | Possible Values | Description |
| --- | --- | --- | --- |
| GetOneLineHeight | Integer | Number of pixels) as Intger | Returns the number of pixels from one line to the next when drawing with this font |

### GetOneLineWidth(text as String, MaxWidth as Integer) as Integer

NameTypeParametersPossible ValuesDescriptionGetOneLineWidthInteger

| Name | Type |
| --- | --- |
| MaxWidth | Integer |
| text | String |

Number of pixels as IntegerReturns the width in pixels occupied by the text (this is capped at the maximum provided value).

Each glyph and the needed spacing between glyphs is measured. The returned number of pixels will be no larger than MaxWidth. MaxWidth is generally the amount of pixels available for rendering on this line.

### GetAscent() as Integer

| Name | Type | Possible Values | Description |
| --- | --- | --- | --- |
| GetAscent | Integer | Pixel value as Intger | Returns the font ascent in pixels |

### GetDescent() as Integer

| Name | Type | Possible Values | Description |
| --- | --- | --- | --- |
| GetDescent | Integer | Pixel value as Integer | Returns the font descent in pixels |

### GetMaxAdvance() as Integer

| Name | Type | Possible Values | Description |
| --- | --- | --- | --- |
| GetMaxAdvance | Integer | Pixel value as Integer | Returns the font maximum advance width in pixels |

Roku Pay push notifications reference
=====================================

Roku Pay push notifications send billing data to a publisher's web server listener when transactions occur. Transactions include purchases, cancellations, refunds, credits, and renewed cancellations. Receiving push notifications enables publishers to update their backend system in real-time as subscriptions are purchased, canceled, and refunded.

> See [Setting up Roku Pay web services](/docs/developer-program/roku-pay/quickstart/setting-up-web-services.md#push-notification-url) for how to add production endpoints and enable them to receive Roku Pay push notifications.

Security
--------

This section describes how to receive and respond to Roku Pay push notifications, which are sent without any authentication.

#### Requests (sent by Roku)

Roku Pay push notifications can not be redirected in any way. Requests time out after 10 seconds. If a redirect attempt is made, the request fails.

Push notifications include transaction data and a `responseKey`.

    {
    ... transaction data fields
    "responseKey":"abcdabcd6b1649f681a408f1beebabcd"
    }
    https://pushNotificationEndpoint
    

#### Responses (required from publisher)

Publishers must acknowledge the receipt of a Roku Pay notification message by sending a response that includes the following headers and text body:

#### Headers

*   **ApiKey**: The developer's Roku Pay API key. This key can be accessed from the [Roku Pay Web Services](/docs/developer-program/roku-pay/implementation/roku-web-service.md#roku-pay-api-key) page in the Developer Dashboard.
    
*   **Content-Length**: The Roku Pay API key must have a content length of 36.
    

    HTTP/1.1 200 OK
    ApiKey: {partnerAPIKey}
    Content-Length: 36
    

#### Text body

Include the value of the **responseKey** sent by Roku Pay (the `responseKey` does not have cryptographic signatures in both the request and response). Roku Pay compares the size of the `responseKey` in the response to ensure it matches the one it sent before downloading the content. This helps maintain the security of the Roku Pay web services.

    abcdabcd6b1649f681a408f1beebabcd
    

Notifications
-------------

Roku Pay sends push notifications for the following transactions:

| Transaction Type | Description | Action Required by Publisher |
| --- | --- | --- |
| [Sale](#sale) | A purchase or renewal occurs, or a free trial starts. Renewals are denoted with the **comment** field set to"Recurring subscription processed". | *   New purchase: Create account (if not already created) and add entitlement.<br>*   Renewal: Check entitlement and verify subscription is not marked for cancellation. |
| [GraceInitiated](#in-grace-period) | The payment for a subscription auto-renewal fails and the subscription was placed in a grace period. | *   Use DoRecovery API to display in-app notice prompting customer to update their method of payment.<br>*   Continue granting access to content in app. |
| [GraceRecovered](#in-grace-period) | A payment is received for a subscription that was in a grace period. | *   Stop prompting the customer to update their method of payment.<br>*   Maintain current billing cycle. |
| [OnHoldInitiated](#on-hold) | The grace period elapsed (renewal payment was still not received) and the subscription was placed on hold. This notification is only sent to publishers using [Enhanced Subscription Recovery](https://developer.roku.com/docs/developer-program/roku-pay/subscription-recovery/subscription-on-hold.md). | *   Use the DoRecovery API to display an in-app notice prompting customers to update their method of payment.<br>*   Block access to content in app.<br>*   Update entitlement system to denote that access to content should be denied. |
| [OnHoldRecovered](#on-hold) | A payment is received for a subscription that was placed on-hold. This notification is only sent to publishers using [Enhanced Subscription Recovery](https://developer.roku.com/docs/developer-program/roku-pay/subscription-recovery/subscription-on-hold.md). | *   Stop prompting the customer to update their method of payment.<br>*   Update billing system with the new billing period.<br>*   Update entitlement system to denote that access to content should be granted. |
| [Cancellation](#cancellation) | A subscription is canceled by the customer or is passively canceled because payment could not be recovered.Active cancellations: The **expirationDate** field is set to the current or future datePassive cancellations: The **expirationDate** field is set to a past date. | *   expirationDate is a future date: no action is required until the expiration date.<br>*   expirationDate is today's date: remove the entitlement (the customer actively canceled the subscription and today is the last day of the billing cycle).<br>*   expirationDate is a past date: remove entitlement (passive cancellation; subscription could not be recovered). |
| [Refund](#refund) | A refund was initiated by the publisher or Roku Pay. | If the refund was a result of an unauthorized purchase, Roku cancels the subscription. Remove the entitlement upon receiving the cancellation notification from Roku. |
| [Credit](#credit) | A service credit was issued to a Roku customer by the publisher or Roku Pay. | No action required. |
| [Resubscribe](#resubscribe) | A subscription previously canceled by the customer is reinstated during the current billing period. | Revert any action taken based on the cancellation. |
| [UpgradeSale](#upgradesdowngrades) | An upgraded subscription is purchased. | Add entitlement for upgraded product. |
| [UpgradeCancellation](#upgradesdowngrades) | An original subscription is canceled as a result of being upgraded. | Remove entitlement for original product. |
| [DowngradeSale](#upgradesdowngrades) | A downgraded subscription is purchased. | On the expiration date of the current subscription, move entitlement to the downgrade subscription. |
| [DowngradeCancellation](upgradesdowngrades) | An original subscription is canceled as a result of being downgraded. | Remove entitlement for original subscription on the expiration date. |
| [Chargeback](#chargeback) | The customer has initiated a transaction dispute. The transaction will be deducted from the partner's payout. | No action required. |
| [ChargebackReversed](#chargebackreversed) | Roku successfully reversed the chargeback claim. The revenue share will be returned to the partner payout. | No action required. |
| [SecondChargeback](#secondchargeback) | The customer's bank has disputed the chargeback reversal on the transaction (this may occur if the customer provided new information, the chargeback reason changed, or the bank determined that the information provided by Roku was not sufficient to refute the chargeback). The transaction will be deducted from the partner's payout. | No action required. |

##### Push notifications workflow

The following diagram illustrates the Roku Pay push notifications workflow:

![roku815px - img](https://image.roku.com/ZHZscHItMTc2/push-notification-workflow.jpeg)

### Sale

A **Sale** push notification is sent when a purchase, renewal (including renewal of a free trial), on-device free trial start, or a free trial start via Instant Signup occurs (in the case of Instant Signup, the push notification includes additional information to be used for creating a customer account).

For a new purchase, publishers should create a user account and add the entitlement to their system. For renewals, publishers should check the entitlement and verify subscription is not marked for cancellation.

When a renewal occurs, the **comments** field in the notification is set to "Recurring subscription processed".

> As of Roku OS 10.0, the Sale push notification includes **purchaseChannel** and **purchaseContext** fields that identify whether a Roku Pay subscription purchase originated from Instant Signup. For purchases made via Instant Signup, the **purchaseChannel** field is set to "web" and **purchaseContext** field is set to "isu". For on-device purchases, these fields are set to "device" and "iap", respectively.

#### Purchase example

    {
        "customerId": "2df58f54b4f7540ca3aa31ce8bec1fe7",
        "transactionType": "Sale",
        "transactionId": "abcb0b53015211edb4490a58a9feac0c",
        "channelId": "1143791",
        "channelName": "1p6d9g0o7k7w9a1m",
        "productCode": "UQcEYh2fVuKqS6cTuR3X_MonthlySub",
        "productName": "UQcEYh2fVuKqS6cTuR3X_MonthlySub_name",
        "price": 0.99,
        "total": 0.99,
        "tax": 0.0,
        "currency": "usd",
        "originalTransactionId": "abcb0b53-0152-11ed-b449-0a58a9feac0c",
        "eventDate": "2022-07-11T19:50:18Z",
        "expirationDate": "2022-08-11T19:50:16Z",
        "comments": "New order processed.",
        "responseKey": "abcb0b53015211edb4490a58a9feac0c",
        "purchaseChannel": "DEVICE",
        "purchaseContext": "IAP",
        "isFreeTrial": false
    }
    

#### Renewal example

    {
        "customerId": "2df58f54b4f7540ca3aa31ce8bec1fe7",
        "transactionType": "Sale",
        "transactionId": "037w1nn4nyzum28gkyj0poqqv7n4cb5q",
        "channelId": "1143791",
        "channelName": "1p6d9g0o7k7w9a1m",
        "productCode": "UQcEYh2fVuKqS6cTuR3X_MonthlySub",
        "productName": "UQcEYh2fVuKqS6cTuR3X_MonthlySub_name",
        "price": 0.99,
        "total": 0.99,
        "tax": 0.0,
        "currency": "usd",
        "originalTransactionId": "447a4348-9c35-4b12-9dbe-64e5ed79cd9e",
        "originalPurchaseDate: '2022-03-03T02:51:33Z',
        "eventDate": "2024-02-03T11:27:16Z",
        "expirationDate": "2024-03-03T02:51:33Z",
        "comments": "Recurring subscription processed",
        "responseKey": "abcb0b53015211edb4490a58a9feac0c",
        "purchaseChannel": "DEVICE",
        "purchaseContext": "IAP",
        "isFreeTrial": false
    }
    

Since March 23, 2020, the `creditsApplied` field is included only if a service credit was applied to the transaction. This field helps verify that a specific service credit issued by the app was applied by Roku Pay.

### In grace period

If the auto-renewal of a customer's subscription fails, Roku Pay automatically places the subscription in a 3-day grace period. When a subscription is in a grace period, the publisher should allow the customer to continue accessing content on the app, while Roku Pay automatically notifies them daily via email to update their method of payment (MOP) and attempts to charge their current MOP on file.

If Roku receives a payment during the 3-day grace period, it is processed and entitlement is maintained (the billing period also remains the same). If no payment is received by the end of the 3-day grace period, the subscription is canceled.

*   A **GraceInitiated** push notification is sent when payment for a subscription auto-renewal fails. When this occurs, the customer may still access content while Roku attempts to charge the MOP. The developer should use the DoRecovery API to display an in-app notice prompting customers to update their method of payment. When the customer selects content in the app, the publisher should still grant access to it.

*   A **GraceRecovered** push notification is sent when payment is received for a subscription that was in a grace period. When this occurs, the customer maintains access to content and the billing period remains the same. The developer should stop prompting the customer to update their method of payment.

See [Basic Subscription Recovery](/docs/developer-program/roku-pay/subscription-recovery/basic-recovery.md) for more information.

#### GraceInitiated example

    {
        "customerId": "9aa37bd6f970578294cea4783af08560",
        "transactionType": "GraceInitiated",
        "transactionId": "024d4e1f-c7b6-11ee-afbe-0a58a9feaca8",
        "channelId": "3605562",
        "productCode": "0fCsu09EGS5C6OHlEUnz_MonthlySub",
        "productName": "0fCsu09EGS5C6OHlEUnz_MonthlySub",
        "originalTransactionId": "024d4e1f-c7b6-11ee-afbe-0a58a9feaca8",
        "originalPurchaseDate": "2024-01-12T01:45:36Z",
        "eventDate": "2024-02-10T01:45:39Z",
        "expirationDate": "2024-02-10T01:45:36Z",
        "comments": "Subscription is in dunning state",
        "responseKey": "163792dbc7b611eeafbe0a58a9feaca8",
        "isFreeTrial": false
    }
    

#### GraceRecovered example

    {
        "customerId": "9d425957549250dcba71e03dacf426b5",
        "transactionType": "GraceRecovered",
        "transactionId": "f0864331-c7b6-11ee-a3c4-0a58a9fead9c",
        "channelId": "3193830",
        "productCode": "PPfCfuZMf3TOXBBl3Ttu_MonthlySub",
        "productName": "PPfCfuZMf3TOXBBl3Ttu_MonthlySub",
        "originalTransactionId": "d4c4da85-c7b6-11ee-a3c4-0a58a9fead9c",
        "originalPurchaseDate": "2024-01-12T01:51:39Z",
        "eventDate": "2024-02-10T01:51:46Z",
        "expirationDate": "2024-03-10T01:51:39Z",  
        "comments": "Subscription recovered from dunning state.",
        "responseKey": "d915ab762a3752e7bf112e7903958f52",
        "isFreeTrial": false
    }
    

### On hold

For publishers using [Enhanced Subscription Recovery](/docs/developer-program/roku-pay/subscription-recovery/subscription-on-hold.md), if the auto-renewal of a customer's subscription continues to fail and the grace period elapses, Roku Pay automatically places the subscription on hold. When a subscription is on hold, the publisher blocks the customer from accessing content on the app, while Roku Pay automatically notifies them daily on-device and via email for 60 days to update their method of payment (MOP) and attempts to charge their current MOP on file.

If Roku receives a payment, it is processed and entitlement is automatically granted again, and the billing period adjusts to the time that the payment was collected. If no payment is received by the end of the 60-day notification cycle, the subscription is canceled.

*   An **OnHoldInitiated** push notification is sent when payment for a subscription auto-renewal fails. When this occurs, the customer should no longer have access to content. The developer should use the DoRecovery API to display an in-app notice prompting customers to update their method of payment. When the customer selects content in the app, the publisher should block access to it. The developer should update their entitlement system to denote that access to content should be denied.

*   An **OnHoldRecovered** push notification is sent when payment is received for a subscription that was on-hold. When this occurs, the customer should once again have access to content and the billing period should adjusted to the time that the payment was collected. The developer should stop prompting the customer to update their method of payment, update their system with the new billing period, and update their entitlement system to denote that access to content should be granted.

See [Enhanced Subscription Recovery](/docs/developer-program/roku-pay/subscription-recovery/subscription-on-hold.md) for more information.

#### OnHoldInitiated example

    {
        "customerId": "8446ceff30e952349bcd9d3b78bc94a0",
        "transactionType": "OnHoldInitiated",
        "transactionId": "ed0ca6b7348411ed84a30a58a9feaec5",
        "channelId": "1688604",
        "productCode": "VR8IqPLBJ7VeWD7bvIHH_MonthlySub",
        "productName": "VR8IqPLBJ7VeWD7bvIHH_MonthlySub",
        "originalTransactionId": "df10f029-3484-11ed-b4bf-0a58a9feacbc",
        "originalPurchaseDate": "2022-08-14T23:28:23Z",
        "eventDate": "2022-09-14T23:28:24Z",
        "expirationDate": "2022-09-13T23:28:23Z",
        "comments": "Subscription is in Passive OnHold state",
        "responseKey": "ed0ca6b7348411ed84a30a58a9feaec5",
        "isFreeTrial": false
    }
    

#### OnHoldRecovered example

    {
        "customerId": "8446ceff30e952349bcd9d3b78bc94a0",
        "transactionType": "OnHoldRecovered",
        "transactionId": "b466213697aa59a4ac53804daa1272bc",
        "channelId": "1688604",
        "productCode": "VR8IqPLBJ7VeWD7bvIHH_MonthlySub",
        "productName": "VR8IqPLBJ7VeWD7bvIHH_MonthlySub",
        "originalTransactionId": "df10f029-3484-11ed-b4bf-0a58a9feacbc",
        "originalPurchaseDate": "2022-08-14T23:28:23Z",
        "eventDate": "2022-09-14T23:28:29Z",
        "expirationDate": "2022-10-14T23:28:09Z",
        "comments": "Subscription recovered from Passive OnHold state.",
        "responseKey": "b466213697aa59a4ac53804daa1272bc",
        "isFreeTrial": false
    }
    

### Cancellation

A **Cancellation** push notification is sent when a user actively cancels their subscription, or a subscription is passively canceled because the customer fails to provide a valid method of payment to keep their subscription. An **expirationDate** in the future indicates an active cancellation; a past date indicates a passive cancellation.

The publisher action required (if any) depends on the **expirationDate** field:

*   **Future date**: No action is required until the expiration date.
*   **Today's date**: Remove the entitlement (the customer actively canceled the subscription and today is the last day of the billing cycle).
*   **Past date**: Remove entitlement (passive cancellation; the subscription could not be recovered).

#### Active cancelation example

    {
        "customerId": "493d0c919a9d547086baaccd2a80daf0",
        "transactionType": "Cancellation",
        "transactionId": "f4abd057015211edb4490a58a9feac0c",
        "channelId": "1143791",
        "productCode": "UQcEYh2fVuKqS6cTuR3X_MonthlySub",
        "productName": "UQcEYh2fVuKqS6cTuR3X_MonthlySub_name",
        "originalTransactionId": "e875704d-0152-11ed-b449-0a58a9feac0c",
        "originalPurchaseDate": "2022-07-11T19:51:57Z",
        "eventDate": "2022-07-11T19:52:12Z",
        "expirationDate": "2022-08-11T19:51:57Z",
        "comments": "Cancellation for UQcEYh2fVuKqS6cTuR3X_MonthlySub_name",
        "responseKey": "f4abd057015211edb4490a58a9feac0c",
        "isFreeTrial": false
    }
    

#### Passive cancelation example

    {
        "customerId": "493d0c919a9d547086baaccd2a80daf0",
        "transactionType": "Cancellation",
        "transactionId": "f4abd057015211edb4490a58a9feac0c",
        "channelId": "1143791",
        "productCode": "UQcEYh2fVuKqS6cTuR3X_MonthlySub",
        "productName": "UQcEYh2fVuKqS6cTuR3X_MonthlySub_name",
        "originalTransactionId": "e875704d-0152-11ed-b449-0a58a9feac0c",
        "originalPurchaseDate": "2023-10-09T00:47:11Z",
        "eventDate": "2024-02-02T08:04:30Z",
        "expirationDate": "2023-11-09T00:47:11Z",
        "comments": "Cancellation for UQcEYh2fVuKqS6cTuR3X_MonthlySub_name",
        "responseKey": "f4abd057015211edb4490a58a9feac0c",
        "isFreeTrial": false
    }
    

### Refund

A **Refund** push notification is sent when the publisher or Roku Pay initiates a refund. If the refund was a result of an unauthorized purchase, Roku cancels the subscription. In this case, the publisher should remove the entitlement upon receipt of a subsequent **Cancellation** notification.

#### Example

    {
        "customerId": "cb570816d25c547ca881cfae77dc4068",
        "transactionType": "Refund",
        "transactionId": "a062b93cdecf5a35bff9b2425ccaff7c",
        "channelId": "1143791",
        "productCode": "UQcEYh2fVuKqS6cTuR3X_MonthlySub",
        "productName": "UQcEYh2fVuKqS6cTuR3X_MonthlySub_name",
        "price": -0.99,
        "total": -1.06,
        "tax": -0.07,
        "currency": "usd",
        "partnerReferenceId": "1657569338",
        "originalTransactionId": "675cc6c9-0153-11ed-b449-0a58a9feac0c",
        "originalPurchaseDate": "2022-07-11T19:55:32Z",
        "eventDate": "2022-07-11T19:55:34Z",
        "comments": "Refund for UQcEYh2fVuKqS6cTuR3X_MonthlySub_name",
        "responseKey": "a062b93cdecf5a35bff9b2425ccaff7c",
        "isFreeTrial": false
    }
    

### Credit

A **Credit** push notification is sent when the publisher or Roku Pay issues a service credit for a Roku customer. No publisher action is required upon receiving this event.

#### Example

    {
        "customerId": "e54246dd10405b159f4799ef60d791ce",
        "transactionType": "Credit",
        "transactionId": "579743",
        "channelId": "1143791",
        "channelName": "1p6d9g0o7k7w9a1m",
        "productCode": "UQcEYh2fVuKqS6cTuR3X_MonthlySub",
        "productName": "UQcEYh2fVuKqS6cTuR3X_MonthlySub_name",
        "price": 1.0,
        "total": 1.0,
        "currency": "usd",
        "partnerReferenceId": "2d6ab759-de47-43b4-939a-15fd491a6698",
        "eventDate": "2022-07-11T20:00:45.458297119Z",
        "comments": "Admin credit push notifications",
        "responseKey": "029282d0015411eda89b0a58a9feac07",
        "isFreeTrial": false
    }
    

### Resubscribe

A **Resubscribe** push notification is sent when a customer opts to keep a subscription they previously canceled within the current billing period. For example, during a 30-day billing period, a customer cancels a subscription on day 10, but on day 20 decides to keep it. If the customer repurchases the subscription after the billing period ends, a **Sale** notification is sent. When a customer resubscribes, service will continue for them as though they never canceled the subscription at all.

#### Example

    {
        "customerId": "12d3ddf4509c5bc5bbcfee76bd97f58e",
        "transactionType": "Resubscribe",
        "transactionId": "3baba090015311edb4490a58a9feac0c",
        "channelId": "1143791",
        "productCode": "UQcEYh2fVuKqS6cTuR3X_MonthlySub",
        "productName": "UQcEYh2fVuKqS6cTuR3X_MonthlySub_name",
        "price": 0.0,
        "total": 0.0,
        "tax": 0.0,
        "currency": "usd",
        "originalTransactionId": "325f8f87-0153-11ed-b449-0a58a9feac0c",
        "originalPurchaseDate": "2022-07-11T19:54:02Z",
        "eventDate": "2022-07-11T19:54:11Z",
        "comments": "Resubscription processed.",
        "responseKey": "3baba090015311edb4490a58a9feac0c",
        "isFreeTrial": false
    }
    

Similar to the **Sale** notification, a `creditsApplied` field is included only if a service credit was applied to the transaction.

### Upgrades/downgrades

When a customer [upgrades or downgrades a subscription](/docs/developer-program/roku-pay/implementation/on-device-upgrade-downgrade.md), a new purchase is made and the original one is canceled. As a result, a pair of notifications are sent: a sale for the new transaction (`UpgradeSale` or `DowngradeSale`), and a cancellation for the original transaction (`UpgradeCancellation` or `DowngradeCancellation` ). The `transactionType` field in the push notification indicates the upgrade/downgrade event associated with the notification. This makes it easy to identify the reason for purchases and cancellations related to upgrades/downgrades.

For example, if a customer upgrades from a monthly to an annual subscription, the following two notifications are sent: (1) an `UpgradeSale` notification for the purchase of the annual subscription, and (2) an `UpgradeCancellation` notification for the cancellation of the monthly subscription. The following table summarizes the transaction types for the notifications sent for upgrades and downgrades.

| Action | Transaction Type |     |
| --- | --- | --- |
| Sale | Cancellation |
| --- | --- | --- |
| **Upgrade** | UpgradeSale | UpgradeCancellation |
| **Downgrade** | DowngradeSale | DowngradeCancellation |

The following samples demonstrate the `UpgradeSale` and `UpgradeCancellation` notifications sent when a customer upgrades from a monthly to an annual subscription. Samples of the `DowngradeSale` and `DowngradeCancellation` notifications are included as well.

#### UpgradeSale example

    {
        "customerId": "8c805ea26be25915a6c15e4545f592a4",
        "transactionType": "UpgradeSale",
        "transactionId": "884b1a6c015311edb4490a58a9feac0c",
        "channelId": "627917",
        "channelName": "disneychannelteststg",
        "productCode": "QynVhYtdThAg7wcfTkgi_MonthlySubFreeTrial",
        "productName": "QynVhYtdThAg7wcfTkgi_MonthlySubFreeTrial",
        "currency": "usd",
        "originalTransactionId": "884b1a6c-0153-11ed-b449-0a58a9feac0c",
        "eventDate": "2022-07-11T19:56:29Z",
        "expirationDate": "2022-07-18T19:56:29Z",
        "comments": "New order processed.",
        "responseKey": "884b1a6c015311edb4490a58a9feac0c",
        "purchaseChannel": "DEVICE",
        "purchaseContext": "IAP",
        "isFreeTrial": true
    }
    

#### UpgradeCancellation example

    {
        "customerId": "8c805ea26be25915a6c15e4545f592a4",
        "transactionType": "UpgradeCancellation",
        "transactionId": "8e7f6459015311edb4490a58a9feac0c",
        "channelId": "627917",
        "productCode": "ZTtL0DvuGNX1sO4tJGNp_MonthlySubFreeTrial",
        "productName": "ZTtL0DvuGNX1sO4tJGNp_MonthlySubFreeTrial",
        "originalTransactionId": "7c8e097a-0153-11ed-b449-0a58a9feac0c",
        "originalPurchaseDate": "2022-07-11T19:56:06Z",
        "eventDate": "2022-07-11T19:56:30Z",
        "expirationDate": "2022-07-18T19:56:06Z",
        "comments": "Cancellation for ZTtL0DvuGNX1sO4tJGNp_MonthlySubFreeTrial",
        "responseKey": "8e7f6459015311edb4490a58a9feac0c",
        "isFreeTrial": false
    }
    

#### DowngradeSale example

    {
        "customerId": "7993a78f2922550589654e4dbe21404a",
        "transactionType": "DowngradeSale",
        "transactionId": "a52ff4b7015311edb4490a58a9feac0c",
        "channelId": "627917",
        "channelName": "rokudeveloperteststg",
        "productCode": "ZTtL0DvuGNX1sO4tJGNp_MonthlySubFreeTrial",
        "productName": "ZTtL0DvuGNX1sO4tJGNp_MonthlySubFreeTrial",
        "currency": "usd",
        "originalTransactionId": "a52ff4b7-0153-11ed-b449-0a58a9feac0c",
        "eventDate": "2022-07-11T19:57:14Z",
        "expirationDate": "2022-07-18T19:56:54Z",
        "comments": "New order processed.",
        "responseKey": "a52ff4b7015311edb4490a58a9feac0c",
        "purchaseChannel": "DEVICE",
        "purchaseContext": "IAP",
        "isFreeTrial": true
    }
    

#### DowngradeCancellation example

    {
        "customerId": "7993a78f2922550589654e4dbe21404a",
        "transactionType": "DowngradeCancellation",
        "transactionId": "a98173fc015311ed810f0a58a9feac11",
        "channelId": "627917",
        "productCode": "QynVhYtdThAg7wcfTkgi_MonthlySubFreeTrial",
        "productName": "QynVhYtdThAg7wcfTkgi_MonthlySubFreeTrial",
        "originalTransactionId": "996acd4c-0153-11ed-b449-0a58a9feac0c",
        "originalPurchaseDate": "2022-07-11T19:56:54Z",
        "eventDate": "2022-07-11T19:57:15Z",
        "expirationDate": "2022-07-18T19:56:54Z",
        "comments": "Cancellation for QynVhYtdThAg7wcfTkgi_MonthlySubFreeTrial",
        "responseKey": "a98173fc015311ed810f0a58a9feac11",
        "isFreeTrial": false
    }
    

### Chargeback

> **Chargebacks**: When a customer disputes a transaction made through Roku Pay that results in a chargeback, the **transactionType** field in the refund [n](https://developer.roku.com/docs/developer-program/roku-pay/implementation/push-notifications.md#refund)otification is set to "Chargeback", "ChargebackReversed", or "SecondChargeback" (this is the sequence in which these events may occur). Each of these events is described in the following sections.
> 
> **SEPA chargebacks (for apps in the Germany Streaming Store)**: When a customer in Germany disputes a transaction made through Roku Pay that results in a chargeback or their bank account has insufficient funds, the **transactionType** field in the refund notification is set to "Chargeback".

A **Chargeback** push notification is sent when a customer initiates a transaction dispute. The transaction is deducted from the partner's payout.

#### Example

    {
        "customerId": "cb570816d25c547ca881cfae77dc4068",
        "transactionType": "Chargeback",
        "transactionId": "wci8ef2snsq0z6micdcye2an6m6k5wq2",
        "channelId": "581251",
        "productCode": "VR8IqPLBJ7VeWD7bvIHH_MonthlySub",
        "productName": "VR8IqPLBJ7VeWD7bvIHH_MonthlySub",
        "price": -2.99,
        "total": -2.99,
        "tax": -0.00,
        "currency": "usd",
        "partnerReferenceId": ",
        "originalTransactionId": "856b408a-65e5-4c43-9d37-20fd7b33e650",
        "originalPurchaseDate": "2024-01-13T18:52:48Z",
        "eventDate": "2024-01-25T17:38:14Z",
        "responseKey": "a062b93cdecf5a35bff9b2425ccaff7c",
        "isFreeTrial": false
    }
    

### ChargebackReversed

A **Chargeback** push notification is sent when Roku has successfully reversed a chargeback claim. The revenue share is returned to the partner payout.

No publisher action is required when this event occurs.

**Example**

    {
        "customerId": "cb570816d25c547ca881cfae77dc4068",
        "transactionType": "ChargebackReversed",
        "transactionId": "1ok27ojghw015hfyulu6uuc3ovh4x2ca",
        "channelId": "581251",
        "productCode": "VR8IqPLBJ7VeWD7bvIHH_MonthlySub",
        "price": 2.99,
        "total": 2.99,
        "tax": 0.00,
        "currency": "usd",
        "partnerReferenceId": ",
        "originalTransactionId": "5b9272e3-93c0-438a-a5ed-b8da5df17b5f",
        "originalPurchaseDate": "2021-12-02T03:21:36Z",
        "eventDate": "2024-02-07T17:41:51Z",
        "responseKey": "a062b93cdecf5a35bff9b2425ccaff7c",
        "isFreeTrial": false
    }
    

### SecondChargeback

A **SecondChargeback** push notification is sent when the customer's bank has disputed the chargeback reversal on a transaction (this may occur if the customer provided new information, the chargeback reason changed, or the bank determined that the information provided by Roku was not sufficient to refute the chargeback). The transaction is deducted from the partner's payout.

No publisher action is required when this event occurs.

**Example**

    {
        "customerId": "cb570816d25c547ca881cfae77dc4068",
        "transactionType": "SecondChargeback",
        "transactionId": "17ehfl6ia1ho3dfinurlgkom3b6ek36n",
        "channelId": "581251",
        "productCode": "VR8IqPLBJ7VeWD7bvIHH_MonthlySub",
        "price": -2.99,
        "total": -2.99,
        "tax": 0.00,
        "currency": "usd",
        "partnerReferenceId": ",
        "originalTransactionId": "6ee32cd3-fd68-4997-b279-1438ea4d8177",
        "originalPurchaseDate": "2023-09-09T01:00:52Z",
        "eventDate": "2024-02-20T19:58:53Z",
        "responseKey": "a062b93cdecf5a35bff9b2425ccaff7c",
        "isFreeTrial": false
    }

ifRegistry
==========

Implemented by
--------------

| Name | Description |
| --- | --- |
| [roRegistry](/docs/references/brightscript/components/roregistry.md "roRegistry") | The Registry is an area of non-volatile storage where a small number of persistent settings can be stored |

Supported methods
-----------------

### GetSpaceAvailable() as Integer

#### Description

Returns the number of bytes available in the app's device registry (32K). This function can be used, for example, to check the remaining space and remove older entries before writing newer ones. The following code demonstrates how to do this:

    registry = CreateObject("roRegistry")
    buffer = 512 ' arbitrary limit based on the app
    if (registry.GetSpaceAvailable() < buffer)
    ' remove some old registry entries before writing new ones
    end if
    

#### Return Value

An integer representing the the number of bytes available in the device registry.

### GetSectionList() as Object

#### Description

Returns the registry sections on the device.

#### Return Value

An roList with one entry for each registry section. Each registry section is an roString containing the name of the section. The section itself can be accessed by creating an [roRegistrySection](/docs/references/brightscript/components/roregistrysection.md "roRegistrySection") object using that name.

### Delete(section as String) as Boolean

#### Description

Deletes the specified registry section.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| section | String | The registry section to be deleted. |

#### Return Value

A flag indicating whether the registry section was successfully deleted.

### Flush() as Boolean

#### Description

Flushes the contents of the registry out to persistent storage in order to permanently store a token or other setting on the device.

#### Return Value

A flag indicating whether the registry was successfully flushed.

ifRegex
=======

> See the PCRE documentation ([http://www.pcre.org/](http://www.pcre.org/)) for documentation on the PCRE library used for regular expression matching. See the [Perlre main page](http://perldoc.perl.org/perlre.html "Perlre main page") for complete documentation of the possible regular expressions this library can parse and match. In general, most Perl compatible regular expressions are supported.

Implemented by
--------------

| Name | Description |
| --- | --- |
| [roRegex](/docs/references/brightscript/components/roregex.md "roRegex") | The roRegex component provides the powerful regular expression processing of the PCRE library to Brightscript strings |

Supported methods
-----------------

### IsMatch(str as String) as Boolean

#### Description

Checks if a string matches the matching pattern.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| str | String | The string to be checked. |

#### Return Value

A flag indicating whether the string matches the matching pattern.

### Match(str as String) as Object

#### Description

If the matching pattern contains N parenthetical substrings, the relevant substrings are returned as an array of length N+1, where array\[0\] is again the entire match and each additional entry in the array is the match for the corresponding parenthetical expression.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| str | String | The string to be searched for matching substrings. |

#### Return Value

An roArray of matched substrings from str. If no match was made, an empty array is returned. If a match was made, the entire match is returned in array\[0\]. If there are no parenthetical substrings this is the only entry in the array

#### Example (from Brightscript Debugger Interactive Shell)

     r = CreateObject("roRegex", "(a|(z))(bc)","")
     ? r.Match("abcd")
     abc
     a
    
     bc
    

### MatchAll(str as String) as Object

#### Description

Returns all matches of the specific regular expression pattern in the target string.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| str | String | The string to be searched for matching substrings. |

#### Return Value

An roArray where the first element is the full matched string and if there are any capture groups those are returned in subsequent array elements

#### Example

      r = CreateObject("roRegex", "\d+", "")
      arr = r.MatchAll("123 456 789")
      print FormatJSON(arr)
    
     [["123"],["456"],["789"]]
    

### Replace(str as String, replacement as String) as String

#### Description

Replaces the first occurrence of a matching pattern in str with replacement and returns the result. The replacement may contain numbered back-references to parenthetical substrings.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| str | String | The string to be searched. |
| replacement | String | The string to be used to replace matches in source string. |

#### Example (from Brightscript Debugger Interactive Shell)

     r = CreateObject("roRegex", "(\d+)\s+(\w+)", "")
     ? r.Replace("123 abc", "word:\2 number:\1")
     word:abc number:123
    

#### Return Value

A string with the result of the replace operation.

### ReplaceAll(str as String, replacement as String) as String

#### Description

Replaces all occurrences of a matching pattern in str with replacement and returns the result. The replacement may contain numbered back-references to parenthetical substrings.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| str | String | The string to be searched. |
| replacement | String | The string to be used to replace matches in source string. |

#### Return Value

A string with the result of the replace all operation.

#### Example (from Brightscript Debugger Interactive Shell)

      r = CreateObject("roRegex", "a", "i")
      ? r.ReplaceAll("Abracadabra", "x")
     xbrxcxdxbrx
    
      r = CreateObject("roRegex", "a", "")
      ? r.ReplaceAll("Abracadabra", "x")
     Abrxcxdxbrx
    

### Split(str as String) as Object

#### Description

Uses the matching pattern as a separator and splits the string on the separator boundaries.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| str | String | The string to be split. |

#### Return Value

An roList of substrings of str that were separated by strings which match the pattern in the CreateObject call. The separator strings are not returned. If no matches were found, the returned list contains a single item with the string unchanged.

**Examples from Brightscript Debugger Interactive Shell**

     r = CreateObject("roRegex", ",", "") ' split on comma
     ? r.Split("first, second, third and fourth")
     first
      second
      third and fourth
     r = CreateObject("roRegex", "/+", "") ' split on one or more slashes
     ? r.Split("example.com/images///2012/cat.jpg")
      example.com
      images
      2012
      cat.jpg

Setting the monetization method
===============================

To add products to a subscription video on demand (SVOD) or transactional video on demand (TVOD) app that is implementing Roku Pay, you must specify which monetization methods your app will use: **subscriptions** and/or **one-time purchases**. This step is required when publishing apps to the Streaming Store; however, it is a best practice to set the monetization method directly after creating an app. This ensures that you can create in-app products without encountering any error messages in the Developer Dashboard.

> **Certification requirement**: Apps offering subscriptions and one-time purchases must [implement Roku Pay](/docs/developer-program/roku-pay/implementation/overview.md) and adhere to all [Roku Pay certification requirements](/docs/developer-program/roku-pay/roku-pay-requirements.md). Per the [Roku Distribution Agreement](https://docs.roku.com/published/developerdistribution/en/us), paid applications must use Roku Pay; they may not use any alternate billing service, direct customers to any alternative billing service(s), or encourage customers to purchase access to content other than through the Roku platform.
> 
> To pass certification, SVOD and TVOD apps (and other subscription services) must complete sign-ups and sign-ins on-device, without having customers visit an external webpage. The sign-up and sign-in workflows may not include links to off-device promotional or marketing materials, nor may it utilize off-device sign-in mechanisms such as rendezvous linking.
> 
> Apps must display the Request for Information (RFI) screen during the on-device sign-up and sign-in flows to enable customers to share their Roku customer account information with apps. Only if the user declines the request, may apps require the customer to manually enter their information.

Monetization methods
--------------------

To select the monetization methods for an app, follow these steps:

1.  In the [Developer Dashboard](https://developer.roku.com/developer), select **Manage My Channels**, click **Preview and** **Update** on your test app, and then select **Monetization** from the drop-down list.
    
    If you have not created a test app yet, click **Add Channel**, select **Developer SDK**, mark the app as **public** or **beta**, enter an app name, and then select **Monetization** from the drop-down list.
    

2.  Select one or more of the following options:
    
    ![roku815px - monetization-method.jpg](https://image.roku.com/ZHZscHItMTc2/monetization-method-v4c.png)
    
    *   **Customers will pay before installing my channel (pay-to-install)**. Pay-to-install apps are typically only used on the Roku platform for games and screensavers. Pay-to-install apps are not typically used for SVOD apps—they do not enable customers to browse the content before installing the app, and they do not support free trial offers. See [In-app products](/docs/developer-program/roku-pay/quickstart/in-channel-products.md) for more information on configuring these fields.
        
    *   **My channel contains in-channel subscriptions (SVOD)**. The app includes a monthly or annual subscription offering. Select this option for SVOD apps. See **In-app products** for more information on creating subscription products.
        

> If you select this check box, you must [implement Roku Pay](/docs/developer-program/roku-pay/implementation/overview.md) in your app and adhere to all [Roku Pay certification requirements](/docs/developer-program/roku-pay/roku-pay-requirements.md).

*   **My channel contains in-channel one-time purchases (TVOD)**. The app offers transactional content such as movie rentals, sporting events, and pay-per-views. Select this option for TVOD-exclusive apps (app contains only transactional content) and SVOD apps that additionally offer one-time purchase products. See [Creating TVOD apps](/docs/developer-program/roku-pay/implementation/tvod-channel.md) for more information on creating one-time purchase products in the **In-App Products** page.

> If you select this check box, you must [implement Roku Pay](/docs/developer-program/roku-pay/implementation/overview.md) in your app and adhere to all [Roku Pay certification requirements](/docs/developer-program/roku-pay/roku-pay-requirements.md).

3.  Click **Save**. See [Publishing apps](/docs/developer-program/publishing/channel-publishing-guide.md#monetization-window) for more information on configuring additional app monetization methods.

MarkupGrid
==========

Extends [**ArrayGrid**](/docs/references/scenegraph/abstract-nodes/arraygrid.md)

The MarkupGrid node class is a is a generic grid class that can be used to display a set of items arranged into a 2D grid. The contents of each grid item is an instance of an XML component specified by the `itemComponentName` field. An instance of the XML component is used to display the data for each item in the grid data model. The appearance of the grid item as it enters/exits the grid focus position can be customized using scripting. [SimpleMarkupList](https://github.com/rokudev/samples/blob/master/ux%20components/lists%20and%20grids/SimpleMarkupList) is a sample app containing a MarkupGrid where each item is an instance of an XML component. See the section [MarkupGrid XML component](/docs/references/scenegraph/list-and-grid-nodes/markupgrid.md#markupgrid-xml-component) for details.

The number of columns in the MarkupGrid node is fixed and the number of rows varies as needed to display all of the items in the grid data model. The items in the grid fill each row from left to right, then top to bottom. For example, if the grid data contains 8 items and the number of columns is set to 3, then items 1, 2 and 3 will be in the first row. Items 4, 5 and 6 will be in the second row. The third row will contain items 7 and 8 in the leftmost two columns and blank space in the right column.

The layout of rows and columns in the grid is very flexible. Possible layouts include:

*   a simple layout with all items in the grid having the same size
*   a layout with the items in some rows having varying heights and/or the items in some columns having varying widths
*   a layout with varying width rows and columns and items that occupy one or more rows and columns

The grid items can be organized into sections that are demarcated by labelled horizontal divider lines between the sections.

### Example

The following is an example using MarkupGrid.

![roku815px - MarkupGrid-example1](https://image.roku.com/ZHZscHItMTc2/MarkupGrid-example1.jpg "MarkupGrid-example1")

Grid Layouts
------------

The MarkupGrid class supports very flexible layouts. The philosophy is that simple layouts are easy to produce and complicated layouts are possible.

There are three general categories of layouts:

1.  Simple layouts with all grid items and spacings between items equal.To specify a simple layout, set the `itemSize` field value to the width and height of each of the items in the grid, and set the `itemSpacing` field value to the desired spacing between items. For example, if the `itemSize` field value is \[300,100\],and `itemSpacing` field value is \[4,8\], then the grid items will be 300 pixels wide and 100 pixels high. There will be four pixels between the columns of the grid, and eight pixels between rows of the grid.
    
2.  All the items are aligned in rows and columns, but the rows and columns (or the spacing between them) varies.To specify this type of layout, set the `columnWidths`, `columnSpacings`, `rowHeights` and `rowSpacings` field values. Each of these fields takes an array of values, specifying the values for each row width, column height or spacing between rows and columns. If there are more rows or columns in the grid than specified in the arrays for these fields, the corresponding simple layout field values are used for the missing values (such as the x-dimension value of the `itemSize` field for a missing `columnWidth` field value).For example, suppose a grid is designed with four columns, where each item was 80 pixels wide, and had four pixels of space between them. The grid data includes ten rows, where the first four rows have items that are 120 pixels tall, and the remaining six rows have items that are 80 pixels high. All the rows should have six pixels of space between them. To specify this layout, you would set the field values like this:
    

| Field | Value |
| --- | --- |
| itemSize | \[ 80, 80 \] |
| itemSpacings | \[ 4, 6 \] |
| rowHeights | \[ 120, 120, 120, 120, 80, 80, 80, 80, 80, 80 \] |

> Since the final six values in the rowHeights field value array equal the y-dimension itemSize field value, you could omit them, so in this case setting the rowHeights field value to \[120,120,120,120\] would have the same result.

3.  There are clear alignments in the row/column layout, but some items can span more than one row or column (plus the space in between).To specify this type of layout, set the field values as in the first two types of grid layouts to define the sizes of the rows/columns. If any of the grid items occupy more than one row or column, then the metadata for each grid item must contain extra metadata specifying the starting row, starting column, numbers of rows and number of columns that the item occupies. In addition, the `fixedLayout` field value must be set to `true`.For example, if a grid item is supposed to span columns 2 and 3, and rows 3 through 6, then in addition to the metadata for the item contents, the metadata for that item would include (X = 2, Y = 3, W = 2, H = 4). W is set to 2 because the item is 2 columns wide. Similarly H is set to 4 because the item is 4 rows tall.The total pixel width of the item would be the (width of column 2) + (spacing between columns 2 and 3) + (width of column 3). Similarly, the height of the item would be the sum of the heights of columns 3, 4, 5 and 6, plus the spacings between columns 3 and 4, 4 and 5, and 5 and 6.The X and Y indices start from 0 (that is, the first column is X = 0).

Fields
------

| Field | Type | Default | Access Permission | Description |
| --- | --- | --- | --- | --- |
| itemComponentName | string |     | READ\_WRITE | Specifies the name of a XML component for the grid items. An instance of this component is created on demand for each visible item of the grid. The XML component must define a specific interface as detailed in [MarkupGrid XML component](/docs/references/scenegraph/list-and-grid-nodes/markupgrid.md#markupgrid-xml-component) below. |
| content | ContentNode | none | READ\_WRITE | Specifies the content for the list. See [Data bindings](/docs/references/scenegraph/list-and-grid-nodes/markupgrid.md#data-bindings) below for more details.  <br>If the data contains section markers, section dividers will be drawn between each section. These section dividers may contain an icon and/or a string. |
| itemSize | vector2d | \[0,0\] | READ\_WRITE | Specifies the width and height of the default size for the grid items. |
| numColumns | integer | 0   | READ\_WRITE | Specifies the number of columns in the grid |
| numRows | integer | 12  | READ\_WRITE | Specifies the number of visible rows displayed. The actual number of rows may be more or less than the number of visible rows specified depending on the number of items in the list content. |
| rowHeights | array of floats | \[ \] | READ\_WRITE | When specified, the rowHeights field specifies the heights of the poster for each row of the grid. This allows the height of each row of the grid to vary from row to row.  <br>  <br>The rowHeights values override the height specified in element 1 of the basePosterSize field. If the rowHeights array contains fewer elements than the number of rows needed to display all the items in the grid, element 1 of the basePosterSize field is used as the height of the excess rows. |
| columnWidths | array of floats | \[ \] | READ\_WRITE | When specified, the columnWidths field specifies the widths of the poster for each column of the grid. This allows the width of each column of the grid to vary from column to column.  <br>  <br>The columnWidths values override the width specified in element 0 of the basePosterSize field. If the columnWidths array contains fewer elements than the number of columns specified by the numColumns field, element 0 of the basePosterSize field is used as the width of the excess columns. |
| rowSpacings | array of floats | \[ \] | READ\_WRITE | When specified, the rowSpacings field specifies the spacing after each row of the grid. This allows the spacing between rows to vary from row to row.  <br>  <br>The rowSpacings values override the vertical spacing specified in element 1 of the itemSpacing field. If the rowSpacings array contains fewer elements than the number of rows needed to display all the items in the grid, element 1 of the itemSpacing field is used as the spacing after the excess rows. |
| columnSpacings | array of floats | \[ \] | READ\_WRITE | When specified, the columnSpacings field specifies the spacing after each column of the grid. This allows the spacing between columns to vary from column to column.  <br>  <br>The columnSpacings values override the horizontal spacing specified in element 0 of the itemSpacing field. If the columnSpacings array contains fewer elements than the number of columns specified by the numColumns field, element 0 of the itemSpacing field is used as the spacing after the excess columns. |
| fixedLayout | Boolean | false | READ\_WRITE | When fixedLayout is false, the MarkupGrid assigns each item in the data model to sequential cells in the grid (or the section if the data model includes section information).  <br>  <br>When fixedLayout is true, the data models using the X, Y, W and H attributes to specify which cells of the grid each item should occupy, where X is the column number, Y is the row number, W is the number of columns the item occupies and H is the number of rows the item occupies.  <br>  <br>Fixed layout should only be set to true for cases where one or more items in the grid should span multiple rows or columns. |
| imageWellBitmapUri | uri |     | READ\_WRITE | Specifies the bitmap file to use to suggest where images would appear for empty grids and empty sections of grids. Only set this field to specify a custom bitmap that differs in appearance from the default bitmap. |
| drawFocusFeedback | Boolean | true | READ\_WRITE | Specifies whether or not the focus indicator bitmap is displayed |
| drawFocusFeedbackOnTop | Boolean | false | READ\_WRITE | Specifies whether the focus indicator bitmap is drawn below or on top of the list items |
| focusBitmapUri | uri |     | READ\_WRITE | Specifies the bitmap file used for the focus indicator when the list has focus. In most cases, this should be a 9-patch image that specifies both expandable regions as well as margins. Only set this field to specify a custom bitmap that differs in appearance from the default bitmap. |
| focusFootprintBitmapUri | uri |     | READ\_WRITE | Specifies the bitmap file used for the focus indicator when the list does not have focus. In most cases, this should be a 9-patch image that specifies both expandable regions as well as margins. Only set this field to specify a custom bitmap that differs in appearance from the default bitmap. |
| focusBitmapBlendColor | color | 0xFFFFFFFF | READ\_WRITE | Blend the graphic image specified by `focusBitmapUri` with the specified color. If set to the default, 0xFFFFFFFF, no color blending will occur. Set this field to show a focus indicator graphic image with a different color than the image specified by `focusBitmapUri.` |
| focusFootprintBlendColor | color | 0xFFFFFFFF | READ\_WRITE | Blend the graphic image specified by `focusFootprintBitmapUri` with the specified color. If set to the default, 0xFFFFFFFF, no color blending will occur. Set this field to show a focus footprint indicator graphic image with a different color than the image specified by `focusFootprintBitmapUri`. |
| wrapDividerBitmapUri | uri |     | READ\_WRITE | Specifies the bitmap file to use as a wrap divider, the visual separator between the last and first list items when the list wraps. In most cases, this should be a 9-patch image that specifies both expandable regions. Only set this field to specify a custom bitmap that differs in appearance from the default bitmap. |
| wrapDividerHeight | float | 0.0 | READ\_WRITE | Specifies the height of the wrap divider, the visual separator between the last and first list items when the list wraps. The bitmap for the wrap divider is scaled to this height. The width of the wrap divider is set to the width of the list items as specified by the `itemSize` field width value. |
| sectionDividerBitmapUri | uri |     | READ\_WRITE | If the ContentNode specifies sections for a list or grid, specifies a custom bitmap to use as a visual divider between the sections of the list or grid. Only set this field to use a bitmap with a different appearance than the system default. For sections that do not include an icon or a title, the system default or custom bitmap specified as the `wrapDividerBitmapUri` field value is used for the section dividers. In most cases, you will want to use a 9-patch PNG bitmap with both expandable regions, which is the type of bitmap used as the system default. |
| sectionDividerFont | font | system default | READ\_WRITE | Specifies the font for section divider labels |
| sectionDividerTextColor | color | 0xddddddff | READ\_WRITE | Specifies the text color for section divider labels |
| sectionDividerSpacing | float | 10  | READ\_WRITE | Specifies the spacing between the items appearing in the section divider (e.g. the spacing between the section divider icon, the section divider label, and the section divider bitmap). Note the section divider does not always include an icon and/or a title. |
| sectionDividerHeight | float | 40  | READ\_WRITE | Specifies the height of the section dividers. The width of the section dividers is determined by the width of the list items as specified by the itemSize field width value. |
| sectionDividerMinWidth | float | 117 | READ\_WRITE | Specifies the minimum width of the section divider bitmap. The section divider label will be ellipsized if necessary in order to ensure that the section divider bitmap meets the minimum width. |
| sectionDividerLeftOffset | float | 0   | READ\_WRITE | Number of pixels to offset the left edge of the section divider relative to the left edge of the list items. |
| itemSelected | integer | 0   | READ\_ONLY | When a list item is selected, itemSelected is set to the index of the selected item. |
| itemFocused | integer | 0   | READ\_ONLY | When a list item gains the key focus, set to the index of the focused item. |
| itemUnfocused | integer | 0   | READ\_ONLY | When a list item loses the key focus, set to the index of the unfocused item. |
| jumpToItem | integer | 0   | WRITE\_ONLY | When set to a valid item index, this causes the list to immediately update so that the specified index moves into the focus position. |
| animateToItem | integer | 0   | WRITE\_ONLY | When set to a valid item index, this causes the list to quickly scroll so that the specified index moves into the focus position. |

MarkupGrid XML component
------------------------

The MarkupGrid node `itemComponentName` field value should be set to the name of an XML component used to display each item in the grid. An instance of this component is created for each visible item in the grid.

If the XML component contains interface fields that match the names shown in the table below, those fields will be updated by the MarkupGrid node. This allows the XML component to alter the item appearance based on changes to these interface fields.

Note that the fields are updated in the order presented in the table below. Any layout scripting you write based on these fields should be done in that order to avoid updating your layout based on a field that has not been updated yet.

| Field Name | Field Type | Description |
| --- | --- | --- |
| width | float | **Read-Only**  <br>Set to the width of the grid item. |
| height | float | **Read-Only**  <br>Set to the height of the grid item |
| index | integer | **Read-Only**  <br>Set to the index of this item in the data model. |
| gridHasFocus | Boolean | **Read-Only**  <br>Set to true if the MarkupGrid node has focus, false otherwise. |
| itemContent | ContentNode | Contains the data to be displayed by the grid item. The relationship between data in the ContentNode and the visual elements of the grid item is determined by the scripts in the item XML component. Typically, an observer callback function of the `itemContent` field is used to update the grid item when the content changes. |
| focusPercent | float | **Read-Only**  <br>The fractional value, from 0.0 to 1.0, of a time delay after focus has moved from one item to the next. The fractional value increases incrementally from 0.0 to 1.0 for the newly-focused item, while simultaneously decreasing from 1.0 to 0.0 for the previously-focused item. This value can be used as a timing key to smoothly animate the appearance of the focused item as well as the previously-focused item, to indicate the movement of focus to the user. |
| itemHasFocus | Boolean | **Read-Only**  <br>Indicates whether the item component currently is the MarkupGrid's focused item. When scrolling starts, the itemHasFocus field for the currently focused item is set to false. When scrolling ends, the itemHasFocus field for the newly focused item is set to true. During the scrolling animation, all itemHasFocus fields are set to false.  <br>Only one item component of any MarkupGrid should have itemHasFocus set to true. If the MarkupGrid does not focus, all itemHasFocus fields of their item components should be set to false. |

Example MarkupGrid XML component
--------------------------------

The following shows an example MarkupGrid node XML component. The XML markup defines a component named `SimpleGridItem` that creates a poster for each grid item. The poster has either a price or an icon overlaid on top of it, depending on the value of the `GOTITEMCONTENT` attribute of the item ContentNode. If `GOTITEMCONTENT` is true, that indicates that the item has already been purchased, and an icon is drawn on top of the lower/right corner of the poster. If `GOTITEMCONTENT` is false, that indicates that the item has not already been purchased. In that case, a semitransparent rectangle is drawn over the bottom part of the poster, and inside that rectangle, a label is drawn containing the price of the item.

To use this component, set the value of the `itemComponentName` field of a MarkupGrid node to `SimpleGridItem`.

Note that the `index` and `focusPercent` interface fields are not used by the component, so they are not included in the component interface.

**MarkupGrid XML component example**

    <?xml version="1.0" encoding="utf-8" ?>
    
    <component name="SimpleGridItem" extends="Group">
    
    <interface>
      <field id="width" type="float" onChange="widthChanged"/>
      <field id="height" type="float" onChange="heightChanged"/>
      <field id="itemContent" type="node" onChange="itemContentChanged"/>
    </interface>
    
    <script type="text/brightscript" >
    <![CDATA[
      function itemContentChanged()
        m.gridPoster.uri = m.top.itemContent.HDPOSTERURL
        if m.top.itemContent.GOTITEMCONTENT
          m.priceBox.visible = false
          m.priceLabel.visible = false
          m.ownedIcon.visible = true
        else
          m.priceLabel.text = m.top.itemContent.PRICE
          m.priceBox.visible = true
          m.priceLabel.visible = true
          m.ownedIcon.visible = false
        end if
        updateLayout()
      end function
    
      function widthChanged()
        updateLayout()
      end function
    
      function heightChanged()
        updateLayout()
      end function
    
      function updateLayout()
        if m.top.height > 0 and m.top.width > 0
          posterSize = m.top.height
          m.gridPoster.width = m.top.width
          m.gridPoster.height = m.top.height
          ' position the ownedIcon in the bottom/right corner
          m.ownedIcon.translation = [ m.top.width - m.ownedIcon.bitmapWidth, m.top.height - m.ownedIcon.bitmapHeight ]
          m.priceBox.width = m.top.width
          m.priceBox.height = m.ownedIcon.bitmapHeight
          m.priceBox.translation = [ 0, m.top.height - m.priceBox.height ]
          m.priceLabel.width = m.top.width
          m.priceLabel.height = m.priceBox.height
          m.priceLabel.vertAlign = "center"
          m.priceLabel.horizAlign = "center"
          m.priceLabel.translation = m.priceBox.translation
        end if
      end function
    
      function init()
        m.gridPoster = m.top.findNode("gridPoster")
        m.priceBox = m.top.findNode("priceBox")
        m.priceLabel = m.top.findNode("priceLabel")
        m.ownedIcon = m.top.findNode("ownedIcon")
        m.ownedIcon.loadSync = true
        m.ownedIcon.uri = "pkg:/images/greenCheck.png"
      end function
    ]]>
    </script>
    
    <children>
    
    <Poster id="gridPoster" renderPass="1" />
    <Rectangle id="priceBox" color="0x00000080" renderPass="2" />
    <Label id="priceLabel" renderPass="3" />
    <Poster id="ownedIcon" renderPass="4" />
    
    </children>
    
    </component>
    

Data bindings
-------------

A MarkupGrid node should have a single ContentNode as the root node in its content field. The structure of the rest of the data model depends on whether or not the grid items are to be grouped into sections.

**List items not grouped into sections**

If the grid items are not to be grouped into sections, one child ContentNode should be added to the root node for each item in the grid (these child nodes can be thought of as _item nodes_). Item nodes should contain the data required by the MarkupGrid node XML component.

**List items grouped into sections**

If the grid items are to be grouped into sections, one child ContentNode should be added to the root node for each section in the grid (these child nodes can be thought of as _section roots_). Each section root should contain one child ContentNode for each item in the section (that is, item nodes). The item nodes should contain the data required by the MarkupGrid node XML component.

The section root ContentNodes use the following attributes:

| Attribute | Type | Description |
| --- | --- | --- |
| `CONTENTTYPE` | string | Must be set to `SECTION` |
| `TITLE` | string | Label for the section divider |
| `HDGRIDPOSTERURL` | uri | The image file for the icon to be displayed to the left of the section label when the screen resolution is set to HD. |
| `SDGRIDPOSTERURL` | uri | The image file for the icon to be displayed to the left of the section label when the screen resolution is set to SD. |
| `X` | integer | When the fixedLayout field is set to true, this specifies the first row of the grid occupied by this item, where 0 refers to the first row. Note that there can be more rows in the data than visible rows, where the number of visible rows is specified by the numRows field.  <br>  <br>For example, if the data model contains enough data to fill 12 rows, X would be set to a value from 0 to 11. |
| `Y` | integer | When the fixedLayout field is set to true, this specifies the first column of the grid occupied by this item, where 0 refers to the first column. Note that the number of columns is always specified by the numColumns field, regardless of how many items are in the data model.  <br>  <br>For example, if the numColumns field is set to 3, Y would be set to 0, 1 or 2. |
| `W` | integer | When the fixedLayout field is set to true, this specifies how many columns the grid item occupies. If not specified, the default value of 1 is used.  <br>  <br>For example, if the numColumns field were set to 3 and a grid item is to occupy the rightmost two columns, X would be set to 1 and W would be set to 2. |
| `H` | integer | When the fixedLayout field is set to true, this specifies how many rows the grid item occupies. If not specified, the default value of 1 is used.  <br>  <br>For example, if a grid item is to occupy the the third, fourth and fifth rows, Y would be set to 2 and W would be set to 3. |

Sample app
----------

[MarkupGridExample](https://github.com/rokudev/samples/tree/master/ux%20components/lists%20and%20grids/MarkupGridExample) is a sample app demonstrating MarkupGrid in action.

roRegistry
==========

The Registry is an area of non-volatile storage where a small number of persistent settings can be stored.

The Registry provides a means for an application to write and read small amounts of data such as settings, scores, etc. The data persists even if the user exits the application and even if the player is rebooted. Registry data is removed only when the application explicitly removes it, the user uninstalls the application, which remove the registry for the application, or the user performs a factory reset, which removes the registry for all applications.

Access to the registry is available through the roRegistry object. This object is created with no parameters:

`CreateObject("roRegistry")`

There is a separate registry for each [developer ID](/docs/developer-program/publishing/packaging-channels.md#step-3-run-the-genkey-utility-to-create-a-signing-key "developer ID"). This allows multiple applications to use the registry without being able to read or modify the registry from other applications. If desired, a single registry can be shared across multiple applications by using the same developer ID to package the applications. This is the conventional way that an "application suite" with shared preferences and other shared information should work. Each registry is divided into sections which are specified by the developer for organization and grouping of attributes. Methods in ifRegistry are provided to list the sections in the registry and to provide access to the data in each section.

> The maximum size of each zlib-compressed application registry is **32K bytes**. Apps should minimize the amount of data stored in the registry and the frequency in which they update it.
> 
> Use the **ifRegistry.GetSpaceAvailable()** function to check the number of bytes available in the registry.

The Registry also supports the use of a special transient registry section. A registry section named "Transient" can be used to store attributes that have the lifetime of a single boot. Within a specific boot session, these values will be persistent to the application and stored as any other registry value. Whenever the user reboots the Roku Streaming Player, all "Transient" registry sections are removed and the values no longer persist. This technique is useful for caching data to minimize network access, yet still ensuring that this data is always fresh after a system reboot.

The registry is encrypted, and updates are relatively performance intensive and should be used sparingly. Note that all writes to the registry are delayed, and not committed to non-volatile storage until ifRegistry.Flush() or ifRegistrySection.Flush() is explicitly called. The platform may choose opportune times to flush data on its own, but no application is technically correct unless it explicitly calls Flush() at appropriate times. Flushing the registry is a relatively time-consuming operation, so it should be done as infrequently as possible. The Registry data is stored in a fault tolerant manner by preserving a backup for each write which is automatically rolled-back in the event of a failure.

Supported interfaces
--------------------

*   [ifRegistry](/docs/references/brightscript/interfaces/ifregistry.md "ifRegistry")

roDeviceInfoEvent
=================

The roDeviceInfo component sends the roDeviceInfoEvent with the following predicates that indicate its valid event types:

Supported methods
-----------------

### isStatusMessage() as Boolean

Checks if the device status has changed. This method returns true if the device status has changed; otherwise, it returns false.

#### GetInfo() as Object

Checks the current status of the device. This method returns an roAssociativeArray containing one of the following members:

| Member | Type | Description |
| --- | --- | --- |
| audioGuideEnabled | Boolean | True if the screen reader is enabled. The audioGuideEnabled event will only ever get fired if [ifDeviceInfo.EnableAudioGuideChangedEvent(true)](/docs/references/brightscript/interfaces/ifdeviceinfo.md#enableaudioguidechangedeventenable-as-boolean-as-dynamic "ifDeviceInfo.EnableAudioGuideChangedEvent(true)") called before entering the message loop |
| exitedScreensaver | Boolean | True if the screensaver was exited. The exitedScreensaver event will only ever get fired if [ifDeviceInfo.EnableScreensaverExitedEvent(true)](/docs/references/brightscript/interfaces/ifdeviceinfo.md#enablescreensaverexitedeventenable-as-boolean-as-dynamic "ifDeviceInfo.EnableScreensaverExitedEvent(true)") is called before entering the message loop |
| appFocused | Boolean | It is set to False when the System Overlay takes focus and True when the app regains focus |
| linkStatus | Boolean | True if the device currently seems to have an active network connection. The linkStatus event will only ever get fired if [ifDeviceInfo.EnableLinkStatusEvent(true)](/docs/references/brightscript/interfaces/ifdeviceinfo.md#enablelinkstatuseventenable-as-boolean-as-boolean "ifDeviceInfo.EnableLinkStatusEvent(true)") is called before entering the message loop |
| generalMemoryLevel | String | Fires notifications to the app about memory levels. This event will be sent first when the OS transitions from "normal" to "low" state and will continue to be sent while in "low" or "critical" states.  <br>  <br>The events will be throttled so as to not overwhelm the application listening for these events. The application may voluntarily free up memory by invalidating references to objects (e.g. release ContentNodes held in a cache, release offscreen renderable nodes, etc.).  <br>  <br>The "low" and "critical" events will be sent to the OS forces the application to exit.<br><br>*   "normal" means that the general memory is within acceptable levels<br>*   "low" means that the general memory is below acceptable levels but not critical<br>*   "critical" means that general memory are at dangerously low level and that the OS may force terminate the application |
| audioCodecCapabilityChanged | Boolean | The audio codec capability has changed if true. If your application receives this event, you can check the current audio playback capability using the [`roDeviceInfo.CanDecodeAudio`](/docs/references/brightscript/interfaces/ifdeviceinfo.md#ifDeviceInfo-CanDecodeAudio\(audio_formatasObject\)asObject) and [`roDeviceInfo.GetAudioDecodeInfo`](/docs/references/brightscript/interfaces/ifdeviceinfo.md#ifDeviceInfo-GetAudioDecodeInfo\(\)asObject) methods.  <br>  <br>This event is only fired if the [`ifDeviceInfo.EnableCodecCapChangedEvent(true)`](/docs/references/brightscript/interfaces/ifdeviceinfo.md#ifDeviceInfo-EnableAudioGuideChangedEvent\(enableasBoolean\)) is called before entering the message loop. |
| videoCodecCapabilityChanged | Boolean | The video codec capability has changed if true. If your application receives this event, you can check the current video playback capability using the [`roDeviceInfo.CanDecodeVideo`](/docs/references/brightscript/interfaces/ifdeviceinfo.md#ifDeviceInfo-CanDecodeVideo\(video_formatasObject\)asObject) method.  <br>  <br>This event is only fired if [`ifDeviceInfo.EnableCodecCapChangedEvent(true)`](/docs/references/brightscript/interfaces/ifdeviceinfo.md#ifDeviceInfoEnableAudioGuideChangedEvent\(enableasBoolean\)) is called before entering the message loop. |

### isCaptionModeChanged() as Boolean

Indicates whether the user has changed the closed caption mode or track. This method returns true if the caption mode changed; otherwise, it returns false.

Call the [GetInfo()](#getinfo-as-object) method to get the caption mode.

#### GetInfo() as Object

Indicates the current global setting for the Mode property, which may be one of the following values:

*   "On"
*   "Off"
*   "Instant replay"
*   "When mute" (Only returned for a TV; this option is not available on STBs).

### EnableValidClockEvent(enable as Boolean)

Indicates whether the RokuOS has successfully connected to the network and contacted the timeserver in order to set the device's clock. Call the [GetInfo()](#getinfo-as-object) method to confirm that the system clock is valid.

#### GetInfo() as Object

This method returns an roAssociativeArray containing a **validClock** field that indicates whether the system clock is valid.

| Member | Type | Description |
| --- | --- | --- |
| validClock | Boolean | True if the system clock is valid. |

Component initialization order
==============================

Instances of components defined in an XML file follow a well-defined initialization order when they are created.

1.  The [**<children>**](children_1608551.html) element nodes defined in XML markup are created, and their fields are set to their initial values, either to a default value, or to the value specified in the XML markup.
    
2.  The **[<interface>](interface_1608549.html)** element fields of the XML component are created, and their initial values are set, either to a default value, or to the value specified by the `value` attribute.
    
3.  The [**<script>**](script_1608550.html) element `init()` function is called, and all initializations contained in the function are performed.
    

Note the following implications of this initialization order.

Initial XML Markup Node Field Values May Be Overridden
------------------------------------------------------

The field values defined in XML markup in the **<children>** nodes may be overridden as many as two times, depending on the definitions of the **<interface>** element field attributes, and the initializations contained in the **<script>** element **`init()`** function.

Observer Functions
------------------

Observer functions of fields that are set up in the **`init()`** function do not get called when those fields are initialized. This is because the initialization of interface fields, or of fields of the component **<children>** element nodes, is done before the **`init()`** function that sets up the observers is called. Thus, in some cases, it may be necessary to explicitly call the field observer functions in **`init()`** if they need to be executed for the initial field setting.

Also note that field observer callback functions set up in **`init()`** cannot be guaranteed to have returned when the component is created using **`createObject()`** or **`createChild()`**. This means that a component object may not have been completely constructed immediately after those calls. For certain nodes that may rely on dynamically-downloaded content to construct the node, such as [**PosterGrid**](PosterGrid_1607203.html), subsequent object function calls may return an object reference to an unconstructed object.

Parenting and the Focus Chain
-----------------------------

For nodes that are defined in the **<children>** XML markup of the component file, the parent node is set after the node is created, and **`init()`** is called. This has implications for the focus chain (see [**Remote Control Events**](Remote-Control-Events_1607636.html)), which must end at a node derived from **[Scene](Scene_1607315.html)**. Until the newly-created node is parented to a node that is either derived from **Scene**, or parented to a node in a focus chain that ends on a node derived from **Scene**, you will not be able to set remote control focus on the node.

Program Action Fields
---------------------

Certain fields should not be set in XML markup of the SceneGraph nodes, specifically any control fields that initiate a program action, such as starting a video to play, or an animation. These fields should be set in BrightScript as part of scripting the program flow of the component.

ifFontRegistry
==============

Implemented by
--------------

| Name | Description |
| --- | --- |
| [roFontRegistry](/docs/references/brightscript/components/rofontregistry.md "roFontRegistry") | The roFontRegistry object allows you to create roFont objects, either using the default font or using fonts in TrueType or OpenType files packaged with your application |

Supported methods
-----------------

### Register(path as String) as Boolean

#### Description

Registers a font file (.ttf or .otf format). Each font file defines one or more font families (usually one).

#### Parameters

#### Return Value

A flag indicating whether the fonts in the specified file were successfully installed.

### GetFamilies() as Object

#### Description

Returns the names of the font families that have been registered via the [Register()](#registerpath-as-string-as-boolean) method. Each name can be passed as the first parameter to the [GetFont()](#getfontfamily-as-string-size-as-integer-bold-as-boolean-italic-as-boolean-as-object) method.

#### Return Value

An [roArray](/docs/references/brightscript/components/roarray.md "roArray") of strings that represent the names of the font families that have been registered.

### GetFont(family as String, size as Integer, bold as Boolean, italic as Boolean) as Object

#### Description

Returns a font from the specified family, selected from the fonts previously registered via the [Register()](#registerpath-as-string-as-boolean) method.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| family | String | The font family name. |
| size | Integer | The requested font size, in pixels, not points. |
| bold | Boolean | "bold" specifies a font variant that may be (but is not always) supported by the font file. |
| italic | Boolean | "italic" specifies a font variant that may be (but is not always) supported by the font file. |

#### Return Value

An [roFont](/docs/references/brightscript/components/rofont.md "roFont") object representing a font from the specified family.

### GetDefaultFont() as Object

#### Description

Returns the system font at its default size. Calling this method is the same as calling the [GetDefaultFont()](#getdefaultfontsize-as-integer-bold-as-boolean-italic-as-boolean-as-object) method with the following syntax: `reg.GetDefaultFont(reg.GetDefaultFontSize(), false, false)`.

#### Return Value

The system font as its default size.

### GetDefaultFont(size as Integer, bold as Boolean, italic as Boolean) as Object

#### Description

Returns the system font. The system font is always available, even if the [Register()](#registerpath-as-string-as-boolean) method has not been called

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| size | Integer | The requested font size, in pixels, not points. |
| bold | Boolean | "bold" specifies a font variant that may be (but is not always) supported by the font file. |
| italic | Boolean | "italic" specifies a font variant that may be (but is not always) supported by the font file. |

#### Return Value

An roFont object representing the system font.

### GetDefaultFontSize() as Integer

#### Description

Returns the default font size.

#### Return Value

The default font size.

### Get(family as String, size as Integer, bold as Boolean, italic as Boolean) as String

#### Description

Returns a valid font string.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| family | String | The font family name. |
| size | Integer | The requested font size, in pixels, not points. |
| bold | Boolean | "bold" specifies a font variant that may be (but is not always) supported by the font file. |
| italic | Boolean | "italic" specifies a font variant that may be (but is not always) supported by the font file. |

#### Return Value

A valid font string.

Designing for devices
=====================

Every public app on the Roku platform is certified on all currently-supported Roku models before being published. The list of supported devices includes a wide range of product classes, from our entry-level set-top-boxes to 4K HDR TVs, and everything in between. This variance signifies that some devices are more powerful than the others. The complete list of supported Roku devices and their product specs can be found in the [Hardware specifications](/docs/specs/hardware.md) page.

It's very important that developers remain mindful of these different product capabilities while building their apps. It is a best practice to build dynamic apps that are conditional to the product specs of the model being used. Take full advantage of the extra "horsepower" of a Roku Premiere, but be sure to gracefully degrade the lower experience on older Roku devices that have been in the market for a few years.

For example, your image management can be handled server-side and serve down the highest-resolution artwork that the device in use can handle. Be strategic about how much data fetching is required on each screen of your app — if a user is on an older Roku device, consider rendering fewer content items on each browsing panel, but display more content on the same page on a higher-end product.

Other optimization techniques include:

*   Limiting animations
*   Limiting the number of overdraws
*   Lower video resolution or kill video playback altogether when the user enters a browsing page

Device model numbers can be found in the [Hardware Specifications](/docs/specs/hardware.md) page.

The best practices are outlined in further detail in the [SceneGraph Performance Guide](/docs/developer-program/performance-guide/development-tips.md).

The "[Best Practices for Roku Cross-Platform UX](https://devtools.web.roku.com/files/Roku%20Best%20Practices%20for%20Cross-Platform%20UX.pptx)" presentation summarizes this concept of designing for high-end devices and gracefully degrading for lower-end devices. \[Download\][https://devtools.web.roku.com/files/Roku%20Best%20Practices%20for%20Cross-Platform%20UX.pptx](https://devtools.web.roku.com/files/Roku%20Best%20Practices%20for%20Cross-Platform%20UX.pptx)) and leverage this guide for your app.

roUrlTransfer
=============

A roUrlTransfer object transfers data to or from remote servers specified by URLs. It can perform mutual authentication with a web server.

This object is created with no parameters:

`CreateObject("roUrlTransfer")`

If using HTTPS, the developer must specify a certificate file by calling SetCertificatesFile() with a .pem file that includes the certificate authority cert (like Verisign, Thawte, etc., or your own with OpenSSL) that signed the web server certificate. This must be called before making a request. The developer can also use the Roku standard cert bundle (which contains certificates for most common signing authorities) stored in common:/certs/ca-bundle.crt; or download the CA certificate [here](https://github.com/rokudev/ca-certificate/blob/master/ca-bundle.crt).

The web server can authenticate that the requested connection is from a Roku Streaming Player and that the request is from your application by taking the following actions:

*   Add the Roku CA certificate to the web server's certificate authorities keychain, download the CA certificate.
*   Configure your web server to reject any connection that does not have a valid client certificate.
*   Check the X-Roku-Reserved-Dev-Id header in the request. It should contain the Developer ID of your application. If it does not, another application on the Roku is attempting to access the server, and the request is rejected.

**Example**

In order for your web server to perform the steps above to authenticate your Roku Streaming Player, your application needs to call the following functions before performing any https requests:

    object.SetCertificatesFile("common:/certs/ca-bundle.crt")
    object.AddHeader("X-Roku-Reserved-Dev-Id", "")
    object.InitClientCertificates()
    

Supported interfaces
--------------------

*   [ifUrlTransfer](/docs/references/brightscript/interfaces/ifurltransfer.md "ifUrlTransfer")
*   [ifHttpAgent](/docs/references/brightscript/interfaces/ifhttpagent.md "ifHttpAgent")
*   [ifSetMessagePort](/docs/references/brightscript/interfaces/ifsetmessageport.md "ifSetMessagePort")
*   [ifGetMessagePort](/docs/references/brightscript/interfaces/ifgetmessageport.md "ifGetMessagePort")

Supported events
----------------

*   [roUrlEvent](/docs/references/brightscript/events/rourlevent.md "roUrlEvent")

StdDlgDeterminateProgressItem
=============================

Extends [StdDlgItemBase](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-item-base.md "**StdDlgItemBase**")

The **StdDlgDeterminateProgressItem** node is used to display a progress indicator in the dialog's content area. It provides the percentage of progress that has been completed for a task that takes a limited amount of time. It should only be used as a child of a [**StdDlgContentArea**](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-content-area.md) node.

![roku815px - std-dlg-determinate-progress-item](https://image.roku.com/ZHZscHItMTc2/std-dlg-determinate-progress-item-2.jpg)

Fields
------

| Field | Type | Default | Access Permission | Description |
| --- | --- | --- | --- | --- |
| percent | string | "0" | READ\_WRITE | Specifies the current completion percentage text and graphic to be displayed (for example "35%" with more than a third of the indicator filled).  <br>  <br>If this is set to a number less than 0 or greater than 100, the progress indicator will display "0%" or "100%" completion, respectively. |
| text | string | ""  | READ\_WRITE | Specifies the text to be displayed next to the progress graphic. If the text width does not fit within the width of the content area, the text will wrap onto multiple lines. |

Sample app
----------

You can download and install a [sample app](https://github.com/rokudev/standard-dialog-framework) that demonstrates how to create a custom dialog that uses the determinate progress item.

roFileSystem
============

The roFilesystem component implements common filesystem inspection and modificationroutines.

All paths are matched case-insensitively, regardless of the case-sensitivity of the underlying filesystem. The supported character set is limited to only those characters supported by vfat filesystems (valid Windows characters). The usbplayer sample application is a good example of roFileSystem usage. USB devices with VFAT, NTFS, HFS, and HFS Plus filesystems are supported. The USB filesystems are currently mounted read only.

This object is created with no parameters:

`CreateObject("roFileSystem")`

Supported interfaces
--------------------

*   [ifFileSystem](/docs/references/brightscript/interfaces/iffilesystem.md "ifFileSystem")
*   [ifSetMessagePort](/docs/references/brightscript/interfaces/ifsetmessageport.md "ifSetMessagePort")
*   [ifGetMessagePort](/docs/references/brightscript/interfaces/ifgetmessageport.md "ifGetMessagePort")

Supported events
----------------

*   [roFileSystemEvent](/docs/references/brightscript/events/rofilesystemevent.md "roFileSystemEvent")

roSGNode
========

The roSGNode object is the BrightScript equivalent of SceneGraph XML file node creation. To create an roSGNode object for a specific node class, call:

`CreateObject("roSGNode", "nodetype")`

Where nodetype is a string specifying the node class to be created. For example, the following creates an object of the SceneGraph Poster node class:

`CreateObject("roSGNode", "Poster")`

Reference information on all SceneGraph node classes can be found in [SceneGraph API Reference](/docs/references/scenegraph/node.md).

Prior to creating an roSGScreen object and calling its `show()` function, creating roSGNode objects and using their interfaces is not guaranteed to work correctly. If you need to create some roSGNode objects and/or use roSGNode interfaces prior to calling an roSGScreen object `show()` function, you can use an roSGScreen object `createScene()` function to create an instance of a SceneGraph XML component that does any required setup and initialization prior to the roSGScreen object being displayed.

In addition, roSGNode implements the ifAssociativeArray interface as a wrapper for ifSGNodeFIeld so that the convenient node.field notation may be using for setting, getting, and observing fields.

Supported Interfaces
--------------------

*   [ifAssociativeArray](/docs/references/brightscript/interfaces/ifassociativearray.md)
*   [ifSGNodeChildren](/docs/references/brightscript/interfaces/ifsgnodechildren.md)
*   [ifSGNodeField](/docs/references/brightscript/interfaces/ifsgnodefield.md)
*   [ifSGNodeDict](/docs/references/brightscript/interfaces/ifsgnodedict.md)
*   [ifSGNodeFocus](/docs/references/brightscript/interfaces/ifsgnodefocus.md)
*   [ifSGNodeBoundingRect](/docs/references/brightscript/interfaces/ifsgnodeboundingrect.md)
*   [ifSGNodeHttpAgentAccess](/docs/references/brightscript/interfaces/ifsgnodehttpagentaccess.md)

Supported Events
----------------

*   [roSGNodeEvent](/docs/references/brightscript/events/rosgnodeevent.md)

ifSourceIdentity
================

Implemented by
--------------

| Name | Description |
| --- | --- |
| [roChannelStoreEvent](/docs/references/brightscript/events/rochannelstoreevent.md "roChannelStoreEvent") | The roChannelStore sends an roChannelStoreEvent in response to a call to any of several Get\* methods in ifChannelStore |
| [roUrlEvent](/docs/references/brightscript/events/rourlevent.md "roUrlEvent") | The roUrlTransfer component sends the roUrlEvent |

Supported methods
-----------------

### GetSourceIdentity() as Integer

#### Description

Returns the ID currently associated with this source (event generating) or event object

#### Return Value

The ID value of the source or event object.

Implementing client-side ad stitching
=====================================

You can combine video content and ad pods into a single playlist and then render it. This optimizes the video playback experience by eliminating buffering between your content and ads. The Roku Advertising Framework (RAF) API includes [**constructStitchedStream**()](/docs/developer-program/advertising/raf-api.md#constructstitchedstreamcontentmetadata-as-object-ads-as-object-as-object) and [**renderStitchedStream()**](/docs/developer-program/advertising/raf-api.md#renderstitchedstreamcsasstream-as-object-view-as-object-as-boolean) methods that enable you to seamlessly create and render stitched streams.

Creating a stitched stream
--------------------------

Once you have [enabled the RAF library](/docs/developer-program/advertising/integrating-roku-advertising-framework.md) in the manifest and [instantiated it](/docs/developer-program/advertising/raf-api.md#roku_ads-as-object) in the app, you can create a stitched stream using the [**constructStitchedStream**()](/docs/developer-program/advertising/raf-api.md#constructstitchedstreamcontentmetadata-as-object-ads-as-object-as-object) method. This method takes two parameters: a ContentNode with the content metadata of the video to be played, and the ads in the ad pod to be rendered during playback (retrieved via the RAF [**GetAds()** method](/docs/developer-program/advertising/raf-api.md#getadsmsg-as-string-as-object)). The method returns a single playlist, which you can then render as described in the next section.

The following code example demonstrates how to create a stitched stream:

    screen = CreateObject("roSGScreen")
    scene = screen.CreateScene("MainScene")
    
    'Specify content to be played
    videoUrl = "http://pmd205604tn.download.theplatform.com.edgesuite.net/Demo_Sub_Account_2/411/535/ED_HD__571970.m3u8"
    
    'Specify VAST template containing ads to be rendered
    adUrl = "https://devtools.web.roku.com/samples/sample.xml"
    
    'Initialize RAF
    m.adIface = Roku_Ads()
    
    'Enable and specify audience identifiers to be passed into impression measurement tags
    m.adIface.enableAdMeasurements(true)
    m.adIface.setContentGenre("Entertainment")
    m.adIface.setContentId("CSASAdSample" )
    
    'Set and get the ads to be rendered
    m.adIface.SetAdURL(adUrl)
    m.adPods = m.adIface.GetAds()
    
    'Create and configure a ContentNode containing the metadata of the content to be played.
    myContentNode = createObject("roSgNode", "ContentNode")
    myContentNode.url = videoUrl
    myContentNode.length = 600
    myContentNode.streamFormat = "hls"
    
    'Combine video and ads into a single playlist
    csasStream = m.adIface.constructStitchedStream(myContentNode, m.adPods)
    

Rendering a stitched stream
---------------------------

You can render a stitched stream using the [**renderStitchedStream()**](/docs/developer-program/advertising/raf-api.md#renderstitchedstreamcsasstream-as-object-view-as-object-as-boolean) method. This method takes the playlist created via the [**constructStitchedStream()**](/docs/developer-program/advertising/raf-api.md#constructstitchedstreamcontentmetadata-as-object-ads-as-object-as-object) method and a renderable node to which the stitched stream can be attached.

    ' render the stitched stream
    m.adIface.renderStitchedStream(csasStream, scene)
    

Firing ad measurement beacons without wrapping
----------------------------------------------

Per [Roku's certification requirements](/docs/developer-program/advertising/ad-requirements.md#ads-3-ad-tracking-requirements), all ad measurement beacons must be fired directly by RAF client-side (they may not be wrapped). This is required to apply the [Roku Advertising Watermark](/docs/developer-program/advertising/ad-watermark.md) to the beacons.

Sample app
----------

You can download and install a [sample app](https://github.com/rokudev/samples/tree/master/advertising/CSASAdSample) that demonstrates how to create and render a client-side stitched stream. It shows you how you can create a stream by combining a video content item with the ads in a Video Ad Serving Template (VAST), and then render the stitched stream in a SceneGraph object.

Group
=====

Extends [**Node**](/docs/references/scenegraph/node.md)

Group is the base class of all renderable nodes. Group also provides fields that control the transformation, visibility and opacity of themselves and all of their children.

Each Group defines a local coordinate system relative to the coordinate system of its parent node. A 2D matrix that describes how points in the local coordinate system can be transformed into the parent node coordinate system is constructed from the values of the translation, rotation, scale, and scaleRotateCenter fields.

The 2D matrix is computed using the values of these four fields in the following order:

*   translating by the negative of the scaleRotateCenter field value
*   scaling by the the scale field value
*   rotating by the rotation field value
*   translating by the the scaleRotateCenter field value
*   translating by the translation field value

In matrix math terms, the overall 2D matrix is:

M = C(-1) S R C T

Where:

*   M is the total matrix
*   C is a 2D translation matrix that describes the location of the scale/rotation center in the node's local coordinate system
*   C(-1) is the inverse of C
*   S is a 2D scaling matrix
*   R is a 2D rotation matrix
*   T is a 2D translation matrix

> In nearly all cases, either the default values for these four fields will be used (in which case, the local coordinate system of the node is the same as the parent node coordinate system), or only a translation will be specified (in which, the local coordinate system is a simple offset from the parent node coordinate system).

Fields
------

FieldTypeDefaultAccess PermissionDescriptionvisibleBooleantrueREAD\_WRITEIf true, the node and its children are rendered. If false, the node and its children do not renderopacityfloat1.0READ\_WRITESets the opacity of the node and its children. Opacity is the opposite of transparency. Opacity values range from 0.0 (fully transparent) to 1.0 (fully opaque). As the SceneGraph is traversed, the opacity values are combined by multiplying the current accumulated opacity with the node opacity, so that if the accumulated opacity of a node ancestors is 0.25 (75% transparent), the node will have opacity of 0.25 or less. This allows entire branches of the SceneGraph to fade in and out by animating the opacity of the node at the root of the branchtranslationvector2d\[0.0,0.0\]READ\_WRITEDefines the origin of the node local coordinate system relative to its parent noderotationfloat0.0READ\_WRITEDefines the rotation angle about the scaleRotateCenter point (in radians) of the node local coordinate system. Positive values specify a counterclockwise rotation, negative values specify a clockwise rotation. For some Roku Player hardware, specifically Roku Players without OpenGL graphics support, only rotations of 0, 90, 180 and 270 degrees (in equivalent radians) are supported. (See [Roku Models and Features](/docs/specs/hardware.md#current-models "Roku Models and Features") for information on OpenGL support)scalevector2d\[1.0,1.0\]READ\_WRITEDefines the scale factor to be applied to the node local coordinatescaleRotateCentervector2d\[0.0,0.0\]READ\_WRITEDescribes the location of a point in the node local coordinate that serves as the center of the scale and rotation operationschildRenderOrderoption as stringrenderLastREAD\_WRITE

| Option | Description |
| --- | --- |
| `"renderFirst"` | any drawing done by this node will be done **before** the node children are rendered |
| `"renderLast"` | any drawing done by this node will be done **after** the node children are rendered |

inheritParentTransformBooleantrueREAD\_WRITEIf true, the node overall transformation is determined by combining the accumulated transformation matrix of all of its ancestors in the SceneGraph with the node local 2D transformation matrix described by its translation, rotation, scale and scaleRotateCenter fields. If false, the accumulated transformation of all of its ancestors in the SceneGraph is ignored and only the node local transformation matrix is used. This causes the node to be transformed relative to the root of the SceneGraph (that is, the Scene component)inheritParentOpacityBooleantrueREAD\_WRITEIf true, the node opacity is determined by multiplying opacity attribute of the node by the opacity of the parent node, which may have been determined by multiplying the opacity of its ancestor nodes. If false, the node opacity is determined by the opacity attribute set for the node or the default opacity attribute valueclippingRectarray of float\[ 0.0, 0.0, 0.0, 0.0 \]READ\_WRITESpecifies a rectangle in the node local coordinate system that is used to limit the region where this node and its children can render. If a non-empty rectangle is specified, then all drawing by this node and its children will be limited to that rectangular area.

*   `ClippingRects` can be specified by the node or by any of its ancestors in the SceneGraph.
*   `ClippingRects` are automatically set by some nodes such as lists and grids.
*   `ClippingRects` are always clipped to the screen boundaries, so if a `clippingRect` is specified that is partially or completely offscreen, it will be clipped to the screen boundaries. With respect to render tracking, although the node could be completely within the bounds of the specified `clippingRect`, it's `renderTracking` field could be set to `"none"` if the portion of the `clippingRect` it occupies is completely offscreen.

renderPassinteger0READ\_WRITEUsed in combination with the numRenderPasses field of nodes extended from the [ArrayGrid](/docs/references/scenegraph/abstract-nodes/arraygrid.md "ArrayGrid") abstract node class, to optimize rendering of lists and grids. This should never be set to a non-zero value unless you are optimizing the performance of a list or grid rendering by specifying the sequence of rendering operations for sub-elements of the list or grid items, and have set the numRenderPasses field value for the list or grid to a value greater than 1. If the numRenderPasses field value for the list or grid is set to a value greater than 1, you must set this field to a value greater than 0 for all sub-elements of the list or grid items, and not greater than the numRenderPasses field value. If the numRenderPasses field is set to a value greater than 1, and you set this field for a list or grid item sub-element to 0 (the default), or a value greater than the numRenderPasses field value, the list or grid item sub-element will not rendermuteAudioGuideBooleanfalseREAD\_WRITESet to true to suppress the default CVAA text to speech. This allows apps to provide their own custom implementationenableRenderTrackingBooleanfalseREAD\_WRITEIf true, renderTracking will be set to a string describing how much of the node is rendered on screenrenderTrackingoption as stringdisabledREAD\_WRITErenderTracking is set to "disabled" when enableRenderTracking is set to false. The following options are only available when enableRenderTracking is set to true:

| Option | Description |
| --- | --- |
| `"none"` | renderTracking is set to: `"none"` if **one or more** of these conditions is true:<br><br>*   the node's `visible` field is set to `false`.<br>*   the node's `opacity` field is set to `0.0`.<br>*   no `clippingRect` is specified and the node is completely offscreen.<br>*   a `clippingRect` is specified and the node lies completely outside that `clippingRect's` coordinates or is completely offscreen. |
| `"partial"` | renderTracking is set to `"partial"` if **all** of the following conditions are true:<br><br>*   the node's `visible` field is set to `true`.<br>*   the node's `opacity` field is greater than `0.0`.<br>*   no `clippingRect` is specified and the node is partially offscreen.<br>*   a `clippingRect` is specified and the node lies partially inside the `clippingRect's` coordinates. |
| `"full"` | renderTracking is set to `"full"` if **all** of the following conditions are true:<br><br>*   the node's `visible` field is set to `true`.<br>*   the node's `opacity` field is greater than `0.0`.<br>*   no `clippingRect` is specified and the node is completely onscreen.<br>*   a `clippingRect` is specified and the node lies completely inside the `clippingRect's` coordinates. |

Expressions, variables, and types
=================================

Identifiers
-----------

Identifiers (names of variables, functions, labels, or object member functions or interfaces (appear after a ".")) have the following rules.

*   Must start with an alphabetic character (a – z) or the symbol "\_" (underscore)
    
*   May consist of alphabetic characters, numbers, or the symbol "\_" (underscore)
    
*   Are not case sensitive
    
*   May be of any length
    
*   May not use a "reserved word" as the name (see [Reserved Words](/docs/references/brightscript/language/reserved-words.md) for list of reserved words).
    
*   If a variable: may end with an optional type designator character ($ for string, % for integer, ! for float, # for double) (function names do not support a type designator character).
    

For example:

    a  
    boy5  
    super_man$
    

Types
-----

BrightScript uses dynamic typing. This means that every value also has a type determined at run time. However, BrightScript also supports declared types. This means that a variable can be made to always contain a value of a specific type. If a value is assigned to a variable which has a specific type, the type of the value assigned will be converted to the variables type, if possible. If not possible, a runtime error will result.

The following types are supported in BrightScript:

*   **Boolean** – Either true or false.
*   **Integer** – A 32-bit signed integer number.
*   **LongInteger** – A 64-bit signed integer number. **This is available in Roku OS 7.0 or above.**
*   **Float** – A 32-bit IEEE floating point number.
*   **Double** – A 64-bit IEEE floating point number. (Although Double is an intrinsically understood type, it is implemented internally with the roIntrinsicDouble component. This is generally hidden from the developer).
*   **String** – A sequence of Unicode characters. Internally there are two intrinsic string states. The first is for constant strings. For example, s="astring", will create an intrinsic constant string. But once a string is used in an expression, it becomes an "roString". For example: s=s+"more", results in s becoming an "roString". If this is followed by an s2=s, s2 will be a reference to s, not a copy.
*   **Object** – A reference to a BrightScript component. Note that if you use the "type()" function, you will not get "Object", but instead you will get the type of object. E.g. "roArray", "roAssociativeArray", "roList", "roVideoPlayer", etc. Note that intrinsic array and associative array values correspond to roArray and roAssociativeArray components respectively.
*   **Function** – Functions (and Subs, which are functions with void return types) are an intrinsic type. They can be stored in variables and passed to functions.
*   **Interface** – An interface in a BrightScript component. If a "dot operator" is used on an interface type, the member must be static (since there is no object context).
*   **Invalid** – The type invalid has only one value: invalid. It is returned in various cases, for example, when reading an array element that has never been set.
*   **Dynamic typing** – Unless otherwise specified, a variable is dynamically typed. This means that the type is determined by the value assigned to it at assignment time. For example "1" is an integer, "2.3" is a float, "hello" is a string, etc. If a dynamically typed variable is assigned a new value, its type may change. For example: a=4 creates "a" as integer, then a = "hello", changes the variable "a" to a string. All variables are dynamically typed, unless: (a) the variable ends in a type designator character, or (b) the "As" keyword is used in a function declaration with the variable.
*   **Tagging unused variables** – Variables can explicitly be marked as unused by prepending an underscore to the value (for example, sub myTask(_\_x_)). This enables avoid compilation errors to occur when an unused variable, for example, has a special behavior or another valid purpose. Unused variables generate warnings that are output to the SceneGraph debug port (8085). The maximum number of warnings that may be generated is 100.

Comments
--------

### In BrightScript

When the BrightScript interpreter encounters an apostrophe (') or the statement REM, it ignores all following text till the end of the line. This has multiple uses:

**Adding brief explanatory notes for the benefit of those reading it**

Used to assist in explaining code functionality, by preceding a block of code or by following a statement on the same line, e.g.

![roku815px - expressionsvariables1](https://image.roku.com/ZHZscHItMTc2/expressionsvariables1.png "expressionsvariables1")

**When debugging**

Used to disable a line. "Commenting out" code snippets is a common developer practice, e.g. say to test what the outcome is without the line:

![roku815px - expressionsvariables2](https://image.roku.com/ZHZscHItMTc2/expressionsvariables2.png "expressionsvariables2")

To comment out multiple lines, precede each of them with REM or apostrophe. To "block comment" big chunks of text, consider using [conditional compilation](/docs/references/brightscript/language/conditional-compilation.md).

### In XML

In the XML part of the code, in order to comment or temporarily disable a line of code, you must use **<!--** comment **\-->** as in the following example:

Note that the apostrophe DOES NOT work within the XML environment.

![roku815px - expressionsvariables3](https://image.roku.com/ZHZscHItMTc2/expressionsvariables3.png "expressionsvariables3")

Literals (constants)
--------------------

Type **Boolean**: true, false  
Type **Invalid**: invalid

### String literals

Type **String**: String in quotes, e.g. "this is a string".

The quotation mark character can be embedded in a string literal using two consecutive quotation marks.

Example: s ="""" : ? len(s), asc(s) outputs 1, 34.

### Numeric literals

Type **Integer**: Hex integer, e.g. &HFF, or decimal integer, e.g. 255

Type **Float**: e.g. 2.01, 1.23456E+30, or 2!

Type **Double**: e.g. 1.23456789D-12 or 2.3#

Type **LongInteger**: Hex integer, e.g. &hFEDCBA9876543210&, or decimal integer, e.g. 9876543210&.

The following rules determine how integers, doubles, and floats are determined:

1.  If a constant contains 10 or more digits, or if D is used in the exponent, that number is double precision. Adding a # declaration character also forces a constant to be double precision.
    
2.  If the number is not double-precision, and if it contains a decimal point, then the number is float. If the number is expressed in exponential notation with E preceding the exponent, the number is float.
    
3.  If neither of the above is true of the constant, then it is an integer.
    

### Source literals

Type **Integer**: **LINE\_NUM** – the current source line number.

### Function literals

Type **Function**: e.g. MyFunction

### Array literals

The Array Operator \[ \] can be used to declare an array. It may contain literals (constants), or expressions.

**Example**

    myarray = [] ' empty array
    
    myarray = [ 1, 2, 3 ] ' array of three members
    
    myarray = [ x+5, true, 1<>2, ["a","b"] ] ' array of four members
    

Arrays can be specified in multi-line form:

**Example**

    a = [
    
    "able"
    
    "baker"
    
    ]
    

**OR**

    a = [
    
    3.1415,
    
    2.71828
    
    ]
    

### Associative array literals

The { } operator can be used to define an Associative Array. It can contain literals or expressions.

**Example**

    aa = { }
    
    aa = { key1: "value", key2: 55, key3: 5+3 }
    

Key names must be valid identifiers.

Key names can be specified as string literals.

**Example**

    aa = { "Jane Doe": 1001, "John Doe": 1002 }
    

Associative Arrays can be specified in multi-line form:

**Example**

    aa = {
    
    Myfunc1: aFunction
    
    Myval1: "the value"
    
    }
    

**OR**

    aa = {
    
    alpha: 1,
    
    zulu: 26
    
    }
    

Dynamic vs. object types
------------------------

Certain functions that return objects can also return invalid (for example, in the case when there is no object to return). In which case, the variable accepting the result must be dynamic, since it may get "invalid" or it may get an "object".

    l=[]  
    a$=l.pop()
    

This example will return a type mismatch (a$ is a string, and can not contain "invalid"). Many functions that return objects can return invalid as well.

Type declaration characters
---------------------------

A type declaration character may be used at the end of either a variable or a literal to fix its type. Variables with the same identifier but separate types are separate variables. For example, a, a$, and a% are all different variables.

| Character | Type | Examples | Notes |
| --- | --- | --- | --- |
| $   | String | A$, STR$ |     |
| %   | Integer | A%, SUM%, 125% |     |
| !   | Float | A!, value!, 125! | Single-precision |
| #   | Double | A#, distance#, 125# | Double-precision |
| &   | LongInteger | A&, ID& | _This is available in Roku OS 7.0 or later._ |

Type conversion (promotion)
---------------------------

When operations are performed on one or two numbers, the result must be typed as integer, double or single-precision (float). When a +, -, or \* operation is performed, the result will have the same degree of precision as the most precise operand. For example, if one operand is integer, and the other double-precision, the result will be double precision. Only when both operands are integers will a result be integer.

Division follows the same rules as +, \* and -, except that it is never done at the integer level: when both operators are integers, the operation is done as float with a float result.

During a compare operation (<, >, =, etc.) the operands are converted to the same type before they are compared. The less precise type will always be converted to the more precise type.

Effects of type conversions on accuracy
---------------------------------------

When a number is converted to integer type, it is "rounded down"; i.e., the largest integer, which is not greater than the number is used (This is the same thing that happens when the INT function is applied to the number).

When a number is converted from double to single precision, it is "4/5 rounded" (the least significant digit is rounded up if the fractional part >=5. Otherwise, it is left unchanged).

When a single precision number is converted to double precision, only the seven most significant digits will be accurate.

Operators
---------

Operations in the innermost level of parentheses are performed first, and then evaluation proceeds according to the precedence in the following table. Operations on the same precedence are left associative, except for exponentiation, which is right associative.

| ()  | Function call, or parentheses |
| --- | --- |
| .   | Dot operator |
| \[ \] | Array operator |
| "?.", "?@", "?\[", "?(" | Optional chaining operators |
| ^   | Exponentiation |
| – , + | Negation (unary) |
| \* , / , MOD, \\ | Multiplicative operators |
| – , + | Additive operators |
| <<, >> | Integer bitshift operators |
| <, >, = , <>, <=, >= | Comparisons |
| NOT | Unary logical NOT or bitwise |
| AND | Logical or bitwise |
| OR  | Logical or bitwise |

### Function call operator

The function call operator "( )" can be used to call a function. When used on a function name, function literal, or variable containing a function reference, it calls the function.

    function five() as Integer
    
    return 5
    
    end function
    
    print five()
    
    fivevar = five
    
    print fivevar()
    
    array[1] = fivevar
    
    print array[1]()
    

### Dot operator

The dot operator can be used on any BrightScript Component. It also has special meaning when used on any roAssociativeArray, roXMLElement or roXMLList. When used on a BrightScript Component, it refers to an interface or a member function.

**Example**

    i = CreateObject("roInt")
    
    i.ifInt.SetInt(5)
    
    i.SetInt(5)
    

"ifInt" is the interface, and "SetInt" is the member function. Every member function of a BrightScript Component is part of an interface. However, specifying the interface with the dot operator is optional. If it is left out, as in the last line of the example above, each interface in the object is searched for the member function. If there is a conflict (a member function with the same name appearing in two interfaces), then the interface should be specified.

When the dot operator is used on an Associative Array, it is the same as calling the Lookup() or AddReplace() member of the AssociativeArray Object. However the dot operator's parameters are set at compile time – they are not dynamic (unlike the Lookup() or AddReplace() functions).

**Example**

    aa = CreateObject("roAssociativeArray")
    
    aa.newkey = "the value" ' same as: aa.AddReplace("newkey", "the value")
    
    print aa.newkey ' same as: print aa.Lookup("newkey")
    

When used for lookups, the dot operator is always case insensitive, even if ifAssociativeArray.SetModeCaseSensitive() has been called. By convention, a statement like:

    aa.NewKey = 55
    

will actually create the Associative Array entry in all lower case ("newkey"). Similarly, an AssociativeArray literal like this will also create the entry in lower case:

    aa = { NewKey: 55 }
    

To create mixed case keys, use the array operator or the ifAssociativeArray.AddReplace method:

    aa["NewKey"] = 55
    
    aa.AddReplace("NewKey", 55)
    

See the section on XML support for details on using the dot operator on xml objects.

### Array operator

The "\[ \]" operator is used to access an Array (any BrightScript Component that has an "ifArray" interface, such as roArray and roList). It can also be used as a synonym for the dot operator to access an AssociativeArray (except that the dot operator is case insensitive as described above).

    array = CreateObject("roArray", 10, true)
    
    array[2] = "two"
    
    print array[2]
    
    aa = CreateObject("roAssociativeArray")
    
    aa["newkey"] = "the value"
    
    print aa["newkey"]
    

The "\[ \]" operator takes expressions that are evaluated at runtime and so is different than the dot operator in this way. Thus the "\[ \]" operator can be used in situations where dot cannot, such as when the value of the index contains a character which is invalid in a variable name.

    aa = {}
    
    aa.name = 1
    
    aa["name"] = 1 ' same as previous line
    
    aa["name with spaces"] = 2 ' cannot do this with dot operator
    

Arrays in BrightScript are one dimensional. Multi-dimensional arrays are implemented as arrays of arrays. The "\[ \]" operator will automatically map a list of indexes separated by commas to the appropriate sequence of indexing. For example, the following two expressions to fetch "item" are the same:

**Example**

    dim array[5,5,5]
    
    item = array[1][2][3]
    
    item = array[1,2,3]
    

If a multi-dimension array grows beyond its hint size the new entries are not automatically set to roArray.

### Optional chaining operators

Developers can use optional chaining operators, "?.", "?@", "?\[", and "?(", in their BrightScript code to access possibly invalid values. This enables developers to execute more concise, higher-performing code. The optional chaining operators are used to read the value of a property nested within a chain of connected objects without having to first check whether each reference in the chain does not return the BrightScript value of "invalid". If the expression to the left of the chaining operator is invalid, the operator to the right of the chaining operator is skipped.

> The optional chaining operators feature is not supported on devices running firmware earlier than Roku OS 11.0 (doing so generates syntax errors). If the app does use the optional chaining operators feature, specify Roku OS 11.0 (or later) as the minimum version when [uploading your package file](/docs/developer-program/publishing/channel-publishing-guide.md#upload-a-package) in order to publish to the Streaming Store.

#### Example

The following example demonstrates how the BrightScript optional chaining operators enable developers to write concise expressions when accessing chained properties that may contain a missing reference. The following example attempts to call the `bar()` method of the `foo` member nested at index 3. With the optional chaining operators, this validation can be done in a single line of code; otherwise, it requires many additional lines.

##### With optional chaining operators

    x = array?[3]?.foo?.bar?()
    

In this example, the `?` variant checks whether the left-hand side of the expression is `invalid`. It returns `invalid` as the result instead of giving an error.

##### No optional chaining operators

    IF array <> invalid THEN
        el = array[3]
        IF el <> invalid THEN
            foo = el.foo
            IF foo <> invalid THEN
                IF foo.bar <> invalid THEN
                    x = foo.bar()
                ELSE
                    x = invalid
                END IF
            ELSE
                x = invalid
            END IF
        ELSE
            x = invalid
        END IF
    ELSE
        x = invalid
    END IF
    

#### Notes

*   The new operators are indivisible "tokens". You must write `a = b ?. c`. Do not write `a = b ? . c`.

*   The `invalid` value and its boxed version, `CreateObject("roInvalid")`, are both treated as invalid; however, no other values are.

*   The new operators only check whether the left-hand of the expression is `invalid`. It does not check for any other errors. For example, the following statements will still throw exceptions:
    
          s = "Hello"
          a = [1,2,3]
        
          x = uninitialized ?. foo  ' Accessing an uninitialized variable
          x = s ?[ 5 ]              ' Trying to index into a string
          x = a ?[ s ]              ' Trying to use a string to index an array
        
    

*   The `?[` and `?(` operators support short-circuiting. If the left-hand of the expression is `invalid`, the terms on the right side are not evaluated.
    
          FUNCTION explode() : THROW "Kaboom!" : END FUNCTION
          i = invalid
          x = i?(1, "String", explode())   ' Does not explode becuase `i` is invalid
          x = i?[explode()]                ' Does not explode becuase `i` is invalid
        
    

*   An `invalid` value is not considered false. The following code fails:
    
          IF aa?.foo THEN ...              ' Throws exception if aa is invalid
        
    
    This code should be written as follows:
    
          IF aa?.foo <> invalid THEN ...   ' Test if aa.foo exists
          IF aa?.foo = TRUE     THEN ...   ' Test if aa.foo is present and true
          IF aa?.foo <> FALSE   THEN ...   ' Test if aa.foo is true, or missing
        
    

#### Support details

*   The optional chaining operators are only supported in the context of expressions. They cannot be used directly in a standalone function call or as the target of an assignment:
    
          x = array?[12]                  ' Supported
          array?[12] = x                  ' Not supported
          x = f?()                        ' Supported
          f?()                            ' Not supported
        
    
    However, the optional chaining operators may be used in an expression that occurs _within_ a standalone function call or assignment target:
    
          f(array?[12])                   ' Supported
          f(foo?.bar).member = 5          ' Supported
        
    

*   The `?.` operator does not work with interface names:
    
          a = [1,2,3]
          PRINT a.ifArray.count()   ' Prints 3
          PRINT a?.ifArray.count()  ' Prints 3
          PRINT a.ifArray.count?()  ' Prints 3
          PRINT a.ifArray?.count()  ' Run-time error
        
    

*   The `?(` operator does not work on built-in or global functions:
    
          PRINT TYPE("Hello")       ' Prints String
          PRINT TYPE?("Hello")      ' Compile-time error; misuse of the keyword TYPE
          PRINT LEN("Hello")        ' Prints 5
          PRINT LEN?("Hello")       ' Run-time error (LEN isn't a keyword, so not faulted at compile time)
        
    

*   In BrightScript, `?` is also an alias for `PRINT` . For backwards compatibility, the following statements are still supported:
    
          ?("Hello")                ' Prints Hello
          ?.1                       ' Prints 0.1
        
    
    However, the following syntax is no longer supported:
    
          ' Previously:
          x = TRUE
          IF x?("Hello")            ' Used to print Hello
        
          ' But now:
          FUNCTION x(_) : RETURN TRUE : END FUNCTION
          IF x?("Hello")            ' Now begins a multi-line IF
              PRINT "Hi"
          END IF
        
    

### Exponentiation operator

If x and y are integer, float or double, `x^y` evaluates to x raised to the power y. Unlike other operators, exponentiation is right associative, so `2^3^2` = `2^(3^2)` = 512, not `(2^3)^2` = 64.

### Negation operator

If x is integer, float or double, -x evaluates to the negation of x, and +x is equal to x.

### Multiplicative operators

If x and y are integer, float or double, x \* y evaluates to their product and x / y evaluates to their quotient.

x MOD y is the remainder when x is divided by y.

x \\ y is the integer division result. For example 7 \\ 2 = 3.

x / y, x MOD y, and x \\ y will all generate a runtime error if y is zero.

### Additive operators

If x and y are integer, float or double, x+y evaluates to their arithmetic sum and x-y evaluates to their difference. If x and y are strings, x+y is the concatenation of x and y.

### Increment and decrement operators

Increment (++) and decrement (–) operators are available to allow integer increment and decrement to have effect on a variable. A few examples:

    x=1  
    x++  
    ' x = 2  
    x--  
    ' x = 1
    

**These operators are available in Roku OS 7.1 and above.**

### Mathematical and bitshift assignment operators

The following assignment operators are available to support mathematical and bitshift operations that take a numeric operand:

*   +=
    
*   \-=
    
*   \*=
    
*   /=
    
*   \\=
    
*   <<=
    
*   \>>=
    

A few examples:

    x=1  
    x+=1  
    ' x = 2  
    x+=2  
    ' x = 4  
    x-=1  
    ' x = 3  
    x/=2  
    ' x = 1.5
    
    x=9  
    x\=2  
    ' x = 4 (integer divide)  
    x*=3  
    ' x = 12
    
    x=1  
    x<<=8  
    ' x = 256  
    x-=1  
    ' x = 255  
    x>>=4  
    ' x = 15
    

**These operators are available in Roku OS 7.1 and above.**

### Integer bitshift operators

Given a number value, evaluated as an integer, and a shift value in the integer range 0..32, returns the integer value bitshifted accordingly.

A runtime error is generated if the shift value is out of range.

Example:

    print 2 << 10 '= 2048
    
    print 7 >> 1 '= 3
    

Right shifting treats the value as an unsigned integer, e.g. &hFFFFFFFF >> 1 is equal to &h7FFFFFFF.

### Comparison operators

This table describes the comparison operators. All operate on either numeric values (integer, float or double) or strings.

| Operator | Numeric | String |
| --- | --- | --- |
| A = B | true if A equals B | true if strings A and B are identical |
| A <> B | true if A is not equal to B | true if strings A and B are different |
| A < B | true if A is less than B | true if string A is lexically less than string B |
| A <= B | true if (A < B) or (A = B) | true if (A < B) or (A = B) |
| A > B | true if A is greater than B | true if string A is lexically greater than string B |
| A >= B | true if (A > B) or (A = B) | true if (A > B) or (A = B) |

That string comparisons are case sensitive. For example, ("one" = "One") evaluates to false.

### Logical and bitwise operators

AND, OR and NOT can be used both for constructing logical (Boolean) expressions and for bit manipulation. If the arguments to these operators are Boolean, then they perform a logical operation. If the arguments are numeric, they perform bitwise operations.

    x = 1 and 2 ' x is zero
    
    y = true and false ' y is false
    
    if a = c and not (b > 40) then print "success"
    

When AND and OR are used for logical operations, the clauses are evaluated from left to right, and only the necessary amount of the expression is executed (a feature sometimes called "minimal evaluation" or "short-circuit evaluation"). For example:

    if true or func()=0 then print "ok"
    

The above statement will print "ok" but will not call func, since the expression is true no matter what func returns. On the other hand

    if false or func()=0 then print "ok"
    

will call func and print ok only if func returns a value of zero.

This feature can be used to write statements such as

    if count > 0 and (total / count) > 33 then ...
    

Because of minimal evaluation, this will work correctly even when count is zero, while the following similar expression would not:

    if (total / count) > 33 and count > 0 then ... ' runtime error when count = 0
    

### \= operator

"=" is used for both assignment and comparison.

    a=5
    
    if a=5 then print "a is 5"
    

BrightScript does not support the use of the "=" assignment operator inside an expression (like C does). This is to eliminate the common class of bugs where a programmer meant "comparison", not "assignment". When an assignment occurs, intrinsic types (numbers, booleans, strings) are copied, but BrightScript objects (native objects, arrays, associative arrays) are reference counted.

Subscription Recovery settings
==============================

You can use the **Subscription recovery** page in the Developer Dashboard to enable Enhanced Subscription Recovery for your apps. The page lists the subscription recovery solution ([basic](/docs/developer-program/roku-pay/subscription-recovery/basic-recovery.md) or [enhanced](/docs/developer-program/roku-pay/subscription-recovery/subscription-on-hold.md)) used for each public and beta app in your developer account and lets you enable the enhanced recovery solution.

> Read the [Enhanced Subscription Recovery documentation](/docs/developer-program/roku-pay/subscription-recovery/subscription-on-hold.md) before enabling this feature for your apps. This integration requires you to update entitlements in your system based on the Roku Pay transaction data you pull from the [Roku Pay web services](/docs/developer-program/roku-pay/implementation/roku-web-service.md#validate-transaction) and/or receive via [push notifications](/docs/developer-program/roku-pay/implementation/push-notifications.md).
> 
> If this feature is not implemented correctly, customers will be unable to purchase a subscription for your app until the on-hold period has elapsed.

![roku600px - subscription-recovery-ui](https://image.roku.com/ZHZscHItMTc2/subscription-recovery-ui.png)

Enabling Enhanced Subscription Recovery
---------------------------------------

To enable the enhanced recovery solution for a public or beta app, follow these steps:

1.  Verify that you have [completed the Enhanced Subscription Recovery integration](/docs/developer-program/roku-pay/subscription-recovery/subscription-on-hold.md) and [published the updated version of your app](/docs/developer-program/publishing/channel-publishing-guide.md#updating-an-existing-channel).
    
2.  Under **Monetization** in the left sidebar, click **Subscription Recovery**.
    
3.  Click the **Edit** icon on the right-hand side of the app.
    
4.  In the **Subscription recovery settings** dialog, click **Enhanced** and then click **Continue**.
    
    ![roku600px - subscription-recovery-selection-dialog](https://image.roku.com/ZHZscHItMTc2/sub-recovery-warning-message.png)
    
5.  Click **Yes, Enable**. Once you switch a app to enhanced subscription recovery, you can cannot switch it back to basic recovery.
    
    ![roku600px - subscription-recovery-selection-dialog](https://image.roku.com/ZHZscHItMTc2/sub-recovery-warning-confirmation.png)
    

Switching subscription recovery settings
----------------------------------------

Once enhanced subscription recovery is enabled, it is used from that point forward for all subscriptions coming up for renewal. Basic recovery is still used for subscriptions currently in a grace period. Once you switch a app to enhanced subscription recovery, you can cannot switch it back to basic recovery.

BrightScript/XML markup equivalence
===================================

Because the SceneGraph API includes BrightScript objects and interfaces, you have the flexibility to create SceneGraph application screens using a variety of methods. You can create the screens entirely in XML markup in the **<children>** element of the SceneGraph XML **<component>** element. This will create the SceneGraph node tree defined by the XML markup when the component is initialized. But you can also create and add nodes to the SceneGraph tree dynamically in BrightScript as needed for your application (for example, in response to user input). You can also configure existing or new nodes in the SceneGraph tree at any time in BrightScript. When and how you create and configure the SceneGraph node tree scene in your application XML files should depend on the intended flow of your SceneGraph application.

To demonstrate the various methods of creating and configuration SceneGraph node trees, the following SceneGraph components all display the same blue rectangle near the top of the screen. The SceneGraph node tree that is created is _exactly_ the same for all the examples. You can verify that all the examples have the exact same screen appearance by downloading and "sideloading" the following application files:

| **File** | **Application** |
| --- | --- |
| [RectangleMU](https://github.com/rokudev/samples/tree/master/ux%20components/screen%20elements/renderable%20nodes/BrightScript_XML_Equivalents) | XML markup of node attributes |
| [RectangleBRS](https://github.com/rokudev/samples/tree/master/ux%20components/screen%20elements/renderable%20nodes/BrightScript_XML_Equivalents) | BrightScript setting of node attributes |
| [RectangleAA](https://github.com/rokudev/samples/tree/master/ux%20components/screen%20elements/renderable%20nodes/BrightScript_XML_Equivalents) | Node attributes set in BrightScript from an associative array |
| [RectangleTN](https://github.com/rokudev/samples/tree/master/ux%20components/screen%20elements/renderable%20nodes/BrightScript_XML_Equivalents) | Node attributes set in BrightScript from attributes downloaded from a server using a **Task** node |

First, a component that uses XML markup exclusively:

**Rectangle XML markup**

    <component name="rectangleexample" extends="Scene" >
    
    <script type = "text/brightscript" >
    
    <![CDATA[
    
    sub init()
    
    m.top.setFocus(true)
    
    end sub
    
    ]]>
    
    </script>
    
    <children>
    
    <Rectangle
    
    id = "exampleRectangle"
    
    color = "0x0000CCFF"
    
    width = "886"
    
    height = "44"
    
    translation = "[290,34]" />
    
    </children>
    
    </component>
    

The blue rectangle is automatically created, and made a child of the component, according the attributes set in the XML markup fields. But in some cases, you might want to set the attributes of a node at a later time, after the node is automatically created (for example, you might want to change the color of a screen element node, or make it invisible). So the following component example sets the attribute fields of the same rectangle in BrightScript:

**Setting node attributes in BrightScript**

    <component name="rectangleexample" extends="Scene" >
    
    <script type = "text/brightscript" >
    
    <![CDATA[
    
    sub init()
    
    m.examplerectangle = m.top.findNode("exampleRectangle")
    
    m.examplerectangle.color = "0x0000CCFF"
    
    m.examplerectangle.width = "886"
    
    m.examplerectangle.height = "44"
    
    m.examplerectangle.translation = "[290,34]"
    
    m.top.setFocus(true)
    
    end sub
    
    ]]>
    
    </script>
    
    <children>
    
    <Rectangle id="exampleRectangle" />
    
    </children>
    
    </component>
    

In this example, the rectangle node is only declared in XML markup, without any field attributes set. Rather, the attributes are set in the init() function, and could be set anywhere at any time for any reason in the component BrightScript code. Note the use of the findNode() function to allow declaring the rectangle object to be part of the component using the m object reference variable (m.examplerectangle). Then each attribute of the rectangle is set in BrightScript.

But a node can be created in BrightScript at any time, using functions like CreateObject() and createChild(); you don't have to use XML markup at all if your application is easier to write by creating SceneGraph nodes dynamically as needed. The following example shows how to create the same blue rectangle completely in BrightScript, and also shows how you might configure the rectangle attributes using an associative array:

**BrightScript creation of SceneGraph nodes**

    <component name="rectangleexample" extends="Scene" >
    
    <script type = "text/brightscript" >
    
    <![CDATA[
    
    sub init()
    
    m.top.backgroundURI = "pkg:/images/purplebg.jpg"
    
    rectattribs = CreateObject("roAssociativeArray")
    
    rectattribs.color = "0x1998CFFF"
    
    rectattribs.width = "886"
    
    rectattribs.height = "44"
    
    rectattribs.translation = "[290,34]"
    
    m.examplerectangle = m.top.createChild("Rectangle")
    
    m.examplerectangle.color = rectattribs.color
    
    m.examplerectangle.width = rectattribs.width
    
    m.examplerectangle.height = rectattribs.height
    
    m.examplerectangle.translation = rectattribs.translation
    
    m.top.setFocus(true)
    
    end sub
    
    ]]>
    
    </script>
    
    </component>
    

In this example, setting up an associative array to configure a simple rectangle at the time of component creation is a waste of time. But the following example shows how you might configure the appearance or behavior of a screen element node dynamically, by downloading the configuration attributes from your server when needed. For this example, you would need an XML (or JSON) file on your server containing the configuration attributes, as follows:

**Server node configuration XML file**

    <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
    
    <RectAttribs
    
    color="0x0000CCFF"
    
    width="886"
    
    height="44"
    
    translation="[290,34]" />
    

These are the same attributes set in all the other examples, only the location of the XML attributes has changed to your server. Now you need to set up a **Task** node to download the XML attributes file from your server (see [**Downloading Server Content**](/docs/developer-program/core-concepts/downloading-server-content.md) and [**Task**](/docs/references/scenegraph/control-nodes/task.md), and convert the attributes to an associative array, as was set up manually in the previous example:

**Task node to download server XML node configuration file**

    <component name="getrectconfig" extends="Task" >
    
    <interface>
    
      <field id = "uri" type = "string" />
    
      <field id = "rectconfig" type = "assocarray" />
    
    </interface>
    
    <script type = "text/brightscript" >
    
    <![CDATA[
    
    sub init()
    
      m.top.functionName = "getConfig"
    
    end sub
    
    sub getConfig()
    
      rectconfigxml = createObject("roXMLElement")
    
      readInternet = createObject("roUrlTransfer")
    
      readInternet.setUrl(m.top.uri)
    
      rectconfigxml.parse(readInternet.getToString())
    
      rectconfig = rectconfigxml.GetAttributes()
    
      m.top.rectconfig = rectconfig
    
    end sub
    
    ]]>
    
    </script>
    
    </component>
    

And then you can assign the attributes from the associative array to the rectangle node in BrightScript code in your component file:

**Configuring SceneGraph nodes using downloaded configuration file**

    <component name="rectangleexample" extends="Scene" >
    
    <script type = "text/brightscript" >
    
    <![CDATA[
    
    sub init()
    
    m.examplerectangle = m.top.createChild("Rectangle")
    
    m.readerTask =
    createObject("roSGNode","getrectconfig")
    
    m.readerTask.setField("uri","http://www.sdktestinglab.com/rectconfig.xml")
    
    m.readerTask.observeField("rectconfig","configureRectangle")
    
    m.readerTask.control = "RUN"
    
    m.top.setFocus(true)
    
    end sub
    
    sub configureRectangle()
    
    rectconfig = m.readerTask.rectconfig
    
    m.examplerectangle.color = rectconfig.color
    
    m.examplerectangle.width = rectconfig.width
    
    m.examplerectangle.height = rectconfig.height
    
    m.examplerectangle.translation = rectconfig.translation
    
    end sub
    
    ]]>
    
    </script>
    
    </component>

roInt
=====

roInt is the object equivalent for intrinsic type Integer.

This is useful in the following situations:

*   When an object is needed, instead of an intrinsic value. For example, "roList" maintains a list of objects. If an Integer is added to roList, it will be automatically wrapped in an roInt by the language interpreter. When a function that expects a BrightScript Component as a parameter is passed an int, BrightScript automatically creates the equivalent BrightScript Component.
*   If any object exposes the ifInt interface, that object can be used in any expression that expects an intrinsic value. For example, in this way an roTouchEvent can be used as an integer whose value is the userid of the roTouchEvent.

> If o is an roInt, then the following statements have the following effects
> 
> print o ' prints o.GetInt()
> 
> i%=o ' assigns the integer i% the value of o.GetInt()
> 
> k=o 'presumably k is dynamic typed, so it becomes another reference to the roInt o
> 
> o=5 'this is NOT the same as o.SetInt(5). Instead it releases o, and 'changes the type of o to Integer (o is dynamically typed). And assigns it to 5.

**Example**

    BrightScript> o=CreateObject("roInt")
    BrightScript> o.SetInt(555)
    BrightScript> print o
    555
    BrightScript> print o.GetInt()
    555
    BrightScript> print o-55
    500
    

Supported interfaces
--------------------

*   [ifInt](/docs/references/brightscript/interfaces/ifint.md "ifInt")
*   [ifIntOps](/docs/references/brightscript/interfaces/ifintops.md "ifIntOps")
*   [ifToStr](/docs/references/brightscript/interfaces/iftostr.md "ifToStr")

Building your first app
=======================

You can build your first Roku app by modifying Roku's Hello World sample. After you sideload the app, you can use the Roku debug console to view the app's runtime output.

Viewing the directory structure
-------------------------------

To get started, [download the Hello World sample app](https://github.com/rokudev/hello-world/archive/refs/heads/master.zip) and unzip it if you have not done so already. Expand the **/hello-world-master/dist/apps/hello-world** folder to view the app's directory structure. The directory of a Roku app typically contains the following folders and files:

*   The **components** folder contains the SceneGraph XML files that define the app's layout.
*   The **source** folder contains the main entry point for launching the app.
*   The **images** folder contains the splash screen image and other artwork for the app.
*   The **manifest** file defines the app attributes and versioning.
*   The **makefile** is an optional utility for installing the app. See Using a makefile for more information.

> The maximum number of files inside a single directory should be less than 100 to avoid performance issues.

Editing the Hello World app
---------------------------

To edit the text displayed on your television screen by the sample app, follow these steps:

1.  Browse to the /**hello-world-master/dist/apps/hello-world.zip** file and extract the archive.

2.  Expand the **/hello-world-master/dist/apps/hello-world/components** folder and then open the **helloworld.xml** file.

3.  In the [SceneGraph **Label** node](/docs/references/scenegraph/label-nodes/label.md), update the **text** field (line 5) to the string you want displayed on your television screen (for example, "My first Roku app!").

4.  In the [init() function](/docs/references/scenegraph/component-functions/init.md), you can also set the **label.color** field (line 27) to a different hex code (for example, white, which is 0xFFFFFF).

5.  Save the file.

6.  Zip the contents of the **hello-world** directory; do not zip the directory itself or the development application installer will report an error when you try to upload the app. Name the zip file something that makes it easy to find (for example, my-hello-world.zip).

Sideloading the updated sample app
----------------------------------

To sideload the updated Hello World sample app, follow these steps:

1.  In your web browser, enter the URL of your Roku device, and then log in (the **User Name** is "rokudev"; the password is the one you created when you activated developer mode on your Roku device.

2.  In the Development Application Installer, click **Upload**, and then select the **/hello-world-master/dist/apps/hello-world/my-hello-world.zip** file.

3.  The updated Hello World app launches on your Roku device and displays "My first Roku app!" in white on the screen.
    
    ![roku600px my-first-roku-app](https://image.roku.com/ZHZscHItMTc2/my-first-roku-channel.jpg)
    

Using the debug console
-----------------------

You can use the [Roku debug console](/docs/developer-program/debugging/debugging-channels.md) to view the output of a Roku app during runtime. If the app fails during runtime, the debug console displays the line number of the error, as well as the contents of variables at the time of the failure. If the app has compilation errors, the debug console displays them as well. It is recommended to have the debug console open whenever you are running a sideloaded app.

To open the debug console, follow these steps:

1.  Using a shell application such as [PuTTY](http://www.putty.org/) for Windows or terminal on Mac and Linux, enter the following telnet command:
    
        telnet roku-ip-address 8085
        
    

2.  Return to the Development Application Installer, click **Delete**, **Upload**, select the **/hello-world-master/dist/apps/hello-world/my-hello-world.zip** file again, and then click **Replace**.

3.  In the debug console, view the output from the sample app.
    
    ![roku600px debug-console](https://image.roku.com/ZHZscHItMTc2/debug-console.png)
    

> The [BrightScript extension for the Visual Studio Code IDE](https://marketplace.visualstudio.com/items?itemName=celsoaf.brightscript), which is maintained by the Roku developer community, also contains a built-in debug console (this VSCode extension is used by many Roku developers and it is well-reviewed; however, it is not built or maintained by Roku and its continued maintenance and support are not guaranteed).

Using a makefile to sideload apps
---------------------------------

To use a makefile to automate the sideloading of an app, follow these steps:

1.  Verify that the **makefile** and the **app.mk** file are in the same directory as the manifest. Optionally, you can modify the "ZIP\_EXCLUDE" line in the makefile to exclude certain files. You can use the makefile in the **/hello-world-master/makefile** directory as a template.

2.  Set the ROKU\_DEV\_TARGET and DEVPASSWORD environment variables.
    
    *   ROKU\_DEV\_TARGET is the IP address of your Roku device.
        
    *   DEVPASSWORD is the password you set when you activated developer mode.
        

3.  Run “make install”.
    
        % export ROKU_DEV_TARGET=192.168.1.140 % export DEVPASSWORD=1234 % cd<sdk>/examples/source/videoplayer % make install

Rectangle
=========

Extends [**Group**](/docs/references/scenegraph/layout-group-nodes/group.md "**Group**")

The Rectangle node class draws a solid color rectangle with the top/left corner of the rectangle drawn at the origin of the node local coordinate system. Because the Rectangle node class extends the Group node class, it can have child nodes. For example, a Rectangle node might have a child Label node, resulting in text being drawn inside of a box.

### Example

The following are examples using the Rectangle node.

![roku815px - rectangle-node](https://image.roku.com/ZHZscHItMTc2/rectangle-node.png "rectangle-node")

![roku815px - rectangle-node-rotated](https://image.roku.com/ZHZscHItMTc2/rectangle-node-rotated.png "rectangle-node-rotated")

Rectangle Node Class Example:

    <?xml version="1.0" encoding="utf-8" ?>
    
    <!--********** Copyright 2015 Roku Corp.  All Rights Reserved. **********-->
    
    <component name="rectangleexample" extends="Group" >
    
    <script type="text/brightscript" >
    <![CDATA[
    
    sub init()
      m.top.setFocus(true)
    end sub
    
    ]]>
    </script>
    
    <children>
    
    <Rectangle
      id="testRectangle"
      color="0x880088FF"
      width="1280"
      height="60"
      translation="[0,0]" />
    
    </children>
    
    </component>
    

### Rotation

Rotation of Rectangles is supported. On platforms that do not support OpenGL, only rotations of 0, 90, 180, and 270 degrees are supported.

Fields
------

[Fields](/docs/references/scenegraph/layout-group-nodes/group.md#fields "Fields") derived from the Group base class can also be used.

| Field | Type | Default | Access Permission | Description |
| --- | --- | --- | --- | --- |
| width | float | 0.0 | READ\_WRITE | Specifies the width of the rectangle in local coordinates |
| height | float | 0.0 | READ\_WRITE | Specifies the height of rectangle in local coordinates |
| color | color (string containing hex value e.g. RGBA) | 0xFFFFFFFF | READ\_WRITE | Specifies the color of the rectangle |
| blendingEnabled | boolean | true | READ\_WRITE | Specifies if the rectangle should be alpha blended with the nodes that are behind it |

Sample app
----------

[RectangleExample](https://github.com/rokudev/samples/tree/master/ux%20components/screen%20elements/renderable%20nodes/RectangleExample) is a sample app demonstrating Rectangle in action.

roImageMetadata
===============

The roImageMetadata component provides developers access to image file metadata included in many .jpg EXIF headers.

roImageMetadata currently only works with local file Urls.

This object is created without any arguments:

`CreateObject("roImageMetadata")`

#### EXIF Background

Each EXIF tag represents one piece of metadata. Each tag is uniquely identified by a tag number and the IFD in which it was found. All the tags are grouped into a small set of IFDs (Image File Directory). The EXIF specification describes 5 IFDs:

| Number | Name | Notes |
| --- | --- | --- |
| 0   | image | Tags related to image structure and some additional basic information |
| 1   | thumbnail | Tags related to the thumbnail image structure |
| 2   | exif | Tags related to non-image structure data. I know this is an odd name. Usually stuff like ApertureValue that a digital camera would write |
| 3   | gps | Tags related to GPS |
| 4   | interoperability |     |

The associative array returned by GetRawExif() function on the roImageMetadata component is organized as a tree where the first level consists of the IFDs, the second level is the tag name, and the third (leaf) level is tag associative array.

Each tag associative array contains the following values:

| Number | Name | Notes |
| --- | --- | --- |
| Tag | Integer | The tag number |
| Value | String | This is a string representation of the data regardless of the underlying data type |

Tag values can be one of several types (string, bytes, rational, enum, etc.) We are using a that converts most values to a string. In the future or time permitting, we may add more values to the tag aa to give access to raw bytes.

The best way to illustrate how the EXIF data is accessed is through some concrete examples using the data in the reference section below. Assume that the associative array aa contains the results of the GetRawExif() function.

*   To get the camera model: aa.image.model.value
*   To get the gps latitude: aa.gps.GPSLatitude.value

#### Reference

For reference here are all the fields from an image taken from my camera (with the addition of GPS attributes I added using Picasa).

The format is IFD#, Tag#\[Tag Name\], Data Format, Value. The Value is a string representation of data.

    0, 272[ Model], ASCII,Canon PowerShot SD700 IS
    0, 274[ Orientation], Short,top - left
    0, 283[ YResolution], Rational,180.00
    0, 296[ ResolutionUnit], Short,Inch
    0, 305[ Software], ASCII,Picasa 3.0
    0, 306[ DateTime], ASCII,2007:08:14 10:06:48
    0, 531[ YCbCrPositioning], Short,centered
    0, 282[ XResolution], Rational,72.00
    1, 259[ Compression], Short,JPEG compression
    1, 282[ XResolution], Rational,180.00
    1, 283[ YResolution], Rational,180.00
    1, 296[ ResolutionUnit], Short,Inch
    2,33434[ ExposureTime], Rational,1/320 sec.
    2,33437[ FNumber], Rational,f/2.8
    2,36864[ ExifVersion], Undefined,Exif Version 2.2
    2,36867[ DateTimeOriginal], ASCII,2007:08:14 10:06:48
    2,36868[ DateTimeDigitized], ASCII,2007:08:14 10:06:48
    2,37121[ ComponentsConfiguration], Undefined,Y Cb Cr -
    2,37122[ CompressedBitsPerPixel], Rational,5.00
    2,37377[ ShutterSpeedValue], SRational,8.31 EV (1/317 sec.)
    2,37378[ ApertureValue], Rational,2.97 EV (f/2.8)
    2,37380[ ExposureBiasValue], SRational,0.00 EV
    2,37381[ MaxApertureValue], Rational,2.97 EV (f/2.8)
    2,37383[ MeteringMode], Short,Pattern
    2,37385[ Flash], Short,Flash did not fire, auto mode
    2,37386[ FocalLength], Rational,5.8 mm
    2,37500[ MakerNote], Undefined,1838 bytes undefined data
    2,37510[ UserComment], Undefined,
    2,40960[ FlashPixVersion], Undefined,FlashPix Version 1.0
    2,40961[ ColorSpace], Short,sRGB
    2,40962[ PixelXDimension], Short,2816
    2,40963[ PixelYDimension], Short,2112
    2,41486[ FocalPlaneXResolution], Rational,12515.56
    2,41487[ FocalPlaneYResolution], Rational,12497.04
    2,41488[ FocalPlaneResolutionUnit], Short,Inch
    2,41495[ SensingMethod], Short,One-chip color area sensor
    2,41728[ FileSource], Undefined,DSC
    2,41985[ CustomRendered], Short,Normal process
    2,41986[ ExposureMode], Short,Auto exposure
    2,41987[ WhiteBalance], Short,Auto white balance
    2,41988[ DigitalZoomRatio], Rational,1.00
    2,41990[ SceneCaptureType], Short,Standard
    2,42016[ ImageUniqueID], ASCII,ba6ad9a9d88ffd9576ea6155afa6c6ef
    3, 0[ GPSVersionID], Byte,2.2.0.0
    3, 1[ GPSLatitudeRef], ASCII,N
    3, 2[ GPSLatitude], Rational,40.00, 12.00, 44.79
    3, 3[ GPSLongitudeRef], ASCII,W
    3, 4[ GPSLongitude], Rational,75.00, 37.00, 47.58
    3, 5[ GPSAltitudeRef], Byte,Sea level
    4, 1[ InteroperabilityIndex], ASCII,R98
    4, 2[ InteroperabilityVersion], Undefined,0100
    4, 4097[ RelatedImageWidth], Short,2816
    4, 4098[ RelatedImageLength], Short,2112
    

**Example**

    REM printAA() is from generalUtils.brs in our sample apps
    REM and used to print an associative Array
    Sub SaveExifImage(filename As String)
        meta = CreateObject("roImageMetadata")
        meta.SetUrl(filename)
        print "------------- GetRawExif() ----------------------"
        allexif = meta.GetRawExif()
        printAA(allexif)
        print "------------- GetMetadata() ---------------------"
        simple = meta.GetMetadata()
        printAA(simple)
        print "------------- GetRawExifTag() -------------------"
        rawexiftag = meta.GetRawExifTag(2,36868)
        printAA(rawexiftag)
        print "------------- GetThumbnail() --------------------"
        thumbnail = meta.GetThumbnail()
        if (thumbnail <> invalid) then
            if (thumbnail.bytes = invalid) then
                return
            end if
            imgtype = thumbnail.type
            image_ext=""
            if (imgtype = "image/jpeg" or imgtype = "jpg") then
                image_ext = "jpg"
            else if (imgtype = "image/png" or imgtype = "png") then
                image_ext = "png"
            else
                image_ext = "jpg"
            end if
            tmp_img = "tmp:/TmpExifImage" + "." + image_ext
            if (tmp_img <> invalid) then
                DeleteFile(tmp_img)
            end if
            thumbnail.bytes.Writefile(tmp_img)
        end if
    End Sub
    

Supported interfaces
--------------------

*   [ifImageMetadata](/docs/references/brightscript/interfaces/ifimagemetadata.md "ifImageMetadata")

Creating TVOD apps
==================

Publishers participating in Roku Pay can monetize content by making it available for rental or purchase. Implementing the transactional video on demand (TVOD) model in a Roku app allows publishers to generate revenue from sporting events, pay-per-views, recent movie releases, and other popular content in their catalog. This enables viewers to enjoy the convenience of consuming a publisher's must-see content on-demand.

![roku815px - tvod-sample-UI](https://image.roku.com/ZHZscHItMTc2/tvod-movie-v2.png)

Overview
--------

Offering transactional content in an app entails [creating in-app products](/docs/developer-program/roku-pay/quickstart/in-channel-products.md) for the content in the Developer Dashboard and using the [ChannelStore node](/docs/references/scenegraph/control-nodes/channelstore.md) to [check the user's billing status](/docs/references/scenegraph/control-nodes/channelstore.md#requestpartnerorder) and [complete the rental or purchase transaction](/docs/references/scenegraph/control-nodes/channelstore.md#confirmpartnerorder).

> This workflow is intended for:
> 
> 1.  Publishers creating a TVOD-exclusive app (an app containing only transactional content such as movie rentals or purchases).
> 2.  Publishers with subscription video on demand (SVOD) apps that also offer transactional content.

Creating in-app products for TVOD
---------------------------------

To link transactional content with Roku Pay, you create in-app products in the Developer Dashboard. With the TVOD model, in-app products only need to be created for each [product category](/docs/developer-program/roku-pay/quickstart/in-channel-products.md#product-basics) (video, audio, game, or app/utility). For example, if you plan on offering movie rentals, you only need to create a single product that has the video category.

To manage multiple transactional content items using the same in-app product, your app application can leverage your product feed or publisher-specific API to retrieve the item's metadata from your catalog at runtime. When a user selects the content to be purchased, your app can use the runtime metadata to display the item's title, price, and poster image and pass the item's SKU through the ChannelStore functions in order to identify for which item to grant the user access.

When creating an in-app product for transactional content, make sure to do the following:

*   **Product Name**. Enter a name that generically describes the rental or purchase product (for example, "movie rental", "movie purchase", and so on).
*   **Purchase Type**. Select **One-Time Purchase, Consumable - Quantity** from the list.
*   **Quantity**. Select **1**.
*   **Price Tier**. Select any price tier. The price passed in the ChannelStore APIs overrides the price corresponding to the selected price tier.

![roku400px -  - tvod-product-pricing](https://image.roku.com/ZHZscHItMTc2/tvod-product-pricing.jpg)

Handling transactional purchases
--------------------------------

To handle purchases of transactional content in your app, your app must send the [ChannelStore node's](/docs/references/scenegraph/control-nodes/channelstore.md) [requestPartnerOrder](/docs/references/scenegraph/control-nodes/channelstore.md#requestpartnerorder) and [confirmPartnerOrder](/docs/references/scenegraph/control-nodes/channelstore.md#confirmpartnerorder) commands to check the user's billing status and complete the transaction.

To send the **requestPartnerOrder** and **confirmPartnerOrder** commands, follow these steps:

1.  Create a **ContentNode** with the following fields:
    
    *   **priceDisplay**. The original price of the product. Do not include a currency symbol (for example, set this to "5.99" instead of "$5.99").
    *   **price**. The final price to be charged for the product, including any discounts. Do not include a currency symbol (for example, set this to "3.99" instead of "$3.99").
    *   **couponCode** (optional). An alphanumeric string entered by the customer to receive a discounted price on the product.
    *   **contentKey**. The publisher's SKU (or other unique identifier) for the product.
    *   **code**. The uniqueID specified for the product in the **In-App Products** page. Use the **addField()** method to add the **code** field to the **ContentNode**.
    *   **title** (optional). The title of the product being purchased (for example, the name of a movie rental).

            m.orderInfo = createObject("roSGNode", "contentNode")
            m.orderInfo.priceDisplay = "5.99"
            m.orderInfo.price = "3.99"
            m.orderInfo.couponCode = "FIRST-RENTAL"
            m.orderInfo.contentKey = "123456"
    
            'Add a code field to the ContentNode
            m.orderInfo.addField("code", "string", false)
    
            'Set the code to the product identifier of your generic TVOD product
            m.orderInfo.code = "ROKUTVODSTORETVSHOW"
    

2.  Set the **ContentNode** to the ChannelStore node's **requestPartnerOrder** field.

            m.channelStore.requestPartnerOrder = m.orderInfo
            m.channelStore.command = "requestPartnerOrder"
    

3.  Add an observer for the **requestPartnerOrderStatus** field and an associated callback function. Check that the **requestPartnerOrderStatus.status** field is set to **success** to confirm the customer's billing request and then proceed with the next steps to complete the transaction.
    
    If the **status** field is set to **failure**, display an error message.
    

            m.store.observeField("requestPartnerOrderStatus", "requestPartnerOrderStatusChanged")
    
            'callback function
            function requestPartnerOrderStatusChanged()
                if m.store.requestPartnerOrderStatus.status = "Success"
                'user's billing status is valid - prompt the user to purchase
                else
                    'display an appropriate error message
                end if
            end function
    

4.  Create a **ContentNode** with the following fields:
    
    *   **orderId**. Set this to the **requestPartnerOrderStatus.orderID** field. This is the order ID generated by Roku for the transactional purchase.
    *   **title**. The name to be shown on user's invoices for the purchased item.
    *   **pin**. Enter an empty string ("") to trigger the Roku Pay user content payment workflow.
    *   **priceDisplay**. The original price of the product. Do not include a currency symbol (for example, set this to "5.99" instead of "$5.99").
    *   **price**. The final price to be charged for the product, including any discounts. Do not include a currency symbol (for example, set this to "3.99" instead of "$3.99").
    *   **couponCode** (optional). An alphanumeric string entered by the customer to receive a discounted price on the product.
    *   **contentKey**. The publisher's SKU (or other unique identifier) for the product.
    *   **code**. The uniqueID specified for the product in the **In-Channel Products** page. Use the **addField()** method to add the **code** field to the **ContentNode**.

            m.confirmOrderInfo = CreateObject("roSGNode", "ContentNode")
            m.confirmOrderInfo.orderId = m.store.requestPartnerOrderStatus.orderID
            m.confirmOrderInfo.title = "TV Show 1"
            m.confirmOrderInfo.pin = ""
            m.confirmOrderInfo.priceDisplay = m.orderInfo.priceDisplay
            m.confirmOrderInfo.price = m.orderInfo.price
            m.confirmOrderInfo.couponCode = m.orderInfo.couponCode
            m.confirmOrderInfo.contentKey = m.orderInfo.contentKey
    
            'Add a code field to the ContentNode
            m.confirmOrderInfo.addField("code", "string", false)
    
            'Set the code to the product identifier of your generic tvod product
            m.confirmOrderInfo.code = "ROKUTVODSTORETVSHOW"
    

5.  Set the **ContentNode** to the ChannelStore node's **confirmPartnerOrder** field. This will prompt the user to complete the transaction.

        'Set the ContentNode to the ChannelStore node
        m.store.confirmPartnerOrder = m.confirmOrderInfo
    
        'Prompt the user to complete the transaction
        m.store.command = "confirmPartnerOrder"
    

6.  Add an observer for the **confirmPartnerOrderStatus** field and an associated callback function. Check that the **confirmPartnerOrderStatus.status** field is set to **success** to confirm the transaction and then display a confirmation dialog to the user with a purchase summary. Grant the customer access to the purchased content. You can pass the publisher-specific SKU in the **contentKey** field to your backend services to do this.
    
    If the **status** field is set to **failure**, display an error message explaining why the transaction could not be completed.
    

            m.store.observeField("confirmPartnerOrderStatus", "confirmPartnerOrderStatusChanged")
    
            'callback function
            function confirmPartnerOrderStatusChanged()
                if m.store.confirmPartnerOrderStatus.status = "Success"
                     displayOrderStatusDialog(m.store.confirmPartnerOrderStatus)
                else
                    'display an appropriate error message
                end if
            end function
    

Sample app
----------

You can download and install a [sample app](https://github.com/rokudev/channelstore-node-tvod-sample) that demonstrates how to handle transactional purchases using the [ChannelStore](/docs/references/scenegraph/control-nodes/channelstore.md) node. This sample shows how to link a single, generic in-app product to multiple transactional content items in an app's catalog. It also shows how to dynamically name and price transactional content items and process their purchases in the Roku Pay workflow.

roDeviceCrypto
==============

The roDeviceCrypto component enables you to encrypt and decrypt data on a device using a key that is unique per app, device, or model. Using an app key for example, you can encrypt data for an app so that it may only be decrypted by that same app. In this case, you could provision credentials or an API key from the cloud to devices securely. With a device key for example, you could implement a secure-storage like algorithm.

Supported interfaces
--------------------

*   [ifDeviceCrypto](/docs/references/brightscript/interfaces/ifdevicecrypto.md)

Description
-----------

roDeviceCrypto has two methods: `Encrypt()` and `Decrypt()`. Both methods take a `roByteArray` and the encryption key type (`encType`), which is a string that may be set to "channel", "device", or "model".

Both methods return a `roByteArray` so that you can encrypt plaintext on a Roku device and then decode it, as demonstrated in the following example:

      ' store plaintext to be encrypted in an roByteArray
      ba = CreateObject("roByteArray")
      ba.FromAsciiString("plain text1")  
    
      ' create roDeviceCrypto object and specify a device key
      dc = CreateObject("roDeviceCrypto")
      encType = "device"
    
      ' encrypt plaintext using the device key and store the encoded data in an roByteArray
      encrypted = dc.Encrypt(ba, encType)
    
      ' decode the encrypted data and store the decrypted data in an roByteArray
      if encrypted <> invalid then
        decrypted = dc.Decrypt(encrypted,encType)
      end if

Sliding panels
==============

Sliding panels allow the creation of sets of other elements, such as lists or grids, that are grouped into _panels_ that can be moved left and right on and off the display screen. The panels can also be created (and removed) dynamically in response to user input and program behavior.

Sliding panel nodes
-------------------

The following are the panel node classes supplied by Roku as part of the SceneGraph API:

*   OverhangPanelSetScene
*   Overhang
*   PanelSet
*   Panel
*   ListPanel
*   GridPanel

Panel nodes, panel sets, and panel set scenes
---------------------------------------------

The **Panel**, **ListPanel**, and **GridPanel** node classes are the panel node classes that can be extended to create a custom panel component design in XML markup. The **Panel** node class is a generic panel node that can include any type of content, while the **ListPanel** and **GridPanel** node classes are specifically intended to contain list or grid content respectively, with special features that can automatically create new panels based on item selection in the panel list or grid.

These panel node classes are designed to be used as part of a _panel set_. Panel sets are groups of child panel nodes that can be dynamically created and moved into view automatically after being created. The **PanelSet** node class is the parent node class of the child panel nodes in the panel set.

A special **Scene** node class is provided for panel sets: **OverhangPanelSetScene**. The **OverhangPanelSetScene** node class by default includes a child **Overhang** node, and a child **PanelSet** node. The **Overhang** node class provides a region at the top of the screen that is the full width of the screen, with default poster and label elements that can be automatically targeted with content by the focused panel in the **PanelSet** node. As part of an **OverhangPanelSetScene** scene, the child **PanelSet** node is automatically positioned below the **Overhang** node. The **PanelSet** node class includes areas on the left and right side of the panel set designed for automatic arrow indicators, to prompt the user to press the **Right**, **Left**, or **Back** keys to select and slide the panels.

![roku815px - sliding-panels](https://image.roku.com/ZHZscHItMTc2/sliding-panels.jpg "sliding-panels")

Panel adding/sliding
--------------------

As part of a panel set, panel node classes are designed to automatically slide into and out of view in response to being added to the panel set as a result of user input or other program behavior. To allow this automatic adding/sliding behavior, panel node classes have a set of default width sizes based on the width of the panel set, excluding the arrow indicators on the sides of the panel set. The `panelSize` field for panel node classes should be set to one of four width sizes:

| Size | Description |
| --- | --- |
| narrow | Approximately a third of the panel set width |
| medium | Approximately one half the panel set width |
| wide | Approximately two-thirds of the panel set width |
| full | Approximately the full panel set width |

The precise horizontal positioning of panels in the panel set depends on the screen resolution, as well as the setting of the `leftPosition` field of the panel node. The `leftPosition` field determines the offset from the left side of the panel set for a panel, but has default settings based on screen resolution that generally should not be changed. The actual pixel sizes and left position of the panels is as follows:

| Panel Field | Panel Size | SD Value | HD Value |
| --- | --- | --- | --- |
| height | all | 403 | 605 |
| width | narrow | 218 | 388 |
|     | medium | 292 | 520 |
|     | wide | 363 | 645< |
|     | full | 520 | 940 |
| leftPosition | narrow | 60  | 105 |
|     | medium | 60  | 105 |
|     | wide | 63  | 112 |
|     | full | 100 | 170 |

The width size you choose for each panel should be determined by the size of the content of the panel, and the size of adjacent panels to the left and right. When a panel is added that can only be displayed by sliding an existing panel (or panels) to the left, the **PanelSet** node class will automatically slide the existing panel or panels to the left. So the simplest method to set up this automatic sliding of the panels as needed is to select the default panel width sizes that fill the panel set width at all times.

To do this, you should pair adjacent panels based on their width size. For example, two medium panels that are added as the first two panels on the left could be paired with full panel to be created on the right, with the `isFullScreen` field set to true, which configures the panel to be the only panel to be shown. Then when the full right panel is added, the two medium panels slide automatically off the screen to the left, and the full right panel slides into view from the right. Alternately, you could pair a narrow and a wide panel on the left with a full panel on the right. In some cases, you might want to create _tombstone_ panels with additional information on focused items in a panel to the left to fill the panel set width.

After setting up the panels in the panel set according to size and content, the panels will slide back and forth automatically based on user **Right**, **Left**, and **Back** key presses, adding new panels to the panel set, and putting the focus on already-added panels. You add new panels as children of the panel set using the `createChild()` function, or using the `createObject()` function followed by the `appendChild()` function, depending on the sequence your application will follow to slide the panels, because the panels will not slide until added to the panel set.

Sliding panels example
----------------------

**Example Application:** [SlidingPanels](https://github.com/rokudev/samples/tree/master/ux%20components/sliding%20panels)

The following adds two medium panels as children of a panel set in an **OverhangPanelSetScene** component `init()` function, and sets up field observers with callback functions to populate and add panels to the right, and slide the panels back and forth based on user key presses.

**Panel Adding/Sliding Example**

    sub init()
      m.top.backgroundURI = "pkg:/images/rsgetbg.jpg"
    
      m.top.overhang.showClock = false
      m.top.overhang.showOptions = true
    
      m.categoriespanel = m.top.panelSet.createChild("categoriesListPanel")
    
      m.categoryinfopanel = m.top.panelset.createChild("categoryinfoPanel")
    
      m.categoriespanel.list.observeField("itemFocused","showcategoryinfo")
      m.categoryinfopanel.observeField("focusedChild","slideexamplesgridpanel")
    
      m.categoriespanel.setFocus(true)
    end sub
    
    sub showcategoryinfo()
      categorycontent = m.categoriespanel.list.content.getChild(m.categoriespanel.list.itemFocused)
      m.categoryinfopanel.description = categorycontent.description
      m.examplespanel = createObject("RoSGNode","examplesGridPanel")
      m.examplespanel.overhangtext = categorycontent.shortdescriptionline1
      m.examplespanel.gridcontenturi = categorycontent.Url
    end sub
    
    sub slideexamplesgridpanel()
      if not m.top.panelSet.isGoingBack
        m.top.panelSet.appendChild(m.examplespanel)
        m.examplespanel.setFocus(true)
      else
        m.categoriespanel.setFocus(true)
      end if
    end sub

The `categoriesListPanel` component object created as a child of the panel set was defined as a medium panel in its component XML file, and the same was done for the `categoryinfoPanel` component. For example, the `categoriesListPanel` component was defined as follows:

**Panel Component XML Markup Example**

    <component name="categoriesListPanel" extends="ListPanel" >
    
    <script type="text/brightscript" >
    <![CDATA[
    
    sub init()
      m.top.panelSize = "medium"
      m.top.focusable = true
      m.top.hasNextPanel = true
      m.top.leftOnly = true
      m.top.createNextPanelOnItemFocus = false
      m.top.selectButtonMovesPanelForward = true
      m.top.overhangTitle = "SceneGraph Examples"
      m.categorieslist = m.top.findNode("categorieslist")
      m.top.list = m.categorieslist
    end sub
    
    ]]>
    </script>
    
    <children>
    
    <LabelList id = "categorieslist" >
    
      <ContentNode role = "content" >
        <ContentNode  
          title = "Renderable Nodes"  
          description = "Basic Nodes That Show Things  
          &#xA;  
          &#xA;  &#8226; Rectangle
          &#xA;  &#8226; Label
          &#xA;  &#8226; Poster  
          &#xA;  &#8226; Video"
          shortdescriptionline1="Renderable Node Markup"  
          Url = "http://www.sdktestinglab.com/renderablegrid.xml" />
        <ContentNode  
          title = "Z-Order/Parent-Child"  
          description = "SceneGraph Tree Order Matters  
          &#xA;  
          &#xA;Demonstrates the basic concepts of SceneGraph element layering
    and inheritance. In Roku SceneGraph, what's on the bottom of your XML tree goes
    on top!"  
          shortdescriptionline1="Z-Order/Parent-Child Markup"  
          Url = "http://www.sdktestinglab.com/zordergrid.xml" />  
        <ContentNode title = "Animations"  
          description = "Fly Things Around and Flash Lights  
          &#xA;  
          &#xA;This shows you how to make your application more moving, by animating
    screen elements. There are examples for all of the field interpolator nodes, plus
    sequential and parallel animations."  
          shortdescriptionline1="Animation Markup"   
          Url = "http://www.sdktestinglab.com/animationgrid.xml" />
        <ContentNode title = "Events and Observers"  
          description = "React When Stuff Happens  
          &#xA;  
          &#xA;You need to handle events that come from both the user, and program
    actions. You'll learn to use the onKeyEvent() and observeField() SceneGraph
    functions to do this."   
          shortdescriptionline1="Events and Observers Markup"  
          Url = "http://www.sdktestinglab.com/eventsobserversgrid.xml" />
      </ContentNode>
    
    </LabelList>
    
    </children>
    
    </component>

Since both the `categoriesListPanel` and `categoryinfoPanel` components were defined as medium panels (each approximately one-half the panel set width), they fill the entire panel set width. The `categoryinfoPanel` component is defined as a simple tombstone panel to be targeted with additional information on the focused item in the `categoriesListPanel` component list on the left. It implements an `<interface>` element with an `onChange` callback function attribute for a string field:

**Simple Tombstone Panel XML Markup Example**

    <component name="categoryinfoPanel" extends="Panel" >
    
    <interface>
      <field id = "description" type = "string" onChange = "showdescription" />
    </interface>
    
    <script type="text/brightscript" >
    <![CDATA[
    
    sub init()
      m.top.panelSize = "medium"
      m.top.focusable = true
      m.top.hasNextPanel = true
    
      m.infolabel = m.top.findNode("infoLabel")
    end sub
    
    sub showdescription()
      m.infolabel.text = m.top.description
    end sub
    
    ]]>
    </script>
    
    <children>
    
    <Rectangle
      id = "infoRectangle"
      translation = "[0,40]"
      height = "420"
      width = "520"
      color = "0x00000099" >
    
      <Label
        id = "infoLabel"
        translation = "[15,15]"
        height = "595"
        width = "510"
        font = "font:MediumBoldSystemFont"   />
    
    </Rectangle>
    
    </children>
    
    </component>

So when a user focuses on an item in the `m.categoriespanel` component list, the `showcategoryinfo()` callback function triggered by the `itemFocused` field change targets the `m.categoryinfopanel` panel object with content for that item, and creates an `examplesGridPanel` component object, a full width **GridPanel** node panel to the right. Because the `m.examplespanel` panel object is created using `createObject()`, but not yet added to the panel set, the panels do not slide. The sliding is performed by the `focusedChild` field observer callback function `slideexamplesgridpanel()` when focus moves to the `m.categoryinfopanel` panel object in automatic response to user **Right**, **Left**, and **Back** key presses. The callback function moves the focus to either the left-hand `m.categoriespanel` panel object, or the full width right-hand `m.examplespanel` object, depending on the direction of the key press indicated by the panel set `isGoingBack` field, automatically sliding the panels in response to the focus change.

The full width `examplesGridPanel` component was defined as follows, setting the `isFullScreen` field to true to automatically slide the panel when added to the panel set and focused:

**Full Width Panel XML Markup Example**

    <component name="examplesGridPanel" extends="GridPanel" >
    
    <interface>
      <field id = "overhangtext" type = "string" />
      <field id = "gridcontenturi" type = "string" onChange = "readpostergrid" />
    </interface>
    
    <script type="text/brightscript" >
    <![CDATA[
    
    sub init()
      m.top.panelSize = "full"
      m.top.isFullScreen = true
      m.top.focusable = true
      m.top.hasNextPanel = false
      m.top.createNextPanelOnItemFocus = false
      m.top.optionsAvailable = true
      m.top.grid = m.top.findNode("examplesPosterGrid")
    end sub
    
    sub readpostergrid()
      m.readPosterGridTask = createObject("roSGNode","postergridCR")
      m.readPosterGridTask.postergriduri = m.top.gridcontenturi
      m.readPosterGridTask.observeField("postergridcontent","showpostergrid")
      m.readPosterGridTask.control = "RUN"
    end sub
    
    sub showpostergrid()
      m.top.grid.content = m.readPosterGridTask.postergridcontent
      m.top.overhangTitle = m.top.overhangtext
    end sub
    
    ]]>
    </script>
    
    <children>
    
    <PosterGrid
      id = "examplesPosterGrid"
      basePosterSize = "[520,296]"
      caption1NumLines = "1"
      numColumns = "2"
      numRows = "5"
      itemSpacing = "[15,15]" />
    
    </children>
    
    </component>

Enhanced Subscription Recovery
==============================

When payment for a subscription auto-renewal fails, Roku's Enhanced Subscription Recovery feature (formerly referred to as "Passive Subscription on Hold" or "Subscription on Hold") notifies the customer on-device and via email to update their method of payment (MOP) on file for 60 days. This helps the publisher improve the chance of recovering payments and thereby reduce passive cancelations.

> All apps offering subscriptions must implement Enhanced Subscription Recovery to pass [certification](/docs/developer-program/roku-pay/roku-pay-requirements.md#rp-4-authentication-and-entitlement-requirements).

Overview
--------

The auto-renewal of a customer's subscription may fail because of out-of-date payment information, insufficient funds, temporary account holds, fraudulent activity, or other reasons. When this occurs, the customer is given a 3-day grace period where they can continue accessing content, while Roku Pay notifies them daily via email to update their method of payment (MOP). Once the 3-day grace period expires, the subscription is placed on hold for a maximum of 57 days. When a subscription is on hold, customers may no longer access content, and they are notified on the Roku home screen, upon app launch, in-app, and via email to update their MOP.

When a subscription is in the grace period or on hold, the publisher displays an in-app renewal dialog when customers select a content item. The dialog prompts the customer to update their MOP, while either granting access to content if the subscription is in grace or blocking access if it is on hold.

If Roku receives a payment, it is processed and entitlement is automatically granted again, and the billing period either remains the same (if the account is recovered during the grace period) or adjusts to the date that the payment was collected (if the account is recovered while on hold). If no payment is received by the end of the 60-day notification cycle, the subscription is canceled.

Integration steps
-----------------

To integrate Enhanced Subscription recovery in your app, you must complete the following app and backend updates:

**App updates required**

1.  [Enable Enhanced Subscription Recovery](#enabling-enhanced-subscription-recovery) for your **beta app** in the Developer Dashboard for testing the integration.
2.  [Perform entitlement checks using the Roku Pay APIs](#entitlement-checks) to check whether a subscription is current, in recovery (in 3-day grace period), on hold, or canceled.
3.  [Implement the ChannelStore DoRecovery API](#dorecovery-api) to display the Roku Pay subscription renewal dialog in your app when a customer selects content, navigates to or lands on a specific screen, or upon other specific interactions. This dialog notifies customers to update their MOP when auto-renewal fails..
4.  [Test your Enhanced Subscription Recovery integration](#subscription-recovery-testing).

**Backend updates required**

5.  [Ingest and process additional push notifications](#push-notifications) sent by Roku Pay as the subscription recovery state changes from in-grace, on-hold, and recovered.

**App publishing and enabling enhanced recovery**

6.  Once you have successfully completed and tested the Enhanced Subscription Recovery integration, you can [publish the updated **public** version of your app](/docs/developer-program/publishing/channel-publishing-guide.md#updating-an-existing-channel), and then [Enable Enhanced Subscription Recovery](#subscription-recovery-settings) for it.

### Enabling enhanced subscription recovery

Use the [**Subscription recovery** page](/docs/developer-program/roku-pay/subscription-recovery/settings.md) in the Developer Dashboard to enable Enhanced Subscription Recovery for your app.

*   **Beta app**: Before starting the integration work, enable enhanced subscription recovery for the **beta** version of your app . This enables you to verify that your app and backend are getting the current state of subscriptions and providing the correct user experience based on the state.
*   **Public app**: Once you have completed and tested the Enhanced Subscription Recovery integration, you can [publish the updated **production** version of your app](/docs/developer-program/publishing/channel-publishing-guide.md#updating-an-existing-channel). Once your updated production app has been published, enable the enhanced recovery solution for it.

> Do not enable Enhanced Subscription Recovery for your public app until you have completed, tested, and verified the integration steps. If this feature is not implemented correctly, customers will be unable to purchase a subscription for your app until the on-hold period has elapsed.

For more information on enabling Enhanced Subscription Recovery for your app, see [Subscription recovery settings](/docs/developer-program/roku-pay/subscription-recovery/settings.md).

### Entitlement checks

You must use the Roku Pay APIs to check whether a subscription is current, in recovery (in 3-day grace period), on hold, or canceled. The [ChannelStore API](/docs/references/scenegraph/control-nodes/channelstore.md#getallpurchases) is used to check the subscription status client-side upon app launch and then block access to content based on the results; the [Roku Pay web service APIs](/docs/developer-program/roku-pay/implementation/roku-web-service.md) are used server-side for regular nightly syncs to update the publisher's entitlement service.

> When payment is recovered for a subscription that is in-grace or on-hold, check the entitlement status of the subscription upon receiving and processing the recovery event and entitle the customer.

#### ChannelStore API

When customers launch an app, the app calls the ChannelStore [getAllPurchases](/docs/references/scenegraph/control-nodes/channelstore.md#getallpurchases) API, as part of the required on-device authentication, to determine whether to block access to content. The [getAllPurchases](/docs/references/scenegraph/control-nodes/channelstore.md#getallpurchases) API returns an **inDunning** flag that is used along with the **status** field to get the status of a subscription:

| Subscription state | **"inDunning"** | **"status"** |
| --- | --- | --- |
| Current | false | Valid |
| In recovery (in 3-day grace period) | true | Valid |
| On Hold | true | Invalid |
| Canceled | false | Invalid |

#### Roku Pay web service APIs

You should routinely synchronize your entitlement service with the Roku Pay web services to make sure your system has up-to-date entitlement data (this also provides a backup in case your backend system occasionally does not receive or process a batch of push notifications sent by Roku). Call the [validate-transaction API](/docs/developer-program/roku-pay/implementation/roku-web-service.md#managing-subscription-recovery) as part of a nightly batch routine to get the updated status of your customers' subscriptions. This API returns an **isEntitled** flag that is used along with the **expirationDate** field and **cancelled** flag to get the status of a subscription:

| Subscription state | **"isEntitled"** | **"expirationDate"** | **"cancelled"** |
| --- | --- | --- | --- |
| Current | true | future date | false |
| In recovery (in 3-day grace period) | true | current or past date | false |
| On Hold | false | current or past date | false |
| Canceled | false | past date | true |
| Canceled - pending **(subscription canceled during current term)** | true | future date | true |

> **Free trials:** When a free trial ends and the customer's method of payment fails, the `is_entitled` flag is set to "false" and the subscription is automatically placed on hold.

### DoRecovery API

You must use the ChannelStore [DoRecovery API](#dorecovery-api) to display the Roku Pay subscription renewal dialog in your app when customers select content, navigate to or land on a specific screen, or upon other specific interactions. This API lets developers configure the last option in the in-app subscription renewal dialog to either "Continue Watching" (if the subscription is in grace) or "Close" (if the subscription is on hold; this is the default and it closes the dialog and returns the customer to the previous screen).

The ChannelStore DoRecovery API uses Roku's Streaming Store generic request framework, which enables developers to pass the ChannelStore command, parameters, and context into a single **request** object (an associative array). The result of the request is encapsulated in a **requestStatus** object (also an associative array), which includes the status of the request and the data returned by it.

This API is available for both SceneGraph (SDK 2) and BrightScript (SDK 1).

This reference summarizes the **request** and **requestStatus** fields used by the DoRecovery API.

#### request

FieldTypeDescriptionrequestassociative arrayIncludes the request's command and context.FieldTypeDescriptioncommandstringSet to "DoRecovery"contextassociative arrayUsed to match the **requestStatus** with **request**. For example, you can set this to {"id: DoRecovery\_1"}.paramsassociative arrayOptional. Used to configure the in-app Roku Pay subscription renewal dialog. If this parameter is not included, the in-app Roku Pay subscription renewal dialog does not allow customers to watch content while their subscription is in recovery.

| Field | Type | Description |
| --- | --- | --- |
| recoveryContext | string | This may be set to the following value:  <br>  <br>"playback": Sets the last option in the Roku Pay subscription renewal dialog to "Continue Watching". This lets customers continue watching content while their subscription is in recovery. |

#### requestStatus

FieldTypeDescriptionrequestStatusassociative arrayIncludes the status of the DoRecovery command and the recovery status data returned by it.FieldTypeDescriptionresultassociative arrayContains the following key-value pairs for the recovery status of the subscription:

| Field | Type | Description |
| --- | --- | --- |
| recoveryStatus | integer | *   **3**. A subscription, which was in recovery (Roku was attempting to charge their method of payment over a period of days), has been canceled by the user. As a result, the subscription is no longer valid.<br>*   **2**. One or more subscriptions are still in recovery.<br>*   **1**. No subscriptions are in recovery. |
| recoveryProducts | array of strings | List of product codes associated with subscriptions for which payments are still attempting to be recovered. |

statusenumThe command completion status, which may be one of the following values:

*   **2** Interrupted
*   **1** Success
*   **0** Network error
*   **\-1** HTTP Error/Timeout
*   **\-2** Timeout
*   **\-3** Unknown Error
*   **\-4** Invalid request

statusMessagestringA text description of the command completion status.commandstringThe command passed into the request, which is "DoRecovery".contextassociative arrayThe context passed into the request (for example, {id: "DoRecovery\_1"}).

#### SceneGraph (SDK 2) example

The following code demonstrates how to use the ChannelStore node (SDK 2) to display the Roku Pay subscription renewal dialog and configure it so it blocks access to content:

    function DoRecovery()
        request = {}
        request.command = "DoRecovery"
        m.store = CreateObject("roSGNode", "ChannelStore")
        m.store.observeField("requestStatus", "onRequestStatus")
        m.store.request = request
    end function
    
    function onRequestStatus()
        print "onRequestStatus"
        requestStatus = m.store.requestStatus
        if requestStatus = Invalid
            print "Invalid requestStatus"
            print "DoRecovery failed"
        else if requestStatus.status <> 1
            print "DoRecovery failed: status:", requestStatus.status
        else
            print "command", requestStatus.command
            print "requestStatus.statusMessage", requestStatus.statusMessage
            print "requestStatus.result.recoveryStatus", requestStatus.result.recoveryStatus
            for each product in requestStatus.result.recoveryProducts
                print "productInRecovery:", product
            end for
       end if
    end function
    

#### BrightScript (SDK 1) example

The following code demonstrates how to use the roChannelStore node (SDK 1) to display the Roku Pay subscription renewal dialog and block access to content. A **DoRequest()** method, which takes the **request** object, is required for sending the DoRecovery request.

    function DoRecovery() as void
        request = {}
        request.command = "DoRecovery"
        m.store = CreateObject("roChannelStore")
        m.port = CreateObject("roMessagePort")
        m.store.SetMessagePort(m.port)
        if FindMemberFunction(m.store, "DoRequest") <> invalid then
            m.store.DoRequest(request)
        else
            m.top.requestStatus = Invalid
            return
        end if
        while true
            msg = wait(0, m.port)
            if type(msg) = "roChannelStoreEvent" then
                command = msg.GetCommand()
                status = msg.GetStatus()
                statusMessage = msg.GetStatusMessage()
                context = msg.GetContext()
                if context <> Invalid then
                    print "Received roChannelStoreEvent:"
                    print "- command:", command
                    print "- status:", status
                    print "- statusMessage:", statusMessage
                    print "- context:", context
                    if msg.isRequestSucceeded()
                        result = msg.GetResponse()
                        print "- result", result
                    else if msg.isRequestFailed()
                        print "***** Failure: " + msg.GetStatusMessage() + " Status Code: " + stri(msg.GetStatus()) + " *****"
                    end if
                end if
                exit while
            end if
        exit while
    end function
    

### Subscription recovery testing

Use the **subscription-recovery** test API to manually force subscriptions into different states (active, in-grace period, on-hold, passively canceled, and recovered), which helps expedite the testing of your [subscription recovery](/docs/developer-program/roku-pay/subscription-recovery/subscription-on-hold.md) integration.

For more information: [Subscription recovery testing](/docs/developer-program/roku-pay/subscription-recovery/testing.md)

### Push notifications

You must ingest and process the following additonal [push notifications](/docs/developer-program/roku-pay/implementation/push-notifications.md) sent by Roku Pay as the subscription recovery state changes:

| Message | Description |
| --- | --- |
| GraceInitiated | Payment for a subscription auto-renewal fails. Customer may still access content while Roku attempts to charge the MOP. |
| GraceRecovered | Payment is received for a subscription that was in a grace period. Customer maintains access to content and the billing period remains the same. |
| OnHoldInitiated | Payment for a subscription auto-renewal fails after the grace period elapses. Customer should no longer have access to content while Roku continues to attempt to charge the MOP. |
| OnHoldRecovered Sale | Payment is received for a subscription that was on-hold. Customer is granted access to content automatically and the billing period is adjusted to the time that the payment was collected. |

#### GraceInitiated

    {
        "customerId": "9aa37bd6f970578294cea4783af08560",
        "transactionType": "GraceInitiated",
        "transactionId": "024d4e1f-c7b6-11ee-afbe-0a58a9feaca8",
        "channelId": "3605562",
        "productCode": "0fCsu09EGS5C6OHlEUnz_MonthlySub",
        "productName": "0fCsu09EGS5C6OHlEUnz_MonthlySub",
        "originalTransactionId": "024d4e1f-c7b6-11ee-afbe-0a58a9feaca8",
        "originalPurchaseDate": "2024-01-12T01:45:36Z",
        "eventDate": "2024-02-10T01:45:39Z",
        "expirationDate": "2024-02-10T01:45:36Z",
        "comments": "Subscription is in dunning state",
        "responseKey": "163792dbc7b611eeafbe0a58a9feaca8",
        "isFreeTrial": false
    }
    

#### GraceRecovered

    {
        "customerId": "9d425957549250dcba71e03dacf426b5",
        "transactionType": "GraceRecovered",
        "transactionId": "f0864331-c7b6-11ee-a3c4-0a58a9fead9c",
        "channelId": "3193830",
        "productCode": "PPfCfuZMf3TOXBBl3Ttu_MonthlySub",
        "productName": "PPfCfuZMf3TOXBBl3Ttu_MonthlySub",
        "originalTransactionId": "d4c4da85-c7b6-11ee-a3c4-0a58a9fead9c",
        "originalPurchaseDate": "2024-01-12T01:51:39Z",
        "eventDate": "2024-02-10T01:51:46Z",
        "expirationDate": "2024-03-10T01:51:39Z",  
        "comments": "Subscription recovered from dunning state.",
        "responseKey": "d915ab762a3752e7bf112e7903958f52",
        "isFreeTrial": false
    }
    

#### OnHoldInitiated

    {
        "customerId": "8446ceff30e952349bcd9d3b78bc94a0",
        "transactionType": "OnHoldInitiated",
        "transactionId": "ed0ca6b7348411ed84a30a58a9feaec5",
        "channelId": "1688604",
        "productCode": "VR8IqPLBJ7VeWD7bvIHH_MonthlySub",
        "productName": "VR8IqPLBJ7VeWD7bvIHH_MonthlySub",
        "originalTransactionId": "df10f029-3484-11ed-b4bf-0a58a9feacbc",
        "originalPurchaseDate": "2022-08-14T23:28:23Z",
        "eventDate": "2022-09-14T23:28:24Z",
        "expirationDate": "2022-09-13T23:28:23Z",
        "comments": "Subscription is in Passive OnHold state",
        "responseKey": "ed0ca6b7348411ed84a30a58a9feaec5",
        "isFreeTrial": false
    }
    

#### OnHoldRecovered

    {
        "customerId": "8446ceff30e952349bcd9d3b78bc94a0",
        "transactionType": "OnHoldRecovered",
        "transactionId": "b466213697aa59a4ac53804daa1272bc",
        "channelId": "1688604",
        "productCode": "VR8IqPLBJ7VeWD7bvIHH_MonthlySub",
        "productName": "VR8IqPLBJ7VeWD7bvIHH_MonthlySub",
        "originalTransactionId": "df10f029-3484-11ed-b4bf-0a58a9feacbc",
        "originalPurchaseDate": "2022-08-14T23:28:23Z",
        "eventDate": "2022-09-14T23:28:29Z",
        "expirationDate": "2022-10-14T23:28:09Z",
        "comments": "Subscription recovered from Passive OnHold state.",
        "responseKey": "b466213697aa59a4ac53804daa1272bc",
        "isFreeTrial": false
    }
    

Appendix A: Rokuprovided renewal notifications
----------------------------------------------

Each of the on-device and email renewal notifications that Roku automatically sends to customers while their subscription is in recovery is as follows:

*   **Roku home screen renewal notifications**. By default, Roku automatically presents a heads-up display on the Roku home screen. It informs the customer that their subscription could not be renewed and prompts them to either update their MOP or be reminded to do so later.
    
    ![roku600px on-hold-hud](https://image.roku.com/ZHZscHItMTc2/on-hold-hud.png)
    

*   **App launch renewal notifications**. When the customer launches the app (via tile, Roku Search, or Roku Voice), Roku by default automatically displays a dialog once a day that gives the customer the option to update their MOP, cancel their subscription, or continue launching the app.
    
    ![roku600px - channel-launch-notification](https://image.roku.com/ZHZscHItMTc2/channel-launch-notification.png)
    

*   **Email renewal notification**. Roku sends email notifications prompting the customer to update their MOP or manage their subscription online at [my.roku.com](http://my.roku.com/). The following images demonstrate the emails customers receive when Roku is trying to recover their subscriptions.
    
    ![roku600px - recovery-email](https://image.roku.com/ZHZscHItMTc2/recovery-email.png)
    
    ![roku600px - recovery-email-last](https://image.roku.com/ZHZscHItMTc2/recovery-email-last.png)
    

![roku600px - recovery-email-cancellation](https://image.roku.com/ZHZscHItMTc2/recovery-email-cancellation.png)

LabelBase
=========

Extends [**Group**](/docs/references/scenegraph/layout-group-nodes/group.md)

The LabelBase node is an abstract base class for the [**Label**](/docs/references/scenegraph/label-nodes/label.md) and [**MultiStyleLabel**](/docs/references/scenegraph/label-nodes/multi-style-label.md) nodes. The Label node is used to display a string of text with a single style; the MultiStyleLabel node is used display a string of text with mixed styles (for example, plain and bold text, different fonts, and/or multiple colors). The LabelBase node provides the dimensions, text alignment, wrapping, auto-truncating, and other common functionality for its child nodes.

> The LabelBase node was introduced in Roku OS 10.5 to provide a single base class for the Label node and the new MultiStyleLabel node, which was added as part of the Roku OS 10.5 release. The Label node now inherits most of its functionality from LabelBase node class. Developers, however, do not need to update their app code to account for this refactoring.

### Text Alignment

The LabelBase node uses the horizAlign and vertAlign fields to allow you to position the rendered text relative to a specified bounding rectangle.

#### Horizontal Alignment

The horizAlign field allows you to position text horizontally relative to the computed width of the label. The computed width is determined in one of two ways:

*   If the width field is greater than zero, the computed width is the value of the width field.
*   If the width field is equal to zero, the computed width is the rendered width of the text.

There are three possible values for the horizAlign field:

*   left The left edge of the text is drawn at the 0 x-coordinate position of the LabelBase node local coordinate system.
    
*   center The horizontal center of each line of text is positioned at the x-coordinate corresponding to half the computed width of the LabelBase node local coordinate system.
    
*   right The right edge of each line of text is positioned at x-coordinate position corresponding to the computed width of the LabelBase node local coordinate system.
    

> If the width field is equal to zero, a single line of text will be rendered (see [Wrapping](/docs/references/scenegraph/label-nodes/label-base.md#wrapping-text "Wrapping") for more details). In that case, all three values of the horizAlign field have the same result, since the computed width equals the rendered width of the text.

#### Vertical Alignment

The vertAlign field allows you to position text vertically relative to the computed height of the label. The computed height is determined in one of four ways, which in some cases depend on the values set in the numLines and maxLines fields:

*   If the height field is greater than zero, the computed height is the value of the height field. In this case, the numLines and maxLines field values are ignored.
    
*   If the height field is zero and the numLines field is greater than zero, the computed height is the height required to render the number of lines specified by the numLines field value. Note that the computed height is set to the height required to render the number of lines even if the rendered text contains fewer lines. For example, if the numLines field value is 4, and the rendered text only occupies two lines, the computed height is still equal to the height required to render four lines. In this case, the value of the maxLines field is ignored.
    
*   If both the height and numLines field values are set to zero, and the maxLines field value is greater than zero, the rendered text will be limited to the number of lines set in the maxLines field value. In this case, the computed height is the height of the rendered text, but that text will be limited to no more than the number of lines set in the maxLines field value. For example, if the maxLines field value is 3, and the rendered text only occupies two lines, the computed height is the height required to render two lines of text. If the maxLines field value is 3, and the rendered text would occupy five lines, only three lines are drawn, and the computed height is the height required to render those three lines.
    
*   If the height, numLines and maxLines field values are all zero, the computed height is the height of the rendered text.
    

There are three possible values for the vertAlign field:

*   top The top edge of the text is drawn at 0 y-coordinate position of the LabelBase node local coordinate system.
    
*   center The vertical center of the rendered text is positioned at y-coordinate position corresponding to half the computed height of the LabelBase node local coordinate system.
    
*   bottom The text is drawn so that bottom edge of the rendered text is positioned at the y-coordinate position corresponding to the computed height of the LabelBase node local coordinate system.
    

Note that if the computed height equals the actual height of the rendered text (such as when the height and numLines field values are both zero), all three values of the vertAlign field have the same result, since the computed height equals the rendered height of the text.

#### Text Alignment Example

The following image shows a Rectangle node with a width of 1000 pixels and a height of 500 pixels. The Rectangle node has nine Label child nodes. Each Label child node has its width field value set to 1000 and its height field value set to 500. All nine combinations of the horizAlign and vertAlign fields are used to position the labels relative to the 1000x500 bounding rectangle.

![roku815px - TextAlign](https://image.roku.com/ZHZscHItMTc2/TextAlign.png "TextAlign")

### Wrapping Text

The wrap field is used to control how the text is broken into multiple lines. The two possible field values are true and false.

**wrap = false**

In this case, a single line of text will be displayed.

If the width field value is zero, and the text does not contain any newline characters, the entire text string is rendered. If the text contains newline characters, the part of the text up to the first newline character is rendered.

If the width field value is greater than zero, the text is truncated or ellipsized so only the portion of text is rendered that fits within the specified width.

**wrap = true**

In this case, if the width field value is greater than zero, the text is broken into several lines, each of which has width no larger than the computed width. Each newline character in the text results in a new line of text. Also, the text is broken into lines at any space or hyphen character. If any word in the text exceeds the computed width, it is broken into lines arbitrarily.

If the width field value is zero and the wrap field value is true, no text is rendered.

The actual numbers of lines displayed is dependent upon the values set in the height, numLines and maxLines fields.

If the height field value is greater than zero, the text is broken into lines based on the value of the width field, but only the number of lines that fit into the specified height are rendered. If the displayPartialLines field value is set to false (the default), only full lines of text are rendered. If the displayPartialLines field value is true, the top or bottom line of text may be clipped vertically.

If the height field value is zero, and the numLines field value is greater than zero, the text is broken into lines based on the value of the width field, and up to the number of lines of text set in the numLines field value are rendered.

If both the height and numLines field values are zero, and the maxLines field value is greater than zero, the text is broken into lines based on the value of the width field, and no more than the number of lines of text set in the maxLines field value are rendered.

### Rotation of Labels

Rotation of LabelBase nodes is supported. On platforms that do not support OpenGL, only rotations of 0, 90, 180, and 270 degrees are supported.

Fields
------

Fields derived from the [Group](/docs/references/scenegraph/layout-group-nodes/group.md#fields) base class can also be used.

| Field | Type | Default | Access Permission | Description |
| --- | --- | --- | --- | --- |
| text | string |     | READ\_WRITE | Specifies the text to be displayed |
| color | color | 0xddddddff | READ\_WRITE | Specifies the text color |
| font | Font | system default | READ\_WRITE | Specifies the Font node to be used |
| monospacedDigits  <br>  <br>_Available since Roku OS 14.0_ | Boolean | false | READ\_WRITE | Renders numeric values using tabular (fixed-width) fonts. |
| horizAlign | string | left | READ\_WRITE | See [Horizontal Alignment](/docs/references/scenegraph/typographic-nodes/scrollinglabel.md#alignment "Vertical Alignment") |
| vertAlign | string | top | READ\_WRITE | See [Vertical Alignment](/docs/references/scenegraph/label-nodes/label-base.md#wrapping-text "Wrapping") |
| width | float | 0   | READ\_WRITE | Specifies the width of the label. If set to zero, the text is always displayed as a single line |
| height | float | 0   | READ\_WRITE | Specifies the height of the label. If set to zero, the actual height is determined by the value of the numLines field if it is greater than zero. See [Vertical Alignment](/docs/references/scenegraph/typographic-nodes/scrollinglabel.md#alignment "Vertical Alignment") and [Wrapping](/docs/references/scenegraph/label-nodes/label-base.md#wrapping-text "Wrapping") for more details. |
| numLines | integer | 0   | READ\_WRITE | If the height field value is zero, provides an alternate way to specify the height of the bounding rectangle of the label. See [Vertical Alignment](/docs/references/scenegraph/typographic-nodes/scrollinglabel.md#alignment "Vertical Alignment") and [Wrapping](/docs/references/scenegraph/label-nodes/label-base.md#wrapping-text "Wrapping") for more details. |
| maxLines | integer | 0   | READ\_WRITE | If the height and numLines field values are both zero, specifies the maximum number of lines of text to be displayed. See [Vertical Alignment](/docs/references/scenegraph/typographic-nodes/scrollinglabel.md#alignment "Vertical Alignment") and [Wrapping](/docs/references/scenegraph/label-nodes/label-base.md#wrapping-text "Wrapping") for more details. |
| wrap | boolean | false | READ\_WRITE | See [Horizontal Alignment](/docs/references/scenegraph/typographic-nodes/scrollinglabel.md#alignment "Horizontal Alignment") |
| displayPartialLines | Boolean | false | READ\_WRITE | If the height field value is greater than zero, used to determine whether or not the last line of visible text is displayed if it would be clipped vertically. |
| ellipsizeOnBoundary | Boolean | false | READ\_WRITE | If the width field value is greater than zero, controls whether or not the last line of text displayed should be ellipsized if it extends beyond the specified width. It is ignored if the truncateOnDelimiter field value is set to a non-empty string<br><br>*   When set to true, text will be ellipsized by whole words. Example: "This is the last line of..."<br>*   When set to false, text will be ellipsized by characters. Example: "This is the last line of tex..." |
| wordBreakChars | string |     | READ\_WRITE | By default, space and hyphen characters are used to determine where lines can be divided. In addition, this field can specify additional characters to be used to determine where the text can be broken into lines |
| ellipsisText | string |     | READ\_WRITE | By default, three dots (...) are used to ellipsize the last line of text that extends beyond the bounding rectangle. This field specifies alternate characters to be displayed when the last line of text is ellipsized |
| isTextEllipsized | Boolean | false | READ\_ONLY | Indicates whether the last line of text has been ellipsized |

Poster
======

Extends [**Group**](/docs/references/scenegraph/layout-group-nodes/group.md)

The Poster node class draws an image with the top/left corner located at the origin of the node local coordinate system. Because the Poster node class extends the Group node class, a Poster node can have child nodes. For example, a Poster node might have a Label node as a child that draws an annotation on top of the poster.

The Poster node class supports JPEG, PNG and (since Roku OS 9.4) [WebP](https://developers.google.com/speed/webp/) image files. Please observe [Special WebP considerations](/docs/specs/media/streaming-specifications.md#special-webp-considerations) when using the latter.

The Poster node class includes the capability to automatically scale graphical images to different sizes as they are loaded, by setting the loadWidth and loadHeight field values. After the graphical images are loaded, the images can be scaled to fit within the target screen element area specified by the width and height field values. To use this capability, select the scaling option you want as the value of the loadDisplayMode field.

See SceneGraph's [Texture Memory](/docs/developer-program/performance-guide/memory-management.md#texture-memory "Texture Memory") feature for more information.

> In order for the load scaling options to work, the option fields must be set in XML markup before the uri field

### Best Practice when using this node

*   Avoid loading either very large images (larger than the target screen dimensions), or very small images, with the intent of the Roku OS scaling to a certain design intention. These can cause an unsatisfactory appearance, or even application issues such as degraded performance.
    
*   For the best appearance and application performance load images either identical to, or close to, the intended target screen dimensions of the Poster node in your application design.
    
*   Set the dimensions of an image in your design by setting the Poster node width and height fields. If you do not set these fields, designs implemented in certain forms of XML markup may not render as intended, unless you use an explicit callback layout function triggered by the Poster node loadStatus field, to render the screen element after the image has loaded and the dimensions are known.
    

### Example

The following example is a poster image placed using Poster node:

![roku815px - poster-node-sample](https://image.roku.com/ZHZscHItMTc2/poster-node-sample.png "poster-node-sample")

The following displays a graphic image from the application images directory near the top left of the display screen.

    <?xml version="1.0" encoding="utf-8" ?>
    
    <!--********** Copyright 2015 Roku Corp.  All Rights Reserved. **********-->
    
    <component name="postertest" extends="Group" >
    
    <script type="text/brightscript" >
    <![CDATA[
    
    sub init()
      m.top.setFocus(true)
    end sub
    
    ]]>
    </script>
    
    <Poster
      id="testPoster"
      uri="pkg:/images/rokuowds.png"
      width="0.0"
      height="0.0"
      translation="[160,8]" />
    
    </component>
    

### Autoscaling

When autoscaling between FHD/HD, there may be cases where using images with widths or heights that are not divisible by 2 (i.e. even numbers) do not work correctly.

### Rotation

Rotation of Posters is supported. On platforms that do not support OpenGL, only rotations of 0, 90, 180, and 270 degrees are supported.

Fields
------

[Fields](/docs/references/scenegraph/layout-group-nodes/group.md#fields "Fields") derived from the Group base class can also be used.

FieldTypeDefaultAccess PermissionDescriptionuristringREAD\_WRITESpecifies the URI of the image file. Images included as part of the application package can be referenced using the pkg:/images prefix. Images included as part of the application package that are to be localized can be referenced using the pkg:/locale/images/ prefix (see [Localizing Graphical Images in the Application Package](/docs/developer-program/core-concepts/localization.md#localizing-graphical-images-in-the-application-package "Localizing Graphical Images in the Application Package"))widthfloat0.0READ\_WRITESpecifies the width of the image in local coordinates. If set to 0.0, the width of the bitmap from the image file is used. If set to a value greater than 0.0, the bitmap is scaled to that widthheightfloat0.0READ\_WRITESpecifies the height of the image in local coordinates. If set to 0.0, the height of the bitmap from the image file is used. If set to a value greater than 0.0, the bitmap is scaled to that heightloadSyncBooleanfalseREAD\_WRITEControls whether the image is loaded synchronously in the render thread, and appears immediately, or loaded asynchronously in a background thread, and may not appear immediately. If set to true, and the uri field specifies a local file (in the pkg:/images directory), the image is loaded synchronously, and appears immediately. If set to false, or if the uri field specifies a file from a remote server (a URL starting with http: or https:), the image is loaded asynchronously in a background thread, and may not appear immediately. Be careful when setting this field to true, as it might cause brief glitches in the rendering while the image is being fetched and loadedloadWidthfloat0.0READ\_WRITEScale the graphical image to the specified width when loaded, preserving aspect ratio. If set to the default, no load-time scaling occurs. If the width field is not set, the loadWidth field is used as the default width of the displayed imageloadHeightfloat0.0READ\_WRITEScale the graphical image to the specified height when loaded, preserving aspect ratio. If set to the default, no load-time scaling occurs. If the height field is not set, the loadHeight field is used as the default height of the displayed imageloadDisplayModeoption stringnoScaleREAD\_WRITEProvides automatic scaling of graphical images after loading. If you intend to load very large graphical images, such as larger than the user interface resolution, you must set one of the scaling options other than noScale, otherwise the image may fail to load. The following are the possible field values:

| Option | Effect |
| --- | --- |
| limitSize | Scale the image while loading it into texture memory so that the maximum width and height in either dimension does not exceed the specified loadWidth or loadHeight values. If the image is smaller in both dimensions than the specified values, the image is loaded at its regular size. Aspect ratio is preserved. |
| noScale | The bitmap will be loaded at the image's original resolution. If the Poster's width and height differ from the bitmap's resolution, it will be scaled to fill the Poster's dimensions. Aspect ratio is not preserved. |
| scaleToFit | Scale the image to fit into the target screen element area, preserving the aspect ratio but "letterboxing" or "pillarboxing" the image (background-color bars at the top/bottom or left/right of the image).  <br><br>> This field in not supported on Liberty and Littlefield devices for images that are both scaled and rotated. On these devices, scaled and rotated images appear as if the **scaleToFill** property was applied to them. |
| scaleToFill | Stretch the image dimensions to fill the target screen element area, distorting the image if the target screen element area has a different aspect ratio than the image. |
| scaleToZoom | Scale the image to fill the target screen element area, preserving the aspect ratio but not "letterboxing" or "pillarboxing" the image, with some of the image cropped out. |

loadStatusvalue stringnoneREAD\_ONLYCan be used to track the progress of loading the graphical image file. A typical use of this field is to set an observer so that when the field value changes to ready, an action can be triggered. The possible values are:

| Value | Meaning |
| --- | --- |
| none | No loading or decoding of the graphical image file is taking place |
| loading | Graphical image file is being fetched and decoded |
| ready | Graphical image file has been fetched and decoded and is ready to be drawn |
| failed | Graphical image file could not be loaded for some reason, such as the uri field value is set to a non-existent file location |

bitmapWidthfloat0.0READ\_ONLYAfter the graphical image file is loaded, contains the width of the graphical image in pixelsbitmapHeightfloat0.0READ\_ONLYAfter the graphical image file is loaded, contains the height of the graphical image in pixelsbitmapMarginsassociative arrayinvalidREAD\_ONLYThis field is set to an associative array with four elements "left", "right", "top" and "bottom". If the Poster's bitmap is a 9-patch image, the associative array is set to margin info encoded along the right and bottom edges of the image. If the Poster's bitmap is not a 9-patch image, all values in the associative array are set to 0. The bitmapMargins field is set whenever the Poster's loadStatus field changes (e.g. when the bitmap has been loaded).blendColorcolor0xFFFFFFFFREAD\_WRITECan be used to tint the image by multiplying the color of each pixel by the specified value. If this value is not set to a value other than the default value, no color blending will be performedloadingBitmapUristringREAD\_WRITESpecifies a bitmap file to display while the poster image is loading.  
  
To execute a seamless cross-fade transition between posters, set the **loadingBitmapUri** of the next poster to be shown to the uri of the currently displayed poster.loadingBitmapOpacityfloat1.0READ\_WRITEUsed to control the rendering opacity of the graphical image that indicates a bitmap is loading. This value multiplies the Poster node opacityfailedBitmapUristringREAD\_WRITESpecifies a bitmap file to display when the poster image failed to loadfailedBitmapOpacityfloat1.0READ\_WRITEUsed to control the rendering opacity of the graphical image that indicates a bitmap failed to load. This value multiplies the Poster node opacityaudioGuideTextstringREAD\_WRITEIf muteAudioGuide is false, this string will be spoken when the poster is focused

Sample app
----------

[PosterExample](https://github.com/rokudev/samples/tree/master/ux%20components/screen%20elements/renderable%20nodes/PosterExample) is a sample app demonstrating Poster in action.

SimpleLabel
===========

Extends [**Group**](/docs/references/scenegraph/layout-group-nodes/group.md "**Group**")

The SimpleLabel node class is used to display a single line of text. SimpleLabel is a lightweight complement to the Label node. It supports simplified font style specification and is more memory efficient than the Label node.

The SimpleLabel node class supports:

*   Specifying either a built-in system font or a TrueType/OpenType font file
*   Specifying the color of the font
*   Customizable Horizontal and Vertical origin

The following shows a text layout derived from the SimpleLabel node:

![roku815px - simpleLabel node](https://image.roku.com/ZHZscHItMTc2/simplelabel.png "simplelabel")

With ui\_resolutions=hd specified in the manifest, the following displays the text string "Application Development Made Easy!" using the medium bold system font, centered horizontally on display, and with the baseline of the text at the vertical center of the display.

    <?xml version="1.0" encoding="utf-8" ?>
    
    <!--********** Copyright 2018 Roku Corp.  All Rights Reserved. **********-->
    
    <component name="simpleLabeltest" extends="Group" >
    
    <script type="text/brightscript" >
    <![CDATA[
    
      sub init()
        m.top.setFocus(true)
      end sub
    
    ]]>
    </script>
    
    <SimpleLabel
      id="testLabel"
      font="fontUri:MediumBoldSystemFont"
      text = "Application Development Made Easy!"
      horizOrigin = "left"
      vertOrigin = "baseline"
      translation="[640,360]" />
    
    </component>
    

### Text Origin

The SimpleLabel node uses the horizOrigin and vertOrigin fields to control the origin of the coordinate system for the node.

#### Horizontal Origin

The horizOrigin field allows controlling the x=0 position of the SimpleLabel node's local coordinate system.

There are three possible values for the horizOrigin field:

*   left The left edge of the text is located at the 0 x-coordinate position of the SimpleLabel node's local coordinate system
    
*   center The horizontal center of the text is positioned at the 0 x-coordinate position of the SimpleLabel node's local coordinate system
    
*   right The right edge of the text is positioned at the 0 x-coordinate position of the SimpleLabel node's local coordinate system
    

#### Vertical Origin

The vertOrigin field allows controlling the y=0 position of the SimpleLabel node's local coordinate system.

There are four possible values for the vertOrigin field:

*   top The top edge of the text is located at the 0 y-coordinate position of the SimpleLabel node's local coordinate system
    
*   center The vertical center of the text is located at the 0 y-coordinate position of the SimpleLabel node's local coordinate system
    
*   baseline The baseline of the text is located at the 0 y-coordinate position of the SimpleLabel node's local coordinate system
    
*   bottom The bottom edge of the text is located at the 0 y-coordinate position of the SimpleLabel node's local coordinate system
    

#### SimpleLabel Origin Example

The following image illustrates the horizontal and vertical origin options supported by the SimpleLabel node. The manifest includes ui\_resolutions=fhd, so all coordinate values are in the range 1920x1080.

*   On the top left, in the image below, a Group node is displayed that has a 1-pixel wide Rectangle node and three SimpleLabel nodes as children. The Group node's x-translation is set to 200, and the x translation of the Rectangle and all three SimpleLabel nodes is set to 0.
    
    *   The Rectangle serves as a visual reference of where x=0 is located in its parent Group's local coordinate system.
    *   The three SimpleLabel nodes illustrate each option for the horizOrigin field (i.e., SimpleLabel horizontal origin at the left edge, center, and right edge of the text).
*   In the bottom of the image, a Group node is displayed that has a 1-pixel tall Rectangle node and four SimpleLabel nodes as children.
    
    *   The Group node's y-translation is set to 480, and the y translation of the Rectangle and all four SimpleLabel nodes is set to 0.
    *   The Rectangle serves as a visual reference of where y=0 is located in its parent Group's local coordinate system.
    *   The four SimpleLabel nodes illustrate each option for the vertOrigin field (i.e., SimpleLabel vertical origin at the top edge, center, baseline, and bottom edge of the text).

![roku815px - simple_label_origin](https://image.roku.com/ZHZscHItMTc2/simpleLabelOriginExample.jpg "simplelabel origin example")

### Rotation

Rotation of SimpleLabel nodes is supported. The center of rotation is determined by the origin point as determined by the horizOrigin and vertOrigin fields. On platforms that do not support OpenGL, only rotations divisible by 90 are supported (e.g., 0, 90, 180, and 270 degrees). For those platforms, other values are rendered using the nearest 90-degree value (e.g., 103 degrees is rendered as a 90-degree rotation, -262 degrees is rendered as a -270 rotation).

Fields
------

FieldTypeDefaultDescriptiontextstring""Specifies the text to be displayedcolorcolor0xddddddffSpecifies the text colorfontUristringsystem defaultSpecifies either a path to a TrueType or OpenType font file or a built-in system font name.  
  
For TrueType or OpenType font files, the file must be included with the application (e.g. `pkg:/fonts/SomeFontFile.ttf`). If no fontUri is specified, the System Default font is used.  
  
The table below shows the options for using built-in system fonts. The "**Fixed Size?"** column indicates whether the `fontSize` field of the **SimpleLabel** is respected or not. For those where the size is fixed, the font size cannot be modified.

| fontUri String | Fixed Size? |
| --- | --- |
| `font:SmallestSystemFont` | Yes |
| `font:SmallSystemFont` | Yes |
| `font:MediumSystemFont` | Yes |
| `font:LargeSystemFont` | Yes |
| `font:SmallestBoldSystemFont` | Yes |
| `font:SmallBoldSystemFont` | Yes |
| `font:MediumBoldSystemFont` | Yes |
| `font:LargeBoldSystemFont` | Yes |
| `font:SystemFontFile` | No  |
| `font:BoldSystemFontFile` | No  |
| System Default (field not set) | Yes |

fontSizeintegersystem defaultSpecifies the size of the font in points. As noted in the description of the `fontUri` field, the use of fixed size system fonts ignores the value of the `fontSize` field.horizOriginstringleftSee [**Horizontal Origin**](/docs/references/scenegraph/renderable-nodes/simplelabel.md#SimpleLabel-HorizontalOrigin)vertOriginstringtopSee [**Vertical Origin**](/docs/references/scenegraph/renderable-nodes/simplelabel.md#SimpleLabel-VerticalOrigin)

The following [Fields](/docs/references/scenegraph/layout-group-nodes/group.md#fields "Fields") derived from the Group base class can also be used:

FieldTypeDefaultAccess PermissionDescriptionscaleRotateCentervector2d\[0.0,0.0\]READ\_WRITEDescribes the location of a point in the node local coordinate that serves as the center of the scale and rotation operationsvisibleBooleantrueREAD\_WRITEIf true, the node and its children are rendered. If false, the node and its children do not renderinheritParentOpacityBooleantrueREAD\_WRITEIf true, the node opacity is determined by multiplying opacity attribute of the node by the opacity of the parent node, which may have been determined by multiplying the opacity of its ancestor nodes. If false, the node opacity is determined by the opacity attribute set for the node or the default opacity attribute valuerotationfloat0.0READ\_WRITEDefines the rotation angle about the scaleRotateCenter point (in radians) of the node local coordinate system. Positive values specify a counterclockwise rotation, negative values specify a clockwise rotation. For some Roku Player hardware, specifically Roku Players without OpenGL graphics support, only rotations of 0, 90, 180 and 270 degrees (in equivalent radians) are supported. (See [Roku Models and Features](/docs/specs/hardware.md#current-models "Roku Models and Features") for information on OpenGL support)scalevector2d\[1.0,1.0\]READ\_WRITEDefines the scale factor to be applied to the node local coordinaterenderTrackingoption as stringdisabledREAD\_WRITErenderTracking is set to "disabled" when enableRenderTracking is set to false. The following options are only available when enableRenderTracking is set to true:

| Option | Description |
| --- | --- |
| `"none"` | renderTracking is set to `"none"` if **one or more** of these conditions is true:  <br>the node's `visible` field is set to `false`the node's `opacity` field is set to `0.0`no `clippingRect` is specified and the node is completely offscreena `clippingRect` is specified and the node lies completely outside that `clippingRect's` coordinates or is completely offscreen |
| `"partial"` | renderTracking is set to `"partial"` if **all** of the following conditions are true:  <br>the node's `visible` field is set to `true`the node's `opacity` field is greater than `0.0`no `clippingRect` is specified and the node is partially offscreena `clippingRect` is specified and the node lies partially inside the `clippingRect's` coordinates |
| `"full"` | renderTracking is set to `"full"` if **all** of the following conditions are true:  <br>the node's `visible` field is set to `true`the node's `opacity` field is greater than `0.0`no `clippingRect` is specified and the node is completely onscreena `clippingRect` is specified and the node lies completely inside the `clippingRect's` coordinates |

inheritParentTransformBooleantrueREAD\_WRITEIf true, the node overall transformation is determined by combining the accumulated transformation matrix of all of its ancestors in the SceneGraph with the node local 2D transformation matrix described by its translation, rotation, scale and scaleRotateCenter fields. If false, the accumulated transformation of all of its ancestors in the SceneGraph is ignored and only the node local transformation matrix is used. This causes the node to be transformed relative to the root of the SceneGraph (that is, the Scene component)renderPassinteger0READ\_WRITEUsed in combination with the numRenderPasses field of nodes extended from the [ArrayGrid](/docs/references/scenegraph/abstract-nodes/arraygrid.md "ArrayGrid") abstract node class, to optimize rendering of lists and grids. This should never be set to a non-zero value unless you are optimizing the performance of a list or grid rendering by specifying the sequence of rendering operations for sub-elements of the list or grid items, and have set the numRenderPasses field value for the list or grid to a value greater than 1. If the numRenderPasses field value for the list or grid is set to a value greater than 1, you must set this field to a value greater than 0 for all sub-elements of the list or grid items, and not greater than the numRenderPasses field value. If the numRenderPasses field is set to a value greater than 1, and you set this field for a list or grid item sub-element to 0 (the default), or a value greater than the numRenderPasses field value, the list or grid item sub-element will not renderchildRenderOrderoption as stringrenderLastREAD\_WRITE

| Option | Description |
| --- | --- |
| `"renderFirst"` | any drawing done by this node will be done **before** the node children are rendered |
| `"renderLast"` | any drawing done by this node will be done **after** the node children are rendered |

clippingRectarray of float\[ 0.0, 0.0, 0.0, 0.0 \]READ\_WRITESpecifies a rectangle in the node local coordinate system that is used to limit the region where this node and its children can render. If a non-empty rectangle is specified, then all drawing by this node and its children will be limited to that rectangular area.

*   `ClippingRects` can be specified by the node or by any of its ancestors in the SceneGraph.
*   `ClippingRects` are automatically set by some nodes such as lists and grids.
*   `ClippingRects` are always clipped to the screen boundaries, so if a `clippingRect` is specified that is partially or completely offscreen, it will be clipped to the screen boundaries. With respect to render tracking, although the node could be completely within the bounds of the specified `clippingRect`, it's `renderTracking` field could be set to `"none"` if the portion of the `clippingRect` it occupies is completely offscreen.

enableRenderTrackingBooleanfalseREAD\_WRITEIf true, renderTracking will be set to a string describing how much of the node is rendered on screentranslationvector2d\[0.0,0.0\]READ\_WRITEDefines the origin of the node local coordinate system relative to its parent nodeopacityfloat1.0READ\_WRITESets the opacity of the node and its children. Opacity is the opposite of transparency. Opacity values range from 0.0 (fully transparent) to 1.0 (fully opaque). As the SceneGraph is traversed, the opacity values are combined by multiplying the current accumulated opacity with the node opacity, so that if the accumulated opacity of a node ancestors is 0.25 (75% transparent), the node will have opacity of 0.25 or less. This allows entire branches of the SceneGraph to fade in and out by animating the opacity of the node at the root of the branchmuteAudioGuideBooleanfalseREAD\_WRITESet to true to suppress the default CVAA text to speech. This allows apps to provide their own custom implementation

Sample app
----------

[LabelExample](https://github.com/rokudev/samples/tree/master/ux%20components/screen%20elements/renderable%20nodes/LabelExample) is a sample app demonstrating Label in action.

ifArray
=======

Implemented by
--------------

| Name | Description |
| --- | --- |
| [roArray](/docs/references/brightscript/components/roarray.md "roArray") | An array stores an indexed collection of BrightScript objects. Each entry of an array can be a different type, or they may all of the same type |
| [roByteArray](/docs/references/brightscript/components/robytearray.md "roByteArray") | The byte array component is used to contain and manipulate an arbitrary array of bytes |
| [roList](/docs/references/brightscript/components/rolist.md "roList") | The list object implements the interfaces: ifList, ifArray, ifEnum and therefore can behave like an array that can dynamically add members |
| [roXMLList](/docs/references/brightscript/components/roxmllist.md "roXMLList") | Contains a list of roXML objects |

Supported methods
-----------------

### Peek() As Dynamic

#### Description

Returns the last (highest index) array entry without removing it. If the array is empty, returns invalid

#### Return Value

Invalid

### Pop() As Dynamic

#### Description

Returns the last entry (highest index) from the array and removes it from the array. If the array is empty, returns invalid and does not change the array.

#### Return Value

The last (highest index) array entry.

### Push(tvalue As Dynamic) As Void

#### Description

Adds the specified value to the end of the array.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| tvalue | Dynamic | The value to be added to the end of the array. |

### Shift() As Dynamic

#### Description

Removes the first entry (zero index) from the beginning of the array and shifts the other entries up. This method is similar to the [Pop method](#pushtvalue-as-dynamic-as-void), but removes the first entry in the array instead of the last one.

#### Return Value

The first entry (zero index) removed from the array.

### Unshift(tvalue As Dynamic) As Void

#### Description

Adds the specified value to the beginning of the array (at the zero index) and shifts the other entries down. This method is similar to the [Push method](#push-as-dynamic), but adds the new entry to the beginning of the array instead of to the end.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| tvalue | Dynamic | The value to be added to the beginning of the array. |

### Delete(index as Integer) As Boolean

#### Description

Deletes the indicated array entry, and shifts all entries up. This decreases the array length by one.

#### Parameters

#### Return Value

A flag indicating whether the specified array entry has been removed. If the entry was successfully deleted, returns true. If index is out of range, returns false and does not change the array.

### Count() As Integer

#### Description

Returns the length of the array, which is one more than the index of highest entry.

#### Return Value

The length of the array.

### Clear() As Void

#### Description

Deletes all the entries in the array.

### Append(array As Object) As Void

#### Description

Appends the entries in one **roArray** to another. If the passed array contains entries that have not been set to a value, they are not appended.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| array | Object | The **roArray** to be appended to the target array. |

ChannelStore
============

Extends [**Node**](/docs/references/scenegraph/node.md)

The **ChannelStore** node class provides an interface to the Streaming Store. It provides functionality equivalent to the [roChannelStore](/docs/references/brightscript/interfaces/ifchannelstore.md) component. In general, the **ChannelStore** node class allows developers to issue one of several commands, which involves the following steps:

1.  Set the fields containing the data needed by the command (optional).
2.  Set up an observer of the result field associated with the command.
3.  Set the command field to the appropriate string to start the command execution.
4.  The field associated with the command is set to a **ContentNode** object containing the results of the command.

Each of the commands starts a sequence of actions associated with the financial transaction that are handled by the Roku OS outside of control or monitoring by the app SceneGraph markup. The SceneGraph markup merely initiates the purchase and receives a final result.

Fields
------

### command

| Field | Type | Default | Access Permission | Description |
| --- | --- | --- | --- | --- |
| command | string |     | READ\_WRITE | Specifies the command to be executed:  <br><br>*   [getUserData](#getuserdata)<br>*   [getUserRegionData](#getuserregiondata) ()<br>*   [getCatalog](#getcatalog) and [getStoreCatalog](#getstorecatalog)<br>*   [doOrder](#doorder)<br>*   [getPurchases](#getpurchases) and [getAllPurchases](#getallpurchases)<br>*   [storeChannelCredData](#storechannelcreddata)<br>*   [getChannelCred](#getchannelcred)<br>*   [getDeviceAttestationToken](#getdeviceattestationtoken)<br>*   [requestPartnerOrder](#requestpartnerorder)<br>*   [confirmPartnerOrder](#confirmpartnerorder) |

### requestedUserData

| Field | Type | Default | Access Permission | Description |
| --- | --- | --- | --- | --- |
| requestedUserData | string | all | READ\_WRITE | Specifies the Roku customer account fields to be retrieved when the [**getUserData**](#getuserdata) command is executed.  <br>  <br>The default value is "all", which causes a ContentNode object to be returned from **getUserData** that includes all of the available Roku customer account information.  <br>  <br>To request specific Roku customer account information items (for example, an email address, first name, and last name) set this field to a string containing a comma-separated list of values (for example, "email, firstname, lastname"). The available values are as follows:  <br><br>*   email<br>*   phone<br>*   firstname<br>*   lastname<br>*   street<br>*   city<br>*   state<br>*   zip<br>*   country<br>*   birth<br>*   gender<br><br>  <br>In this case, the ContentNode object returned from the **getUserData** command includes the specified customer account information. |

### requestedUserDataInfo

FieldTypeDefaultAccess PermissionDescriptionrequestedUserDataInfoContentNodeinvalidREAD\_WRITESpecifies whether the RFI screen is used for customer sign-ups or sign-ins. This may be one of the following values:  

| Field | Type | Default | Description |
| --- | --- | --- | --- |
| context | string | "signup" | Specifies the context of the RFI screen, which may be one of the following values:  <br><br>*   "signup": The RFI screen displays a "Let's create your account" title and lists the customer information specified in the [**requestedUserData** field](#requesteduserdata). The RFI screen uses the "signup" context by default. See [Sign-up requirements and best practices](/docs/developer-program/roku-pay/signup-best-practices.md) for more information on implementing the app sign-up UI.<br>*   "signin: "The RFI screen displays a "Sign in" title and lists only email or phone attributes, if specified in the [**requestedUserData** field](#requesteduserdata). Other attributes are ignored, even if specified. See the [Sign-in example](#sign-in-example) for how to use this field. See [Sign-in requirements and best practices](/docs/developer-program/roku-pay/signin-best-practices.md) for more information on implementing the app sign-in UI. |
| forceShowData | Boolean | false | If true, the RFI signup screen displays the values of the requested customer information to be shared with the app (for example, Jone Doe, jon.doe@emailaddress.com).  <br>  <br>By default, this flag is set to false, which means that the default RFI screen for the region is used. For example, in the US, the RFI screen displays the type of customer information being requested (email address, name, and so on).  <br>  <br>This flag has no effect if the context field is set to "signin" (the RFI sign-in screen always displays the customer information values).  <br>  <br>**Example**:  <br><br>    store = CreateObject("roSGNode", "ChannelStore")<br>    <br>    ' Doesn't show user data in dialog unless necessary in the user's region.<br>    store.requestedUserData = "email,firstname,lastname,gender,birth"<br>    store.command = "getUserData"<br>    <br>    ' Shows user data in dialog.<br>    info = CreateObject("roSGNode", "ContentNode")<br>    info.addFields({forceShowData: true})<br>    store.requestedUserDataInfo = info<br>    store.requestedUserData = "email"<br>    store.command = "getUserData" |

#### Sign-up example

    store = CreateObject("roSGNode", "ChannelStore")
    
    ' Request several properties for sign-up
    store.requestedUserData = "email, phone, firstname, lastname"
    store.command = "getUserData"
    
    ' Store requested properties
     email = store.userdata.email
     firstname = m.store.userData.firstname
     lastname = m.store.userData.lastname
     phone = m.store.userData.phone
    

#### Sign-in example

    store = CreateObject("roSGNode", "ChannelStore")
    
    ' Set sign-in context for RFI screen
    info = CreateObject("roSGNode", "ContentNode")
    info.addFields({context: "signin"})
    store.requestedUserDataInfo = info
    
    ' Request user's email for sign-in
    store.requestedUserData = "email"
    store.command = "getUserData"
    
    ' Store requested properties
     email = store.userdata.email
    

### userData

| Field | Type | Default | Access Permission | Description |
| --- | --- | --- | --- | --- |
| userData | ContentNode | invalid | READ\_WRITE | Contains the results of a [**getUserData**](#getuserdata) command. The value stored in this field depends on whether the user clicks **Continue** or **Cancel** in the Request for Information (RFI) screen.  <br>  <br>If the user clicks **Continue**, this field is populated with the Roku customer account information that was requested in the [**requestedUserData**](#requesteduserdata) field.  <br>  <br>If the user clicks **Cancel**, this field is set to "invalid". |

### order

FieldTypeDefaultAccess PermissionDescriptionorderContentNodeinvalidREAD\_WRITEContains the order to be filled when the [**doOrder**](#doorder) command is executed. This ContentNode contains one child ContentNode for each of the items to be purchased. The child ContentNode must contain the following fields:  

| Field | Type | Description |
| --- | --- | --- |
| code | string | Identifies the product to be purchased, as entered in the **Product Identifier** field on the [In-App Product page in the Developer Dashboard](https://developer.roku.com/products) when the product was created. See [Creating an order](#creating-an-order) for more information. |
| qty | string | The quantity of the item to be purchased, which is typically 1 for most in-app products.  <br>  <br>This is only typically more than 1 if the product is a "packet" of identical items (such as game points, number of viewings permitted of some item of content, and so on). |
| action | string | **For upgrades/downgrades only**. Set this to "Upgrade" or "Downgrade" to change the subscription plan from a previous purchase (for example, `myOrder.action = "Upgrade"`). The required values are case-sensitive; do not pass "upgrade" or "downgrade". See [On-device upgrade and downgrade](/docs/developer-program/roku-pay/implementation/on-device-upgrade-downgrade.md) for more information. |

  
To clear an order, set the **order** field to "invalid".

#### Creating an order

To create an order, this field needs to be set to a ContentNode that has one child ContentNode for each item to be purchased. There are two approaches to setting the `order` field: setting it directly, or setting the `deltaOrder` field.

To set the `order` field directly, first create a ContentNode, then create one child ContentNode with the `"code"` and `"qty"` fields set for each item to be purchased. Assuming `m.channelStore` is a ChannelStore node object, the following Brightscript code shows how to do this:

    myOrder = CreateObject("roSGNode", "ContentNode")
    myFirstItem = myOrder.createChild("ContentNode")
    myFirstItem.addFields({ "code": "UPC2397", "qty": 1})
    mySecondItem = myOrder.createChild("ContentNode")
    mySecondItem.addField({ "code": "UPC4321", "qty": 1})
    m.channelStore.order = myOrder
    

The `order` field can be set indirectly as well, by setting the `deltaOrder` field to add or modify the desired quantity of an item. Assuming `m.channelStore` is a ChannelStore node object, the following results in the `order` field containing the same items as the previous example:

    m.channelStore.deltaOrder = { "code": "UPC2397", "qty": 1}
    m.channelStore.deltaOrder = { "code": "UPC4321", "qty": 1}
    

### deltaOrder

| Field | Type | Default | Access Permission | Description |
| --- | --- | --- | --- | --- |
| deltaOrder | associative array | {}  | WRITE\_ONLY | Enables the [**order**](#order) field to be populated incrementally. Each time this field is set, the **order** field is modified.  <br>  <br>The **deltaOrder** associative array should contain a "code" string that identifies an available item, and a "qty" integer value to indicate how the children of the order field **ContentNode** should be modified.  <br>  <br>For example, if the order is invalid, setting the deltaOrder field to the following associative array:  <br>  <br>  `{ "code": "Merchandise1", "qty": 1 }`  <br>  <br>Would cause an order field to be set to a **ContentNode**, with one child **ContentNode** with a "code" field set to "Merchandise1", and a "qty" field set to 1.  <br>  <br>If the deltaOrder field was then set to:  <br>  <br>  `{ "code": "MyItem2", "qty": 1 }`  <br>  <br>The order field **ContentNode** would have a second **ContentNode** child appended to it, with the specified "code" and "qty" field values.  <br>  <br>The "qty" field can be set to a negative value to remove an item from an order. For example, if the order field was set as above, and the deltaOrder field was set to:  <br>  <br>  `{ "code" MyItem2", "qty": -1 }`  <br>  <br>The order field **ContentNode** would have the second child **ContentNode** removed. |

#### requestPartnerOrder

> See [Creating TVOD apps](/docs/developer-program/roku-pay/implementation/tvod-channel.md) for how to use this field for transactional purchases.

FieldTypeDefaultAccess PermissionDescriptionrequestPartnerOrderContentNodeinvalidREAD\_WRITESpecifies the product to be ordered from a TVOD app. The order contains the following fields:  

| Field | Type | Description |
| --- | --- | --- |
| code | string | Identifies the product to be purchased, as entered in the **Product Identifier** field on the [In-App Product page in the Developer Dashboard](https://developer.roku.com/products) when the product was created. For TVOD-exclusive apps, a single in-app product may be used for all orders.  <br>  <br>A TVOD-exclusive app only has transactional products such as movie rentals; it does not offer any subscription products. |
| priceDisplay | string | The original price of the product. Do not include a currency symbol (for example, set this to "3.99" instead of "$3.99"). |
| price | string | The final price of the product, including any discounts. Do not include a currency symbol (for example, set this to "3.99" instead of "$3.99"). |
| title | string | A description of the product (for example, the name of a rental movie). |
| couponCode | string | An alphanumeric string entered by the customer to receive a discounted price on the product. |
| contentKey | string | The publisher-specific SKU (or other unique identifier) for the product. |

#### confirmPartnerOrder

> See [Creating TVOD apps](/docs/developer-program/roku-pay/implementation/tvod-channel.md) for how to use this field for transactional purchases.

FieldTypeDefaultAccess PermissionDescriptionconfirmPartnerOrderContentNodeinvalidREAD\_WRITEConfirms the product being ordered from a TVOD app. The order contains the following fields:  

| Field | Type | Description |
| --- | --- | --- |
| orderId | string | The orderID returned by Roku in the [RequestPartnerOrderStatus](#requestpartnerorderstatus) content node. |
| code | string | The product identifier. |
| priceDisplay | string | The original price of the product. Do not include a currency symbol (for example, set this to "3.99" instead of "$3.99"). |
| price | string | The final price of the product, including any discounts. Do not include a currency symbol (for example, set this to "3.99" instead of "$3.99"). |
| title | string | The name of the product to be displayed on customers' invoices. |
| couponCode | string | An alphanumeric string entered by the customer to receive a discounted price on the product. |
| contentKey | string | The publisher-specific SKU (or other unique identifier) for the product. |

#### orderStatus

| Field | Type | Default | Access Permission | Description |
| --- | --- | --- | --- | --- |
| orderStatus | ContentNode | invalid | READ\_WRITE | Contains the results of the [**doOrder**](#doorder) command. |

#### purchases

| Field | Type | Default | Access Permission | Description |
| --- | --- | --- | --- | --- |
| purchases | ContentNode | invalid | READ\_WRITE | Contains the results of a [**getPurchases**](#getpurchases) or [**getAllPurchases**](#getallpurchases) command. |

#### catalog

| Field | Type | Default | Access Permission | Description |
| --- | --- | --- | --- | --- |
| catalog | ContentNode | invalid | READ\_WRITE | Contains the results of a [**getCatalog**](#getcatalog) command. |

#### storeCatalog

| Field | Type | Default | Access Permission | Description |
| --- | --- | --- | --- | --- |
| storeCatalog | ContentNode | invalid | READ\_WRITE | Contains the results of a [**getStoreCatalog**](#getstorecatalog) command. |

#### requestPartnerOrderStatus

| Field | Type | Default | Access Permission | Description |
| --- | --- | --- | --- | --- |
| requestPartnerOrderStatus | ContentNode | invalid | READ\_WRITE | Contains the results of a [**requestPartnerOrder**](#requestpartnerorder) command. |

#### confirmPartnerOrderStatus

| Field | Type | Default | Access Permission | Description |
| --- | --- | --- | --- | --- |
| confirmPartnerOrderStatus | ContentNode | invalid | READ\_WRITE | Contains the results of a [**confirmPartnerOrder**](#confirmpartnerorder) command. |

#### fakeServer

| Field | Type | Default | Access Permission | Description |
| --- | --- | --- | --- | --- |
| fakeServer | Boolean | false | READ\_WRITE | Enables a test mode for the **ChannelStore** node. The test mode disables communication by the ChannelStore node with the Streaming Store server, and it causes responses to asynchronous queries and operations to come from XML test configuration files rather than the server.  <br>  <br>To use this test method, create a **csFake** folder and add the following XML files to it in order to simulate web service request and response data:<br><br>*   **csfake/GetCatalog.xml**: Simulates the list of products available for purchase in the app.<br>*   **csfake/GetPurchases.xml**: Simulates the list of products already purchased by the user.<br>*   **csfake/PlaceOrder.xml**: Contains information about the product to be ordered.<br>*   **csfake/CheckOrder.xml**: Verifies the validity of the order placed. For example, if the **order** and **id** values in the PlaceOrder and CheckOrder XML files do not match, the fake server will report an error in the order processing.<br><br>  <br>  <br>See the [SimpleChannelStore sample app](https://github.com/rokudev/samples/tree/master/roku%20pay/SimpleChannelStore/csfake) for how to use this testing method.  <br>  <br>The **fakeServer** field must be set to false in a published app to allow actual [In-App Product](/docs/developer-program/roku-pay/quickstart/in-channel-products.md) purchases by users.<br><br>It is recommended that developers use [billing testing](/docs/developer-program/roku-pay/testing/billing-testing.md) instead of the fakeServer. |

Commands
--------

Each of the actions associated with a command string are described in detail below.

### getUserData

Displays the Roku Pay Request for Information (RFI) screen, which prompts customers to confirm that Roku may share their Roku customer account information with the calling app in order to sign up/sign in to that app. This enables apps to create and update customer accounts in their system without requiring customers to manually enter their personal information in an account creation screen.

> To pass [certification](/docs/developer-program/certification/certification.md#2-purchases), all authenticated apps (SVOD, TVOD, other subscription services, and AVOD) must use the [getUserData](/docs/references/scenegraph/control-nodes/channelstore.md#getuserdata) command to display a Request For Information (RFI) screen during the sign-up and sign-in workflows to enable customers to share their Roku account information with the app. Only if the user declines the request may apps require the customer to manually enter their information.

To use this command, follow these steps:

1.  Set the [**requestedUserData** field](#requesteduserdata) to the Roku customer account information to be requested. This may be set to either "all" to get all the available account information items, or a string with a comma-separated list of specific information items (for example, "email, firstname). Request the minimum amount of information required to create/update an account.
    
        store = CreateObject("roSGNode", "ChannelStore")
        store.requesteduserdata = "email, first name, lastname, phone"
        
    

2.  Send the **getUserData** command.
    
        m.store.command = "getUserData"
        
    

3.  The RFI screen's asks the customer to use their Roku customer account information to sign up or sign in to the app, and it lists the requested information.
    
    ![roku815px - signup-rfi-getuserdata-v2](https://image.roku.com/ZHZscHItMTc2/signup-rfi-getuserdata-v2.jpg)
    
    ![roku815px - signin-2-rfi-splash](https://image.roku.com/ZHZscHItMTc2/signin-2-rfi-splash-v2.jpg)
    

4.  If the customer clicks **Continue** in the RFI screen to confirm that Roku can share their Roku customer account information with the app, the [**userData** field](#userdata) field is populated with the Roku customer account information that was requested in the [**requestedUserData**](#requesteduserdata) field. If the customer clicks **Cancel** in the RFI screen to decline sharing their information, the **userData** field is set to "invalid".
    
        email = store.userdata.email
        firstname = m.store.userData.firstname
        lastname = m.store.userData.lastname
        phone = m.store.userData.phone
        
    

Overall, the [**userData** field](#userdata) field may contain the following Roku customer account information fields.

| Field | Type | Description |
| --- | --- | --- |
| firstName | string | The user first name |
| lastName | string | The user last name |
| email | string | The user email address |
| street1 | string | The first line of the user street address |
| street2 | string | The second line of the user street address |
| city | string | The city where the user lives |
| state | string | The state where the user lives |
| zip | string | The user postal code |
| country | string | The country where the user lives |
| phone | string | The user phone number |
| birth | string | The user birthdate (YYYY-MM). |
| gender | string | The user gender ("Male", "Female", or unspecified). |

> For authenticated free and AVOD apps that are not enrolled in the [Roku Partner Payouts Program](/docs/developer-program/roku-pay/quickstart/partner-payouts.md), the [**userData** field](#userdata) contains a limited set of account information fields:
> 
> *   **Sign-up RFI screen**: email, phone, and zip.
> *   **Sign-in RFI screen**: email and phone.

### getUserRegionData

The **getUserRegionData** command retrieves the state, zip code, and country associated with the customer's Roku account. The location information returned by this command can be used to determine a customer's eligibility for regional-specific subscription products and content.

When this command is invoked, the ContentNode stored in the **userRegionData** field contains the following fields:

| Field | Type | Description |
| --- | --- | --- |
| state | string | The state associated with the customer's Roku account. |
| zip | string | The zip code associated with the customer's Roku account. |
| country | String | The country associated with the customer's Roku account. |

### getCatalog

Lists the [In-App Products](/docs/developer-program/roku-pay/quickstart/in-channel-products.md) that are linked to the running app. When this command completes, the **catalog** the completion status:

| Field | Type | Description |
| --- | --- | --- |
| status | integer | Contains the command completion status. which may be one of the following values:  <br><br>*   2: Interrupted<br>*   1: Success<br>*   0: Network error<br>*   \-1: HTTP Error/Timeout<br>*   \-2: Timeout<br>*   \-3: Unknown Error<br>*   \-4: Invalid request |
| statusMessage | string | Contains a string describing the command completion status |

If the command is successful, the **catalog** or **storeCatalog** ContentNode contains a child ContentNode for each product available for purchase. Each child ContentNode includes the following information related to the product:

| Field | Type | Description |
| --- | --- | --- |
| code | string | The product identifier, as entered in the **Product Identifier** field on the [In-App Product page in the Developer Dashboard](https://developer.roku.com/products) when the product was created. |
| name | string | The item name (this name will also be set as the description). |
| quantity | Integer | For one-time purchase/consumable products only. The number of the product purchased (for example "1000" game points, "3" viewings of a movie rental). |
| productType | string | The product type (ex. "MonthlySub") |
| cost | string | Localized cost of the product with local currency symbol |
| freeTrialQuantity | integer | If the product has a free trial offer, the length of the trial period. For example, **1** for a 1-month free trial or **7** for a 7-day free trial. |
| freeTrialType | string | If the product has a free trial offer, the unit of time used by the trial ("Days" or "Months") |
| trialCost | integer | If the product uses introductory pricing, the discounted price. |
| trialQuantity | integer | If the product uses introductory pricing, the number of months the discounted pricing is applicable. |
| trialType | string | Set to "months" for all products. All products using introductory pricing use "months" as the unit of time for the trial. |
| status | string | Indicates whether the product has been "saved" or "approved for sale". |
| purchaseDate | String | The subscription purchase date |

### getStoreCatalog

Lists the globally available [In-App Products](/docs/developer-program/roku-pay/quickstart/in-channel-products.md), which are available to all apps. When the command completes, the **storeCatalog** field is set to a ContentNode containing completion status. If successful, the **storeCatalog** field ContentNode has child **ContentNodes** for each available item. See the [**getCatalog**](#getcatalog) command for the fields related to the product that are available in the child ContentNode.

### doOrder

Displays the Roku Pay order confirmation screen, which is populated with information about the current order (product name, price, any free trial or discount offer). The customer can then either approve and complete the purchase, or cancel the purchase.

![roku815px - signup-order-confirmation-do-order](https://image.roku.com/ZHZscHItMTc2/signup-order-confirmation-do-order.jpg)

When the command completes, the [**orderStatus** field](#orderstatus) is set to a ContentNode containing information about the command completion.

| Field | Type | Description |
| --- | --- | --- |
| status | integer | Contains the command's completion status, which may be on the following values:  <br><br>*   2: Interrupted<br>*   1: Success<br>*   0: Network error<br>*   \-1: HTTP Error/Timeout<br>*   \-2: Timeout<br>*   \-3: Unknown Error<br>*   \-4: Invalid request |

If this command is successful, the [**orderStatus** field](#orderstatus) ContentNode will have child ContentNodes for each item purchased. The fields for each child ContentNode include the same information when the [**getPurchases** command](#getpurchases) is sent, but only the following fields are populated when the transaction is made:

| Field | Type | Description |
| --- | --- | --- |
| amount | string | Localized amount of the item purchased (post transaction) with local currency symbol |
| code | string | The product identifier, as entered in the **Product Identifier** field on the [In-App Product page in the Developer Dashboard](https://developer.roku.com/products) when the product was created. |
| purchaseId | string | The transaction ID |
| qty | integer | The quantity purchased |
| total | string | Localized total of the item purchased (including tax if applicable) with local currency symbol |

> As of Roku OS 9.4, if the back button is pressed from the **Order Confirmation** dialog, the **doOrder** command returns only a status of 2 ("interrupted"). Error handling in apps may need to be updated based on this behavior.

### getPurchases

Returns the list of purchases of current subscription products associated with the Roku customer account.

When this command completes, the [**purchases** field](#purchases) is set to a ContentNode containing the completion status.

| Field | Type | Description |
| --- | --- | --- |
| status | integer | Contains the command's completion status, which may be one of the following values:  <br><br>*   2: Interrupted<br>*   1: Success<br>*   0: Network error<br>*   \-1: HTTP Error/Timeout<br>*   \-2: Timeout<br>*   \-3: Unknown Error<br>*   \-4: Invalid request |

If this command is successful, the [**purchases** field](#purchases) ContentNode will have child ContentNodes for each item purchased. The fields for each child ContentNode include the following information about the purchased item:

| Field | Type | Description |
| --- | --- | --- |
| code | string | The product identifier, as entered in the **Product Identifier** field on the [In-App Product page in the Developer Dashboard](https://developer.roku.com/products) when the product was created. |
| cost | string | Localized cost of the item (prior to purchase) with local currency symbol |
| expirationDate | string | The subscription expiration date ([ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format) |
| freeTrialQuantity | integer | The free trial amount associated with the freeTrialType. For example, **1** for a 1-month free trial or **7** for a 7-day free trial. |
| freeTrialType | string | The free trial type ("Days" or "Months") |
| inDunning | string | A flag that indicates whether the purchased subscription is past due state because of an invalid method of payment.  <br>  <br>This flag is set to "true" if the subscription is in the dunning state. In this case, check the **status** field to determine whether to grant the customer access to content:  <br><br>*   If the **status** field is set to "Valid", the subscription is in a grace period and the viewer can access content.<br>*   If the **status** field is set to "Invalid", the subscription is on hold and the viewer cannot access content. If the viewer adds a valid method of payment, the subscription will be automatically renewed and the status will become "Valid". |
| name | string | The item name (this name will also be set as the description). |
| productType | string | The product type (ex. "MonthlySub") |
| purchaseChannel | string | Indicates where the Roku Pay subscription purchase was made:  <br><br>*   **web**. Subscription was purchased from [Roku.com](http://roku.com/) (for example, through [Instant Signup](/docs/developer-program/discovery/instant-signup.md) during the device activation).<br>*   **device**. Subscription was purchased on the Roku device (through the on-device sign-up flow). |
| purchaseContext | string | Indicates how the subscription purchase was made:  <br><br>*   **isu**. Subscription was purchased via [Instant Signup](/docs/developer-program/discovery/instant-signup.md).<br>*   **iap**. Subscription was purchased via an in-application purchase. |
| purchaseDate | string | The purchase date ([ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format) |
| purchaseId | string | The transaction ID |
| qty | integer | The quantity purchased |
| renewalDate | string | The subscription renewal date ([ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format) |
| status | string | Indicates whether the purchase is for a current subscription ("Valid") or for a subscription that has been canceled, expired, or terminated ("Invalid") |
| trialCost | integer | If the product uses introductory pricing, the discounted price. |
| trialQuantity | integer | If the product uses introductory pricing, the number of months the discounted pricing is applicable. |
| trialType | string | Set to "months" for all products. All products using introductory pricing use "months" as the unit of time for the trial. |

### getAllPurchases

The **getAllPurchases** command is similar to the [**getPurchases** command](#getpurchases) except that it requests the historical list of all canceled, expired, and terminated subscriptions over the lifetime of the current user account—in addition to the active subscriptions. You can use this method to leverage purchase history in order to implement subscription renewal flows and more easily determine if subscriptions have expired.

When this command completes, the [**purchases** field](#purchases) is set to a ContentNode containing the completion status.

| Field | Type | Description |
| --- | --- | --- |
| status | integer | Contains the command's completion status, which may be one of the following values:  <br><br>*   2: Interrupted<br>*   1: Success<br>*   0: Network error<br>*   \-1: HTTP Error/Timeout<br>*   \-2: Timeout<br>*   \-3: Unknown Error<br>*   \-4: Invalid request |

If this command is successful, the [**purchases** field](#purchases) ContentNode has child ContentNodes for each item purchased. The fields for each child ContentNode include a `status` field that indicates whether the purchase is for a current subscription ("Valid") or for a subscription that has been canceled, expired, or terminated ("Invalid"), and the following information about the purchased item:

| Field | Type | Description |
| --- | --- | --- |
| code | string | The product identifier, as entered in the **Product Identifier** field on the [In-App Product page in the Developer Dashboard](https://developer.roku.com/products) when the product was created. |
| cost | string | Localized cost of the item (prior to purchase) with local currency symbol |
| expirationDate | string | The subscription expiration date ([ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format) |
| freeTrialQuantity | integer | If the product has a free trial offer, the length of the trial period. For example, **1** for a 1-month free trial or **7** for a 7-day free trial. |
| freeTrialType | string | If the product has a free trial offer, the unit of time used by the trial ("Days" or "Months") |
| inDunning | string | A flag that indicates whether the purchased subscription is past due state because of an invalid method of payment.  <br>  <br>This flag is set to "true" if the subscription is in the dunning state. In this case, check the **status** field to determine whether to grant the customer access to content:  <br><br>*   If the **status** field is set to "Valid", the subscription is in a grace period and the viewer can access content.<br>*   If the **status** field is set to "Invalid", the subscription is on hold and the viewer cannot access content. If the viewer adds a valid method of payment, the subscription will be automatically renewed and the status will become "Valid". |
| name | string | The item name (this name will also be set as the description). |
| productType | string | The product type (ex. "MonthlySub") |
| purchaseChannel | string | Indicates where the Roku Pay subscription purchase was made:  <br><br>*   **web**. Subscription was purchased from [Roku.com](http://roku.com/) (for example, through [Instant Signup](/docs/developer-program/discovery/instant-signup.md) during the device activation).<br>*   **device**. Subscription was purchased on the Roku device (through the on-device sign-up flow). |
| purchaseContext | string | Indicates how the subscription purchase was made:  <br><br>*   **isu**. Subscription was purchased via [Instant Signup](/docs/developer-program/discovery/instant-signup.md).<br>*   **iap**. Subscription was purchased via an in-application purchase. |
| purchaseDate | string | The purchase date ([ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format) |
| purchaseId | string | The transaction ID |
| qty | integer | The quantity purchased |
| renewalDate | string | The subscription renewal date ([ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format) |
| status | string | Indicates whether the purchase is for a current subscription ("Valid") or for a subscription that has been canceled, expired, or terminated ("Invalid") |
| trialCost | Integer | If the product uses introductory pricing, the discounted price. |
| trialQuantity | integer | If the product uses introductory pricing, the number of months the discounted pricing is applicable. |
| trialType | string | Set to "months" for all products. All products using introductory pricing use "months" as the unit of time for the trial. |

### storeChannelCredData

Stores an OAuth token, custom token, or other custom data, which you can then retrieve with the [getChannelCred](#getchannelcred) command (the token is stored in the **channelCred.json.channel\_data** field). This data is stored securely in the Roku cloud and can be retrieved by other devices linked to the same Roku account. As a result, users do not have to re-enter their account credentials when setting up new devices associated with the same Roku account. For more information, see [Automatic Account Link](/docs/developer-program/authentication/universal-authentication-protocol-for-single-sign-on.md).

    function init():
        m.store.ObserveField("storeChannelCredDataStatus", "onStoreChannelCredData")
        m.store.ObserveField("channelCred", "onGetChannelCred")
    
        ' trigger "storeChannelCredData" command with "test app cred data" in m.store.channelCredData field.
        print "StoreChannelCredData"
        m.store.channelCredData = "test app cred data"
        print "store.channelCredData: " m.store.channelCredData
        m.store.command = "storeChannelCredData"
    end function
    
    function onStoreChannelCredData() as void
        print "onStoreChannelCredData"
        if (m.store.storeChannelCredDataStatus <> invalid)
            print "- response: " m.store.storeChannelCredDataStatus.response
            print "- status: " m.store.storeChannelCredDataStatus.status
        end if
    
        ' trigger "getChannelCred" command.
        print "GetChannelCred"
        m.store.command = "getChannelCred"
    end function
    
    function isstr(value)
        return (value <> invalid) and (GetInterface(value, "ifString") <> invalid)
    end function
    
    function isNullOrEmpty(obj)
        if obj = invalid return true
        if not isstr(obj) return true
        if Len(obj) = 0 return true
        return false
    end function
    
    function onGetChannelCred() as void
        print "onGetChannelCred"
        if (m.store.channelCred <> invalid)
            print "- channelID: " m.store.channelCred.channelID
            print "- status: " m.store.channelCred.status
            print "- publisherDeviceID: " m.store.channelCred.publisherDeviceID
            if (not isNullOrEmpty(m.store.channelCred.json))
                json = parsejson(m.store.channelCred.json)
                if (json <> invalid) and (not isNullOrEmpty(json.roku_pucid))
                    print "- error: " json.error
                    print "- roku_pucid: " json.roku_pucid
                    print "- token_type: " json.token_type
                    print "- channel_data: " json.channel_data
                end if
            end if
        end if
    end function
    

This command returns an roAssociativeArray with the following values:

KeyTypeValueresponsejsonA string in JSON format, with the following key-value pairs:  

| Key | Type | Description |
| --- | --- | --- |
| status | string | The request status, which may be "success" or "failure". |
| error | string | A description of the error (if any). This will be set to "none" for a successful request. |
| error\_detail | string | A detailed description of the service error (if any). This value will be null (uninitialized) for a successful request. |

  
  
if billing is not enabled for the app, this field will include a string with a service error message.statusIntegerAn integer representing the request status. A successful request will return a status of 0.

### getChannelCred

Retrieves an oAuth token, custom token, or other authentication artifact (`channel_data`), or a Roku Partner Unique Customer Identifier (`roku_pucid`) if the app is using the [Roku single-sign on (SSO) authentication service](/docs/developer-program/authentication/roku-sso-authentication-protocol.md) for authenticating users. If successful, the ContentNode stored in the `channelCred` field represents the app credentials with the following fields:

KeyTypeDescriptionchannelIDstringA string representing the app ID (ex. "2213" for Roku Media Player)errorCodestringA description of the service error (if any). This will be an empty string for a successful request.jsonstringA string in JSON format, with the following key-value pairs:  

| Key | Type | Description |
| --- | --- | --- |
| error | string | A string containing an error message (if any). This value will be null (uninitialized) for a successful request. |
| roku\_pucid | string | An agnostic ID (in UUID format) representing the user. This value will be identical when retrieved in the same app across devices linked to the same Roku account.  <br>  <br>If an app is storing an access token in the Roku cloud, this field does not contain a PUCID value. |
| token\_type | string | Type of the returned token, e.g. "urn:roku:pucid:token\_type:pucid\_token" |
| channel\_data | String | The access token, oAuth token, or other authentication artifact stored by the app in the Roku cloud via the [StoreChannelCredData](#storechannelcreddata) command.  <br>  <br>This field is not returned if the [StoreChannelCredData](#storechannelcreddata) command is not used to store an artifact in the Roku cloud. |

  
If the request fails, this json string will be empty.publisherDeviceIDstringA unique identifier of the device.statusintegerAn integer representing the request status. A successful request will return a status of 0.

### getDeviceAttestationToken

Generates a signed JSON web token (JWT) in the Roku cloud and returns it to the app. This token can then be used by the publisher's web services to verify that a message originated from a genuine Roku device. The following example demonstrates how to generate the device attestation token:

    sub handleData(event)
      data = event.getData()
      print data.status
      print data.token
    end sub
    
    m.channelstore_node= m.top.findNode("deviceAttestationToken")
    m.data.observeField("deviceAttestationToken", "handleData")
    ..
    m.channelstore_node.nonce = GetHexString(16)
    m.channelstore_node.command = "getDeviceAttestationToken"
    

**Sample JWT**

The following demonstrates a sample JWT that is returned to the app. Developers can use a [JWT debugger](https://jwt.io/#debugger-io) to decode this token.

    eyJ4NXUiOiJodHRwczovL2V4YW1wbGUucm9rdS5jb20vc2FtcGxlY2VydCIsInR5cCI6IkpXVCIsImFsZyI6IlJTMjU2In0.eyJuYmYiOjE2NTYzNzQyNzQsIngtcm9rdS1hdHRlc3RhdGlvbi1kYXRhIjp7Im5vbmNlIjoiNUUwNjkyRTBBMzg5RjRGNiIsImNoYW5uZWxJZCI6ImRldiIsImRldmVsb3BlcklkIjoiY2FhNzNmYmI1ZTc1YTQ2YTRiNjExNGRlNTFhNWFkYTdkNjE2ZTJlZCIsInRpbWVzdGFtcE1zIjoxNjU2Mzc3ODczOTkwfSwiaXNzIjoidXJuOnJva3U6Y2xvdWQtc2VydmljZXM6ZGV2aWNlLWF0dGVzdGF0aW9uIiwiZXhwIjoxNjU2NDY0Mjc0fQ.nywDvSUys27oeaQZ3yXwNBfOnXbO-TUDuekOPZYjSssfZhNhWwRXvPLbJKHcNMR5Z0vFOQLVDFeqEVGauIMxMEke5UFLuCRxhr3ayBJJPt_BPfrEFbAvYjFEGdKkxJqYUhuFE38R8lU2k7dhO0iFxDw1Qq7W4w8_7CjmDy4YFf7IfyhV7Vf2kGiOx5C94Niw5N2td3s21F3z77Rq_bofQ51DOKIwo_cDVuvPQnDyxG-CNEydZKCZZwGPYCKEHMPrIOOXJ-S9ZjArgaEpBUpMXWJibFxnkpVUVzbC22GEaqz_SjOJXFMQU7TaCKkDeCYVKylgKwCvbvHRDlgogf7kqg
    

**Verifying the JWT**

To verify the JWT, developers must [download the Roku device attestation token certificate](https://devtools.web.roku.com/device_attestation_token_cert/RokuDeviceAttestationIntermediateCA.cert.pem) and authenticate that the token is signed by that certificate (see [https://jwt.io/introduction](https://jwt.io/introduction) for more information on JWT verification methods). The decoded JWT contains the following fields

**Decoded JWT**

The decoded JWT contains the following fields:

    "x-roku-attestation-data": {
        "nonce": "5E0692E0A389F4F6",
        "channelId": "dev",
        "developerId": "caa73fbb5e75a46a4b6114de51a5ada7d616e2ed",
        "timestampMs": 1656377873990
     }
    

### requestPartnerOrder

> See [Creating TVOD channels](/docs/developer-program/roku-pay/implementation/tvod-channel.md) for how to use this command for transactional purchases.

Checks the user's billing status for transactional purchases. This is a prerequisite for sending the [confirmPartnerOrder command](#confirmpartnerorder).

If this command is successful, the [**requestPartnerOrderStatus** field](#requestpartnerorderstatus) contains the following values:

| Field | Type | Description |
| --- | --- | --- |
| orderId | String | The ID that must be included as a field in the **confirmOrderInfo** ContentNode used by the [confirmPartnerOrder](#confirmpartnerorder) command. |
| status | String | Success |
| tax | String | Cost of tax (if applicable) |
| total | String | Total cost of transaction |

If this command fails, the [**requestPartnerOrderStatus** field](#requestpartnerorderstatus) contains the following values:

| Field | Type | Description |
| --- | --- | --- |
| errorCode | String | An error code representing why the transaction failed |
| errorMessage | String | An error message explaining why the transaction failed |
| status | String | Failure |

### confirmPartnerOrder

> See [Creating TVOD channels](/docs/developer-program/roku-pay/implementation/tvod-channel.md) for how to use this command for transactional purchases.

This command is equivalent to the **doOrder** command for transaction purchases. The user's billing status must first be confirmed with the [requestPartnerOrder command](#requestpartnerorder) before sending this command.

If this command is successful, the [**confirmPartnerOrderStatus** field](#confirmpartnerorderstatus) contains the following values:

| Field | Type | Description |
| --- | --- | --- |
| purchaseId | String | The transaction ID |
| status | String | Success |

If this command fails, the [**confirmPartnerOrderStatus** field](#confirmpartnerorderstatus) contains the following values:

| Field | Type | Description |
| --- | --- | --- |
| errorCode | String | An error code representing why the transaction failed |
| errorMessage | String | An error message explaining why the transaction failed |
| status | String | Failure |

roStreamSocket
==============

The roStreamSocket component enables BrightScript apps to accept and connect to TCP streams as well as send and receive data with them. The interface is modeled on and works much like standard Berkeley sockets.

This object is created without any arguments:

`CreateObject("roStreamSocket")`

**Example: Open TCP Connection to Server**

    sendAddress = CreateObject("roSocketAddress")
    sendAddress.SetAddress("www.google.com:80")
    socket = CreateObject("roStreamSocket")
    socket.setSendToAddress(sendAddress)
    If socket.Connect()
        Print "Connected Successfully"
    End If
    

**Example: Echo Server**

    function main()
        messagePort = CreateObject("roMessagePort")
        connections = {}
        buffer = CreateObject("roByteArray")
        buffer[512] = 0
        tcpListen = CreateObject("roStreamSocket")
        tcpListen.setMessagePort(messagePort)
        addr = CreateObject("roSocketAddress")
        addr.setPort(54321)
        tcpListen.setAddress(addr)
        tcpListen.notifyReadable(true)
        tcpListen.listen(4)
        if not tcpListen.eOK()
            print "Error creating listen socket"
            stop
        end if
        while True
            event = wait(0, messagePort)
            if type(event) = "roSocketEvent"
                changedID = event.getSocketID()
                if changedID = tcpListen.getID() and tcpListen.isReadable()
                    ' New
                    newConnection = tcpListen.accept()
                    if newConnection = Invalid
                        print "accept failed"
                    else
                        print "accepted new connection " newConnection.getID()
                        newConnection.notifyReadable(true)
                        newConnection.setMessagePort(messagePort)
                        connections[Stri(newConnection.getID())] = newConnection
                    end if
                else
                    ' Activity on an open connection
                    connection = connections[Stri(changedID)]
                    closed = False
                    if connection.isReadable()
                        received = connection.receive(buffer, 0, 512)
                        print "received is " received
                        if received > 0
                            print "Echo input: '"; buffer.ToAsciiString(); "'"
                            ' If we are unable to send, just drop data for now.
                            ' You could use notifywritable and buffer data, but that is
                            ' omitted for clarity.
                            connection.send(buffer, 0, received)
                        else if received=0 ' client closed
                            closed = True
                        end if
                    end if
                    if closed or not connection.eOK()
                        print "closing connection " changedID
                        connection.close()
                        connections.delete(Stri(changedID))
                    end if
                end if
            end if
        end while
    
        print "Main loop exited"
        tcpListen.close()
        for each id in connections
            connections[id].close()
        end for
    End Function
    

Supported interfaces
--------------------

*   [ifSocketConnection](/docs/references/brightscript/interfaces/ifsocketconnection.md "ifSocketConnection")
*   [ifSocket](/docs/references/brightscript/interfaces/ifsocket.md "ifSocket")
*   [ifSocketAsync](/docs/references/brightscript/interfaces/ifsocketasync.md "ifSocketAsync")
*   [ifSocketStatus](/docs/references/brightscript/interfaces/ifsocketstatus.md "ifSocketStatus")
*   [ifSocketConnectionStatus](/docs/references/brightscript/interfaces/ifsocketconnectionstatus.md "ifSocketConnectionStatus")
*   [ifSocketConnectionOption](/docs/references/brightscript/interfaces/ifsocketconnectionoption.md "ifSocketConnectionOption")
*   [ifSocketOption](/docs/references/brightscript/interfaces/ifsocketoption.md)

Supported events
----------------

*   [roSocketEvent](/docs/references/brightscript/events/rosocketevent.md "roSocketEvent")

ifSGScreen
==========

Implemented by
--------------

| Name | Description |
| --- | --- |
| [roSGScreen](/docs/references/brightscript/components/rosgscreen.md "roSGScreen") | The roSGScreen object is a SceneGraph canvas that displays the contents of a SceneGraph Scene node tree |

Supported methods
-----------------

### SetMessagePort(port as roMessagePort) as Void

#### Description

Specifies the roMessagePort object for the roSGScreen object

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| port | roMessagePort | The roMessagePort to be used for the SceneGraph scene. |

### GetMessagePort() as roMessagePort

#### Description

Returns the roMessagePort object for the SceneGraph scene.

#### Return Value

The roMessagePort object.

### getGlobalNode() as roSGNode

#### Description

Returns a global reference object for the SceneGraph application.

#### Return Value

A global reference object.

#### Example: Starting Scene Graph Applications

    sub showChannelSGScreen()
      print "in showChannelSGScreen"
      screen = CreateObject("roSGScreen")
      m.port = CreateObject("roMessagePort")
      screen.setMessagePort(m.port)
      m.global = screen.getGlobalNode()
      m.global.id = "GlobalNode"
      m.global.addFields( {red: &hff0000ff, green: &h00ff00ff, blue: &h0000ffff} )
      scene = screen.CreateScene("TrivialScene")
      screen.show()
      scene.setFocus(true)
    
      child = createObject("RoSGNode","ContentNode")
      child.contentkey = "test_string"
      print "child: '"; child.contentkey; "'"
    
      while(true)
        msg = wait(0, m.port)
        msgType = type(msg)
        if msgType = "roSGScreenEvent"
          if msg.isScreenClosed() then return
        end if
      end while
    
    end sub
    

### Show() as Boolean

#### Description

Renders the SceneGraph scene defined by the roSGScreen object on the display screen.

#### Return Value

A flag indicating whether the screen is displayed.

### Close() as Void

#### Description

Removes the SceneGraph scene from the display screen.

### CreateScene(sceneType as String) as Object

#### Description

Creates the SceneGraph scene object based on the specified sceneType object.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| sceneType | String | The sceneType object to be used to create the scene object. |

#### Return Value

The roSGScene object associated with the screen.

### GetScene() as roSGNode

#### Description

The roSGScene object associated with the screen.

#### Return Value

Typically, the scene created in main.brs by a roSGScreen.CreateScene() call.

ListPanel
=========

Extends [**Panel**](/docs/references/scenegraph/sliding-panels-nodes/panel.md)

The ListPanel node class allows you to easily create a Panel that adheres to the Roku layout and behavior for panels that contain a LabelList or MarkupList node. The ListPanel provides the following functionality:

*   Resolution appropriate positioning and sizing of the list node
*   Automatic key focus handling (i.e. the list node is set to receive key events when the ListPanel is given the key focus by the PanelSet)
*   Left-justified and right-justified labels that can be used to provide descriptive information about the list (e.g. "1 of N", etc.). These labels are automatically positioned and sized appropriately.
*   Simple mechanism for setting up the case where focusing any item in the grid triggers the creation of a new panel to add to the PanelSet
*   Default fade in/out animation of the next panel when the simple mechanism is used
*   Default fade out mask effect applied to the list items at the bottom of the panel

#### Automatic Create Next Panel Functionality

One key feature of the ListPanel node is providing a simple mechanism for setting up the common use case where each time a new item in the grid receives the focus, a new "next" panel is added to the PanelSet. This mechanism is enabled or disabled by setting the createNextPanelOnItemFocus field to true or false.

createNextPanelOnItemFocus should be set to true when a new right panel should be displayed each time the list's focused item changes. For example, in the Roku Homescreen, when you navigate up/down the Settings list, a new right panel is displayed that contains information about the currently focused list item. createNextPanelOnItemFocus should be set to false when the right panel should not change in response to the list's focus changes. 

When the create next panel mechanism is enabled and the user presses the up or down arrow key, the panel to the right of the ListPanel smoothly fades out, then when the user releases the arrow key, a new right panel is created, added to the PanelSet and smoothly faded in. To implement this, the ListPanel automatically triggers the fade out of the right panel when the up or down arrow key is pressed. When the arrow key is released, the ListPanel will set the createNextPanelIndex field to the index into the list's content that corresponds to the newly focused list item. In response to the createNextPanelIndex field being set, the ListPanel's control logic must be written to mmediately create the Panel node for the new right panel and set the nextPanel field to that Panel. The Panel creation must occur in the main SceneGraph render thread.

The createNextPanelIndex field is guaranteed to be set exactly once whenever a new right panel needs to be created and populated with the data that corresponds to the specified index. This may happen when the ListPanel's data is changed, in response to up or down arrow key releases, or when the PanelSet's moves the focus onto the ListPanel from the left.

For efficiency, sometimes the control logic for the ListPanel may create and hold onto Panel pointers internally so that the next Panel does not have to be newly created each the createNextPanelIndex field is set. If this is done, it is important to never reuse the current Panel node, as that Panel may still be fading out when the new next Panel needs to be created. A typical use case, where all the right Panels are identical other than the data they display, is to create a single pair of Panel nodes and alternate between them each time the createNextPanelIndex field is set, updating the panel data based on the specified list index.

#### LabelList Specific UsageNotes

If you set the list field to a LabelList node, the default values for the itemSize, itemSpacing, numRows and translation fields for the LabelList will be automatically set to the recommended default values for Roku apps. By default, the panel will use the "narrow" panelSize. It is possible to override these default values, but in most cases, that will not be necessary.

#### MarkupList Specific Usage Notes

If you set the list field to a MarkupList node, because the MarkupList is by nature custom, you will generally need to set the MarkupList's itemSize, itemSpacing and numRows fields. The ListPanel will position the list appropriately.

Fields
------

| Field | Type | Default | Access Permission | Description |
| --- | --- | --- | --- | --- |
| list | Node | NULL | READ\_WRITE | The list field should be set to either a LabelList or MarkupList node to be displayed in the Panel. See the LabelList and MarkupList notes above about setting up the list's layout. |
| leftLabel | Node | Label node | READ\_WRITE | The leftLabel field is set to a Label node that is positioned just above the left/top corner of the list. Setting the Label node's text field will cause that text string to be displayed. Setting other fields of the Label node can be used to adjust the Label's text color and other visual attributes. |
| rightLabel | Node | Label node | READ\_WRITE | The rightLabel field is set to a Label node that is positioned just above the right/top corner of the list. Setting the Label node's text field will cause that text string to be displayed. Setting other fields of the Label node can be used to adjust the Label's text color and other visual attributes.  <br>  <br>The rightLabel is often used to display a "1 of N" message that reflects the index of the list's focused item. |
| showSectionLabels | Boolean | false | READ\_WRITE | If showSectionLabels is set to true and the data for the list node is divided into sections, the Title attribute of the current section will be displayed as the leftLabel of the list. As the list items scroll, the leftLabel will smoothly transition as each section of the list reaches the focus position. |
| createNextPanelIndex | integer | N/A | READ\_ONLY | When the createNextPanelOnItemFocus field is true, createNextPanel is set when a new panel needs to be created and added to the PanelSet. The value of the field is the index of the list's content that should be used to create and populate the new panel.  <br>  <br>The createNextPanelIndex field is guaranteed to be set exactly once whenever the next panel for the focused list item needs to be created. |
| nextPanel | Node | false | WRITE\_ONLY | When the createNextPanelOnItemFocus field is true, the nextPanel field should be set to a Panel node to the next panel to add to the PanelSet in response to the createNextPanelIndex field being set. It must be set immediately in repsonse to the createNextPanelIndex field being set. |
| createNextPanelOnItemFocus | Boolean | true | READ\_WRITE | When set to true, the Create Next Panel mechanism is enabled (i.e. the createNextPanelIndex field will be set when a new list item receives the focus). When set to false, the Create Next Panel mechanism is disabled (i.e. the createNextPanelIndex field will not be set when a new list item receives the focus). |

> If you are creating the list field(either a LabelList or MarkupList) associated with a ListPanel in script of a component that extends ListPanel, you also need to add the list as a child of the ListPanel. For example, in a component that extends ListPanel, where m.top is that component, you would associate the list field with a LabelList as follows:

    list = m.top.createChild("LabelList")
    m.top.list = list
    

Data bindings
-------------

If the list's data includes sections and the ListPanel's showSectionLabel's field is set to true, the title field of the section's ContentNode will be used as the text for the left label of the ListPanel.

Sample app
----------

[ListPanelExample](https://github.com/rokudev/samples/tree/master/ux%20components/sliding%20panels/ListPanelExample) is a sample app demonstrating ListPanel in action.

roAudioMetadata
===============

The roAudioMetadata component provides developers access to audio file metadata included in many audio files. This should enable some audiofiles to deliver the information needed to fill out an roSpringboard screen without passing the info in a separate xml feed. roAudioMetadata currently only works with local file URLs.

The component requires the use of a dynamically loaded library that is not part of the initially booted image. Therefore, an entry must be added to the manifest of any applications that use the roAudioMetadata component so it can be loaded when the app is launched. Here's the manifest entry:

_requires\_audiometadata=1_

This object is created without any arguments:

`CreateObject("roAudioMetadata")`

**Example**

    REM printAA() is from generalUtils.brs in our sample apps
    REM and used to print an associative Array
    
    Sub SaveCoverArtFile(filename As String)
        meta = CreateObject("roAudioMetadata")
        meta.SetUrl(filename)
        print "------------- GetTags() -------------------------"
        tags = meta.GetTags()
        printAA(tags)
        print "------------- GetAudioProperties() --------------"
        properties = meta.GetAudioProperties()
        printAA(properties)
        print "------------- GetCoverArt() ---------------------"
        thumbnail = meta.GetCoverArt()
        if (thumbnail <> invalid) then
                if (thumbnail.bytes = invalid) then
                return
            end if
            imgtype = thumbnail.type
            image_ext=""
            if (imgtype = "image/jpeg" or imgtype = "jpg") then
                image_ext = "jpg"
            else if (imgtype = "image/png" or imgtype = "png") then
                image_ext = "png"
            else
                image_ext = "jpg"
            end if
            tmp_img = "tmp:/CoverArtImage" + "." + image_ext
            if (tmp_img <> invalid) then
                DeleteFile(tmp_img)
            end if
            thumbnail.bytes.Writefile(tmp_img)
        end if
    End Sub
    

Supported interfaces
--------------------

*   [ifAudioMetadata](/docs/references/brightscript/interfaces/ifaudiometadata.md "ifAudioMetadata")

roSGScreen
==========

The roSGScreen object is a SceneGraph canvas that displays the contents of a SceneGraph Scene node instance. The object is created by calling:

`CreateObject("roSGScreen")`

`CreateScene()` takes one argument, the name of the scene component. An app will typically extend Scene to define its own app-specific Scene type (such as MyScene, etc.) This Scene component name is passed to `CreateScene().`

**roSGScreen typical usage example**

    screen = CreateObject("roSGScreen")
    scene  = screen.CreateScene("Scene")
    screen.show()
    

Supported interfaces
--------------------

*   [ifSgScreen](/docs/references/brightscript/interfaces/ifsgscreen.md "ifSgScreen")

Supported events
----------------

*   [roSGScreenEvent](/docs/references/brightscript/events/rosgscreenevent.md "roSGScreenEvent")

GridPanel
=========

Extends [**Panel**](/docs/references/scenegraph/sliding-panels-nodes/panel.md)

The GridPanel node class allows you to easily create a Panel that adheres to the Roku layout and behavior for panels that contain a PosterGrid or MarkupGrid node. The GridPanel node class provides the following functionality:

*   Resolution appropriate positioning and sizing of the grid node
*   Automatic key focus handling (i.e. the grid node is set to receive key events when the GridPanel is given the key focus by the PanelSet)
*   Left-justified and right-justified labels that can be used to provide descriptive information about the grid (e.g. "1 of N", etc.). These labels are automatically positioned and sized appropriately.
*   Simple mechanism for setting up the case where focusing any item in the grid triggers the creation of a new panel to add to the PanelSet
*   Default fade in/out animation of the next panel when the simple mechanism is used
*   Default fade out mask effect applied to the grid items at the bottom of the panel

#### Automatic Create Next Panel Functionality

One key feature of the GridPanel node is providing a simple mechanism for setting up the common use case where each time a new item in the list receives the focus, a new "next" panel is added to the PanelSet. This mechanism is enabled or disabled by setting the createNextPanelOnItemFocus field to true or false.

createNextPanelOnItemFocus should be set to true when a new right panel should be displayed each time the grid's focused item changes. For example, in the Roku Homescreen, when you navigate up/down/left/right in the grid, a new right panel is displayed that contains information about the currently focused grid item. createNextPanelOnItemFocus should be set to false when the right panel should not change in response to the grid's focus changes. For example, when focus is on the installed apps grid in the Roku Homescreen, the right panel always displays an ad panel, regardless of which item is focused in the grid.

When the create next panel mechanism is enabled and the user presses a navigation arrow key, the panel to the right of the GridPanel smoothly fades out, then when the user releases the arrow key, a new right panel is created, added to the PanelSet and smoothly faded in. To implement this, the GridPanel automatically triggers the fade out of the right panel when the navigation arrow key is pressed. When the arrow key is released, the GridPanel will set the createNextPanelIndex field to the index into the grid's content that corresponds to the newly focused grid item. In response to the createNextPanelIndex field being set, the GridPanel's control logic must be written to immediately create the Panel node for the new right panel and set the nextPanel field to that Panel. The Panel creation must occur in the main SceneGraph render thread.

The createNextPanelIndex field is guaranteed to be set exactly once whenever a new right panel needs to be created and populated with the data that corresponds to the specified index. This may happen when the GridPanel's data is changed, in response to up or down arrow key releases, or when the PanelSet's moves the focus onto the GridPanel from the left.

For efficiency, sometimes the control logic for the GridPanel may create and hold onto Panel pointers internally so that the next Panel does not have to be newly created each the createNextPanelIndex field is set. If this is done, it is important to never reuse the current Panel node, as that Panel may still be fading out when the new next Panel needs to be created. A typical use case, where all the right Panels are identical other than the data they display, is to create a single pair of Panel nodes and alternate between them each time the createNextPanelIndex field is set, updating the panel data based on the specified list index.

Fields
------

| Field | Type | Default | Access Permission | Description |
| --- | --- | --- | --- | --- |
| grid | Node | NULL | READ\_WRITE | The grid field should be set to either a PosterGrid or MarkupGrid node to be displayed in the Panel. In general, because the layout of any grid is usually custom, you will generally need to set the grid's itemSize, itemSpacing, numRows and numColumns fields. The GridPanel will position the grid appropriately. |
| leftLabel | Node | Label node | READ\_WRITE | The leftLabel field is set to a Label node that is positioned just above the left/top corner of the grid. Setting the Label node's text field will cause that text string to be displayed. Setting other fields of the Label node can be used to adjust the Label's text color and other visual attributes. |
| rightLabel | Node | Label node | READ\_WRITE | The rightLabel field is set to a Label node that is positioned just above the right/top corner of the grid. Setting the Label node's text field will cause that text string to be displayed. Setting other fields of the Label node can be used to adjust the Label's text color and other visual attributes.  <br>  <br>The rightLabel is often used to display a "1 of N" message that reflects the index of the grid's focused item. |
| showSectionLabels | Boolean | false | READ\_WRITE | If showSectionLabels is set to true and the data for the grid node is divided into sections, the Title attribute of the current section will be displayed as the leftLabel of the grid. As the grid items scroll, the leftLabel will smoothly transition as each section of the grid reaches the focus position. |
| createNextPanelIndex | integer | N/A | READ\_ONLY | When the createNextPanelOnItemFocus field is true, createNextPanel is set when a new panel needs to be created and added to the PanelSet. The value of the field is the index of the grid's content that should be used to create and populate the new panel.  <br>  <br>The createNextPanelIndex field is guaranteed to be set exactly once whenever the next panel for the focused grid item needs to be created. |
| nextPanel | Node | false | WRITE\_ONLY | When the createNextPanelOnItemFocus field is true, the nextPanel field should be set to a Panel node to the next panel to add to the PanelSet in response to the createNextPanelIndex field being set. It must be set immediately in repsonse to the createNextPanelIndex field being set. |
| createNextPanelOnItemFocus | Boolean | true | READ\_WRITE | When set to true, the Create Next Panel mechanism is enabled (i.e. the createNextPanelIndex field will be set when a new grid item receives the focus). When set to false, the Create Next Panel mechanism is disabled (i.e. the createNextPanelIndex field will not be set when a new grid item receives the focus). |

> If you are creating the grid field (either a PosterGrid or MarkupGrid) associated with a GridPanel in script of a component that extends GridPanel, you also need to add the grid as a child of the GridPanel. For example, in a component that extends GridPanel, where m.top is that component, you would associate the grid field with a PosterGrid as follows:

    grid = m.top.createChild("PosterGrid")
    m.top.grid = grid
    

Data bindings
-------------

If the grid's data includes sections and the GridPanel's showSectionLabel's field is set to true, the title field of the section's ContentNode will be used as the text for the left label of the GridPanel.

Sample app
----------

[GridPanelExample](https://github.com/rokudev/samples/tree/master/ux%20components/sliding%20panels/GridPanelExample) is a sample app demonstrating GridPanel in action.

roRegistrySection
=================

A Registry Section enables the organization of settings within the registry. Different registry sections may have their own keys with the same name. In other words, key names are scoped within the registry section to which they belong.

This object must be supplied with a "section" name on creation. If no such section exists, it will be created. Section names are case sensitive, so sections named "Settings" and "settings" are two different sections.

`CreateObject("roRegistrySection", section as String)`

**Example: Get and set some user authentication in the registry**

    Function GetAuthData() As Dynamic
         sec = CreateObject("roRegistrySection", "Authentication")
         if sec.Exists("UserRegistrationToken")
             return sec.Read("UserRegistrationToken")
         endif
         return invalid
    End Function
    
    Function SetAuthData(userToken As String) As Void
        sec = CreateObject("roRegistrySection", "Authentication")
        sec.Write("UserRegistrationToken", userToken)
        sec.Flush()
    End Function
    

Supported interfaces
--------------------

*   [ifRegistrySection](/docs/references/brightscript/interfaces/ifregistrysection.md "ifRegistrySection")

Handling application events
===========================

Observer callback models
------------------------

Roku OS 7.5 introduces a fundamental change in the observer callback model changing from a queued or deferred model to a more intuitive and expected recursive callback model.

### Queued callback model

In Roku OS releases prior to v7.5, callbacks operated in a queued manner.

**Nested functions example**

    function init()
        m.top.observeField("f1", "c1")
        m.top.observeField("f2", "c2")
        m.top.f1 = v1
        print "init(): "; m.top.f2
    end function
    function c1()
        m.top.f2 = v2 ' immediate callback of c2() right here
        print "c1(): "; m.top.f2
    end function      ' deferred callback of c2() on return
    function c2()
        print "c2(): "; m.top.f2
    end function
    

In the nested functions example above, the queued callback model would have the ordering of the print statements as:

**Output**

    c1(): v2
    c2(): v2
    init(): v2
    

### Recursive callback model

With the recursive callback model, the expected output is now more intuitive and the order of the print statements would be:

**Output**

    c2(): v2
    c1(): v2
    init(): v2
    

The `rsg_version` entry in your the manifest file defaults to 1.2. To check and test different SceneGraph versions without refactoring your app, see the guide on [Debugging](/docs/developer-program/debugging/debugging-channels.md)

> Note that support for the [“rsg\_version=1.0"](/docs/developer-program/getting-started/architecture/channel-manifest.md#special-purpose-attributes) manifest flag is deprecated as of Roku OS 8. This deprecation means that the 1.0 features continue to work in Roku OS 8, but will no longer be supported (and thus should not be expected to work) starting with the next major firmware release. All apps must adopt the [current observer callback](/docs/developer-program/core-concepts/handling-application-events.md#recursive-callback-model) model in successive firmware updates.

### Event handling

There are three types of events that can occur in a SceneGraph application that you can use to control the behavior of an application component.

*   User remote control key presses
*   Component and node field value changes, such as state changes of a previously-launched component, and node actions
*   Functional Fields

Handling remote control key presses
-----------------------------------

You can handle remote control key events by writing an [`onKeyEvent()`](/docs/references/scenegraph/component-functions/onkeyevent.md) function in the [<script>](/docs/references/scenegraph/xml-elements/script.md) element of the component you want to handle the key press event. When the component, or its children, have remote control focus, the `onKeyEvent()` function is called whenever an unhandled key event bubbles up the focus chain to the component.

### Using the onKeyEvent() function

The `onKeyEvent()` function takes two parameters, `key` and `press`. The `press` parameter is a Boolean value that is true if the key was pressed, and false if the key was released. The `key` parameter of the `onKeyEvent()` function contains a string, which is case-sensitive, that identifies the key that was pressed. The `key` strings supported by the `onKeyEvent()` function, and the corresponding remote key, are as follows:

![roku815px - rokuremotekeysnew](https://image.roku.com/ZHZscHItMTc2/rokuremotekeysnew-v1.png "rokuremotekeysnew")

| String | Key | Appearance/Icon |
| --- | --- | --- |
| back | **Back** | left-pointing arrow at top of remote |
| up  | **Up** | up-pointing caret of remote directional pad |
| down | **Down** | down-pointing caret of remote directional pad |
| left | **Left** | left-pointing caret of remote directional pad |
| right | **Right** | right-pointing caret of remote directional pad |
| OK  | **OK** | key usually labeled **OK** near or in the center of remote directional pad |
| replay | **Replay** | key usually labeled with a circular-pointing arrow |
| play | **Play/Stop** | key usually labeled with a right-pointing triangle and two bars |
| rewind | **Rewind** | key usually labeled with two left-pointing triangles |
| fastforward | **Fast Forward** | key usually labeled with two right-pointing triangles |
| options | **Options** | key labeled with an asterisk |

The `onKeyEvent()` function must return true if the component handled the event, or false if it did not handle the event. Returning false allows the event to continue bubbling up the focus chain (see [Remote control events](/docs/developer-program/core-concepts/scenegraph-xml/remote-control-events.md)) so that ancestors of the component can handle the event.

Starting from Roku OS 8, the behavior of the Roku system overlay is such that the system overlay now slides in whenever the \* button is pressed, the Video node is in focus, and the app does not have its OnKeyEvent() handler fired. When the Video node is not in focus, the system overlay does not slide in and the OnKeyEvent() handler is fired.

There are one or more keys on any Roku remote control which are not handled by the `onKeyEvent()` function (or any Roku application event handler), such as the **Home** key. Presses of these keys are handled by the global Roku firmware event handler in a default manner that cannot be modified by application code. Also note that several node classes handle certain remote control key events automatically, so `onKeyEvent()` is not required to handle those events, and should not be used for those events in those nodes. As an example of node classes that automatically handle certain remote control key events, grid node classes such as [PosterGrid](/docs/references/scenegraph/list-and-grid-nodes/postergrid.md) automatically handle **Up**, **Down**, **Right**, and **Left** key presses when the poster grid has focus. Typically, you should use the [ifSGNodeField](/docs/references/brightscript/interfaces/ifsgnodefield.md) `observeField()` method to handle changes in the subject node fields caused by automatic key event handling of the node.

### Example

The following `onKeyEvent()` example handles supported remote control key presses other than the **Back** key by displaying a warning message until the **OK** key is pressed.

**onKeyEvent() event handling example**

    function onKeyEvent(key as String, press as Boolean) as Boolean
      handled = false
      if press then
        if (key = "back") then
          handled = false
        else
          if (m.warninglabel.visible = false)
            m.warninglabel.visible="true"
          else
            if (key = "OK") then
              m.warninglabel.visible="false"
            end if
          end if
          handled = true
        end if
      end if
      return handled
    end function
    

Handling node field value changes
---------------------------------

There are two [ifSGNodeField](/docs/references/brightscript/interfaces/ifsgnodefield.md) methods that allow you to create (and remove) observers that continuously monitor any field value of any [roSGNode](/docs/references/brightscript/components/rosgnode.md) object, including the interface fields you have created for custom SceneGraph components:

*   `observeField()`
*   `unobserveField()`

### Using the ifSGNodeField observeField() and unobserveField() methods

`observeField()` is an overloaded method with two versions, useful for different purposes. The first allows you to trigger a specified callback function in response to any change in the value of the observed node field. For example, to set up an observer of a [Timer](/docs/references/scenegraph/control-nodes/timer.md) node `fire` field that calls a `handleexampletimerfire()` event handler function that you write:

`exampletimer.ObserveField("fire", "handleexampletimerfire")`

Once this observer is set up, the component will continuously monitor the `exampletimer` node object `fire` field for the remaining existence of the component or node, or until `unobserveField()` is called (perhaps as part of the event handler function itself):

`exampletimer.unobserveField("fire")`

The event handler function you write must be included in the component <script> element, and manipulate objects within the scope of the component.

By default observers are only called when the value of a field changes. Code that assigns a field value to the same value as currently assigned to the field will not trigger observers. If you want observers to be called any time a field value is set, regardless of the value, an <interface> field must be defined with the `alwaysNotify` attribute set to true.

Here is an example of a field observer and the associated event handler function:

**Field observer XML BrightScript example**

    <script type = "text/brightscript" >
    
      <![CDATA[
    
      sub init()
        m.top.setFocus(true)
        m.bottomlabel = m.top.findNode("bottomLabel")
        m.texttimer = m.top.findNode("textTimer")
        m.defaulttext = "All The Best Videos!"
        m.alternatetext = "All The Time!!!"
        m.textchange = false
        m.texttimer.ObserveField("fire", "changetext")
      end sub
    
      sub changetext()
        if (m.textchange = false) then
          m.bottomlabel.text = m.alternatetext
          m.textchange = true
        else
          m.bottomlabel.text = m.defaulttext
          m.textchange = false
        end if
      end sub
    
      ]]>
    
    </script>
    

> **Optional roSGNodeEvent Callback Function** Argument Field observer callback functions can specify an [roSGNodeEvent](/docs/references/brightscript/events/rosgnodeevent.md) argument. For example, the changetext() callback function signature in the example above could have been written as sub changetext(event as roSGNodeEvent). In this case, the callback function can call the [roSGNodeEvent](/docs/references/brightscript/events/rosgnodeevent.md) functions to extract information about the node that triggered the callback, specific field that triggered the callback, etc.

The second version of `observeField()` lets you specify a message port to notify when the observed field changes:

        `m.texttimer.ObserveField("fire", m.port)`
    

This second case is used when you want a field change to trigger an event in a BrightScript message loop. This is useful when using BrightScript components (such as roChannelStore) which can only be instantiated in the main BrightScript thread or a **Task** node thread. In this case, when the observed field changes, an [roSGNodeEvent](/docs/references/brightscript/events/rosgnodeevent.md) is sent to the port passed to the `observeField()` call. The event `getField()` and `getData()` functions can be called to determine the specific node field that changed, and the new value of the field, respectively.

### Event cascades

Setting the value of a field triggers any field observer functions that may be associated with the field as the result of an observeField() call. These observer functions may set other component fields, triggering calls to their observer functions. Such a situation triggers what is called an **event cascade**. Simply put, this is the chain of field setting and observer function calls that result from setting a single field of a node.

For example, if the width field of a Rectangle that contains a Label is set, an observer of that width field might set the width field of the Label. The width field of the Label might have an observer function that sets the Label’s wrap field. The chain of field settings and observer callback functions that result from setting a field (in this case, the Rectangle’s width field) is an event cascade.

With the release of Roku OS 7.5, nested observer callbacks are no longer deferred. Observer callbacks now happen recursively. See the [Queued Callback Model](/docs/developer-program/core-concepts/handling-application-events.md#queued-callback-model) section above for details.

Handling component <interface> field value changes
--------------------------------------------------

Any <field> element defined in a component [<interface>](/docs/references/scenegraph/xml-elements/interface.md) element can have an observer attached by setting the value of the optional `onChange` attribute. Set the `onChange` attribute to the callback function name that will handle the component field value change.

Note that the <field> element also includes a related optional attribute, `alwaysNotify`. You can set this attribute to true to have the callback function triggered every time the component field value is set, even if the value itself does not change. To have the callback function triggered only when the component field value changes, set the `alwaysNotify` attribute to false.

Functional fields
-----------------

In addition to the field observer model, functions can be called procedurally using the [callFunc() method](/docs/references/brightscript/interfaces/ifsgnodedict.md#callfunc).

MarkupList
==========

Extends [**ArrayGrid**](/docs/references/scenegraph/abstract-nodes/arraygrid.md)

The MarkupList node class is a generic list class that can be used to display a list of items.

The contents of each list item is an instance of an XML component specified by the `itemComponentName` field value. An instance of the XML component is used to display the data for each item in the list data model. The appearance of the list item as it enters/exits the list focus position can be customized using BrightScript.

[SimpleMarkupList](https://github.com/rokudev/samples/tree/master/ux%20components/lists%20and%20grids) is a sample app containing a MarkupList where each item is an instance of an XML component. See the [MarkupList XML component](#markuplist-xml-component) section for details.

**Example**

The following example displays the use of the MarkupList node.

![roku815px - markuplist-node](https://image.roku.com/ZHZscHItMTc2/markuplist-node.png "markuplist-node")

Fields
------

| Field | Type | Default | Access Permission | Description |
| --- | --- | --- | --- | --- |
| itemComponentName | string |     | READ\_WRITE | Specifies the name of a XML component for the list items. An instance of this component is created on demand for each visible item of the list. The XML component must define a specific interface as detailed in [MarkupList XML component](/docs/references/scenegraph/list-and-grid-nodes/markuplist.md#MarkupList-XML-Component) below. |
| content | ContentNode | none | READ\_WRITE | Specifies the content for the list. See [Data bindings](/docs/references/scenegraph/list-and-grid-nodes/markuplist.md#Data-Bindings) below for more details.  <br>If the data contains section markers, section dividers will be drawn between each section. These section dividers may contain an icon and/or a string. |
| itemSize | vector2d | \[0,0\] | READ\_WRITE | Specifies the width and height of each item in the list |
| itemSpacing | vector2d | \[0,0\] | READ\_WRITE | The second value of the vector specifies the vertical spacing between items in the list. The first value of the vector is ignored. |
| numRows | integer | 12  | READ\_WRITE | Specifies the number of visible rows displayed. The actual number of rows may be more or less than the number of visible rows specified depending on the number of items in the list content. |
| drawFocusFeedback | Boolean | true | READ\_WRITE | Specifies whether or not the focus indicator bitmap is displayed |
| drawFocusFeedbackOnTop | Boolean | false | READ\_WRITE | Specifies whether the focus indicator bitmap is drawn below or on top of the list items |
| focusBitmapUri | uri |     | READ\_WRITE | Specifies the bitmap file used for the focus indicator when the list has focus. In most cases, this should be a 9-patch image that specifies both expandable regions as well as margins. Only set this field to specify a custom bitmap that differs in appearance from the default bitmap. |
| focusFootprintBitmapUri | uri |     | READ\_WRITE | Specifies the bitmap file used for the focus indicator when the list does not have focus. In most cases, this should be a 9-patch image that specifies both expandable regions as well as margins. Only set this field to specify a custom bitmap that differs in appearance from the default bitmap. |
| focusBitmapBlendColor | color | 0xFFFFFFFF | READ\_WRITE | Blend the graphic image specified by `focusBitmapUri` with the specified color. If set to the default, 0xFFFFFFFF, no color blending will occur. Set this field to show a focus indicator graphic image with a different color than the image specified by `focusBitmapUri.` |
| focusFootprintBlendColor | color | 0xFFFFFFFF | READ\_WRITE | Blend the graphic image specified by `focusFootprintBitmapUri` with the specified color. If set to the default, 0xFFFFFFFF, no color blending will occur. Set this field to show a focus footprint indicator graphic image with a different color than the image specified by `focusFootprintBitmapUri`. |
| wrapDividerBitmapUri | uri |     | READ\_WRITE | Specifies the bitmap file to use as a wrap divider, the visual separator between the last and first list items when the list wraps. In most cases, this should be a 9-patch image that specifies both expandable regions. Only set this field to specify a custom bitmap that differs in appearance from the default bitmap. |
| wrapDividerHeight | float | 0.0 | READ\_WRITE | Specifies the height of the wrap divider, the visual separator between the last and first list items when the list wraps. The bitmap for the wrap divider is scaled to this height. The width of the wrap divider is set to the width of the list items as specified by the `itemSize` field width value. |
| sectionDividerBitmapUri | uri |     | READ\_WRITE | If the ContentNode specifies sections for a list or grid, specifies a custom bitmap to use as a visual divider between the sections of the list or grid. Only set this field to use a bitmap with a different appearance than the system default. For sections that do not include an icon or a title, the system default or custom bitmap specified as the `wrapDividerBitmapUri` field value is used for the section dividers. In most cases, you will want to use a 9-patch PNG bitmap with both expandable regions, which is the type of bitmap used as the system default. |
| sectionDividerFont | font | system default | READ\_WRITE | Specifies the font for section divider labels |
| sectionDividerTextColor | color | 0xddddddff | READ\_WRITE | Specifies the text color for section divider labels |
| sectionDividerSpacing | float | 10  | READ\_WRITE | If the ContentNode specifies sections for a list or grid, and the section dividers are specified to include an icon and/or a label, specifies the spacing between the icon, label, and section divider bitmap. |
| sectionDividerHeight | float | 40  | READ\_WRITE | Specifies the height of the section dividers. The width of the section dividers is determined by the width of the list items as specified by the itemSize field width value. |
| sectionDividerMinWidth | float | 117 | READ\_WRITE | Specifies the minimum width of the section divider bitmap. The section divider label will be ellipsized if necessary in order to ensure that the section divider bitmap meets the minimum width. |
| sectionDividerLeftOffset | float | 0   | READ\_WRITE | Number of pixels to offset the left edge of the section divider relative to the left edge of the list items. |
| itemSelected | integer | 0   | READ\_ONLY | When a list item is selected, itemSelected is set to the index of the selected item. |
| itemFocused | integer | 0   | READ\_ONLY | When a list item gains the key focus, set to the index of the focused item. |
| itemUnfocused | integer | 0   | READ\_ONLY | When a list item loses the key focus, set to the index of the unfocused item. |
| jumpToItem | integer | 0   | WRITE\_ONLY | When set to a valid item index, this causes the list to immediately update so that the specified index moves into the focus position. |
| animateToItem | integer | 0   | WRITE\_ONLY | When set to a valid item index, this causes the list to quickly scroll so that the specified index moves into the focus position. |
| itemClippingRect | rect2d | \[ 0.0, 0.0, 0.0, 0.0 \] | READ\_WRITE | Specifies a clipping region for the list or grid items |

### MarkupList XML Component

The **MarkupList** node `itemComponentName` field value should be set to the name of an XML component used to display each item in the list. An instance of this component is created for each visible item in the list.

If the XML component contains interface fields that match the names shown in the table below, those fields will be updated by the **MarkupList** node. This allows the XML component to alter the item appearance based on changes to these interface fields.

Note that the fields are updated in the order presented in the table below. Any layout scripting you write based on these fields should be done in that order to avoid updating your layout based on a field that has not been updated yet.

| Field Name | Field Type | Access Permission | Description |
| --- | --- | --- | --- |
| width | float | READ\_ONLY | Set to the width of the list item. |
| height | float | READ\_ONLY | Set to the height of the list item |
| index | integer | READ\_ONLY | Set to the index of this item in the data model. |
| listHasFocus | Boolean | READ\_ONLY | Set to true if the **MarkupList** node has focus, false otherwise. |
| itemContent | **ContentNode** | READ\_WRITE | Contains the data to be displayed by the list item. The relationship between data in the **ContentNode** node and the visual elements of the list item is determined by the scripts in the item XML component. Typically, an observer of the `itemContent` field is used to update the list item when the content changes. |
| focusPercent | float | READ\_ONLY | The fractional value, from 0.0 to 1.0, of a time delay after focus has moved from one item to the next. The fractional value increases incrementally from 0.0 to 1.0 for the newly-focused item, while simultaneously decreasing from 1.0 to 0.0 for the previously-focused item. This value can be used as a timing key to smoothly animate the appearance of the focused item as well as the previously-focused item, to indicate the movement of focus to the user. |
| itemHasFocus | Boolean | READ\_ONLY | Indicates whether the item component currently is the MarkupList's focused item. When scrolling starts, the itemHasFocus field for the currently focused item is set to false. When scrolling ends, the itemHasFocus field for the newly focused item is set to true. During the scrolling animation, all itemHasFocus fields are set to false.Only one item component of any MarkupList should have itemHasFocus set to true. If the MarkupList does not focus, all itemHasFocus fields of their item components should be set to false. |

### Example MarkupList XML Component

The following shows an example **MarkupList** node XML component. The XML markup defines a component named `SimpleListItem` that displays a poster as an icon, and two labels on the right for each list item. The labels are arranged vertically, with the top label having a larger font than the bottom one.

To use this component, set the value of the `itemComponentName` field of a **MarkupList** node to `SimpleListItem`.

Note that the `index` interface field is not used by the component, so it is not included in the component interface.

Also note how the `focusPercent` interface field has an `onChange` function defined that changes the color of the label text as the item enters/leaves the focus region of the list.

**Markup List XML Component Example**

    <?xml version="1.0" encoding="utf-8" ?>
    
    <component name="SimpleListItem" extends="Group">
    
    <interface> 
      <field id="width" type="float" onChange="widthChanged"/> 
      <field id="height" type="float" onChange="heightChanged"/> 
      <field id="itemContent" type="node" onChange="itemContentChanged"/> 
      <field id="focusPercent" type="float" onChange="focusPercentChanged"/> 
      <field id="listHasFocus" type="bool" onChange="focusPercentChanged"/> 
    </interface>
    
    <script type="text/brightscript" >
    <![CDATA[ 
      function itemContentChanged() 
        m.itemImage.uri = m.top.itemContent.HDPOSTERURL
        m.itemText.text = m.top.itemContent.TITLE
        m.itemArtist.text = m.top.itemContent.ARTISTS[0] 
        updateLayout()
      end function
    
      function widthChanged() 
        updateLayout()
      end function
    
      function heightChanged() 
        updateLayout()
      end function
    
      function focusPercentChanged() 
        if m.top.listHasFocus and m.top.focusPercent > 0.5 
          m.itemText.color = "0x000000FF" 
        else 
          m.itemText.color = "0xFFFFFFFF" 
        end if 
        m.itemArtist.color = m.itemText.color
      end function
    
      function updateLayout() 
        if m.top.height > 0 and m.top.width > 0 
          posterSize = m.top.height
          m.itemImage.width = m.top.height - 20 ' make the posters square 
          m.itemImage.height = m.top.height - 20
          m.itemText.width = m.top.width - m.itemImage.width - 20 
          m.itemArtist.width = m.top.width - m.itemImage.width - 20 
        end if
      end function
    
      function init() 
        m.itemText = m.top.findNode("itemText") 
        m.itemArtist = m.top.findNode("itemArtist") 
        m.itemImage = m.top.findNode("itemImage")
        m.playIcon = m.top.findNode("playIcon")
      end function
    ]]>
    </script>
    
    <children>
    
    <LayoutGroup layoutDirection="horizontal" vertAlignment="center" itemSpacings="20" translation="[0,34]" > 
      <Poster id="itemImage" /> 
      <LayoutGroup layoutDirection="vertical" horizAlignment="left" itemSpacings="0" > 
         <Label id="itemText" font="theme:MediumSystemFont" /> 
         <Label id="itemArtist" font="theme:SmallestSystemFont" /> 
       </LayoutGroup>
    </LayoutGroup>
    
    </children>
    </component>
    

### Data Bindings

A **MarkupList** node should have a single **ContentNode** node as the root node in its content field. The structure of the rest of the data model depends on whether or not the list items are to be grouped into sections.

#### List Items Not Grouped Into Sections

If the list items are not to be grouped into sections, one child **ContentNode** node should be added to the root node for each item in the list (these child nodes can be thought of as _item nodes_). Item nodes should contain the data required by the **MarkupList** node XML component.

#### List Items Grouped Into Sections

If the list items are to be grouped into sections, one child **ContentNode** node should be added to the root node for each section in the list (these child nodes can be thought of as _section roots_). Each section root should contain one child **ContentNode** node for each item in the section (that is, item nodes). The item nodes should contain the data required by the **MarkupList** node XML component.

The section root **ContentNode** nodes use the following attributes:

| Attribute | Type | Description |
| --- | --- | --- |
| CONTENTTYPE | string | Must be set to `SECTION` |
| TITLE | string | Label for the section divider |
| HDGRIDPOSTERURL | uri | The image file for the icon to be displayed to the left of the section label when the screen resolution is set to HD. |
| SDGRIDPOSTERURL | uri | The image file for the icon to be displayed to the left of the section label when the screen resolution is set to SD. |

Sample app
----------

[MarkupListExample](https://github.com/rokudev/samples/tree/master/ux%20components/lists%20and%20grids/MarkupListExample) is a sample app demonstrating MarkupList in action.

RadioButtonList
===============

Extends [**LabelList**](/docs/references/scenegraph/list-and-grid-nodes/labellist.md)

The RadioButtonList node class is a simple list class that can be used to display a list of mutually exclusive radio buttons. Each item in the list displays a text string and an optional check mark icon positioned to the left of the text string that indicates which of the radio buttons is currently selected.

Example
-------

The following is an example screenshot showing the use of RadioButtonList:

![roku815px - radiobutton-screen](https://image.roku.com/ZHZscHItMTc2/radiobutton-screen.png "radiobutton-screen")

Fields
------

| Field | Type | Default | Access Permission | Description |
| --- | --- | --- | --- | --- |
| checkedItem | integer | \-1 | READ\_WRITE | Specifies the index of the currently selected item in the list. The initial default value of -1 indicates that no radio button is currently selected. Setting the field changes the currently selected radio button list item to match the specified index. |
| checkOnSelect | Boolean | true | READ\_WRITE | Controls whether or not pressing the remote control OK key causes the `checkedItem` field value to be automatically updated to the index of the currently focused list item. By default, the field value is set to true, but there are use cases where other behavior may be desired. In those cases, it is up to the developer to manage the currently selected radio button by setting the checkedItem field value to the desired index. |
| checkedIconUri | uri | ""  | READ\_WRITE | Specifies the check mark icon to use for the currently selected radio button list item when that list item does not have the key focus. Only set this field to specify a custom bitmap that differs in appearance from the default bitmap. |
| focusedCheckedIconUri | uri | ""  | READ\_WRITE | Specifies the check mark icon to use for the currently selected radio button list item when that list item has the key focus. Only set this field to specify a custom bitmap that differs in appearance from the default bitmap. |

Data bindings
-------------

The data model for the RadioButtonList node should have a single ContentNode as the root node, with one child ContentNode added to the root node for each item in the list (these child nodes can be thought of as `item nodes`). Item nodes should have their ContentNode attributes set as shown in the table below.

| Attribute | Type | Description |
| --- | --- | --- |
| TITLE | string | The label for the list item |

Sample app
----------

[RadioButtonListExample](https://github.com/rokudev/samples/tree/master/ux%20components/lists%20and%20grids/RadioButtonListExample) is a sample app demonstrating RadioButtonList in action.

ifInt
=====

> Interface equivalent for intrinsic type 'Integer'

Implemented by
--------------

| Name | Description |
| --- | --- |
| [roInt](/docs/references/brightscript/components/roint.md "roInt") | Object equivalent for intrinsic type Integer |

Supported methods
-----------------

### GetInt() As Integer

#### Description

Gets the integer value stored in the calling Integer object.

#### Return Value

The integer value stored in the calling Integer object.

### SetInt(value As Integer) As Void

#### Description

Sets the calling Integer object to the specified integer value.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| value | Integer | The integer value to be set on the calling Integer object. |

Animation
=========

Extends [**AnimationBase**](/docs/references/scenegraph/abstract-nodes/animationbase.md)

The Animation node class provides animations of renderable nodes, by applying interpolator functions to the values in specified renderable node fields. For an animation to take effect, an Animation node definition must include a child field interpolator node ([FloatFieldInterpolator](/docs/references/scenegraph/animation-nodes/floatfieldinterpolator.md "FloatFieldInterpolator"), [Vector2DFieldInterpolator](/docs/references/scenegraph/animation-nodes/vector2dfieldinterpolator.md "Vector2DFieldInterpolator"), [ColorFieldInterpolator](/docs/references/scenegraph/animation-nodes/colorfieldinterpolator.md "ColorFieldInterpolator")) definition for each renderable node field that is animated.

The Animation node class provides a simple linear interpolator function, where the animation takes place smoothly and simply from beginning to end. The Animation node class also provides several more complex interpolator functions to allow custom animation effects. For example, you can move a graphic image around the screen at differing speeds and curved trajectories at different times in the animation by specifying the appropriate function in the easeFunction field (quadratic and exponential are two examples of functions that can be specified). The interpolator functions are divided into two parts: the beginning of the animation (ease-in), and the end of the animation (ease-out). You can apply a specified interpolator function to either or both ease-in and ease-out, or specify no function for either or both (which is the linear function). You can also change the portion of the animation that is ease-in and ease-out to arbitrary fractional values for a quadratic interpolator function applied to both ease-in and ease-out.

### Example

[Animation Markup](https://github.com/rokudev/samples/tree/master/ux%20components/lists%20and%20grids/PosterGridExampleanimation-markup.md "Animation Markup") in the [SceneGraph Samples](https://github.com/rokudev/samples/tree/master/ux%20components/lists%20and%20grids/PosterGridExampleoverview.md "SceneGraph Samples") provides several simple examples of Animation node definitions that use all of the field interpolator nodes. Other simple examples of using the field interpolators can be found in the [FloatFieldInterpolator](/docs/references/scenegraph/animation-nodes/floatfieldinterpolator.md "FloatFieldInterpolator"), [Vector2DFieldInterpolator](/docs/references/scenegraph/animation-nodes/vector2dfieldinterpolator.md "Vector2DFieldInterpolator"), and [ColorFieldInterpolator](/docs/references/scenegraph/animation-nodes/colorfieldinterpolator.md "ColorFieldInterpolator").

The following example shows how to use some simple animations. It uses two Animation nodes, each with its own Vector2DFieldInterpolator. The first defines a translation animation of the poster image, and the second defines a scale animation. They are both launched in an init() function using BrightScript. When run together, the effect is to "bloom" the poster image on the screen.

#### Animation BrightScript example

    function init()
       scaleAnimation = m.top.FindNode("scaleAnimation")
       transAnimation = m.top.FindNode("transAnimation")
       scaleAnimation.control = "start"
       transAnimation.control = "start"
    end function
    

#### Animation XML example

    <?xml version="1.0" encoding="utf-8" ?>
    <component name="SimpleScaleAnimation" extends="Group" >
    <script type="text/brightscript" uri="pkg:/xml/SimpleAnimation.brs" />
    
    <children>
    
    <Poster id="myPoster"
        opacity="1.0"
        uri="pkg:/images/myImage.jpg" />
    <Animation id="scaleAnimation"
           duration="1"
           repeat="true"
           easeFunction="linear" >
        <Vector2DFieldInterpolator id = "myInterp"
        key="[0.0, 0.25, 0.5, 0.75, 1.0]"
        keyValue="[ [0.0, 0.0], [0.25, 0.25], [0.5, 0.5], [0.75, 0.75], [1.0, 1.0]]"
        fieldToInterp="myPoster.scale" />
    </Animation>
    <Animation id="transAnimation"
           duration="1"
           repeat="true"
           easeFunction="linear" >
        <Vector2DFieldInterpolator id = "myInterp2"
            key="[0.0, 1.0]"
            keyValue="[ [640.0, 320.0], [100.0, 100.0] ]"
        fieldToInterp="myPoster.translation" />
    </Animation>
    
    </children>
    
    </component>
    

Fields
------

FieldTypeDefaultAccess PermissionDescriptiondurationTime0READ\_WRITESets the duration of the animation in secondseaseFunctionstring"outCubic"READ\_WRITESpecifies the interpolator function to be used for the animation:

| Value | Ease-In/Ease-Out Function |
| --- | --- |
| linear | No ease-in or ease-out |
| inQuad | Quadratic ease-in function, no ease-out |
| inCubic | Cubic ease-in function, no ease-out |
| inQuartic | Quartic ease-in function, no ease-out |
| inQuintic | Quintic ease-in function, no ease-out |
| inExpo | Exponential ease-in function, no ease-out |
| outQuad | Quadratic ease-out function, no ease-in |
| outCubic | Cubic ease-out function, no ease-in |
| outQuartic | Quartic ease-out function, no ease-in |
| outQuintic | Quintic ease-out function, no ease-in |
| outExpo | Exponential ease-out function, no ease-in |
| inOutQuad | Quadratic ease-in and ease-out function |
| inOutCubic | Cubic ease-in and ease-out function |
| inOutQuartic | Quartic ease-in and ease-out function |
| inOutQuintic | Quintic ease-in and ease-out function |
| inOutExpo | Exponential ease-in and ease-out function |
| piecewise | Quadratic ease-in and ease-out function with extra control over the percentage of the duration during which ease-in and ease-out occurs. The extra control is specified using the `easeInPercent` and `easeOutPercent` fields. |

easeInPercentfloat0.5READ\_WRITEIf easeFunction is set to piecewise, easeInPercent sets the percentage of the animation duration during which ease-in is applied. Note that the values of easeInPercent plus easeOutPercent must be less than or equal to 1. For all other values of easeFunction, easeInPercent is ignoredeaseOutPercentfloat0.5READ\_WRITEIf easeFunction is set to piecewise, easeOutPercent sets the percentage of the animation duration during which ease-out is applied. Note that the values of easeInPercent plus easeOutPercent must be less than or equal to 1. For all other values of easeFunction, easeOutPercent is ignoredoptionalbooleanfalseREAD\_WRITESet to true to skip animations on lower performing Roku devices. See [Roku Devices](/docs/specs/hardware.md#current-models "Roku Devices") for model numbers and code names. When an Animation has optional set to true, setting the control field to start will cause the state field to change to running and immediately change again to finished. These state changes allow any logic tied to state field observers that run at the start and end of the Animation to be properly calledwillBeSkippedbooleanfalseREAD\_ONLYIndicates whether the animation runs or jumps to the end (effectively skipping the animation and rendering it in its final state).

Sample app
----------

[SimpleAnimation](https://github.com/rokudev/samples/tree/master/ux%20components/animation) demonstrates Animation in action.

InfoPane
========

The **InfoPane** node class is used to display an opaque, white-bordered, rounded rectangular label with text providing help for a specific setting. This component can be used to help customers successfully configure settings related to their account profile, closed captioning, parental controls, and so on.

![roku815px - info-pane](https://image.roku.com/ZHZscHItMTc2/infopane.jpg "info-pane")

Fields
------

| Field Name | Type | Default | Access Permission | Description |
| --- | --- | --- | --- | --- |
| infoText | string | none | READ\_WRITE | The text to be displayed in the label. |
| width | integer | 0   | READ\_WRITE | The width of the label. |
| height | integer | 0   | READ\_WRITE | The height of the label. |
| textColor | color | 0xFFFFFFFF | READ\_WRITE | The color of the text displayed in the label. |
| bulletText | array of strings | none | READ\_WRITE | List of strings preceded by a bullet (for example, \["Bullet 1","Bullet 2"\]). |
| infoText2 | string | none | READ\_WRITE | A second text string that can be offset from the first. |
| infoText2Color | color | 0xFFFFFFFF | READ\_WRITE | Specifies the **infoText2** string color |
| infoText2BottomAlign | boolean | false | READ\_WRITE | Specifies whether the **infoText2** string is vertically aligned to the bottom of the info pane |

Sample app
----------

You can download and install a [sample app](https://github.com/rokudev/samples/tree/master/ux%20components/screen%20elements/renderable%20nodes/InfoPaneExample) that demonstrates how to use the InfoPane node.

SceneGraph localization
=======================

You can supply localized versions of the strings and package graphical images used in a SceneGraph application package. The SceneGraph application can then automatically insert the localized versions of the strings and graphical images that you supply, according to the current locale as set by the user.

You can also localize your application from your server using URL directives based on the current locale as set by the user.

> The application package localization features rely on the locales and locale IDs currently supported by Roku. The list of these supported locales can be found in the description of the [ifDeviceInfo](/docs/references/brightscript/interfaces/ifdeviceinfo.md) `GetCurrentLocale()` method.

Localizing strings in the application package
---------------------------------------------

For each string to be localized, provide localized translations of the string, in as many languages as you want that are currently supported by Roku. You can provide localized strings in either the TS or XLIFF XML localization file formats as supported by Roku. The string localization files should be placed in the `pkg:/locale/` subdirectory for the supported locale. For example, if you want to include a `translations.ts` localization file in the TS format for Canadian French, place the file in the `pkg:/locale/` subdirectory named for the locale ID `fr_CA`:

    pkg:/locale/fr_CA/translations.ts
    

For strings defined in XML markup in a <children> element, or <interface> element field strings, the strings will be automatically translated by the SceneGraph application, if translations of the string exist in the localization files. If no translation file exists for the current locale, or no translation of the string exists in the translation file, the original string will be used.

> All field values set in markup will be translated if the string value has a corresponding entry in a translation file. Roku best practices therefore strongly recommend initializing RSG field values that need to be localized in the corresponding BrightScript Init() function.

For strings assigned using BrightScript in a <script> element, you can use the [`tr()`](/docs/references/brightscript/language/global-utility-functions.md#trsource-as-string-as-string) function to localize a string, if you have provided a translation of the string in a `translations.xml` file in the XLIFF XML format in the package directory `pkg:/locale/locale_ID/` directory. The `tr()` function is a global BrightScript utility function that looks for the string in the `translations.xml` file, then finds the corresponding string translation in the file for the current locale. To use the `tr()` function to localize a specific _source_ string:

    tr(String source) as String
    

For example, to translate the string "hello world" in BrightScript:

    m.greetinglabel.text = tr("hello world")
    

The `tr()` function will look for the `pkg:/locale/locale_ID/translations.xml` file, and look in the file for the "hello world" source string. If the source string exists in the file, with a translated string, the translated string will be returned, and assigned to the `text` field of the [**Label**](/docs/references/scenegraph/label-nodes/label.md) node object `m.greetinglabel`. If no translation file exists, or the source string and translated string does not exist in the file, the original source string will be returned, and assigned to the `text` field.

The `tr()` function also supports string substitutions. For example:

    text = tr("Video will start in %1 seconds").Replace("%1", numSeconds.ToStr())
    

Localizing graphical images in the application package
------------------------------------------------------

For each graphical image to be localized, provide each localized image in the `pkg:/locale/` directory, in as many languages as you want that are currently supported by Roku. Then use the following format for the value of the `uri` field of the [Poster](/docs/references/scenegraph/renderable-nodes/poster.md) node:

    pkg:/locale/images/localized_image
    

For example, to provide a localized version of `myPoster.jpg`, set the Poster node `uri` field as follows:

    <Poster uri = pkg:/locale/images/myPoster.jpg />
    

This causes the application to search through the `pkg:/locale` directory in the following order to find the localized graphical image. The first graphical image of the specified name found in this search sequence is returned to be rendered by the SceneGraph application.

1.  not localized  
    `pkg:/locale/images/image_name`
2.  current locale  
    `pkg:/locale/locale_id/images/image_name`
3.  default  
    `pkg:/locale/default/images/image_name`
4.  US English  
    `pkg:/locale/en_US/images/image_name`

If none of those files exist, the URL access will fail to return a file.

For example, if you want to have a localized version of a graphical image for Canadian French, and a default image for all other languages, place two versions of the image in the `pkg:/locale` directory as follows:

`pkg:/locale/fr_CA/images/image_name_canadian_french` `pkg:/locale/default/images/image_name_default`

In Brightscript in a <script> element, you can also use the getLocalizedAsset() method in [ifLocalization](/docs/references/brightscript/interfaces/iflocalization.md) to get a localized graphical image.

For example:

    localize = createObject("RoLocalization")
    bannerposter = m.top.findNode("bannerPoster")
    bannerposter.uri = localize.GetLocalizedAsset("images", "banner.png")
    

Is equivalent to:

    bannerposter = m.top.findNode("bannerPoster")
    bannerposter.uri = "pkg:/locale/images/banner.png"
    

TS file example
---------------

The following is an example of a `translations.ts` file in the TS XML format placed in the `pkg:/locale/fr_CA` directory to translate English to Canadian French:

**Example of a translations.ts file in the TS XML format**

    <?xml version="1.0" encoding="utf-8"?>
    <!DOCTYPE TS>
    <TS version="2.0" language="fr_CA" sourcelanguage="en_US">
    <defaultcodec>UTF-8</defaultcodec>
    <context>
      <name>default</name>
      <message>
        <source>Hello</source>
        <translation>Bonjour</translation>
      </message>
      <message>
        <source>Goodbye</source>
        <translation>Au revoir</translation>
      </message>
      <message>
        <source>Christmas</source>
        <translation>Noel</translation>
      </message>
    </context>
    </TS>
    

XLIFF file example
------------------

The following is an example of a `translations.xml` file in the XLIFF XML format placed in the `pkg:/locale/fr_CA` directory to translate English to Canadian French:

**Example of a translations.xml file in the XLIFF XML format**

    <?xml version="1.0" encoding="UTF-8"?>
    <xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2">
    <file source-language="en-US" target-language="fr-CA" >
    <body>
      <trans-unit id="0">
        <source>Hello</source>
        <target>Bonjour</target>
      </trans-unit>
      <trans-unit id="1">
        <source>Goodbye</source>
        <target>Au revoir</target>
      </trans-unit>
    </body>
    </file>
    </xliff>
    

Localizing content
------------------

Apps can identify the region associated with a customer's Roku account to determine which content to display in the app UI. For example, apps can [get the external IP address of a Roku device](/docs/references/brightscript/interfaces/ifdeviceinfo.md#getexternalip-as-string) client-side, and return it back to the app's backend server. In the backend, the app can get the country ranges mapped to the IP address in order to determine which content to show to the customer and allow streaming. See [Channel localization](/docs/developer-program/getting-started/channel-localization.md) for how publishers should consider localization in the development, distribution, engagement, and monetization of their apps

ifStringOps
===========

Implemented by
--------------

| Name | Description |
| --- | --- |
| [roString](/docs/references/brightscript/components/rostring.md "roString") | Object equivalent for intrinsic type 'String' |

Supported methods
-----------------

> ifStringOps provides various methods for manipulating string objects. Some of these duplicate functionality also available in the [global string functions](/docs/references/brightscript/language/brightscript-language-reference.md "global string functions").
> 
> Note that the ifStringOps string indices start at 0; they do not start at 1 like global string functions.

### SetString(s as String, len as Integer) as Void

#### Description

Sets the roString object to the specified first set of characters of the provided string.

The [ifString interface](/docs/references/brightscript/interfaces/ifstring.md) includes a similar function, [ifString.SetString()](/docs/references/brightscript/interfaces/ifstring.md#setstringvalue-as-string-as-void), which does not take a length parameter.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| s   | String | The source string to be used for setting the roString object. |
| len | Integer | The first number of characters in the source string to which the roString object is to be set. |

### AppendString(s as String, len as Integer) as Void

#### Description

Appends the specified first set of characters of the provided string to the end of the roString object.

The AppendString() function modifies the object on which it is called, which can result in unexpected results if called on a literal string constant rather than a string object. Consider the following example:

    x = "one"
    print type(x) ' prints "String"
    x.AppendString("two", 3)
    print x ' will print "one" not "onetwo"
    
    y = box("one")
    print type(y) ' prints "roString"
    y.AppendString("two", 3)
    print y ' will print "onetwo"
    

The third line does not appear to do an append, but it is working as designed since the append happens to the temporary boxed object. x="string" sets x to the intrinsic type, vs. y=box("string"), which works as expected.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| s   | String | The source string to be used for appending characters to the roString object. |
| len | Integer | The first number of characters in the source string to append to the roString object. |

### Len() as Integer

#### Description

Returns the number of characters in the string.

#### Return Value

Number of characters.

### Left(len as Integer) as String

#### Description

Returns a string consisting of the first len characters of the string.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| len | Integer | The first number of characters in the roString object to be retrieved. |

#### Return Value

The string generated by the method.

### Right(len as Integer) as String

#### Description

Returns a string consisting of the last len characters of the string.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| len | Integer | The last number of characters in the roString object to be retrieved. |

#### Return Value

The string generated by the method.

### Mid(start\_index as Integer) as String

#### Description

Returns a string consisting of the last characters of the string, starting at the zero-based start\_index.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| start\_index | Integer | The position in the roString object from which to return the remaining characters. |

#### Return Value

The string generated by the method.

### Mid(start\_index as Integer, num\_chars as Integer) as String

#### Description

Returns a string consisting of num\_chars characters of the string, starting at the zero-based start\_index. If there are fewer than num\_chars in the string after start\_index, returns the remaining characters in the string.

`s.Left(len)` is equivalent to `s.Mid(0, len)``s.Right(len)` is equivalent to `s.Mid(s.Len() - len`.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| start\_index | Integer | The position in the roString object from which to return the number of characters specified by num\_chars. |
| num\_chars | Integer | The number of characters in the remaining part of the roString object to be retrieved. |

### Instr(substring as String) as Integer

#### Description

Returns the zero-based index of the first occurrence of substring in the string. If the substring does not occur in the string, this method returns -1

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| substring | String | The substring within the roString object to be returned. |

#### Return Value

The index of the first instance of the substring within the string.

### Replace(fromStr As String, toStr As String) As String

#### Description

Returns a copy of the string with all instances of **fromStr** replaced with **toStr**. If **fromStr** is empty the return value is the same as the source string.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| fromStr | String | The string of characters within the roString object to be replaced. |
| toStr | String | The string of characters that will replace all instances of the **from** string. |

#### Return Value

A copy of the string with all the instances

#### Example

    print "a-b-c".Replace("-", "/")
    
    ' result is "a/b/c"
    

### Instr(start\_index as Integer, substring as String) as Integer

#### Description

Returns the zero-based index of the first occurrence of substring in the string, starting at the specified zero-based start\_index. If the substring does not occur in the string after start\_index, returns -1

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| start\_index | Integer | The position in the roString object from which to start looking for and returning the **substring**. |
| substring | String | The substring within the roString object to be found. |

#### Return Value

The index of the first instance of the substring within the string, based on the specified starting position.

### Trim() as String

#### Description

Returns the string with any leading and trailing whitespace characters (space, TAB, LF, CR, VT, FF, NO-BREAK SPACE, et al) removed.

#### Return Value

The trimmed string.

### ToInt() as Integer

#### Description

Returns the value of the string interpreted as a decimal number.

#### Return Value

The decimal number representation of the string.

### ToFloat() as Float

#### Description

Returns the value of the string interpreted as a floating point number.

#### Return Value

The floating point number representation of the string.

### Tokenize(delim as String) as Object

#### Description

Splits the string into separate substrings separated by a single delimiter character.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| delim | String | A set of characters which are treated as delimiters. A sequence of two or more contiguous delimiters in the string is treated as a single delimiter. |

#### Return Value

An roList containing the each of the substrings. The delimiters are not returned.

### Split(separator as String) as Object

#### Description

Splits the input string using the separator string as a delimiter. An empty separator string indicates to split the string by character.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| separator | String | The delimiter to be used to parse the roString object. |

#### Return Value

An array of the split token strings (not including the delimiter).

#### Examples

    a = "".Split("")
    
    'creates the array equivalent to
    a = []
    

    a = "123".Split("")
    
    'creates the array equivalent to
    a = ["1", "2", "3"]
    

    a = "123".Split("/")
    
    'creates the array equivalent to
    a = ["123"]
    

    a = "/123/".Split("/")
    
    'creates the array equivalent to
    a = ["", "123", ""]
    

    a = "one, two, three".Split(", ")
    
    'creates the array equivalent to
    a = ["one", "two", "three"]
    

### GetEntityEncode() as String

#### Description

Returns the string with the following characters replaced with their corresponding HTML entity encoding sequences below:

| Character | Replaced with |
| --- | --- |
| " (double quote) | \\" |
| ' (single quote) | \\' |
| <   | \\< |
| \>  | \\> |
| &   | \\& |

#### Return Value

The encoded string.

### Escape() as String

#### Description

URL encodes the specified string per [RFC 3986](https://www.ietf.org/rfc/rfc3986.txt "RFC 3986") and returns the encoded string. Non-ASCII characters are encoded as UTF-8 escape sequences. This functionality is essentially the same as roUrlTransfer.Escape, but without the overhead of creating a roUrlTransfer object.

> Use the EncodeUri or EncodeUriComponent methods instead.

#### Return Value

The URL-encoded version of the specified string.

#### Example

    s = "@&=+/#!*"
    t = s.Escape()
    print """" + t + """"
    REM "%40%26%3D%2B%2F%23%21%2A"
    
    ' escaped characters are encoded as UTF-8 sequences
    s = Chr(&h2022)
    t = s.Escape()
    print """" + t + """"
    REM "%E2%80%A2"
    

### Unescape() as String

#### Description

URL decodes the specified string per [RFC 3986](https://www.ietf.org/rfc/rfc3986.txt "RFC 3986") and returns the decoded string.

The functionality is essentially the same as [roUrlTransfer](/docs/references/brightscript/components/rourltransfer.md). Unescape, but without the overhead of creating a roUrlTransfer object.

If the escaped string includes invalid escape sequences, the decode will fail and an empty string will be returned.

> Consider using the [DecodeUri](#decodeuri-as-string) or [DecodeUriComponent](#decodeuricomponent-as-string) method instead.

#### Return Value

The URL-decoded string.

#### Example

    t = "%3B%3F%3A%24%2C%28%29"
    s = t.Unescape()
    print """" + s + """"
    REM ";?:$,()"
    

### EncodeUri() as String

#### Description

Encodes the specified string with escape sequences for reserved Uniform Resource Identifier (URI) characters. Non-ASCII characters are encoded as UTF-8 escape sequences.

#### Return Value

The provided string encoded as a Uniform Resource Identifier (URI).

#### Example

    s = "http://roku.com/my test.asp?first=jane&last=doe"
    t = s.EncodeUri()
    print """" + t + """"
    REM "http://roku.com/my%20test.asp?first=jane&last=doe"
    

### DecodeUri() as String

#### Description

Decodes the specified string with escape sequences for reserved Uniform Resource Identifier (URI) characters. If the escaped string includes invalid escape sequences, the decode will fail and an empty string will be returned.

#### Return Value

An unencoded version of the provided encoded Uniform Resource Identifier (URI).

#### Example

    t = "http://roku.com/my%20test.asp?first=jane&last=doe"
    s = t.DecodeUri()
    print """" + s + """"
    REM "http://roku.com/my test.asp?first=jane&last=doe"
    

### EncodeUriComponent() as String

#### Description

Encodes the specified string with escape sequences for reserved Uniform Resource Identifier (URI) component characters.

#### Return Value

The provided string encoded as a Uniform Resource Identifier (URI).

#### Example

    s = "http://roku.com/my test.asp?first=jane&last=doe"
    t = s.EncodeUriComponent()
    print """" + t + """"
    REM "http%3A%2F%2Froku.com%2Fmy%20test.asp%3Ffirst%3Djane%26last%3Ddoe"
    

### DecodeUriComponent() as String

#### Description

Decodes the specified string with escape sequences for reserved Uniform Resource Identifier (URI) component characters. If the escaped string includes invalid escape sequences, the decode will fail and an empty string will be returned.

#### Return Value

An unencoded version of the provided encoded Uniform Resource Identifier (URI).

#### Example

    t = "http%3A%2F%2Froku.com%2Fmy%20test.asp%3Ffirst%3Djane%26last%3Ddoe"
    s = t.DecodeUriComponent()
    print """" + s + """"
    REM "http://roku.com/my test.asp?first=jane&last=doe"
    

### StartsWith(matchString as String) As Boolean

Checks whether the string starts with the substring specified in **matchString**, starting at the beginning of the string (position 0).

#### Return Value

A flag indicating whether a matching substring was found.

#### Example

    s = "Roku Rocks"
    ? s.StartsWith("Roku") ' => true
    ? s.StartsWith("roku") '=> false
    

### StartsWith(matchString as String, matchPos as Integer) As Boolean

Checks whether the string starts with the substring specified in **matchString**, starting at the **matchPos** parameter (0-based character offset).

#### Return Value

A flag indicating whether a matching substring was found.

#### Example

    s = "Roku Rocks"
    ? s.StartsWith("Rocks", 5) ' => true
    ? s.StartsWith("Roku", 5) ' => false
    

### EndsWith(matchString as String) As Boolean

Checks whether the string ends with the substring specified in **matchString**, starting at the end of the string.

#### Return Value

A flag indicating whether a matching substring was found.

#### Example

    s = "Roku Rocks"
    ? s.EndsWith("Rocks") ' => true
    ? s.EndsWith("roku") '=> false
    

### EndsWith(matchString as String, length as Integer) As Boolean

Checks whether the string ends with the substring specified in **matchString**, starting at the position specified in the **length** parameter.

#### Return Value

A flag indicating whether a matching substring was found.

#### Example

    s = "Roku Rocks"
    ? s.EndsWith("Roku", 4) ' => true
    

### Format(...) As String

#### Description

Returns a format conversion using the specified printf-like [format string](/docs/references/brightscript/language/global-string-functions.md#format-strings) and matching dynamic parameters.

The parameters must match the format string's placeholders in count and expected data type or an [error](/docs/references/brightscript/language/error-handling.md) may occur.

#### Return Value

The formatted string.

#### Support

Format support (the `ifStringOps` interface) is implemented by the following type:

*   roString (String)

#### Examples

##### Mixed

    '* example of mixed parameters
    s = "Roku" + " " + "rocks!"
    print "The length of '%s' is %d.".Format(s, s.Len())
    '=> "The length of 'Roku rocks!' is 11."
    

##### Integer (Decimal)

    '* example of decimal integers
    print "%d * %d = %d".Format(-13, 21, -13 * 21)
    '=> "-13 * 21 = -273"
    
    '* example of decimal integers with left-side 0-padding
    print "%04d-%02d-%02d".Format(17, 3, 99)
    '=> "0017-03-99"
    

##### Integer (Hexadecimal)

    '* example of hexadecimal integer with left-side 0-padding
    print "%07x".Format(&hFACE1)
    '=> "00face1"
    
    '* example of using a dynamic field width parameter
    '* (left-side blank padding by default)
    print "%*X".Format(6, &hFACE1)
    '=> " FACE1"
    
    '* example of using a dynamic field width parameter,
    '* left-aligned to put the blank padding on the right
    print "%-*X".Format(6, &hFACE1)
    '=> "FACE1 "
    
    '* example of using a dynamic field width parameter,
    '* with left-side 0-padding
    print "%0*x".Format(8, &hFACE1)
    '=> "000face1"
    

##### Floating Point

    '* example of floating point formatting
    pi = 3.1415 : r = 2.5
    print "r=%4.2f => c=%4.2f".Format(r, 2 * pi * r)
    '=> "r=2.50 => c=15.71"
    

##### String

    '* example plain string formatting
    print "%s, %s".Format("Fields", "Sally")
    '=> "Fields, Sally"
    
    '* example of string formatting with field widths
    '* first is left-aligned / right-padded, second is left-padded by default
    print "[%-3s:%3s]".Format("A", "B")
    '=> "[A  :  B]"
    

##### Character

    '* example of character formatting
    print "(%c%c%c)".Format(&h7B, 64, &h7D)
    '=> "({@})"

roChannelStore
==============

The roChannelStore component allows the application to perform a purchase of an In-App Product or upgrade an app. Most of the purchase flow, screens and messaging associated with the financial transaction are handled by the Roku OS outside of control or monitoring by BrightScript code. The BrightScript code merely initiates the purchase and receives a final result. This will engender trust with users and give them confidence that they are dealing with the Streaming Store.

The roChannelStore component allows purchasing only those In-App Products which are associated with the running app. Please see [Adding in-app products](/docs/developer-program/roku-pay/quickstart/in-channel-products.md "Adding in-app products") for details on how to create an In-App Product and associate it with an app. After one or Products are created, GetCatalog() can be used to retrieve a list of Products and their attributes. DoOrder() can be called to initiate a purchase of one or more of the Products.

This object is created without any arguments:

`CreateObject("roChannelStore")`

> Because [ifChannelStore.DoOrder()](/docs/references/brightscript/interfaces/ifchannelstore.md#doorder-as-boolean "ifChannelStore.DoOrder()") needs to read the product type returned by GetCatalog(), only one instance of roChannelStore should ever be used for a complete purchase flow - you should never create a separate roChannelStore object to complete a purchase that was initiated by a different instance of roChannelStore.

Supported interfaces
--------------------

*   [ifChannelStore](/docs/references/brightscript/interfaces/ifchannelstore.md "ifChannelStore")
*   [ifSetMessagePort](/docs/references/brightscript/interfaces/ifsetmessageport.md "ifSetMessagePort")
*   [ifGetMessagePort](/docs/references/brightscript/interfaces/ifgetmessageport.md "ifGetMessagePort ")

Supported events
----------------

*   [roChannelStoreEvent](/docs/references/brightscript/events/rochannelstoreevent.md "roChannelStoreEvento")

roHdmiStatus
============

The HDMI status component provides an interface to the current HDMI operational status.

This component allows you to query the status of the HDMI connection for a Roku streaming player (or set-top box \[STB\]) through the ifHdmiStatus interface functions. This node is not applicable for Roku TVs.

Supported interfaces
--------------------

*   [ifHdmiStatus](/docs/references/brightscript/interfaces/ifhdmistatus.md "ifHdmiStatus")
*   [ifSetMessagePort](/docs/references/brightscript/interfaces/ifsetmessageport.md "ifSetMessagePort")

Best practices
==============

Performance
-----------

| Best Practice | Rationale/Benefits |
| --- | --- |
| Optimize your app code to provide smooth transitions and animations. | Jerky or blocky transitions erode the seamlessness of the Roku user experience and feel unfinished or “broken” to users. |
| Minimize perceived latency by providing active feedback during all operations that may take longer than a second to complete. | Keeping users entertained and informed during routine time-intensive operations like video buffering and app loading gives the illusion of added performance, and positively impacts users’ perception of app quality. |

Presentation
------------

| Best Practice | Rationale/Benefits |
| --- | --- |
| Design your application to work in both 4:3 and 16:9 TV formats. Roku can scale HD applications for SD but expect some cropping to occur. | Users select their display types using the Roku settings menu, which includes only formats that their player model will support. Designing your application to work in SD and HD formats ensures that it can be optimally displayed on any Roku player. |
| Strive to provide graphics for every “thumbnail” and preview image in your app. | Content graphics help users make faster decisions around what to watch. They’re also visually interesting and fun to browse. |
| Ensure that all active UI has sufficient contrast to make it readable in sunny environments. | Without sufficient contrast, users will have trouble correctly reading screens and using your app. Most applicable to apps with custom UI. |
| Strive to push timely updates to your app for any 2nd screen events that update user data: purchases, rentals, watch / history list updates, and so on. | Data that is out of sync across screens confuses users and can erode trust in the system. Good synchronization is a nice touch that builds user trust in your app. |

Navigation
----------

| Best Practice | Rationale/Benefits |
| --- | --- |
| Use the remote navigation buttons consistently within your app. | app-wide UI consistency helps provide a seamless, content-focused user experience |
| Respect platform conventions and assign remote navigation button behavior consistent with the Roku system UI wherever applicable. | Again, system-wide UI consistency helps provide a seamless, content-focused user experience. |
| Strive for “minimum clicks to consumption.” Make it trivial for users to find and watch what they want. | Users want to watch videos, not navigate the UI. Fast access to content delights users and increases time spent in an app. |

Content organization
--------------------

| Best Practice | Rationale/Benefits |
| --- | --- |
| Provide audience-focused editorial categories, both automated (Top Stories, New This Week…) and curated (Critics’ Picks, Classics…) on or directly under your App home. | Catering to your users with content organized “their way” delights them, builds loyalty and increases use over time. |
| Don’t just imitate or force fit information architecture from any second screens your app may utilize (e.g. Web, mobile). Instead, optimize for the 10-foot “On Roku” consumption experience, including platform standards and design conventions, wherever possible. | Content is king; finding, discovering, browsing and watching it should be as friction free as possible to give your app’s users a Best On Roku experience. |
| Tag your content so that it will appear as appropriate during search, discovery, deep linking, and recommendation activities. | Properly tagged content is able to be utilized in and out of your app, not only for ease of discovery and location but also for alignment with user expectations. For example, if a user likes show X, Roku’s recommendation for “You might also like A, B and C” should be as accurate and relevant as possible. |

User engagement
---------------

### Ad experience

| Best Practice | Rationale/Benefits |
| --- | --- |
| When presenting mid-roll ads, strive to insert the ads into scene cuts rather than randomly. | Seamless content presentation is as important as seamless UI navigation. A cut to commercial in the middle of a dialogue or a climactic scene disrupts the entertainment flow and annoys users. |
| Consider front-loading ads in pre-roll to minimize interruption of videos. | Fewer content interruptions mean happier users. |
| Consider not increasing the frequency of mid-roll ads as users progress through content. | From a business perspective, this policy makes sense. Users who have invested time and attention in a show are a more captive ad audience. More importantly, from a user perspective, it is very intrusive and frustrating to see more and more ads as a story is reaching its conclusion. You will “win the battle, but lose the war” as users seek entertainment elsewhere. |

### In-app purchasing

| Best Practice | Rationale/Benefits |
| --- | --- |
| Provide clear pricing for any and all purchase options prior to entering Purchase workflow. | Simply put, users want to know prices before buying. Not providing this information will have a direct negative impact on sell-through. |

### Deep linking

| Best Practice | Rationale/Benefits |
| --- | --- |
| Consider providing appropriate metadata to support deep linking (ads, Roku Search…) | Deep linking gives users another way to discover your app, increasing content consumption and time spent in your app. |

### Roku Search

| Best Practice | Rationale/Benefits |
| --- | --- |
| Support incremental search (refresh results as characters are input) | Incremental search is becoming a de facto standard - users expect to see results from partial searches without waiting. This behavior makes Search more efficient and reduces the friction between UI interaction and content consumption. |
| If your app supports Search, provide one Search entry point in the Home screen of your app and (optionally) one in the “global” section of your app’s Options menus. | To users, Search is not an app specific behavior (though they may expect app-specific results). Making this consistent everywhere allows users to leverage learned behavior in your app, again removing friction in regular use. |

Settings and options
--------------------

### App settings

| Best Practice | Rationale/Benefits |
| --- | --- |
| If your app supports Settings, it’s recommended to provide a single entry point in the Options dialog of your Home screen. | Settings are rarely used, and do not belong in primary UI such as the Home screen of your app. |
| If your app supports Settings, follow the Roku platform model: a flat Settings screen with one click access to specific sub screens. | Following the platform interaction model means that there is no need for users to learn additional layout or navigation behaviors. |

### Options menu(s)

| Best Practice | Rationale/Benefits |
| --- | --- |
| “Search (app name)” is recommended as a global option if your app supports in-app Search. | Users may decide to find another piece of content at any time. Providing Search globally prevents users from having to navigate to a Search jumping-off point within your app UI. |
| “(app name) Home” is recommended as a global option. | Users may want to restart their browsing or locate a specific content item or category from memory, at any time. This option enables that behavior. Adding the app name ensures that users do not confuse this option with the Roku Home screen. |
| Strive to limit the Options menu to no more than 4 local options and 2 global options. | Stuffing the Option menu with too many choices slows down users’ interaction with your app UI and goes against Roku’s core principle of simplicity. If you find that there are too many features in your Options menus, consider refactoring your app’s UI or removing features not essential to your app experience on the Roku platform. |

ColorFieldInterpolator
======================

Extends [**Node**](/docs/references/scenegraph/node.md)

The ColorFieldInterpolator node class specifies a keyframe animation sequence to be applied to the color field of a node (such as the color field of a Label node).

All field interpolators include a set of key/keyValue field pairs that define a keyframe of the animation. Field interpolators are generally used as children of an Animation node. As the animation progresses, it sets the fraction field of its field interpolators to a value between 0 and 1, indicating the fraction of the animation progress. The keyframe fields of the interpolator are key, the percentage where the keyframe should occur, and keyValue, the value that the field should have at that fraction of the animation.

For example, if a ColorFieldInterpolator node had three keyframes:

*   0.0, 0xFF0000FF (red)
*   0.4, 0x00FF00FF (green)
*   1.0, 0x0000FFFF (blue)

When the interpolator fraction field value was 0.0 (that is, 0%), the color field value would be set to red. When the fraction field value was 0.4 (that is, 40%), the color field value would be set to green. When the fraction field value was 1.0 (that is, 100%), the color field value would be set to blue.

For values of the fraction field between 0.0 and 0.4 (such as 0.2 or 20%), the field value is determined by linearly interpolating the keyValue field values for the first two keyframes. In this case, since the key of 0.2 is halfway between the key at 0.0 and the key at 0.4, the field would be set to a color halfway between red and green. Similarly, when the fraction field value is between the second and third keys (that is, between 0.4 and 1.0), the field value is determined by linearly interpolating the keyValue field values of the second and third keyframes.

If the first keyframe has a key field fraction value greater than zero, then the field value is equal to the keyValue field value of the first keyframe until the fraction field value reaches the first keyframe key field fraction value. Similarly, if the last keyframe has a key field fraction value less than one, the color field value is set to the keyValue field value of the last keyframe, from when the fraction field value equals the last keyframe key field fraction value percentage, and will not change as the fraction field value increases from that value to 1.0.

The ColorFieldInterpolator node class works in the HSV color space. Doing the interpolation in the HSV color space produces the most intuitive, visually pleasing results when animating color values.

> While linear interpolation is used to compute the keyValue field values for fraction field values between successive keys, non-linear easing functions may be applied to the fraction field values computed by the Animation node, so the overall animation may vary in speed.

### Example

The following changes the color of a rectangle, from blue to very dark blue, and back to blue, in 10 seconds, repeatedly.

#### ColorFieldInterpolator Node Class Example

    <?xml version="1.0" encoding="utf-8" ?>
    
    <!--********** Copyright 2015 Roku Corp.  All Rights Reserved. **********-->
    
        <component name="animationcolortest" extends="Group" >
    
            <script type="text/brightscript" >
                <![CDATA[
                    function init()
                       m.top.setFocus(true)
                    end function
                ]]>
            </script>
    
    <children>
    
        <Rectangle   id="testRectangle"   color="0x0000CCFF"   width="810"   height="44"   translation="[310,8]" />
        <Animation   id="testAnimation"  duration="10"  repeat="true"  control="start"  easeFunction="linear" >
            <ColorFieldInterpolator id = "testColor"   key="[0.0, 0.5, 1.0]"    keyValue="[ 0x0000CCFF, 0x00000FFF, 0x0000CCFF ]"       fieldToInterp="testRectangle.color"   />
        </Animation>
    
    
    </children>
    
    </component>
    

Fields
------

| Field | Type | Default | Access Permission | Description |
| --- | --- | --- | --- | --- |
| fieldToInterp | string | ""  | READ\_WRITE | Specifies the field to interpolate. This generally refers to the field on a SceneGraph node that contains the color to animate, such as testRectangle.color field in the example below |
| key | array of floats | \[ \] | READ\_WRITE | Specifies the key fractions for the interpolator keyframes. Each key fraction should be a unique value from 0 to 1 indicating the fraction of the animation where the keyValue field value should occur. Behavior is undefined if the number of values in the key field does not match the number of values in the keyValue field |
| keyValue | array of colors | \[ \] | READ\_WRITE | Specifies the key values for the interpolator keyframes. Each value in the keyValue field array corresponds to a value in the key field array. Behavior is undefined if the number of values in the key field does not match the number of values in the keyValue field |
| fraction | float | 0.0 | READ\_WRITE | Specifies the fraction to be used to compute a value for the field |
| reverse | boolean | false | READ\_WRITE | Enables animation to be played in reverse |

Sample app
----------

[AnimationColorExample](https://github.com/rokudev/samples/tree/master/ux%20components/animation/AnimationColorExample) is a sample app demonstrating ColorFieldInterpolator in action.

roProgramGuide
==============

Represents Electronic Program Guide (EPG) information from the tuner.

Some Roku devices incorporate a tuner giving access to broadcast TV and radio received over an antenna or cable. In addition to the video and audio data from the tuner, the Roku Player receives electronic program guide (EPG) data about the currently-broadcasting program, and the next few programs to be broadcast. The roProgramGuide object provides access to that guide data.

This object can be created with no parameters:

`createObject("roProgramGuide")`

Supported Interfaces
--------------------

*   [ifProgramGuide](/docs/references/brightscript/interfaces/ifprogramguide.md)

roList
======

The list object implements the interfaces: ifList, ifArray, ifEnum and therefore can behave like an array that can dynamically add members. The array operator \[ \] can be used to access any element in the ordered list.

**Example**

Implementation:

    list = CreateObject("roList")
    list.AddTail("a")
    list.AddTail("b")
    list.AddTail("c")
    list.AddTail("d")
    list.ResetIndex()
    x= list.GetIndex()
    while x <> invalid
        print x
        x = list.GetIndex()
    end while
    
    
    print list[2]
    

Output:

    a
    b
    c
    d
    c 
    

Supported Interfaces
--------------------

*   [ifList](/docs/references/brightscript/interfaces/iflist.md "ifList")
*   [ifArray](/docs/references/brightscript/interfaces/ifarray.md "ifArray")
*   [ifArrayGet](/docs/references/brightscript/interfaces/ifarrayget.md "ifArrayGet")
*   [ifArraySet](/docs/references/brightscript/interfaces/ifarrayset.md "ifArraySet")
*   [ifEnum](/docs/references/brightscript/interfaces/ifenum.md "ifEnum")
*   [ifListToArray](/docs/references/brightscript/interfaces/iflisttoarray.md "ifListToArray")

ifRegistrySection
=================

Implemented by
--------------

| Name | Description |
| --- | --- |
| [roRegistrySection](/docs/references/brightscript/components/roregistrysection.md "roRegistrySection") | A Registry Section enables the organization of settings within the registry |

Supported methods
-----------------

### Read(key as String) as String

#### Description

Reads and returns the value of the specified key.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| key | String | The key name to be read. |

#### Return Value

The value of the key.

| Name | Return Type | Parameters | Return Value | Description |
| --- | --- | --- | --- | --- |
| Read | String | ${readparamTable} | Value of the key - String |     |

### ReadMulti(keysArray as Object) as Object

#### Description

Reads multiple values from the registry.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| keysArray | Object | An array of strings containing the key names to be read. |

#### Return Value

An associative array containing the keys and corresponding values read from the registry.

### Write(key as String, value as String) as Boolean

#### Description

Replaces the value of the specified key. Does not guarantee a commit to non-volatile storage until an explicit [Flush()](#flush-as-boolean) is done.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| key | String | The name of the key to be updated. |
| value | String | The updated value to be written to the specified key. |

#### Return Value

A flag indicating whether the value of the key was successfully updated.

### WriteMulti(roAssociativeArray as Object) as Boolean

#### Description

Writes multiple values to the registry.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| roAssociativeArray | Object | An associative array with key-value pairs to be updated. |

#### Return Value

A flag indicating whether the values were successfully updated.

### Delete(key as String) as Boolean

Deletes the specified key.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| key | String | The key to be deleted. |

#### Return Value

A flag indicating whether the key was successfully deleted.

### Exists(key as String) as Boolean

#### Description

Checks if the specified key resides in the registry.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| key | String | The key to be checked. |

#### Return Value

A flag indicating whether the key is in the registry.

### Flush() as Boolean

#### Description

Flushes the contents of the registry out to persistent storage in order to permanently store a token or other setting on the device. Developers should explicitly this method after performing a write or series of writes. This method is transactional and all writes between calls to it are atomic.

#### Return Value

A flag indicating whether the registry was successfully flushed.

### GetKeyList() as Object

#### Description

Gets a list of the keys in the registry.

#### Return Value

An roList containing one entry per registry key in this section.

roTextToSpeech
==============

> To implement CVAA/screen reader support in your app, use the [roAudioGuide](/docs/references/brightscript/components/roaudioguide.md) component object. The roTextToSpeech component object is typically used for book readers and other special-purpose applications.
> 
> Please note this component is only available on the following devices: Roku Streaming Stick (3600X), Roku Express (3700X) and Express+ (3710X), Roku Premiere (4620X) and Premiere+ (4630X), Roku Ultra (4640X), and any Roku TV running Roku OS version 7.2 and later.

The roTextToSpeech component provides text to speech capabilities to applications.

An roTextToSpeech component object is created with no parameters:

`CreateObject("roTextToSpeech")`

Supported interfaces
--------------------

*   [ifTextToSpeech](/docs/references/brightscript/interfaces/iftexttospeech.md "ifTextToSpeech")
*   [ifSetMessagePort](/docs/references/brightscript/interfaces/ifsetmessageport.md "ifSetMessagePort")
*   [ifGetMessagePort](/docs/references/brightscript/interfaces/ifgetmessageport.md "ifGetMessagePort")

Supported events
----------------

*   [roTextToSpeechEvent](/docs/references/brightscript/events/rotexttospeechevent.md "ifTextToSpeechEvent")

Controlling screen layout
=========================

Screen element layout is accomplished in several different ways in SceneGraph applications:

*   setting the `translation` fields of nodes or groups of nodes
*   controlling the z-order of the renderable nodes in SceneGraph trees to place nodes over or under each other
*   controlling the parent-child relationship of renderable nodes in SceneGraph trees, to allow grouping of several renderable nodes together
*   grouping renderable nodes together using the **Group** and **LayoutGroup** node classes

More complex SceneGraph node classes, such as the list and grid node classes, automatically control the spacing and layout of the items in the node. Many times, this layout control is configured in special data bindings for the node, and you can configure the layout by reading the layout data from XML or JSON files on your server.

How Roku Pay works
==================

Roku Pay is Roku's proprietary payment platform. It provides a robust payment experience featuring a low-friction signup flow and an end-to-end payment process. By integrating Roku Pay in an app, publishers can provide simple, streamlined workflows that enable customers to purchase and access content with minimal interaction. Once customers add a method of payment to their Roku customer account, they can subscribe to apps, rent movies, and purchase sporting events and pay-per-views all directly on-device with just a few key presses from their Roku remote control.

 <img src='https://image.roku.com/ZHZscHItMTc2/roku-pay-how-it-works-v3.png' alt='Roku Pay: Simplifying customer payments'

This document uses the example of a customer signing up for a subscription video on demand (SVOD) app to highlight the streamlined purchasing experience provided by Roku Pay. This purchasing workflow is similar for customers renting movies, ordering pay-per-views and sporting events, or making other one-time purchases in a [transactional video on demand (TVOD) app](/docs/developer-program/roku-pay/implementation/tvod-channel.md).

Customer adds payment method
----------------------------

When a customer activates their Roku device, they create their Roku account and link a payment method to it. This allows them to subscribe to apps directly from their Roku device via Roku Pay. In addition to adding a payment method upon device activation, customers can set a 4-digit PIN that is required for making any on-device purchase through Roku Pay. Customers can also update their payment method anytime online or on-device (see [Customer updates payment method](#customer-updates-payment-method) for more information).

![roku400px - img](https://image.roku.com/ZHZscHItMTc2/customer-account-MOP-v2.png?)

> Apps can participate in [Instant Signup](/docs/developer-program/discovery/instant-signup.md) to offer free trial subscriptions to customers when they activate their device.

Customer selects subscription product
-------------------------------------

Once a customer installs an SVOD app, they can select a subscription product. Apps can offer free trial periods and discounted offers, and Roku Pay automatically handles the auto-renewals of the trial or discounted offers to paid full-price subscriptions. Apps can also offer monthly and annual subscriptions and allow customers to [upgrade their plan directly on-device](/docs/developer-program/roku-pay/implementation/on-device-upgrade-downgrade.md).

![roku815px - mtv-hits-subscription](https://image.roku.com/ZHZscHItMTc2/mtv-hits-subscription-v2a.png)

Customer shares Roku account information
----------------------------------------

When the customer selects a product, the app displays a "Request for information" screen. It guides the customer to create an account using their existing Roku account information such as their name, email address, and phone number. The RFI screen eliminates the need for the customer to enter any account information, which minimizes keypresses and reduces friction.

![roku400px - rfi-create-account](https://image.roku.com/ZHZscHItMTc2/rfi-create-account-v3.png)

Customer confirms order
-----------------------

An order confirmation dialog opens prompting the customer to review the subscription terms and then start the subscription. The dialog displays the app's logo, the trial/discounted offer (if any), subscription price and billing period, and payment method or PIN dialog.

![roku815px - mtv-hits-confirm-subscription](https://image.roku.com/ZHZscHItMTc2/mtv-hits-confirm-subscription-v2.png)

> The customer experience depicted in this confirmation dialog is for service available in The Roku Channel. For Direct-to-Consumer apps, the app's logo is displayed in the left pane rather than app artwork.

Account automatically created for customer
------------------------------------------

The app uses the customer's information to create a user account in their backend system. The app generates a secure temporary password and stores it in the customer's account, and then sends the customer a "Welcome" email with information on how to reset the temporary password.

Customer manages subscriptions
------------------------------

Customers can view their active and expired subscriptions from their account's **Subscriptions** page. This page lets customers cancel existing subscriptions, keep canceled subscriptions, or resubscribe to expired ones with just two clicks.

![roku815px - online-subscription-management](https://image.roku.com/ZHZscHItMTc2/online-subscription-management-v2.png)

Customer updates payment method
-------------------------------

If the customer's payment method expires, Roku makes it easy for customers to update it in order to continue their subscriptions. Customers can update their payment online from their account's **Update Payment Method** page, on-device by pressing **Settings>Payment method**, and even on their phone via SMS.

In addition, to further reduce passive cancellation, the Roku home page will display payment method expiration notifications once a day for multiple consecutive days (typically three). Customers can click this notification, update their payment method directly on-device, and then continue their subscriptions.

![roku815px - mop-expired](https://image.roku.com/ZHZscHItMTc2/mop-expired-v2.png)

SceneGraph compilation
======================

SceneGraph components are compiled as the application is started. All SceneGraph component files (with the extension `*.xml)`, and any related BrightScript files (with the extension `*.brs)`, in the `pkg:/components` directory, are compiled.

BrightScript files in the `pkg:/components` directory are compiled in the same way as BrightScript files in the `pkg:/source` directory. The SceneGraph component files are compiled by creating a list of component names for the application, based on the `name` attribute of the [**<component>**](component_1608292.html) element of each file. These component names are checked for validity as instances of the components are created in the application. This check is _case-sensitive_: the component name to be created must _exactly_ match a name in the component name list, _including_ case. The application begins to create instances of SceneGraph components starting with a component extended from a scene node class (either [**Scene**](Scene_1607315.html) or [**OverhangPanelSetScene**](OverhangPanelSetScene_1613108.html)). See [**Component Initialization Order**](Component-Initialization-Order_1611697.html) for a description of the process that creates component instances.

> There _must_ be only _one_ SceneGraph component extended from a scene node class in the `pkg:/components` directory. All component names in an application should be unique to avoid the possibility of creating an instance of an unwanted component definition.

Implementing Nielsen Digital Content Ratings (DCR) measurement
==============================================================

Publishers can enable Digital Content Ratings (DCR) measurement on their Roku apps to understand their viewers' content consumption. Nielsen DCR provides publishers with analytics and reporting for the average audience, reach, frequency, gross rating point (GRP) and time spent metrics on the Roku platform.

Getting started
---------------

Onboarding and deploying Nielsen DCR entails the following steps:

1.  Contact your Nielsen Client Services representative.
2.  Your Nielsen Technical Account Manager (TAM) will provide an Application ID and integration support.
3.  [Integrate the Nielsen Cloud API](https://engineeringportal.nielsen.com/docs/DCR_Video_%26_Static_Roku_Cloud_API) to enable DCR measurement of your Roku apps.
4.  Your TAM will test your app application to ensure that the integration is functioning properly and all of the necessary data is present and triggered appropriately.
5.  Once your integration is in production, Nielsen will continue to test and monitor it to ensure that it is functioning correctly.

Documentation
-------------

[Nielsen DCR Solutions](https://www.nielsen.com/us/en/solutions/capabilities/digital-content-ratings)

[DCR Video & Static Roku Cloud API](https://engineeringportal.nielsen.com/docs/DCR_Video_%26_Static_Roku_Cloud_API)

Conditional compilation
=======================

Conditional Compilation allows boolean constants to determine whether a section of code should be compiled. Conditional compilation values are defined by the `#const` identifier and has the form:

`#const <constant-name> = <expression>`

**Examples of valid expressions**

    #const someFlag = true
    #const anotherFlag = false
    #const someOtherFlag = someFlag
    

* * *

Criteria:
---------

This initial release only supports `boolean` constant values.

*   Constant names must be composed of alphanumeric characters, and optionally, the underscore `_` character. There is no limit to the length of a constant name.
*   Constant names are case-insensitive.
*   A constant name should not be redefined if it has already been defined prior.

Defining a constant
-------------------

A constant can be defined in 2 ways:

*   A manifest attribute in the package file
*   A constant locally scoped to individual BrightScript files

### Manifest constant

Conditional compilation values can be specified in the manifest via the `bs_const` attribute:

`bs_const=someFlag=false`

More than one conditional compilation value can be specified via semi-colon separated key-value pairs:

`bs_const=someFlag=false;anotherFlag=true`

Uses
----

There are a variety of ways Conditional compilation can be used:

**Example demonstrating use of manifest constants**

    #if someFlag
    
        'code to execute when someFlag is true
    
    #else if anotherFlag
    
        'code to execute when anotherFlag is true
    
    #end if
    

**Example demonstrating locally scoped constants**

    #const FeatureA = true
    #const FeatureB = false
    
    #if FeatureA
    
        'code for Feature A
    
    #else if FeatureB
    
        'code for Feature B
    
    #else
    
        'production code
    
    #end if
    

An `#error` constant can also be used to force a compilation error with an error message:

**Example demonstrating usage of #error constant**

    #const FeatureAImplemented = true
    
    #if FeatureAImplemented
        ' code for Feature A
    #else
        #error TO DO: implement feature A
    #end if
    

### Block comments

Conditional compilation can also be used to form block comments. Previously, each line of code needed to be commented out.

**Example of code block comments**

    #if false
    
        This is a function that does nothing.
    
        This function takes no parameters.
    
        This function does not return anything.
    
    #end if
    
    Function foo() as void
    
        'do nothing
    
    End Function
    

**Example of commenting out code**

    #if false
    
    Function Order66() as void
    
        'code for Order66
    
    End Function
    
    #end if
    

Calling this function would result in a compile time error. To re-enable this function, change `#if false` to `#if true`.

Roku Analytics Component Library
================================

The Roku Analytics Component Library (RACL) implements Google Analytics, Omniture, and Ooyala Analytics, amongst other third-party analytics solutions. The library creates a simple method for using SceneGraph apps with one or more of these analytics solutions.

Support Models
--------------

The analytics platforms supported by RACL are classified into three different models:

### Model #1

The app passes video-related events to the analytics module as they are received, and the analytics module is responsible for building and firing any analytics beacons needed for that event. This approach is most common for services focused only on video metrics. Platforms that use this model include **Brightcove** and **Ooyala**.

### Model #2

The app is responsible for deciding when an analytics beacon needs to be fired and collecting the data that needs to be sent with the beacon. The analytics module uses that data to build and fire the beacon. This approach is most common for services that track UX interactions as well as video metrics. Platforms that use this model include **Omniture** and **Google Analytics 4 (GA4)**.

### Model #3

This model utilizes Roku's Event Dispatcher library that allows apps to share in-app user behaviors and events with Roku by inserting custom tracking pixels into the app. The Event Dispatcher enables Roku to customize the Universal Search results based on a user's ability to view a particular piece of content without making a transaction. In other words, content in an app that the user already subscribes to will appear higher in the search results than content behind an additional paywall or content with ads. The Roku Event Dispatcher is the vehicle used to allow Roku to determine a user's authenticated status.

Supported vendors
-----------------

The Roku Analytics Component Library officially supports the following vendors. Other vendors may be partially supported but may need to be updated to be compatible with RACL.

### Ooyala

**Model #1**

#### Initialization attributes

| Attribute | Type | Required | Description |
| --- | --- | --- | --- |
| pcode | String | Required | Ooyala [publisher code](https://help.ooyala.com/video-platform/concepts/api_keys.html) |
| userinfo | roAssociativeArray of Strings | Optional | [User information](https://apidocs.ooyala.com/iq_roku/IQ.html#toc17__anchor) |
| geoinfo | roAssociativeArray of Strings | Optional | [Geographic information](https://apidocs.ooyala.com/iq_roku/IQ.html#toc16__anchor) |

#### Vendor-specific attributes for `setContentMetadata`

| Attribute | Type | Required | Description |
| --- | --- | --- | --- |
| assetType | String | Required | Possible values include "ooyala" or "external" |
| assetID | Integer | Optional | The video's embed code - If omitted, the ID attribute from the standard metadata is used |
| duration | Integer | Optional | The duration of the video - If omitted, the length attribute from the standard metadata is used |

### Brightcove

**Model #1**

#### Initialization attributes

| Attribute | Type | Required | Description |
| --- | --- | --- | --- |
| account | String | Required | Brightcove account ID |
| user | String | Optional | Unique ID for this user |

#### Vendor-specific attributes for `setContentMetadata`

| Attribute | Type | Required | Description |
| --- | --- | --- | --- |
| source | String | Optional | If omitted, the `url` attribute from the standard content metadata is used |
| destination | String | Optional | If omitted, the `url` attribute from the standard content metadata is used |
| video | Integer | Optional | If omitted, the `id` attribute from the standard content metadata is used |
| video\_name | String | Optional | If omitted, the `title` attribute from the standard content metadata is used |
| video\_duration | Integer | Optional | If omitted, the `length` attribute from the standard content metadata is used. If length is also absent, the duration field from the Video Node is used |

### Omniture

**Model #2**

| Attribute | Type | Required | Description |
| --- | --- | --- | --- |
| baseURL | String | Required | The URL of the Omniture suite that data should be sent to |
| persitentParams | roAssociativeArray | Optional | A set of static parameters and values that should be sent with every request |

Analytics vendors using Model #2 use `trackEvent` rather than `setContentMetadata`.

### Google analytics

**Model #2**

> This section has been updated based on Google Analytics 4 (GA4).

### Initialization attributes

| Parameter | Type | Required | Default value | Description | RACL implementation |
| --- | --- | --- | --- | --- | --- |
| api\_secret | string | Required | \-  | An `API Secret` that is generated through the Google Analytics UI. | This parameter is added to each request.  <br>  <br>If the parameter is not specified or the type is incorrect, RAC prints a warning to the debug console, and the payload is not sent.  <br>  <br>If data needs to be sent to multiple data streams, create one RAC instance per stream. |
| measurement\_id | string | Required | \-  | The identifier for a Data Stream. In the Google Analytics UI, this parameter is listed under **Admin** > **Data Streams** > **choose your stream** > **Measurement ID**.  <br>  <br>Google Analytics (GA4) supports tracking multiple data streams for a single property. | This parameter is added to each request.  <br>  <br>If the parameter is not specified or the type is incorrect, RAC prints a warning to the debug console, and the payload is not sent. |
| defaultParams | roAssociativeArray | Optional | \-  | A set of static parameters and values that should be included in each request (see the [Google Analytics (GA4) JSON body documentation](https://developers.google.com/analytics/devguides/collection/protocol/ga4/reference?client_type=gtag#payload_post_body) for more information). | RAC applies these parameters and values to the root level of each payload constructed by the [**trackEvent()** method](#trackevent). |
| defaultEventParams | roAssociativeArray | Optional | \-  | A set of static parameters and values that should be sent with every event. | RAC applies these parameters and values to each event within every payload constructed by the [**trackEvent()** method](#trackevent). |

#### Example:

    m.global.RSG_analytics.init = {
        ga4: {
            api_secret: "apisecret_value"
            measurement_id: "measurementid_value"         
            defaultParams: {
                // Applied to the root level of every payload constructed by trackEvent
                client_id: “client_id”
    
            }
            defaultEventParams: {
                // Applied to all events contained within payloads constructed by trackEvent
                currency: “USD”
            }
    }
    

Guidelines
----------

Manifest entry to use RACL:

    sg_component_libs_required=Roku_Analytics
    

Video Node - `notificationInterval`: For vendors using model #1, the `notificationInterval` field of the Video node must be set to `1`. The component will check this when setting `initVideoPlayer` and change the value if necessary.

Mid-roll ads: When using multiple Video nodes for client-side inserted mid-roll ads, `initVideoPlayer` must be set for each Video node that is created. However, `finishedVideoPlayback` should only be set **once** at the end of the content session. `finishedVideoPlayback` **should not be set** at the end of mid-roll ads.

### Implementation

To use RACL, add a field, "RSG\_analytics," to `m.global` and then create an roSGNode object like so:

    m.global.addField("RSG_analytics","node",false)
    m.global.RSG_analytics = CreateObject("roSGNode","Roku_Analytics:AnalyticsNode")
    

[`addField`](/docs/references/brightscript/interfaces/ifsgnodefield.md#addfieldfieldname-as-string-type-as-string-alwaynotify-as-boolean-as-boolean) takes three parameters:

*   The `fieldName` - the name of the field to add
*   The `type` of the field to add
*   And a `alwaysNotify` value which determines if observers are triggered when the field changes or when the value of the field is set

### Initialization

This method takes a roAssociativeArray of roAssociativeArrays containing configuration data for each analytics service such as endpoint URLs, API keys, etc. See [Supported Vendors](/docs/developer-program/libraries/roku-analytics-component.md#supported-vendors) for vendor-specific configuration data.

**Example:**

    m.global.RSG_analytics.init = {
        IQ : {
            PCODE : "pcode_value"
        }
        omniture : {
            baseURL : “https://omniture.suite.url/”
            ' For convenience, this allows developers to define a set of parameters and values that will be sent with every omniture call
            defaultParams : {}
        }
    }
    

### Methods

#### Model #1

#### initVideoPlayer

> This method can only be used for vendors using model #1 such as Ooyala or Brightcove.

This method takes a single roAssociativeArray with exactly one attribute named `video` containing a SceneGraph [Video node](/docs/references/scenegraph/media-playback-nodes/video.md). If your app uses multiple Video nodes (as might be done for mid-roll ads), this method needs to be set each time a new Video node is created.

**Example:**

    m.global.RSG_analytics.initVideoPlayer = {
        video: m.video
    }
    

#### setContentMetadata

> This method can only be used for vendors using model #1 such as Ooyala or Brightcove.

This method takes a roAssociativeArray of roAssociativeArrays. At least one sub-AA is required and must contain the [content metadata](/docs/developer-program/getting-started/architecture/content-metadata.md) for playback. Any other sub-AAs may contain additional information required for analytics providers and are optional.

**Example with only Roku content meta-data:**

    myContent = {
        streamFormat = "mp4"
        streamUrl = "www.mycontent.com/video.mp4"
    }
    
    m.global.RSG_analytics.setContentMetadata = {
        content: myContent
    }
    

**Example with Roku content meta-data and additional analytics provider information:**

    myContent = {
        streamFormat = "mp4"
        streamUrl = "www.mycontent.com/video.mp4"
    }
    
    metadata = {
        duration : item.length,
        assetId : item.id,
        assetType : "external"
    }
    
    m.global.RSG_analytics.setContentMetadata = {
        content: myContent
        IQ : metadata
    }
    

#### finishedVideoPlayback

> This method can only be used for vendors using model #1 such as Ooyala or Brightcove.

This method is similar to `initVideoPlayer` and takes a single roAssociativeArray with exactly one attribute named `video` containing a Scenegraph [Video Node](/docs/references/scenegraph/media-playback-nodes/video.md). This should be set once video playback has finished which will allow the component to finish analytics tasks and stop observing Video node events.

Unlike `initVideoPlayer`, this method should only be set once the last Video node is closed (i.e., do not set this when closing a Video node after a mid-roll ad).

**Example:**

    sub onVideoState()
        closeStates = {
            finished : "",
            error : ""
        }
        if closeStates[m.video.state] <> invalid then
            'Send video player so analytics node could unobserve all fields and close session properly
            m.global.RSG_analytics.finishedVideoPlayback = {
                video: m.video
            }
            hideVideo() 'implement this to restore prev screen
        end if
    end Sub
    

* * *

#### Model #2

#### trackEvent

> This method can only be used for vendors using model #2 such as Google Analytics (GA4) or Omniture.

This method takes a roAssociativeArray of roAssociativeArrays containing the parameters and values that are sent with a beacon. This method can be set anytime an event needs to be fired.

*   [Google analytics (GA4) attributes](https://developers.google.com/analytics/devguides/collection/protocol/ga4/sending-events?client_type=gtag#required_parameters)
    
*   [Omniture attributes](https://marketing.adobe.com/resources/help/en_US/sc/implement/query_parameters.html)
    

### Google Analytics (GA4) events tracking

Developers can track events from the [standard GA4 events](https://developers.google.com/analytics/devguides/collection/protocol/ga4/reference/events) list, and they can track their custom events and their parameters. To do this, pass the following data for events tracking and any other optional parameters, per [GA4 documentation](https://developers.google.com/analytics/devguides/collection/protocol/ga4/reference?client_type=gtag#payload_post_body), as needed.

> Parameters may also be placed in the `defaultParams` or `defaultEventParams` fields during initialization and RAC will automatically apply them to every event.

| Parameter | Type | Required | Default value | Description | RAC implementation |
| --- | --- | --- | --- | --- | --- |
| client\_id | string | Required | [GetChannelClientID()](/docs/references/brightscript/interfaces/ifdeviceinfo.md#getchannelclientid-as-string) | Uniquely identifies a user instance of a web client.  <br>  <br>This is the equivalent of the "cid" parameter in Universal Analytics (UA). | This field is populated with value returned by the [GetChannelClientID()](/docs/references/brightscript/interfaces/ifdeviceinfo.md#getchannelclientid-as-string) method, if it is not provided by the developer. |
| events | roArray | Required | \-  | An array of event items that to be provided by developer.  <br>  <br>Up to 25 events can be sent per request.  <br>  <br>See the [Google Analytics (GA4) events reference](https://developers.google.com/analytics/devguides/collection/protocol/ga4/reference/events) for all valid events. | RAC will print a debug console warning if this value is empty or is not an array. The payload is still sent if this parameter is not specified. |
| events\[\].name | string | Required | \-  | The name for the event.  <br>  <br>See the [Google Analytics (GA4) events reference](https://developers.google.com/analytics/devguides/collection/protocol/ga4/reference/events) for all options.  <br>  <br>This is an equivalent of the "t" parameter in Universal Analytics (UA). | RAC only checks the "name" for each event in array. If the event "name" is not provided, RAC prints a debug console warning, but still sends the events to the Google server.  <br>  <br>If this parameter is not specified, the payload is still sent. |

**Example:**

    m.global.RSG_analytics.trackEvent = {
        GA4: {
            events: [
                {
                    name: "test_event"
                    params: {
                        "param1": "value1"
                        "param2": 222
                        ' here RAC will append defaultEventParams. For instance, currency from the init example above
                    }
                }
            ]
            ' here RAC will append defaultParams, For instance, client_id, api_secret, and measurement_id from the init example above
         }
        omniture: {
            events: “event15,event17”,
            page_name: “splash_screen”,
            c17: “channel_launch”
        }
    }
    

### Debug

This method takes a boolean to determine if debug data will be shown in the console. The default value is `false` (No debug data will be displayed in the console).

**Example:**

    m.global.RSG_analytics.debug = true
    

Example
-------

Following is a simple example of using RACL with a service that supports Model #1.

    Sub VerySimpleShowVideo(item)
        m.global.addField("RSG_analytics","node",false)
        m.global.RSG_analytics = CreateObject("roSGNode","Roku_Analytics:AnalyticsNode")
    
        ' Analytics Initialization
        m.global.RSG_analytics.init = {
            IQ : {
                PCODE : "pcode_value"
            }
        }
    
        m.video = m.top.createchild("roSGNode","Video")
        m.video.notificationInterval = 1
        m.video.content = item
    
        'Setup analytics for this video player
        'We will pass IDs of analytics that should take part in this video playback
        m.global.RSG_analytics.initVideoPlayer = {
            video: m.video
        }
        'set IQ specific metadata
        'This metadata is IQ specific and cannot be stored in ContentNode
        metadata = {
            duration : item.length,
            assetId : item.id,
            assetType : "external"
        }
        m.global.RSG_analytics.setContentMetadata = {
            IQ : metadata
        }
    
        m.video.observeField("state","onVideoState")
        m.video.control = "start"
    End Sub
    
    Sub onVideoState()
        closeStates = {
            finished : "",
            error : ""
        }
        if closeStates[m.video.state] <> invalid then
            'Send video player so analytics node could unobserve all fields and close session properly
            m.global.RSG_analytics.finishedVideoPlayback = {
                video: m.video
            }
            hideVideo() 'implement this to restore prev screen
        end if
    end Sub
    

Expected Output
---------------

Once you run the Roku analytics component, you should see the beacons it fires on the BrightScript console. The analytics are displayed on your analytics dashboard.

**Example:**

Google Analytics Dashboard after running RACL:

![roku815px - analyticscomponent](https://image.roku.com/ZHZscHItMTc2/analyticscomponent.png "analyticscomponent")

Sample Apps
-----------

To test the library, sideload the sample apps below with respect to the analytics platform you are using. You can test either Ooyala (Model #1) or Google Analytics (Model #2).

Use the Sample app #1 to test Ooyala analytics. Change the publisher code (PCODE) in the baseScene.brs to your Ooyala account PCODE to see the analytics.

When using the sample app for Google analytics (Model #2), make sure to change the tracking ID to your Google analytics tracking ID in baseScene.brs under the folder components.

| Model | Download |
| --- | --- |
| Simple model #1 | [RokuAnalyticsComponent\_Model1](https://github.com/rokudev/samples/tree/master/analytics) |
| Simple model #2 | [RokuAnalyticsComponent\_Model2](https://github.com/rokudev/samples/tree/master/analytics) |

ifIntOps
========

Implemented by
--------------

| Name | Description |
| --- | --- |
| [roInt](/docs/references/brightscript/components/roint.md "roInt") | Object equivalent for intrinsic type Integer |

> To verify whether an object is of an integer type, you can pass the object and this interface into the [GetInterface() method](/docs/references/brightscript/language/global-utility-functions.md#getinterfaceobject-as-object-ifname-as-string-as-interface):
> 
>     if (GetInterface(someInteger, "ifIntOps") <> invalid)
>         ...
>     End if
>     

Supported methods
-----------------

### ToStr() As String

#### Description

Returns the integer value formatted as a decimal string. No leading space is appended for non-negative numbers.

#### Return Value

A decimal string.

#### Example

`5.ToStr() = "5", (-5).ToStr() = "-5"`

Basic Subscription Recovery
===========================

When payment for a subscription auto-renewal fails, Roku's basic subscription recovery feature gives customers a 3-day grace period where they can continue accessing content, while Roku Pay notifies them daily via email to update their method of payment (MOP). Once the 3-day grace period expires, the subscription is canceled. This solution helps the publisher improve the chance of recovering payments and thereby reduce passive cancelations.

> Effective October 1, 2024, all apps using Roku Pay must implement Enhanced Subscription Recovery to pass [certification](/docs/developer-program/certification/certification.md#4-channel-operation). As a result, apps using basic subscription recovery solution must migrate to [Enhanced Subscription Recovery](/docs/developer-program/roku-pay/subscription-recovery/subscription-on-hold.md).

Overview
--------

When the auto-renewal of a customer's subscription fails, Roku Pay automatically places the subscription in recovery. When a subscription is in recovery, the customer is given a grace period where they may continue accessing content for 3 days. During this 3-day grace period, the customer is notified daily via email to update their MOP.

If Roku receives a payment during the 3-day grace period, it is processed and entitlement is maintained (the billing period also remains the same). If no payment is received by the end of the 3-day grace period, the subscription is canceled.

Email renewal notifications
---------------------------

Roku sends email notifications prompting the customer to update their MOP or manage their subscription online at [my.roku.com](http://my.roku.com/).

![roku600px - email-hold-notification](https://image.roku.com/ZHZscHItMTc2/email-hold-notification.jpg)

Entitlement checks
------------------

Publishers can use the Roku Pay APIs to check whether a subscription is current, on hold, or canceled. The [ChannelStore API](/docs/references/scenegraph/control-nodes/channelstore.md#getallpurchases) can be used to check the subscription status client-side upon app launch and then block access to content based on the results; the [Roku Pay web service APIs](/docs/developer-program/roku-pay/implementation/roku-web-service.md) can be used server-side for regular nightly syncs to update the publisher's entitlement service.

### ChannelStore API

When customers launch an app, the app should call the ChannelStore [getAllPurchases](/docs/references/scenegraph/control-nodes/channelstore.md#getallpurchases) API, as part of the required on-device authentication, to determine whether to block access to content. The [getAllPurchases](/docs/references/scenegraph/control-nodes/channelstore.md#getallpurchases) API returns an **inDunning** flag that can be used along with the **status** field to get the status of a subscription:

| Subscription state | **"inDunning"** | **"status"** |
| --- | --- | --- |
| Current | false | Valid |
| In recovery (3-day grace period) | true | Valid |
| Canceled | false | Invalid |

### Roku Pay web service APIs

The publisher should routinely synchronize their entitlement service with the Roku Pay web services to make sure their system has up-to-date entitlement data. Publishers can call the [validate-transaction API](/docs/developer-program/roku-pay/implementation/roku-web-service.md#managing-subscription-recovery) as part of a nightly batch routine to get the updated status of customers' subscriptions. This API returns an **isEntitled** flag that can be used along with the **expirationDate** field and **cancelled** flag to get the status of a subscription:

| Subscription state | **"isEntitled"** | **"expirationDate"** | **"cancelled"** |
| --- | --- | --- | --- |
| Current | true | future date | false |
| In recovery (3-day grace period) | true | current or past date | false |
| Canceled | false | past date | true |

> **Free trials:** When a free trial ends and the customer's method of payment fails, the `is_entitled` flag is set to "false", and the subscription is automatically cancelled (there is no grace period in this case).

Push notifications
------------------

Roku Pay sends a [GraceInitiated push notification](/docs/developer-program/roku-pay/implementation/push-notifications.md#in-grace-period) when a subscription is put on hold, it sends a [GraceRecovered](/docs/developer-program/roku-pay/implementation/push-notifications.md#in-grace-period) notification when the subscription is recovered (renewed after being put in a grace period):

### GraceInitiated

    {
        "customerId": "9aa37bd6f970578294cea4783af08560",
        "transactionType": "GraceInitiated",
        "transactionId": "024d4e1f-c7b6-11ee-afbe-0a58a9feaca8",
        "channelId": "3605562",
        "productCode": "0fCsu09EGS5C6OHlEUnz_MonthlySub",
        "productName": "0fCsu09EGS5C6OHlEUnz_MonthlySub",
        "originalTransactionId": "024d4e1f-c7b6-11ee-afbe-0a58a9feaca8",
        "originalPurchaseDate": "2024-01-12T01:45:36Z",
        "eventDate": "2024-02-10T01:45:39Z",
        "expirationDate": "2024-02-10T01:45:36Z",
        "comments": "Subscription is in dunning state",
        "responseKey": "163792dbc7b611eeafbe0a58a9feaca8",
        "isFreeTrial": false
    }
    

### GraceRecovered

        "customerId": "9d425957549250dcba71e03dacf426b5",
        "transactionType": "GraceRecovered",
        "transactionId": "f0864331-c7b6-11ee-a3c4-0a58a9fead9c",
        "channelId": "3193830",
        "productCode": "PPfCfuZMf3TOXBBl3Ttu_MonthlySub",
        "productName": "PPfCfuZMf3TOXBBl3Ttu_MonthlySub",
        "originalTransactionId": "d4c4da85-c7b6-11ee-a3c4-0a58a9fead9c",
        "originalPurchaseDate": "2024-01-12T01:51:39Z",
        "eventDate": "2024-02-10T01:51:46Z",
        "expirationDate": "2024-03-10T01:51:39Z",  
        "comments": "Subscription recovered from dunning state.",
        "responseKey": "d915ab762a3752e7bf112e7903958f52",
        "isFreeTrial": false
    }

ifAppInfo
=========

Implemented by
--------------

| Name | Description |
| --- | --- |
| [roAppInfo](/docs/references/brightscript/components/roappinfo.md) | Returns information about the application |

Supported methods
-----------------

### GetID() As String

#### Description

Returns the app's channel ID.

#### Return Value

Channel ID; e.g., "12345" or "dev"

### IsDev() As Boolean

#### Description

Returns true if the application is sideloaded, i.e. the app ID is "dev".

#### Return Value

True/ False

### GetVersion() As String

#### Description

Returns the conglomerate version number from the manifest, as formatted major\_version + minor\_version + build\_version.

#### Return Value

App version number. e.g. "1.2.3"

### GetTitle() As String

#### Description

Returns the title value from the manifest.

#### Return Value

Title of the app

### GetDevID() As String

#### Description

Returns the app's developer ID, or the keyed developer ID, if the application is sideloaded.

> If the device has not been keyed, this method returns "34c6fceca75e456f25e7e99531e2425c6c1de443" for sideloaded channels.

#### Return Value

App's Developer ID

### GetValue(key As String) As String

#### Description

Returns the named manifest value, or an empty string if the entry is does not exist.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| Key | String | The manifest value to be returned. |

#### Return Value

Manifest value; empty string

Event loops
===========

Events
------

An event is a thing like an on-screen button press, a remote button press, a video that has finished playing back, etc. When an event occurs, a "message" describing the event is created. In this documentation, we often refer to messages or events interchangably.

Event loops
-----------

A script will normally interact with events via an event loop. At a high level, an event loop is a piece of code with this structure:

    while true
        ' wait for an event
        ' process the event
    end while
    

Message ports
-------------

Messages describing events are sent to and received from objects of type "roMessagePort". By calling ifSetMessagePort.SetMessagePort() in a particular component, you instruct that component to deliver messages to a particular roMessagePort. Your script can then receive messages from that port to be notified of the events related to that component.

Script structure
----------------

Normally a script will have a structure like this:

*   The script creates a BrightScript Component of type "roMessagePort" .
*   The script instructs one or more other BrightScript Components to send their events to this message port, by calling SetMessagePort().
*   The script waits for an event to be delivered to the message port. The actual function to do this is [ifMessagePort.WaitMessage](/docs/references/brightscript/interfaces/ifmessageport.md), but BrightScript also provides the built-in statement WAIT to make this easier.
*   When the script receives a message, it determines what type of event occurred and handles the event.
*   If a script receives an unknown type of event, it should ignore it; then just continue processing other events. Roku may occasionally add new events, and if your script is written to exit on unknown events, any future events that Roku may add will cause your application to misbehave.

Here is an example of a simple script that processes events.

    port = CreateObject("roMessagePort")
    screen = CreateObject("roSGScreen")
    scene = screen.CreateScene("Scene")
    screen.SetMessagePort(port) ' instruct screen to send events to port
    screen.Show()
    while true
        msg = wait(0, port) ' wait for a message
        if type(msg) = "roSGScreenEvent" then
            if msg.isScreenClosed() then
                return -1
            elseif msg.isButtonPressed()
                print "button pressed: ";msg.GetIndex()
            else
                ' ignore other unknown or uninteresting screen events
            endif
        else
            ' ignore other events non-screen events
        endif
    end while
    

Game scripts
------------

Real-time games which use the [ifDraw2D](/docs/references/brightscript/interfaces/ifdraw2d.md) interface typically cannot wait like this for a message in their event loop, because the screen may need to be updated with new animation frames even if no buttons are pressed or other events occur. One way to deal with this is to use a timeout as the first parameter of the call to wait:

    msg = wait(5, port)
    

This waits for a message, but if no message is received within 5 milliseconds, the wait returns and msg is set to 'invalid'. When feasible, this is a simple approach.

However, an approach that usually offers more predictable performance is to use [ifMessagePort.GetMessage](/docs/references/brightscript/interfaces/ifmessageport.md) instead of wait. This is because GetMessage will return immediately if no message is available, while the actual amount of time before a timed wait returns can vary depending on various factors. A game script is often structured like this.

    port = CreateObject("roMessagePort")
    screen = CreateObject("roScreen")
    screen.SetMessagePort(port) ' instruct screen to send events to port
    while true
        msg = port.GetMessage() ' get a message, if available
        if type(msg) = "roUniversalControlEvent" then
            print "button pressed: ";msg.GetInt()
        endif
        DrawOntoScreen(screen) ' call some ifDraw2D methods to draw on screen
        screen.SwapBuffers()
    end while
    

Note that in this case, it is the call to SwapBuffers, not GetMessage, that causes the wait in each iteration of the loop.

Timed events
------------

Sometimes you may wish to have certain code executed periodically, or a certain amount of time after another event has occurred. The best way to handle this is usually to incorporate the handling of the timed event into your main event loop, and use an roTimespan object as a clock to determine when it is time to perform the next action. For example, this loop is similar to the Springboard screen event loop shown above, but it also calls the function DoSomething once every 5 seconds.

    clock = CreateObject("roTimespan")
    next_call = clock.TotalMilliseconds() + 5000
    while true
        msg = wait(250, port) ' wait for a message
        if type(msg) = "roSpringboardScreenEvent" then
            if msg.isScreenClosed() then
                return -1
            elseif msg.isButtonPressed()
                print "button pressed: ";msg.GetIndex()
            else
                ' ignore other unknown or uninteresting roSpringBoardScreenEvents
            endif
        else
            ' ignore other events, not type roSpringboardScreenEvent
        endif
        if clock.TotalMilliseconds() > next_call then
            DoSomething()
            next_call = clock.TotalMilliseconds() + 5000
        end if
    end while
    

Notice that the first parameter of wait has been changed so that it returns after 250 milliseconds even if no event has occurred. This ensures that DoSomething gets called even in the absence of other activity on the port.

Types of messages
-----------------

Different Brightscript components generate different types of messages. For example, the component "roSpringboardScreen" sends event messages of type "roSpringboardScreenEvent". In general, a Brightscript function dealing with a specific component should only react to events generated by that component. For example, as in the example above, code that deals with events generated by an roSpringboardScreen should be inside an if statement like this:

        if type(message) = "roSpringboardScreenEvent"
    

When a message of the desired type is received, the code will process it. For example, one might be looking for a "button pressed" event type. The example above shows that the way to test for this is to call the method isButtonPressed:

        if message.isButtonPressed()
    

An event loop needs to be aware of the possible event classes and types which it can receive and process them.

The following is the list of tests for event types. If new types are added, these tests will remain valid.

        isListItemSelected() as Boolean
        isScreenClosed() as Boolean
        isListFocused() as Boolean
        isListSelected() as Boolean
        isListItemFocused() as Boolean
        isButtonPressed() as Boolean
        isPlaybackPosition() as Boolean
        isRemoteKeyPressed() as Boolean
        isRequestSucceeded() as Boolean
        isRequestFailed() as Boolean
        isRequestInterrupted() as Boolean
        isStatusMessage() as Boolean
        isPaused() as Boolean
        isResumed() as Boolean
        isCleared() as Boolean
        isPartialResult() as Boolean
        isFullResult() as Boolean
        isAdSelected() as Boolean
        isStorageDeviceAdded() as Boolean
        isStorageDeviceRemoved() as Boolean
        isStreamStarted() as Boolean
        isListItemInfo() as Boolean
        isButtonInfo() as Boolean
    

*   **Instant replay button**. Upon pressing this button, the video will skip back 7 seconds without re-buffering. Active only in video mode. App developers do not need to do anything to support it.
    
*   **Info button**. This button must be programmed by app developers, or it will do nothing. Developers should provide contextually relevant information overlaid on video or other UI screens by using the predicates isListItemInfo() and isButtonInfo() listed above.
    
*   **Back button**. Closes the current screen and pops the display stack in the UI. Active only in non-video mode. In most screens developers handle this by exiting the event loop when an isScreenClosed event is received. On some screens like roMessageDialog and roPinEntryDialog, developers must explicitly enable the Back button by calling EnableBackButton.

ScrollableText
==============

Extends [**Group**](/docs/references/scenegraph/layout-group-nodes/group.md "**Group**")

The ScrollableText node class provides an interactive, vertically scrolling pane of text. This is typically used to display several paragraphs of text to the user that are too long to fit onto the display, such as a license agreement.

### Alignment

The ScrollableText node class uses the horizAlign and vertAlign fields to allow you to position the rendered text relative to a specified bounding rectangle.

#### Horizontal Alignment

The horizAlign field allows you to position text horizontally relative to the computed width of the ScrollableText node. The computed width is determined by subtracting the width of the scrollbar from the value specified by the width field.

There are three possible values for the horizAlign field:

*   left The left edge of the text is drawn at the 0 x-coordinate position of the ScrollableText node's local coordinate system.
    
*   center The horizontal center of each line of text is positioned at the x-coordinate corresponding to half the computed width of the ScrollableText node's local coordinate system.
    
*   right The right edge of each line of text is positioned at x-coordinate position corresponding to the computed width of the ScrollableText node's local coordinate system.
    

In most cases, the horizAlign field should remain set to left.

#### Vertical Alignment

The vertAlign field allows you to position text vertically relative to the height of the ScrollableText node, as specified by the height field.

There are three possible values for the vertAlign field:

*   top The top edge of the text is drawn at 0 y-coordinate position of the ScrollableText node's local coordinate system.
    
*   center The vertical center of the rendered text is positioned at y-coordinate position corresponding to half the computed height of the ScrollableText node's local coordinate system.
    
*   bottom The text is drawn so that bottom edge of the rendered text is positioned at the y-coordinate position corresponding to the computed height of the ScrollableText node's local coordinate system.
    

In most cases, the vertAlign field should remain set to top.

Fields
------

| Field | Type | Default | Access Permission | Description |
| --- | --- | --- | --- | --- |
| text | string | ""  | READ\_WRITE | Specifies the text to be displayed |
| color | color | 0xddddddff | READ\_WRITE | Specifies the text color |
| font | Font | system default | READ\_WRITE | Specifies the Font node to be used |
| width | float | 0.0 | READ\_WRITE | Specifies the width of the node. This includes both the area where the text is rendered in addition to the scroll bar on the right |
| height | float | 0.0 | READ\_WRITE | Specifies the height of the node. If the text to be displayed is larger than this height, a scrollbar is automatically added on the right, allowing users to scroll up and down using the remote's arrow keys |
| lineSpacing | float | 8   | READ\_WRITE | If the text is displayed on more than one line, specifies the amount of additional space added between lines |
| horizAlign | string | left | READ\_WRITE | See [Horizontal Alignment](/docs/references/scenegraph/typographic-nodes/scrollinglabel.md#alignment "Horizontal Alignment") |
| vertAlign | string | top | READ\_WRITE | See [Vertical Alignment](/docs/references/scenegraph/typographic-nodes/scrollinglabel.md#alignment "Vertical Alignment") |
| scrollbarTrackBitmapUri | string | ""  | READ\_WRITE | Specifies the URI of an image file to be loaded to replace the default scrollbar track. This should be a 9-patch image so that it can be stretched to the appropriate height specifed by the height field |
| scrollbarThumbBitmapUri | string | ""  | READ\_WRITE | Specifies the URI of an image file to be loaded to replace the default scrollbar thumb. This should be a 9-patch image so that it can be stretched to the appropriate size |

Sample app
----------

[ScrollableTextExample](https://github.com/rokudev/samples/tree/master/ux%20components/text/ScrollableTextExample) is a sample app demonstrating ScrollableText in action.

Button
======

Extends [**Group**](/docs/references/scenegraph/layout-group-nodes/group.md "**Group**")

The Button node is a simple widget that generates a buttonSelected event when the user selects it. The button can display a label and/or an icon, as well as a background image. Fields are provided to customize the label text and color depending on whether or not the button has the key focus. Similarly, the bitmaps used for the icon and background can be specified for both focused and unfocused button states.

By default, the background of the button is only shown when the button has the key focus. Buttons are typically used in a ButtonGroup node that manages which button in the group will have the key focus when the ButtonGroup node receives the focus. When the ButtonGroup node has the focus, the button in the group that has the focus will display the focusBitmapUri bitmap as its background. When the ButtonGroup node does not have the focus, it remembers which button in the group had the focus and sets that button showFocusFootprint field to true, causing it to a render a "footprint" bitmap as a visual indicator that it will be the focused button when the ButtonGroup node receives the focus again. All other buttons in the ButtonGroup node do not display a background image.

When a Button node is created that is not a child of a ButtonGroup node, typically the showFootprintfield field should be set to true, so that the button always displays a background image.

Fields
------

| Field | Type | Default | Access Permission | Description |
| --- | --- | --- | --- | --- |
| text | string | ""  | READ\_WRITE | Specifies the text to be displayed as the button label |
| textColor | color | 0xddddddff | READ\_WRITE | Specifies the color of the button label when the button does not have the key focus |
| focusedTextColor | color | 0x262626ff | READ\_WRITE | Specifies the color of the button label when the button has the key focus |
| textFont | Font |     | READ\_WRITE | Specifies the font of the button label when the button does not have the key focus |
| focusedTextFont | Font |     | READ\_WRITE | Specifies the font of the button label when the button has the key focus |
| focusFootprintBitmapUri | uri | ""  | READ\_WRITE | Specifies the button focus "footprint" bitmap file to display when the button does not have key focus. Only set this field to specify a custom bitmap that differs in appearance from the default bitmap. By default the "footprint" bitmap is not displayed when the button does not have the key focus. To display the background when the button is unfocused, the showFocusFootprint field must be set to true |
| focusBitmapUri | uri | ""  | READ\_WRITE | Specifies the button background bitmap file to display when the button has the key focus. Only set this field to specify a custom bitmap that differs in appearance from the default bitmap |
| iconUri | uri | ""  | READ\_WRITE | Specifies a bitmap file for the button icon when the button does not have the key focus. Only set this field to specify a custom bitmap that differs in appearance from the default bitmap. For a button with no icon, set this field to an empty string (iconUri="") |
| focusedIconUri | uri | ""  | READ\_WRITE | Specifies a bitmap file for the button icon when the button has the key focus. Only set this field to specify a custom bitmap that differs in appearance from the default bitmap. For a button with no icon, set this field to an empty string (iconUri="") |
| minWidth | float | 0   | READ\_WRITE | Specifies the minimum width of the button. The minWidth field must be less than or equal to the maxWidth field |
| maxWidth | float | 32767 | READ\_WRITE | Specifies the maximum width of the button. The maxWidth field must be greater than or equal to the minWidth field |
| height | float | 64  | READ\_WRITE | Specifies the height of the button |
| showFocusFootprint | Boolean | false | READ\_WRITE | Controls whether the focus "footprint" bitmap is displayed when the button does not have the key focus. Since the default value of the showFocusFootprint field is false, the "footprint" bitmap is not displayed by default |
| buttonSelected | Event | N/A | READ\_ONLY | The buttonSelected field is set whenever the button is selected. The field should be used to call observer callback functions when the button is selected |

Sample app
----------

[ButtonExample](https://github.com/rokudev/samples/tree/master/ux%20components/widgets/ButtonExample) is a sample app demonstrating Button in action.

ifDraw2D
========

Coordinates (x,y) for this interface are based on an origin (0,0) at the top, left. (This is common for 2D drawing APIs, but is different than OpenGL's default coordinate system).

Bitmap pixel values and color values are always represented as 32-bit integer RGBA color values. That is, red is in the most significant byte and alpha is in the least significant byte.

Implemented by
--------------

| Name | Description |
| --- | --- |
| [roBitmap](/docs/references/brightscript/components/robitmap.md "roBitmap") | The roBitmap component contains image data and provides an interface (ifDraw2D) for drawing |
| [roRegion](/docs/references/brightscript/components/roregion.md "roRegion") | The roRegion component is used to represent a subsection of a bitmap |
| [roScreen](/docs/references/brightscript/components/roscreen.md "roScreen") | The roScreen component provides a full screen drawing surface that can be stacked and that you can receive input events from |

Supported methods
-----------------

### Clear(rgba as Integer) as Void

#### Description

Clears the bitmap, and fills it with the specified RGBA color.

> The alpha channel will be filled into the bitmap, even when not used. Once AlphaEnable is set to true, the alpha channel will be taken into account when using this bitmap as a source. See SetAlphaEnable() for more information on alpha blending.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| rgba | Integer | The RGBA color to be used to fill the bitmap. |

> Clear() is not the same as a DrawRect() for the entire bitmap. Clear() fills the bitmap with the specified RGBA; it does not perform any alpha blending operations.

### GetWidth() as Integer

#### Description

Gets the width of the bitmap.

#### Return Value

The width of the bitmap in pixels.

### GetHeight() as Integer

#### Description

Gets the height of the bitmap in pixels.

#### Return Value

The height of the bitmap in pixels.

### GetByteArray(x as Integer, y as Integer, width as Integer, height as Integer) as Object

#### Description

Gets the RGBA pixel values for the specified rectangle.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| x   | Integer | The x-coordinate of the rectangle. |
| y   | Integer | The y-coordinate of the rectangle. |
| width | Integer | The width of the rectangle. |
| height | Integer | The height of the rectangle. |

#### Return Value

An roByteArray representing the RGBA pixel values for the specified rectangle.

### GetPng(x as Integer, y as Integer, width as Integer, height as Integer) as Object

#### Description

Gets PNG image data for the specified area of the bitmap. The PNG is in 32-bit RGBA format.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| x   | Integer | The x-coordinate of the rectangle. |
| y   | Integer | The y-coordinate of the rectangle. |
| width | Integer | The width of the rectangle. |
| height | Integer | The height of the rectangle. |

#### Return Value

An roByteArray object containing PNG image data for the specified area of the bitmap. If the coordinates are out of bounds, or the PNG conversion fails for any reason, then invalid is returned

#### Example

    Function SaveTestPng()
        w = 200 : h = 100
        bm = CreateObject("roBitmap", {width: w, height: h, AlphaEnable: true})
        bm.DrawRect(10, 10, w-20, h-20, &hFF0000FF)
        bm.Finish()
        ba = bm.GetPng(0, 0, w, h)
        ba.WriteFile("tmp:/test.png")
     End Function
    

### GetAlphaEnable() as Boolean

#### Description

Checks if the alpha blending is enabled.

#### Return Value

A flag indicating whether alpha blending is enabled.

### SetAlphaEnable(enable as Boolean) as Void

#### Description

Enables alpha blending when the source bitmap is the destination. The setting of the source bitmap's alpha enable is ignored.

When alpha blending is enabled, each pixel in the destination bitmap is set by combining the destination and source pixels according to the alpha value in the source bitmap (or rectangle). The destination alpha is not used. (In OpenGL this is referred to as GL\_ONE\_MINUS\_SRC\_ALPHA).

By default, alpha blending is off. Even when alpha blending is off, the alpha value is still present in the bitmap, and it must be passed when a function parameter is a color, which is always RGBA.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| enable | Boolean | A flag specifying whether alpha blending is enabled. |

#### Example

    Function Main()
        s=CreateObject("roScreen")
        ' Clear to White with alpha fully opaque
        ' but alpha not actually ever used since it is the bottom most plane
        ' alpha is only looked at on "source" planes, not "destination".
        s.Clear(&hFFFFFFFF)
    
        ' AlphaEnable must be enabled in the destination surface to have effect.
        s.SetAlphaEnable(true)
        bm=CreateObject("roBitmap", {width:100, height: 100, alphaenable: false} )
        bm.Clear(&h0000FFFF) 'blue, fully opaque alpha
    
        ' draw a blue rect in the upper left corner
        s.DrawObject(0,0, bm)
        s.Finish()
        Sleep(2000)
        s.Clear(&hFFFFFFFF)
        bm.Clear(&h0000FF00) 'blue, fully transparent alpha
    
        ' draw a blue rect in the upper left corner
        ' but, since it is transparent, nothing will appear on the screen.
        s.DrawObject(0, 0, bm)
        s.Finish()
        Sleep(2000)
     End Function
    

### DrawRect(x as Integer, y as Integer, width as Integer, height as Integer, rgba as Integer) as Void

#### Description

Fills the specified rectangle from left (x), top (y) to right (x + width), bottom (y + height) with the RGBA color.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| x   | Integer | The x-coordinate of the rectangle. |
| y   | Integer | The y-coordinate of the rectangle. |
| width | Integer | The width of the rectangle. |
| height | Integer | The height of the rectangle. |
| rgba | Integer | The RGBA color to be used to fill the rectangle. |

### DrawPoint(x as Integer, y as Integer, size as Float, rgba as Integer) as Void

#### Description

Draws a point at (x,y) with the given size and RGBA color.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| x   | Integer | The x-coordinate of the point. |
| y   | Integer | The y-coordinate of the point. |
| size | Float | The size of the point. |
| rgba | Integer | The RGBA color of the point. |

### DrawLine(xStart as Integer, yStart as Integer, xEnd as Integer, yEnd as Integer, rgba as Integer) as Void

#### Description

Draws a line from (xStart, yStart) to (xEnd, yEnd) with RGBA color.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| xStart | Integer | The x-coordinate of the line's start point. |
| yStart | Integer | The y-coordinate of the line's start point. |
| xEnd | Integer | The x-coordinate of the line's end point. |
| yEnd | Integer | The y-coordinate of the line's end point. |
| rgba | Integer | The RGBA color of the line. |

### DrawObject(x as Integer, y as Integer, src as Object) as Boolean

#### Description

Draws the source object, where src is an [roBitmap](/docs/references/brightscript/components/robitmap.md "roBitmap") or an [roRegion](/docs/references/brightscript/components/roregion.md "roRegion") object, at position x,y.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| x   | Integer | The x-coordinate of the source object. |
| y   | Integer | The y-coordinate of the source object. |
| src | Object | The [roBitmap](/docs/references/brightscript/components/robitmap.md "roBitmap") or an [roRegion](/docs/references/brightscript/components/roregion.md "roRegion") object to be drawn. |

#### Return Value

A flag indicating whether the object was successfully drawn.

### DrawScaledObject(x as Integer, y as Integer, scaleX as Float, scaleY as Float, src as Object) as Boolean

#### Description

Draws the source object, where src is an [roBitmap](/docs/references/brightscript/components/robitmap.md "roBitmap") or an [roRegion](/docs/references/brightscript/components/roregion.md "roRegion") object, at position x,y, scaled in the x direction by scaleX and in the y direction by scaleY. scaleX and scaleY should each be greater than zero and less than one to reduce the object size, or greater than one to increase the object size

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| x   | Integer | The x-coordinate of the source object. |
| y   | Integer | The y-coordinate of the source object. |
| scaleX | Float | The x direction in which the source object is to be scaled. |
| scaleY | Float | The y direction in which the source object is to be scaled. |
| src | Object | The [roBitmap](/docs/references/brightscript/components/robitmap.md "roBitmap") or an [roRegion](/docs/references/brightscript/components/roregion.md "roRegion") object to be drawn. |

#### Return Value

A flag indicating whether the object was successfully drawn.

### DrawScaledObject(x as Integer, y as Integer, scaleX as Float, scaleY as Float, src as Object, rgba as Integer) as Boolean

#### Description

Draws the source object, where src is an [roBitmap](/docs/references/brightscript/components/robitmap.md "roBitmap") or an [roRegion](/docs/references/brightscript/components/roregion.md "roRegion") object, at position x,y, scaled in the x direction by scaleX and in the y direction by scaleY. scaleX and scaleY should each be greater than zero and less than one to reduce the object size, or greater than one to increase the object size.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| x   | Integer | The x-coordinate of the source object. |
| y   | Integer | The y-coordinate of the source object. |
| scaleX | Float | The x direction in which the source object is to be scaled. |
| scaleY | Float | The y direction in which the source object is to be scaled. |
| src | Object | The [roBitmap](/docs/references/brightscript/components/robitmap.md "roBitmap") or an [roRegion](/docs/references/brightscript/components/roregion.md "roRegion") object to be drawn. |
| rgba | Integer | The RGBA color of the source object. |

#### Return Value

A flag indicating whether the object was successfully drawn.

### DrawRotatedObject(x as Integer, y as Integer, theta as Float, src as Object) as Boolean

#### Description

Draws the source object, where src is an [roBitmap](/docs/references/brightscript/components/robitmap.md "roBitmap") or an [roRegion](/docs/references/brightscript/components/roregion.md "roRegion") object, at position x,y rotated by angle theta degrees.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| x   | Integer | The x-coordinate of the source object. |
| y   | Integer | The y-coordinate of the source object. |
| Theta | Float | The position which to rotate the source object. This may be 0, 90, 180, and 270 degrees. |
| src | Object | The [roBitmap](/docs/references/brightscript/components/robitmap.md "roBitmap") or an [roRegion](/docs/references/brightscript/components/roregion.md "roRegion") object to be drawn. |

#### Return Value

A flag indicating whether the object was successfully drawn.

### DrawTransformedObject(x as Integer, y as Integer, theta as Float, scaleX as Float, scaleY as Float, src as Object) as Boolean

#### Description

Draws and then scales and rotates the source object, where src is an [roBitmap](/docs/references/brightscript/components/robitmap.md "roBitmap") or an [roRegion](/docs/references/brightscript/components/roregion.md "roRegion") object; at position x,y; scaled in the x direction by scaleX and in the y direction by scaleY; and rotated by angle theta degrees.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| x   | Integer | The x-coordinate of the source object. |
| y   | Integer | The y-coordinate of the source object. |
| Theta | Float | The position which to rotate the source object. This may be 0, 90, 180, and 270 degrees. |
| scaleX | Float | The x direction in which the source object is to be scaled. |
| scaleY | Float | The y direction in which the source object is to be scaled. |
| src | Object | The [roBitmap](/docs/references/brightscript/components/robitmap.md "roBitmap") or an [roRegion](/docs/references/brightscript/components/roregion.md "roRegion") object to be drawn. |

#### Return Value

A flag indicating whether the object was successfully drawn.

### DrawTransformedObject(x as Integer, y as Integer, theta as Float, scaleX as Float, scaleY as Float, src as Object, rgba as Integer) as Boolean

#### Description

Draws and then scales and rotates the source object, where src is an [roBitmap](/docs/references/brightscript/components/robitmap.md "roBitmap") or an [roRegion](/docs/references/brightscript/components/roregion.md "roRegion") object; at position x,y; scaled in the x direction by scaleX and in the y direction by scaleY; and rotated by angle theta degrees.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| x   | Integer | The x-coordinate of the source object. |
| y   | Integer | The y-coordinate of the source object. |
| Theta | Float | The position which to rotate the source object. This may be 0, 90, 180, and 270 degrees. |
| scaleX | Float | The x direction in which the source object is to be scaled. |
| scaleY | Float | The y direction in which the source object is to be scaled. |
| src | Object | The [roBitmap](/docs/references/brightscript/components/robitmap.md "roBitmap") or an [roRegion](/docs/references/brightscript/components/roregion.md "roRegion") object to be drawn. |
| rgba | Integer | The RGBA color of the source object. |

#### Return Value

A flag indicating whether the object was successfully drawn.

### DrawRotatedObject(x as Integer, y as Integer, theta as Float, src as Object, rgba as Integer) as Boolean

#### Description

Draws and rotates the source object, where src is an [roBitmap](/docs/references/brightscript/components/robitmap.md "roBitmap") or an [roRegion](/docs/references/brightscript/components/roregion.md "roRegion") object at position x,y, rotated by angle theta degrees.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| x   | Integer | The x-coordinate of the source object. |
| y   | Integer | The y-coordinate of the source object. |
| Theta | Float | The position which to rotate the source object. This may be 0, 90, 180, and 270 degrees. |
| src | Object | The [roBitmap](/docs/references/brightscript/components/robitmap.md "roBitmap") or an [roRegion](/docs/references/brightscript/components/roregion.md "roRegion") object to be drawn. |
| rgba | Integer | The RGBA color of the source object. |

#### Return Value

A flag indicating whether the object was successfully drawn.

### DrawText(text as String, x as Integer, y as Integer, rgba as Integer, font as Object) as Boolean

#### Description

Draws the text at position (x,y) using the specified RGBA color and [roFont](/docs/references/brightscript/components/rofont.md "roFont") font object. Text is drawn anti-aliased. The background image/color behind the text will show through the spaces and holes in the text. To have the text erase the background, make a call to [DrawRect()](#drawrectx-as-integer-y-as-integer-width-as-integer-height-as-integer-rgba-as-integer-as-void) before calling DrawText(). The size, bold, and italic attributes are specified when creating the [roFont](/docs/references/brightscript/components/rofont.md "roFont").

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| text | String | The text to be drawn. |
| x   | Integer | The x-coordinate of the source object. |
| y   | Integer | The y-coordinate of the source object. |
| rgba | Integer | The color of the text. |
| font | Object | The [roFont](/docs/references/brightscript/components/rofont.md "roFont") object to be used for the text. |

#### Return Value

A flag indicating whether the object was successfully drawn.

### Finish() as Void

#### Description

Realizes the bitmap by finishing all queued draw calls. Until Finish() is called, prior graphics operations may not be user visible. For example, they may be in the graphics display pipeline, or in a server queue.

> This method is synchronous; it does not return until all graphic operations are complete.
> 
> When working with an [roScreen](/docs/references/brightscript/components/roscreen.md "roScreen") object, the [ifScreen.SwapBuffers()](/docs/references/brightscript/interfaces/ifscreen.md#swapbuffers-as-void) method should be used instead of this method.

roScreen
========

The roScreen component provides a full screen drawing surface that can be stacked and that you can receive input events from.

You will need at least one roScreen component in your 2D game application to draw on and get events from. The origin (0,0) is the top left corner of the screen. The pixels are always RGBA 32 bits. Multiple roScreen components stack, and like other screen components only the top screen is viewable and gets events. An roScreen that is not the top most screen can still be drawn to.

> Once an roScreen is created, the display stack enters "Game Mode", and other screen components cannot be used. Screensavers will also be disabled and will appear as a black screen in its place. Other screen components cannot be intermixed with roScreens as the roScreen display stack is maintained independently from the main screen component display stack. When the final roScreen component is closed, other screen components can be used again.

When the roScreen constructor is called, an optional double buffer flag, and an optional resolution can be passed. If the screen is double buffered, two buffers are fully allocated when CreateObject() succeeds. If the screen is single buffered only one buffer is allocated and the "front" and "back" buffers in method descriptions below are the same buffer. When a screen is created with a different resolution than the output display, it is scaled automatically to the output display resolution.

To maintain proper aspect ratio, and take care of the different pixel aspect ratio in HD vs SD; there is a fixed set of bitmap resolutions that are allowed to be created for screens:

##### **HD mode screensizes**

*   1280x720PAR=1:1 (default for HD)
*   854x480 PAR=1:1 useful for higher performance HD games, also for 640x480 games
*   940x480 PAR=1.1:1 used for displaying a RokuSD (720x480) games

##### **SD mode screensizes**

> SD mode has been deprecated. Developers should develop games in HD mode.

*   720x480 PAR=1.1:1 (default for SD)
*   640x480 PAR=1:1 (used for 640x480 games)
*   854x626 PAR=1:1 (used for 854x480 HD games)

The screen dimensions correspond to the drawable area that applications see. The dimensions were chosen so that applications do not need to compensate for screen aspect ratio or pixel aspect ratio.

It's likely that when porting games from other platforms, the active game area may be smaller and correspond to more traditional dimensions. In this case, the application can supply letterbox or pillarbox artwork and use an [roRegion](/docs/references/brightscript/components/roregion.md "roRegion") to define the active area. The roRegion will translate and clip graphics to the proper area for the game. Similarly, roRegions are used to describe the left and right pillars for an SD game in HD mode, or the upper and lower letterbox regions for an HD game in SD mode.

Games that require more performance should use smaller dimensions. Games should run in HD and SD mode. The screensizes HD 854x480 paired with SD 854x626 and HD 940x480 paired with SD 720x480 were designed for this purpose.

The game creates a single active game roRegion to do all graphics operations in. roRegions for pillar or letter boxes are used to fill the rest of the screen area depending on if the app is in HD or SD mode. Please refer to the dfSetupDisplayRegions() function in [v30/bslDefender.brs](/docs/references/brightscript/language/component-architecture.md#v30bslcorebrs "v30/bslDefender.brs") for help in setting up the drawable regions in screen scaling.

There are some useful rules of thumb to be aware of to get the best performance when rendering your games:

*   Alpha enabled regions are expensive to render

It is a requirement that the destination be alpha enabled in order for non-rectangular sprites to be properly rendered with transparency. However the sprite used for a background would typically have all pixels be fully nontransparent. Since alpha blending is expensive, a quick way to blit the background in this scenario is to first disable alpha on the screen, manually draw the background, and then enable alpha for the screen before drawing the rest of the sprites.

*   Use smaller resolution images wherever possible. Scaling a large image down at run time is expensive with no benefit to the user
*   Rendering text with DrawText() is expensive

Fortunately, many of these calls are redundant and can be eliminated. The static text for a particular level can be drawn on the background once and this newly created background can be used for refreshing the screen. This will eliminate almost all text redraws.

A screen can be created with one of three constructors. If it is created with no parameters, the screen will be single buffered, and its output resolution will match the current display resolution (if the current resolution is specified in the manifest file ui\_resolutions entry, otherwise the size will be 720p).

`CreateObject("roScreen")`

If a single parameter is passed, it is a Boolean that indicates if the screen is double buffered or not. See SwapBuffers():

`CreateObject("roScreen", true) ' double buffered screen`

If four parameters are passed, the last two specify the screen's resolution. The dimensions must be one of the screen sizes specified above:

`CreateObject("roScreen", true, 720, 480) ' db & SD res`

**Example: Display an image**

    Screen=CreateObject("roScreen")
    dfDrawImage(screen, "myphoto.jpg",0,0)
    Screen.Finish()
    

**Example: Alpha blending**

    white=&hFFFFFFFF
    screen0=CreateObject("roScreen")
    screen0.SetAlphaEnable(true)
    screen0.Clear(white)
    screen0.DrawRect(100,100, screen0.GetWidth()-200, screen0.GetHeight()-200, &h80)
    ' &h80 is black with a 50% alpha mix (RGBA)
    screen0.finish()
    

Supported interfaces
--------------------

*   [ifScreen](/docs/references/brightscript/interfaces/ifscreen.md "ifScreen")
*   [ifDraw2D](/docs/references/brightscript/interfaces/ifdraw2d.md "ifDraw2D")
*   [ifSetMessagePort](/docs/references/brightscript/interfaces/ifsetmessageport.md "ifSetMessagePort")
*   [ifGetMessagePort](/docs/references/brightscript/interfaces/ifgetmessageport.md "ifGetMessagePort")

Supported events
----------------

*   [roUniversalControlEvent](/docs/references/brightscript/events/rouniversalcontrolevent.md "roUniversalControlEvent")

SceneGraph threads
==================

SceneGraph introduced multi-threaded operations to Roku application programming. The following are the basic threads available to a SceneGraph application programmer:

*   **Main BrightScript thread**: This is the thread that is launched for all Roku applications from the `main.brs` file. For SceneGraph applications, the thread is used primarily to create the scene component object, which starts the SceneGraph render thread. For other applications, this is the only thread for the entire application.

*   **SceneGraph render thread**: The render thread is the main SceneGraph thread that performs all rendering of the application visual elements. Certain BrightScript operations and components that might block or modify the SceneGraph in the render thread cannot be used in this thread. Operations and components that might block the render thread can be used in a Task node thread. The thread usage of these operations and components is listed in [BrightScript support](/docs/developer-program/core-concepts/scenegraph-brightscript/brightscript-support.md).

> If the render thread blocks execution, production apps will terminate after 10 seconds; sideloaded apps will timeout in 3 seconds.

*   **Task node threads**: By creating and running a [Task](/docs/references/scenegraph/control-nodes/task.md) node, you can launch asynchronous BrightScript threads. These threads can perform most typical BrightScript operations.

Thread limits
-------------

As of Roku OS 10.0, the maximum number of concurrent threads per running instance of an app is limited to 100. However, developers should limit their apps to a maximum of 50 concurrent threads.

*   When an instance exceeds 50 concurrent threads, Roku displays a warning on the port 8085 console.

*   When the instance exceeds 100 threads, a “too many threads” error exception (&h29) is raised; if the app does not catch this exception, app operation is terminated, along with a corresponding stack trace.

Task threads that have properly terminated and are no longer running will not count towards the limit, even if the task object itself is still valid (for example, the state is stopped or done).

> Developers should take steps to ensure that their apps always remain well under the 50-thread "warning" limit.

Thread ownership
----------------

All SceneGraph node objects have a thread owner, which by default, is the render thread. Only components that extend the Node node class and the ContentNode class can be owned by a Task node or main BrightScript thread when created by those threads. When a node object is stored in a field, the ownership of the node is changed to the node object that contains the field. When a node object is added as a child of another node object, the ownership is changed to the parent node object.

Operations on node objects are executed on their owning thread. If invoked by another thread, the invoking thread must rendezvous with the owning thread to execute the operation.

Thread rendezvous
-----------------

In a thread rendezvous, the invoking thread makes a request of the owning thread, and then waits for a response. The owning thread receives the request, processes it, and then responds. The invoking thread then continues with the response as if it had made the call itself. The response appears synchronous to the invoking thread.

Only the render thread may serve a rendezvous. Since Task node threads do not have an implicit event loop (though they may have an explicit event loop), they cannot serve a rendezvous. No node object owned by a Task node thread is accessible outside that thread. The Task node itself is owned by the render thread, so the Task node and its fields can only be accessed by rendezvous from other threads, even from the thread launched by the Task node itself.

The entire interface to a node object, including field creation, setting, and getting, uses this rendezvous mechanism to ensure thread safety, without having to use explicit locks in the application, and without the possibility of deadlock. The rendezvous mechanism does add more overhead than simple field getting and setting, so SceneGraph application programmers should use it carefully, taking into account the following concerning Task node threads.

> Use the [**logrendezvous** command](/docs/developer-program/debugging/debugging-channels.md#scenegraph-debug-server-port-8080-commands) in the SceneGraph debug console to identify performance issues in the Task thread caused by a rendezvous. This command indicates whether a rendezvous is occurring and the length of it is taking (in milliseconds).

### BrightScript operations without SceneGraph node objects

If a BrightScript operation does not involve a SceneGraph node object, such as reading a URL, or parsing XML, the rendezvous mechanism is not used. These types of operations can be used in a Task node thread without the overhead of the rendezvous mechanism.

### Task node thread fully-owned node objects

Task node threads can create node and ContentNode objects that are fully owned by the Task node thread. These node objects cannot be parented to unowned nodes, or be set as fields of unowned nodes. Entire trees of the nodes fully owned by the Task node thread may be created.

### Renderable node (Group) objects

You should generally not create renderable node objects in a Task node thread. The rendezvous mechanism will be required to create and operate on those node objects. Every field set or get operation on such nodes will require a full rendezvous, and this could impact the performance of your application.

### Excessive rendezvous operations

You should avoid as many rendezvous operations as possible to ensure maximum performance of your application. It is better to build an entire tree of nodes or ContentNodes, then pass the tree to the render thread using one rendezvous, than to repeatedly pass each node in the tree as it is created. For field setting and getting, [ifSGNodeField](/docs/references/brightscript/interfaces/ifsgnodefield.md) methods such as `getFields()` and `setFields()`, which set and get multiple fields at once, should be used rather than several get and set operations.

### Task node thread rendezvous timeout

> Thread rendezvous do not timeout and will wait indefinitely. The rendezvous information below is only valid for Roku OS version 7.2 and older.

A Task node thread rendezvous can time out after a few seconds. This can happen if the render thread is very busy, maybe with other rendezvous operations. If a timeout occurs while getting a field, the response will be invalid, which may crash the application if the script is not prepared for the invalid response. During application development, you should check for these timeouts to increase the performance of your published application.

Also note that the render thread can time out while it is executing long linear searches, long iterative calculations, synchronous file accesses, and the like. These types of operations not only slow down the rendering of the UI, but can lead to a rendezvous timeout generating an invalid response, possibly crashing the application. Push computing not directly related to rendering or reacting to the UI into Task node threads.

### Task node objects ownership

Since Task node objects are owned by the render thread, setting Task node object fields is done on the render thread, and all observer callbacks on the fields are executed in the render thread. The only case where observer callbacks are executed in a Task node object is if the observed field is in a node object owned by the Task node thread.

### Re-running a task

If a Task is already in a given state as indicated by its state field, including RUN, setting its control field to that same state value has no effect. To rerun a Task, it must be in the STOP state, either by returning from its function or being commanded to STOP via its control field. At the time a Task transitions to RUN, it will look at its functionName field to determine what function to execute. It will transition to the STOP state automatically when that function returns. To get multiple independent threads running from the same Task component class, create multiple Task instances. There can be several simultaneously executing objects of the same Task component class, and each can be running different functions from the component.

### Component global associative array

All components have a global associative array designated as `m`, including Task node objects. This associative array is local to the component but global within it. For Task node objects, this associative array is not shared between threads. The Task node m is initially owned by the render thread. The Task node `init()` function then populates the Task node object with references in the associative array. On every setting of the Task node control field to `RUN`, a new thread is launched, and the Task node object associative array is cloned, with the launched thread receiving the original object associative array, and the render thread receiving the clone. Only basic object types are cloned: integers, Booleans, strings, floats, nodes, and recursively, arrays and associative arrays. These are generally the same object types that are copied through the fields, plus functions and timespans. Because of this cloning mechanism, some object references, such as a message port created in `init()`, are only passed to the first thread launched from a Task node, and not to subsequent threads launched by the same Task node.

### Task node changes in Roku OS 7.2

In both Roku OS 7.1 and 7.2, within the same Task node component object, the `m` for the render thread is distinct from that of any spawned node Task node thread. The initialization of a Task node object happens in the render thread, so the Task node `init()` function operates on the `m` for the render thread.

In Roku OS 7.1, on transition of a Task node control state to `"RUN"`, the `m` for the Task node thread was almost empty save for the references to the top and global nodes.

In Roku OS 7.2, on each transition of the Task node control state to `"RUN"`, the render thread `m` is cloned, the original is passed to the new Task node thread, and the render thread retains the clone. Members of `m` which are basic types like integers, Booleans, strings, and floats are cloned. Associative arrays and arrays are cloned recursively. RoSGNodes are also cloned, but not recursively, since they are already thread-safe. This is all much like what would happen when an associative array is set to a field.

Since the non-port observer callbacks can modify the render thread `m`, any state changes they make are seen by new threads spawned after such changes.

This means that previously, in Roku OS version 7.1, only the render thread `m` had state from `init()`. In Roku OS version 7.2, both the render thread `m` and the Task node thread `m` have state from `init()`. Since the Task node thread gets the original, non-cloneable objects, like message ports, they end up in the Task node thread `m` . The render thread `m` would no longer have them, and would have to recreate them in its `m` if it wanted to pass such things to the Task node thread for subsequent control state transitions to `"RUN"`.

The general idea is that you should expect `init()` to operate on the `m` state visible to both the render thread and the Task node thread.

In the port form of the ifSGNodeField [`observeField()`](/docs/references/brightscript/interfaces/ifsgnodefield.md#observefieldfieldname-as-string-functionname-as-string-as-boolean) method, it can be helpful to create the port, and observe using it in `init()`, so that no subsequent field settings are missed due to race. Transferring the original to the Task node thread rather than the clone allows this to work since the port is not cloneable.

roLocalization
==============

The roLocalization object provides functions to assist in localization. This object provides functions to assist in localization.

It is created with no parameters:

`CreateObject("roLocalization")`

**Example**

    loc = CreateObject("roLocalization")
    image = loc.GetLocalizedAsset("images", "splash.png")
    

Supported interfaces
--------------------

*   [ifLocalization](/docs/references/brightscript/interfaces/iflocalization.md "ifLocalization")

Deep linking
============

Deep linking enables users to get to your content faster from the Roku UI via [Roku's content discovery features](/docs/features/engagement/overview.md) (for example, [Roku Search](/docs/developer-program/discovery/search/implementing-search.md) and [Roku home screen banners](/docs/features/engagement/self-serve-promotions.md#display-ads-on-roku)). With deep linking, your app is launched into playback or content springboards directly from the Roku UI. For example, when a movie is selected from Roku Search, playback starts immediately without any app navigation. This functionality enables you to leverage Roku's content discovery features in order to drive users to your app and increase engagement.

> Public apps with video content must implement deep linking to pass [certification](/docs/developer-program/certification/certification.md#5-deep-linking).

Overview
--------

The following diagram demonstrates how deep linking from Roku Search works. When content is selected, the [contentId](#understanding-deep-linking-parameters) and [mediaType](#understanding-deep-linking-parameters) are passed as query string parameters to the app. The app accepts and validates the deep linking parameters and identifies the appropriate launch behavior, which is determined by the mediaType. In this example, contentId "loganLucky123" corresponds to the film "Logan Lucky", and the mediaType is "movie". The "movie" mediaType requires the app to launch directly into playback (see [MediaType behavior](#mediatype-behavior) for more information on the launch behavior required for different mediaTypes).

![DeepLinkingDiagram](https://image.roku.com/ZHZscHItMTc2/DeepLinkingDiagram-rev3a.png "DeepLinkingDiagram")

Implementing deep linking in an app entails the following steps:

1.  **Understand deep linking parameters**. Identify the different content types in your app and map them to their corresponding Roku-supported mediaTypes.

2.  **Scope required deep linking behavior**. Identify the work required for handling deep link requests based on content classifications.

3.  **Update the app**. Program the app so it accepts and validates the deep linking parameters and launches into the required experience.

4.  **Test deep linking in the app**. Verify that the app handles deep links correctly using the Roku Deep Linking Tester or [External Control Protocol](/docs/developer-program/dev-tools/external-control-api.md) (ECP) commands sent via cURL.

5.  **Submit deep link samples for certification**. Submit sample deep link parameters in the Developer Dashboard for each mediaType in your app.

Understanding deep linking parameters
-------------------------------------

Deep link requests contain two key parameters: **contentid** and **mediaType**.

*   A contentId is a URL-encoded ASCII string (maximum 255 characters) that uniquely identifies content in your app. The contentId may be an alphanumeric string, URL, or pipe-separated key-value pairs (for example, series=myAwesomeShow|Season=1|Episode=1).

*   The mediaType specifies how an app should behave when receiving a deep link request. See [MediaType behavior](#mediatype-behavior) for more information.

The following example demonstrates a deep link request sent to an app. The [**source** parameter](/docs/developer-program/getting-started/architecture/dev-environment.md#source-parameter) specifies the origin of the deep link request (in this case, it is from [Roku Search](/docs/developer-program/discovery/search/implementing-search.md)):

      http://192.168.1.114:8060/launch/50000?contentId=myAwesomeShow|Season=1|Episode=1&mediaType=series&source=hs-search
    

The app receives the deep link parameters as an associative array as demonstrated in the following example (see [Implementing Deep Linking](/docs/developer-program/discovery/implementing-deep-linking.md#implementing-deep-linking) for more information on handling these parameters; see [Using the debug console for troubleshooting deep linking parameters](#using-the-debug-console-for-troubleshooting-deep-linking-parameters) for how to check the deep linking parameters being sent to your app):

    <Component: roAssociativeArray> =
      {
          action: "display"
          contentid: "myAwesomeShow|Season=1|Episode=1"
          instant_on_run_mode: "foreground"
          isexternal: true
          lastExitOrTerminationReason: "EXIT_UNKNOWN"
          mediatype: "series"
          source: "hs-search"
          splashTime: "0"
      }
    

> If an app is participating in [Roku Search](/docs/features/engagement/roku-search.md), the contentid in the Roku Search feed (PlayID) must map to the contentid in your app for the same content. It is therefore important to keep the Roku Search feed synchronized with the app's content feed.
> 
> For episodic content, Roku Search only recognizes the episode contentid. An episode's contentid therefore must remain consistent, regardless if a deep link launches the episode or an episodic picker screen. These different deep link behaviors are determined solely by the mediaType. Separate contentIDs used to identify the season and series of the same content item are therefore ignored.

Scoping deep linking requirements
---------------------------------

Before programming your app to handle deep links, you need to understand the required behavior for launching content based on the different mediaTypes. In addition, there are general requirements that your app should follow when responding to deep link requests.

Understanding and adhering to these deep linking requirements provides a standard user experience across the Roku platform and helps ensure that your app passes certification.

### MediaType behavior

When a deep link is sent to your app, it will include contentId and a mediaType. The contentId specifies which content to play, and the mediaType tells your app how it must handle the launching of the content item. The following table summarizes the required launch behavior for each mediaType. For examples of the different mediaType behaviors, see [MediaType behavior examples](#mediatype-behavior-examples).

| mediaType in Deep Link | Description | Required Launch Behavior |
| --- | --- | --- |
| movie | Movie or long-form film (over 15 minutes). | Play the movie identified by the contentId. Use [bookmarks](/docs/developer-program/media-playback/bookmarking.md) to determine the playback position. |
| episode | Single content item (an episode of a TV show, for example). | Play the episode identified by the contentId. Use [bookmarks](/docs/developer-program/media-playback/bookmarking.md) to determine the playback position. |
| season (optional) | As part of a series, single set of related TV episodes. | Optionally, launch a content springboard that displays episodes organized by season; highlight the episode mapped to the contentid.  <br><br>Season deep links are no longer being sent from Roku Search. |
| series | Set of related serialized episodes and possibly seasons. Includes TV shows and daily/weekly ongoing shows. | Launch an episode into direct playback using smart bookmarks. A smart bookmark determines the episode to be launched and the playback position based on the type of series, whether the user has previously watched the series, and whether they completed the last watched episode.  <br>  <br>The different types of series and their recommended smart bookmark behavior are as follows:  <br><br>*   Followed TV (a series that the user has already started watching in the past): Use bookmarks to determine whether the user completed the previously watched episode. If they completed the last episode, launch the next episode in the series. If they did not, launch the episode where the user stopped watching.<br>*   Unwatched TV (a cataloged series that the user has not yet watched on your service): launch playback at the beginning of S1E1.<br>*   Daily/weekly shows (a regularly-occurring show that does not necessarily need to be watched in chronological order; for example, news broadcasts, talk shows, sports podcasts, and religious sermons): Launch the most recent episode in the series. |
| shortFormVideo | Standalone content that is 15 minutes or less that is not a movie or TV show (for example, movie trailers, news clips, comedy clips, food reviews, or other clips). | Play the short-form item identified by the contentId.  <br>  <br>Apps containing only short-form items are exempt from deep linking certification requirements. |
| tvSpecial | One-time TV programs that are not part of a series, or content that does not fit into any other mediaType category (for example, music, artists, sporting events, non-episodic news specials). | Play the TV special identified by the contentId. Use [bookmarks](/docs/developer-program/media-playback/bookmarking.md) to determine the playback position. |

> A deep link for a single content item will always have the same contentId; however, the mediaType may vary based on the Roku content discovery feature sending the deep link. Your app therefore must be designed to execute the specified behavior required by each mediaType that could be sent to your app.
> 
> For example, if your app only includes short video clips, the app only needs to handle the "shortFormVideo" mediaType. Similarly, if your app only contains movies, the app only needs to handle the "movie" mediaType.
> 
> But if your app includes the last three seasons of a television episode, your app needs to handle the "episode", "season", and "series" mediaTypes to be able to respond to deep links sent from Roku Search, Roku voice search, and on-device ads.
> 
> You can use the ["source" parameter](/docs/developer-program/getting-started/architecture/dev-environment.md#source-parameter) to determine from where the deep linking request originated.

### General app behavior

Your app should exhibit the following behaviors when responding to deep link requests:

*   **Handle invalid deep links**: If a deep link has an invalid contentid or mediaType, launch the app's home screen.

*   **Handle unauthenticated users:** If an unauthenticated user is launching or deep linking into your app for the first time, route the user to the appropriate authentication flow and then process the deep link request after the user has been authenticated. This can happen when a user deep links into your app via Roku Search or an on-device ad but the app is not installed. In this case, the Roku OS will prompt the user to install the app before continuing with the deep link. 

*   **Display a paywall (if needed)**: If your app requires a purchase prior to launching, the app may display a purchase screen before the letting the user view deep linked content.

*   **Support a default profile** If your app supports different profiles, set the last one used as the default for a movie, episode or series. An app may not display a profile selection screen, or any other screen other than one for purchases or authentication, between the selection and playback of a movie or episode. Do not use any profiles linked to children as the default. 

*   **Avoid resume/start over screens**: Apps may not use resume/start over screens when handling deep links into movies, TV episodes, or TV series. Apps must use bookmarks or smart bookmarks to identify the playback position and resume at that spot.

*   **Avoid deep linking into other apps**: An app may not deep link into third-party apps.

Implementing deep linking
-------------------------

Deep linking is implemented by passing launch parameters to your app's Main() function. These launch parameters are passed in using an associative array similar to argv in C. Your app is responsible for parsing these parameters and taking the appropriate action, or in the case of an error, detecting it and going to the app's home screen. To integrate deep linking in your app, follow these steps:

1.  Accept the deep linking parameters (contentId and mediaType) being passed to it. To do this, add an associativeArray argument to your app's main entry point, which is typically either the **main()** or **runuserinterface()** function. The name of the argument is arbitrary; for the example in this section, it is **args**.
    
        Function Main (args as Dynamic) as Void
        
    

2.  Verify that the contentId and mediaType have valid values. To do this, parse the associativeArray received by your app using the **contentid** and **mediatype** key names, and then check the values. 
    
        if (args.mediaType <> invalid) and (args.contentId <> invalid)
        
    

> Use a case-insensitive check when validating the **contentId** and **mediaType** key names.

3.  If the contentId and mediaType are valid, launch the specified content item using the appropriate [launch behavior for the mediaType](/docs/developer-program/discovery/implementing-deep-linking.md#mediatype-behavior). If either the contentId or mediaType are invalid, launch the app home page.
    
        if (args.mediaType = "movie" or args.mediaType = "episode" or args.mediaType = "shortFormVideo" or args.mediaType = "series" or args.mediaType = "tvSpecial")
           if valid_contentId(contentId) ' You define this function in your back-end
               'play content directly, starting at last bookmarked position
           else
               'pop an error message and launch channel home page.
           end if
        else if (args.mediaType = “season”)
           if valid_contentId(contentId) ' You define this function in your back-end
               'display an episodic picker screen with the episode of the contentId selected
           else
               'pop an error message and launch channel home page.
           end if
        else
            'deep linking issue such as contentId not matching any content in the partner's catalog
            'display an appropriate error message for the user and launch home page.
        end if
        
    

4.  Use [roInputEvent](/docs/references/brightscript/events/roinputevent.md) to check whether a deep link has been passed into the app while your app is running. This enables your app to deep link into content without re-launching your app.
    
    a. The [supports\_input\_launch](/docs/developer-program/getting-started/architecture/channel-manifest.md) attribute (**supports\_input\_launch=1**) must be added to the manifest for this functionality to work.For example, when a voice input request is received (for example, "Play Game of Thrones" while your app is in the foreground), your app can send the deep link parameters through the roInputEvent—instead of re-launching your app with the parameters.
    
    b. A message loop that listens for incoming events is typically used. If that event is an roInputEvent, an action is taken based on the input. If the input is content ID, the app typically finds the stream URL and metadata for that content ID, and then cues and plays the content. See [Sample app](/docs/developer-program/discovery/implementing-deep-linking.md#sample-app) to download and install a sample app that demonstrates how to use [roInputEvent](/docs/references/brightscript/events/roinputevent.md) to handle deep links while your app is running.
    
         ...
         screen = CreateObject("roSGScreen")
         m.port = CreateObject("roMessagePort")
         screen.setMessagePort(m.port)
         ...
         while(true)
             msg = wait(0, m.port)
             msgType = type(msg)
             if msgType = "roSGScreenEvent"
                 if msg.isScreenClosed() then return
             end if
             if type(msg) = "roInputEvent"
                 if msg.IsInput()
                     info = msg.GetInfo()
                     if info.DoesExist("mediatype") and info.DoesExist("contentid")
                         mediaType = info.mediatype
                         contentId = info.contentid
                     end if
                 end if
             end if
         end while
        
    

#### Custom deep linking experiences from ads and Home screen banners

For campaigns and promotions, publishers can build custom deep linking experiences to drive users to any screen within their app from a home screen banner or ad placement. Use cases include (but are not limited to) launching to a content details screen or a subscription plan selection screen to promote content or subscriptions plans.

To handle deep linking for these scenarios, assign a unique **contentId** to the screen and update the app to launch that screen upon receiving the contentId. In this case, no business logic is required for handling the **mediaType**; the app should launch the screen regardless of whichever mediaType is received.

Testing deep linking in the app
-------------------------------

You can verify whether your app is implementing the correct deep linking behavior using either the [Roku Deep Linker Tester](https://devtools.web.roku.com/DeepLinkingTester/) and the associated [Roku Deep Linking Tester channel](https://my.roku.com/account/add?channel=KX3UPK) or [ECP](/docs/developer-program/dev-tools/external-control-api.md) commands sent via cURL. Both methods enable you to test deep linking into content when launching an app; however, to test deep linking while your app is running, you must use ECP commands.

You can also check which deep linking parameters are being sent to your app using the [debug console](/docs/developer-program/debugging/debugging-channels.md#accessing-the-debug-console).

> Test each mediaType in your content feed. For example, if your feed contains movies and short-form videos, you should test deep linking to content of both mediaTypes. In addition, if your feed contains series content, you must test that both series and episode mediaTypes demonstrate their required launch behaviors.
> 
> Deep links must work for your app to pass certification; therefore, it is recommended you do this testing.

### Using the Roku Deep Linking Tester

The Roku Deep Linking Tester provides a UI for configuring, saving, import/exporting, and executing deep linking test cases. To use the tool for testing deep linking in your app, follow these steps:

1.  Verify that your Roku device and computer are connected to the same sub-network.

2.  Open the Roku Deep Linking Tester ([https://devtools.web.roku.com/DeepLinkingTester](https://devtools.web.roku.com/DeepLinkingTester/)). Optionally, you can download the Mac, PC, or Linux version of the tool onto your desktop. This saves you the step of having to manually enter the ID and name of the app to be tested.

3.  In the **Device Manager > Online** tab, select your test device by toggling the On/Off button and then clicking **Select device**. You can also manually add your device by clicking **Add a Device**, entering its IP address, entering a name to be used to identify it, and then clicking **Add**. To test sideloaded apps, click the settings icon under **Options**, enter the user name (rokudev) and password for your device, and then click **Save**.
    
    ![roku400px - rrmselectdevice](https://image.roku.com/ZHZscHItMTc2/rrm-device-manager.png)
    

4.  Click the app to be tested from the list of apps on the left. For production apps, the Roku device must be keyed with the same developer key that was used to sign the app for publishing to the Streaming Store.

5.  Add one or more test cases. To do this, click the **Add a Test Case** icon, enter a name for the test case, and then save the test case. Enter the **contentId** and select the **mediaType** for the test case; these will automatically be saved after you enter them.
    
    ![roku400px - deeplinktest](https://image.roku.com/ZHZscHItMTc2/deep-link-test-case.png)
    

6.  Click **Send**, and verify that your app is launched and direct playback of the content starts immediately. You can change the command being sent from **Launch** (the default) to **Input** in order to verify that your app properly handles deep links while it is already running.

### Using ECP commands for testing deep linking

You can test deep linking in an app by sending ECP commands via cURL to your Roku device. This enables you to test deep linking into content when your app is launched and while it also running.

To test deep linking using ECP/cURL, send an HTTP POST request to port 8060 on your Roku device using the following syntax:

    http://<roku-device-ip-address>:8060/<EcpCommand>/<channelId>?contentId=<contentIdValue>&mediaType=<mediaTypeValue>
    

The following attributes are required:

| Parameter | Description | Example |
| --- | --- | --- |
| EcpCommand | Enter one of the following commands:  <br><br>*   **launch**: Test deep linking into content when app is launched.<br>*   **input**: Test deep linking into content while app is running. | launch |
| channelId | Enter one of the following:  <br><br>*   **dev**: Sideloaded app.<br>*   **<_id_\>**: Public or [beta](/docs/developer-program/publishing/channel-publishing-guide.md#beta-channel-guidelines) apps. To find your app ID, use the preview page on the Developer Dashboard. | dev |
| contentIdValue | Enter the **contentId** of the content item to be used for the deep link test. | 1234 |
| mediaTypeValue | Enter the **mediaType** of the content item to be used for the deep link test. See [MediaType behavior](#mediatype-behavior) for the possible values. | movie |

The following examples show how to send ECP commands via cURL HTTP POST requests. The examples are based on a sideloaded app with contentId of 1234 and a mediaType of movie. The **launch** command is used to test deep linking into content when the app is launched; the **input** command is used for when the app is already running. When sending the **input** command, the app (**dev**) is not required.

    curl -d '' 'http://192.168.1.114:8060/launch/dev?contentId=1234&mediaType=movie'
    curl -d '' 'http://192.168.1.114:8060/input?contentId=1234&mediaType=movie'
    

To test deep links on your production app, replace "dev" with your app ID (an app ID of 50000 is used in the following example). Because the **input** command does not require the app ID, the same command can be used for testing in development and production.

    curl -d '' 'http://192.168.1.114:8060/launch/50000?contentId=1234&mediaType=movie'
    curl -d '' 'http://192.168.1.114:8060/input?contentId=1234&mediaType=movie'
    

### Using the debug console for troubleshooting deep linking parameters

You can use the [debug console](/docs/developer-program/debugging/debugging-channels.md#accessing-the-debug-console) to check the deep linking parameters that are being sent to your app. To do this, add a print statement to your app application that outputs the associative array passed into your app's `Main()` function and [roInputEvent](/docs/references/brightscript/events/roinputevent.md).

This is useful when troubleshooting deep links because it helps you identify the **contentId** of the content being launched in case it is unknown, and it provides the **mediaType** in case the expected behavior is not being executed.

The following example demonstrates how to output the associative array containing the deep linking parameters:

    sub Main(args)
        ...
        if (args.mediaType <> invalid) and (args.contentId <> invalid)
            ...
            'print deep linking paramaters in args
            "args= "; formatjson(args)  'pretty print AA'
            'output
            ' args= {action: "display", contentid: "myAwesomeShow|Season=1|Episode=1", instant_on_run_mode: "foreground", isexternal: true, lastExitOrTerminationReason: "EXIT_UNKNOWN", mediatype: "series", source: "hs-search", splashTime: "0"}
            ...
    

### Submitting deep linking samples for certification

As part of the app certification process, you must use the Developer Dashboard to submit sample deep linking parameters for your app. This enables Roku to certify that your app is responding with the correct behavior for the different types of content in your app.

To submit deep links for certification, follow these steps:

1.  Verify that your app meets all [certification requirements](/docs/developer-program/certification/certification.md).

2.  Open the [Developer Dashboard](https://developer.roku.com/developer) and click **Manage My Channels**. Click your app, and then select **Deep Linking** from the list on the right.

3.  Follow the instructions in the [Deep Linking window documentation](/docs/developer-program/publishing/channel-publishing-guide.md#deep-linking-window).

MediaType behavior examples
---------------------------

The following GIFs demonstrate the required launch behavior for the different mediaType values:

#### movie

The movie identified by the contentId is launched directly into playback. [Bookmarks](/docs/developer-program/media-playback/bookmarking.md) are used to determine the playback position.

![roku600px movie-deeplink-gif](https://image.roku.com/ZHZscHItMTc2/weird-deeplink-movie.gif)

#### episode

The episode identified by the contentId is launched directly into playback. [Bookmarks](/docs/developer-program/media-playback/bookmarking.md) are used to determine the playback position.

![roku600px movie-deeplink-gif](https://image.roku.com/ZHZscHItMTc2/children-deeplink-episode.gif)

#### season (optional)

A content springboard is launched. The springboard displays episodes organized by season and the episode mapped to the contentid is highlighted.

![roku600px movie-deeplink-gif](https://image.roku.com/ZHZscHItMTc2/rokurec-deeplink-season.gif)

#### series

The episode identified by the contentId is launched directly into playback. Smart bookmarks are used to determine which episode to launch. The playback position is based on the type of series, whether the user has previously watched the series, and whether they completed the last watched episode.

![roku600px movie-deeplink-gif](https://image.roku.com/ZHZscHItMTc2/reno911-deeplink-series.gif)

#### shortFormVideo

The shortForm video (less than 15 minutes) identified by the contentId is launched directly into playback.

![roku600px movie-deeplink-gif](https://image.roku.com/ZHZscHItMTc2/bangles-deeplink-shortform.gif)

#### tvSpecial

The one-time TV program identified by the contentId is launched directly into playback. [Bookmarks](/docs/developer-program/media-playback/bookmarking.md) are used to determine the playback position.

![roku600px movie-deeplink-gif](https://image.roku.com/ZHZscHItMTc2/ozzy-deeplink-special.gif)

Deep linking video lesson
-------------------------

You can learn how to implement deep linking in your app by watching the [Deep linking](/videos/courses/rsg/deep-linking.md) video lesson in Roku's [SceneGraph: Build a Channel online video course](https://developer.roku.com/videos/courses/rsg/overview.md).

This lesson details how to program your app application to accept and process deep links upon being launched and while it is already running. It lists the different playback experiences requried for the various types of content in the app's feed.

Sample app
----------

You can download and install a [sample app](https://github.com/rokudev/deep-Linking-samples) that demonstrates how to launch content with deep links. It provides content that you can use to test deep linking via ECP commands sent via cURL. It shows you how you can design your app to deep link into content when both launching an app and while the app is already running.

Key Definition File
===================

The Key Definition File is a JSON-formatted file that specifies the layout of a keyboard. The Key Definition Files for the classes derived from **DynamicKeyboardBase** (**DynamicKeyboard**, **DynamicPinPad**, and **DynamicMiniKeyboard**) are built-in and cannot be modified because the keyboard layout for these nodes is fixed. Conversely, the **DynamicCustomKeyboard** node requires developers to create the Key Definition File in order to implement a custom keyboard layout.

The Key Definition File is a single JSON object with the following six hierarchal objects (listed in order from the top to the bottom of the hierarchy):

1.  [KeyLayout](#keylayout)
2.  [Section](#section)
3.  [Grid](#grid)
4.  [Row](#row)
5.  [Key](#key)
6.  [KeySuggestions](#keysuggestions)

Properties can be set at any level of the hierarchy and are used to determine the default values for the subparts at lower levels in the hierarchy. For example, setting the **keyboardHeight** property at the **KeyLayout** level will specify the default height of each **Row** in each **Grid** in each **Section** of the grid used. If a **Grid** specifies a **gridHeight** property, it is set as the default for each **Row** in that **Grid**. In both cases, if any **Row** in the **Grid** specifies a **rowHeight** property, that height will be used as the default for each **Key** in that **Row**.

KeyLayout
---------

The **KeyLayout** object specifies the key configuration for a keyboard instance. Each Key Definition File includes a single **KeyLayout**. The **KeyLayout** contains one or more Section arrays.

| Attribute | Type | Description |
| --- | --- | --- |
| keyboardHeightFHD | unsigned | Overall height of the keyboard for FHD. |
| keyboardWidthFHD | unsigned | Overall width of the keyboard for FHD. |
| keyboardHeightHD | unsigned | Overall height of the keyboard for HD. |
| keyboardWidthHD | unsigned | Overall width of the keyboard for HD. |
| sections | array of **Section** objects | An array of **Section** objects in the **KeyLayout**. A **KeyLayout** object contains one or more **Section** objects (it must have at least one). Most have a single **Section** object (for example, a PIN pad). In some cases, however, a **KeyLayout** will have multiple **Section** objects (for example, Roku's WiFi keyboard has four sections). |

Section
-------

A **Section** contains one or more **Grid** objects.

| Attribute | Type | Description |
| --- | --- | --- |
| sectionWidthFHD | unsigned | Width of the section for FHD. This attribute is only required if the **KeyLayout** includes multiple **Section** objects that have different widths. |
| sectionWidthHD | unsigned | Width of the section for HD. This attribute is only required if the **KeyLayout** includes multiple **Section** objects that have different widths. |
| grids | array of **Grid** objects | An array of Grid objects in the **Section**. A **Section** object contains one or more **Grid** objects (it must have at least one). |

Grid
----

A **Section** may contain one or more **Grid** objects. A **Section** typically contains multiple **Grid** objects when defining different key layouts for a particular mode of the overall **KeyLayout**. For example, the "alpha key" section of Roku's current WiFi keyboard has six modes ("alphanumLowerCase", "alphanumUpperCase", "symbolsLowerCase", "symbolsUpperCase", "accentsLowerCase", "accentsUpperCase"). Each of the modes for these **Section** objects is specified using a different **Grid**.

| Attribute | Type | Description |
| --- | --- | --- |
| gridHeightFHD | unsigned | Height of the grid for FHD.This attribute is only required if the **Section** includes multiple **Grid** objects and the grid's height is different from the overall KeyLayout height.The gridHeight must be less than or equal to the overall KeyLayout height. |
| gridHeightHD | unsigned | Height of the grid for HD.This attribute is only required if the **Section** includes multiple **Grid** objects and the grid's height is different from the overall KeyLayout height.The gridHeight must be less than or equal to the overall KeyLayout height. |
| modes | string/array of strings | The keyboard mode when this grid is shown.If the **mode** field of a **[DynamicKeyGrid](/docs/references/scenegraph/dynamic-voice-keyboard-nodes/dynamic-key-grid.md)** node is set, the **Grid** object with the matching mode is displayed. In some cases, the same grid is shown for different keyboard modes. For example, Roku's WiFi keyboard shows the same numeric characters grid in both "alphaNumUpperCase" and "alphaNumLowerCase" modes. |
| rows | array of **Row** objects | An array of **Row** objects in the **Grid**. A **Grid** object contains one or more **Row** objects (it must have at least one).If the _rows_ array contains a null Row (for example, {} in the _rows_ array), a blank space will be shown (no key background, label or icon is drawn) and focus cannot be set on that Row object. |

Row
---

A **Row** is a container for a set of keys. A **Grid** may contain one or more **Row** objects.

| Attribute | Type | Description |
| --- | --- | --- |
| rowHeightFHD | unsigned | Height of the row for FHD. This attribute is only required if the **Grid** includes multiple **Row** objects with different heights. |
| rowHeightHD | unsigned | Height of the row for HD. This attribute is only required if the **Grid** includes multiple **R\*\***ow\*\* objects with different heights. |
| keys | array of **Key** objects | An array of **Key** objects in the **Row**. A **Row** object contains one or more **Key** objects (it must have at least one).If the **Key** object does not include either a **label** field or an **icon\***/**\*focusIcon** field, a blank key background will be drawn and focus cannot be set on that key. |

Key
---

A **Key** specifies a single key within a **Row** object. The **Key** defines the string or icon that is displayed on the key and the string that is sent when the key is focused or selected. Keys may either have a label or an icon, but may not have both.

| Attribute | Type | Description |
| --- | --- | --- |
| keyWidthFHD | unsigned | Width of the key for FHD. This attribute is only required if the **Row** includes multiple **Key** objects with different widths. |
| keyWidthHD | unsigned | Width of the key for HD. This attribute is only required if the **Row** includes multiple **Key** objects with different widths. |
| label | string | The string to be displayed on the key. Labels can be specified using the character itself or UTF-16 encoding. For example, the lowercase n tilde can be specified with "ñ" or "\\u00F1".If the **strOut** field is not specified, this is also the string that is sent when the key is focused or selected. |
| icon | uri | The icon to be displayed on the key. If an icon is specified, the **strOut** field must be specified to send the appropriate string when the key is focused or selected. If an icon is specified, do not specify a label. |
| focusIcon | uri | The icon to be displayed when the key has focus. If an icon is specified, do not specify a label. |
| strOut | string | The string to be sent when the key is focused or selected. |
| autoRepeat | unsigned | By default, this field is set to **0**, which means the action associated with the key occurs only once. If this field is not set to **0**, the action will continue until the key is released. |
| disabled | unsigned | If this field is set to **0**, the key's label or icon is drawn with a disabled appearance and the key cannot be focused. |
| suggestions | KeySuggestions | The alternate strings to be displayed in a pop-up when the key is triggered. |

KeySuggestions
--------------

A **KeySuggestions** object specifies one or more optional values for the associated **Key** object. The optional values are displayed when one of the key's triggers occurs.

AttributeTypeDescriptionoptionsstring/array of stringsThe optional strings associated with the **Key** object (for example, the @ key may have options of @[gmail.com](http://gmail.com/), @[msn.com](http://msn.com/), and so on).triggersstring/array of stringsThe actions that trigger the suggestions pop-up. This may be one or both of the following values:  
  

| string | description |
| --- | --- |
| select | The suggestions pop-up appears when the key is selected. |
| hover | The suggestions pop-up appears if focus remains on the key for a short interval. |

Computing Key Sizes
-------------------

Key sizes are computed based on the various width and height properties specified by the hierarchy of parts. In general, default key widths and heights are computed using the width/height values from higher levels in the hierarchy, but can be overridden by values specified lower in the hierarchy.

### Key Height Computation

*   The overall keyboard height is specified by the KeyLayout's **keyboardHeight** attribute.

*   All **Section** objects have the same height.

*   Key heights are computed based on the number of **Row** objects in a KeyGrid.

*   For equal height rows, if there are _N_ Rows in a KeyGrid, the height of each key for each row in a KeyGrid is computed as follows: `keyHeight = (keyboardHeight) / N`.

*   To configure rows with varying heights, specify the **rowHeight** attribute for those rows. Those rows will use the explicitly specified heights and the heights of the remaining rows will be computed by equally dividing the remaining **keyboardHeight** evenly after subtracting the height of the rows with explicitly specified heights. For example, if there are _N_ rows and Row 1 has its **rowHeight** explicitly specified as 75, the keys in Row 1 will have height 75, and the height of the keys in the other rows will be calculated as follows: `keyHeight = (keyboardHeight - 75) / (N - 1)`.

### Key Width Computation

*   The overall keyboard width is specified by the KeyLayout's **keyboardWidth** attribute.

*   If there are _S_ sections, the width of each section by default would be as follows: `sectionWidth = (keyboardWidth) / N`.
    
*   Individual sections can override the default section width by explicitly specifying a **sectionWidth** attribute. Those sections will use the explicitly specified widths, and the remaining **keyboardWidth** will be equally divided between the sections that do not specify explicit widths, similar to how the key height is computed above if the **rowHeight** is explicitly specified for some rows.
    

*   Each Grid in a Section object has the same width.

*   For keys with equal width in a Row object, if there are _K_ keys in the Row, the height of each key is computed as follows: `keyWidth = (sectionWidth) / K`.

*   To configure keys with varying widths within in a Row, specify the **keyWidth** attribute for those keys. Those keys will use the explicitly specified widths, and the widths of the remaining keys will be computed by equally dividing the remaining **sectionWidth** evenly after subtracting the width of the keys with explicitly specified widths. For example, if there are _K_ keys in a row and Key 1 has its **keyWidth** explicitly specified as 100, Key 1 will have width 100 and the other keys in the Row will be calculated as follows: `keyWidth = (sectionWidth - 100) / (K - 1)`.

Examples
--------

### PinPad

This example uses a Key Definition File to specify a simple numeric PIN pad. The KeyLayout includes a single Section with a single Grid that has four Rows with three Keys each.

![roku815px - pin-pad-kdf](https://image.roku.com/ZHZscHItMTc2/pin-pad-kdf.jpg)

    {
      "keyboardWidthFHD": 495,
      "keyboardHeightFHD": 300,
      "keyboardWidthHD": 324,
      "keyboardHeightHD": 200,
      "sections": [
        {
          "grids": [
            {
              "rows": [
                {
                  "keys": [
                    { "label": "1" },
                    { "label": "2" },
                    { "label": "3" }
                  ]
                },
                {
                  "keys": [
                    { "label": "4" },
                    { "label": "5" },
                    { "label": "6" }
                  ]
                },
                {
                  "keys": [
                    { "label": "7" },
                    { "label": "8" },
                    { "label": "9" }
                  ]
                },
                {
                  "keys": [
                    {
                      "icon": "theme:DKB_ClearKeyBitmap",
                      "focusIcon": "theme:DKB_ClearKeyFocusBitmap",
                      "strOut": "clear"
                    },
                    { "label": "0" },
                    {
                      "icon": "theme:DKB_DeleteKeyBitmap",
                      "focusIcon": "theme:DKB_DeleteKeyFocusBitmap",
              "autoRepeat": 1,
                      "strOut": "backspace"
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    }
    

### MiniKeyboard

This example uses the Key Definition File for the Search "MiniKeyboard" used by the RokuOS. The KeyLayout has a single Section with a single Grid that has six rows, with six keys each for the characters a-z and 0-9. The seventh row of the grid has three double-width keys for **Clear**, **Space**, and **Backspace**.

![roku815px - mini-keyboard-kdf](https://image.roku.com/ZHZscHItMTc2/mini-keyboard-kdf-v2.jpg)

    {
      "keyboardWidthFHD": 576,
      "keyboardHeightFHD": 630,
      "keyboardWidthHD": 384,
      "keyboardHeightHD": 420,
      "sections": [
        {
          "grids": [
            {
              "rows": [
                {
                  "keys": [
                    { "label": "a" },
                    { "label": "b" },
                    { "label": "c" },
                    { "label": "d" },
                    { "label": "e" },
                    { "label": "f" }
                  ]
                },
                {
                  "keys": [
                    { "label": "g" },
                    { "label": "h" },
                    { "label": "i" },
                    { "label": "j" },
                    { "label": "k" },
                    { "label": "l" }
                  ]
                },
                {
                  "keys": [
                    { "label": "m" },
                    { "label": "n" },
                    { "label": "o" },
                    { "label": "p" },
                    { "label": "q" },
                    { "label": "r" }
                  ]
                },
                {
                  "keys": [
                    { "label": "s" },
                    { "label": "t" },
                    { "label": "u" },
                    { "label": "v" },
                    { "label": "w" },
                    { "label": "x" }
                  ]
                },
                {
                  "keys": [
                    { "label": "y" },
                    { "label": "z" },
                    { "label": "1" },
                    { "label": "2" },
                    { "label": "3" },
                    { "label": "4" }
                  ]
                },
                {
                  "keys": [
                    { "label": "5" },
                    { "label": "6" },
                    { "label": "7" },
                    { "label": "8" },
                    { "label": "9" },
                    { "label": "0" }
                  ]
                },
                {
                  "keys": [
                    {
                      "icon": "theme:DKB_ClearKeyBitmap",
                      "focusIcon": "theme:DKB_ClearKeyFocusBitmap",
                      "strOut": "clear"
                    },
                    {
                      "icon": "theme:DKB_SpaceKeyBitmap",
                      "focusIcon": "theme:DKB_SpaceKeyFocusBitmap",
              "strOut": "space"
                    },
                    {
                      "icon": "theme:DKB_DeleteKeyBitmap",
                      "focusIcon": "theme:DKB_DeleteKeyFocusBitmap",
              "autoRepeat": 1,
                      "strOut": "backspace"
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    }
    

### Address Keyboard

This is an example of a keyboard with a single Section that supports five different modes used for entering a name, zip code and an address. The five modes are as follow:

*   NameUpper
*   NameLower
*   Zip
*   FullUpper
*   FullLower

Each mode is associated with a different Grid layout.

The examples below show the Keyboard in the "NameLower", "Zip" and "FullLower" modes. These examples illustrate the following:

*   For all of the modes, the same **KeyboardWidth** is used.
*   The grid used for the "Zip" mode has fewer rows than the other two modes. The **SectionHeight** for that mode is set so that the height of each row stays the same as in the other modes that use **KeyboardHeight**.
*   In the "NameLower" mode, the **Prev** key is disabled. Similarly, in the "FullUpper" mode, the **Next** key is disabled.

![roku815px - key-grid-1-lower-kdf](https://image.roku.com/ZHZscHItMTc2/key-grid-1-lower-kdf.jpg)

![roku815px - key-grid-2-full-lower](https://image.roku.com/ZHZscHItMTc2/key-grid-2-full-lower-kdf.jpg)

![roku815px - key-grid-3-zip](https://image.roku.com/ZHZscHItMTc2/key-grid-3-zip-kdf.jpg)

    {
      "keyboardWidthFHD": 576,
      "keyboardHeightFHD": 432,
      "keyboardWidthHD": 384,
      "keyboardHeightHD": 288,
      "sections": [
        {
          "grids": [
            {
              "modes": "NameUpper",
              "rows": [
                {
                  "keys": [
                    { "label": "A" },
                    { "label": "B" },
                    { "label": "C" },
                    { "label": "D" },
                    { "label": "E" },
                    { "label": "F" }
                  ]
                },
                {
                  "keys": [
                    { "label": "G" },
                    { "label": "H" },
                    { "label": "I" },
                    { "label": "J" },
                    { "label": "K" },
                    { "label": "L" }
                  ]
                },
                {
                  "keys": [
                    { "label": "M" },
                    { "label": "N" },
                    { "label": "O" },
                    { "label": "P" },
                    { "label": "Q" },
                    { "label": "R" }
                  ]
                },
                {
                  "keys": [
                    { "label": "S" },
                    { "label": "T" },
                    { "label": "U" },
                    { "label": "V" },
                    { "label": "W" },
                    { "label": "X" }
                  ]
                },
                {
                  "keys": [
                    { "label": "Y" },
                    { "label": "Z" },
                    {
                      "icon": "theme:DKB_SpaceKeyBitmap",
                      "focusIcon": "theme:DKB_SpaceKeyFocusBitmap",
                      "strOut": "space"
                    },
                    {
                      "icon": "theme:DKB_DeleteKeyBitmap",
                      "focusIcon": "theme:DKB_DeleteKeyFocusBitmap",
                      "strOut": "backspace"
                    },
                    {
                      "icon": "theme:DKB_ClearKeyBitmap",
                      "focusIcon": "theme:DKB_ClearKeyFocusBitmap",
                      "strOut": "clear"
                    },
                    {
                      "label": "Aa",
                      "strOut": "UpperLower"
                    }
                  ]
                },
                {
                  "keys": [
                    { "label": "Prev", "disabled": 1 },
                    { "label": "Next" }
                  ]
                }
              ]
            },
            {
              "modes": "NameLower",
              "rows": [
                {
                  "keys": [
                    { "label": "a" },
                    { "label": "b" },
                    { "label": "c" },
                    { "label": "d" },
                    { "label": "e" },
                    { "label": "f" }
                  ]
                },
                {
                  "keys": [
                    { "label": "g" },
                    { "label": "h" },
                    { "label": "i" },
                    { "label": "j" },
                    { "label": "k" },
                    { "label": "l" }
                  ]
                },
                {
                  "keys": [
                    { "label": "m" },
                    { "label": "n" },
                    { "label": "o" },
                    { "label": "p" },
                    { "label": "q" },
                    { "label": "r" }
                  ]
                },
                {
                  "keys": [
                    { "label": "s" },
                    { "label": "t" },
                    { "label": "u" },
                    { "label": "v" },
                    { "label": "w" },
                    { "label": "x" }
                  ]
                },
                {
                  "keys": [
                    { "label": "y" },
                    { "label": "z" },
                    {
                      "icon": "theme:KeyboardSpaceOnBitmap",
                      "focusIcon": "theme:KeyboardSpaceOffBitmap",
                      "strOut": "space"
                    },
                    {
                      "icon": "theme:KeyboardDeleteOnBitmap",
                      "focusIcon": "theme:KeyboardDeleteOffBitmap",
                      "strOut": "backspace"
                    },
                    {
                      "icon": "theme:KeyboardClearOnBitmap",
                      "focusIcon": "theme:KeyboardClearOffBitmap",
                      "strOut": "clear"
                    },
                    {
                      "label": "Aa",
                      "strOut": "UpperLower"
                    }
                  ]
                },
                {
                  "keys": [
                    { "label": "Prev", "disabled": 1 },
                    { "label": "Next" }
                  ]
                }
              ]
            },
            {
              "modes": "Zip",
              "gridHeightFHD": 360,
              "gridHeightHD": 240,
              "rows": [
                {
                  "keys": [
                    { "label": "1" },
                    { "label": "2" },
                    { "label": "3" }
                  ]
                },
                {
                  "keys": [
                    { "label": "4" },
                    { "label": "5" },
                    { "label": "6" }
                  ]
                },
                {
                  "keys": [
                    { "label": "7" },
                    { "label": "8" },
                    { "label": "9" }
                  ]
                },
                {
                  "keys": [
                    {
                      "icon": "theme:KeyboardDeleteOnBitmap",
                      "focusIcon": "theme:KeyboardDeleteOffBitmap",
                      "strOut": "backspace"
                    },
                    { "label": "0"},
                    {
                      "icon": "theme:KeyboardClearOnBitmap",
                      "focusIcon": "theme:KeyboardClearOffBitmap",
                      "strOut": "clear"
                    }
                  ]
                },
                {
                  "keys": [
                    { "label": "Prev" },
                    { "label": "Next" }
                  ]
                }
              ]
            },
            {
              "modes": "FullUpper",
              "rows": [
                {
                  "keys": [
                    { "label": "0" },
                    { "label": "1" },
                    { "label": "2" },
                    { "label": "3" },
                    { "label": "4" },
                    { "label": "5" },
                    { "label": "6" },
                    { "label": "7" }
                  ]
                },
                {
                  "keys": [
                    { "label": "8" },
                    { "label": "9" },
                    { "label": "A" },
                    { "label": "B" },
                    { "label": "C" },
                    { "label": "D" },
                    { "label": "E" },
                    { "label": "F" }
                  ]
                },
                {
                  "keys": [
                    { "label": "G" },
                    { "label": "H" },
                    { "label": "I" },
                    { "label": "J" },
                    { "label": "K" },
                    { "label": "L" },
                    { "label": "M" },
                    { "label": "N" }
                  ]
                },
                {
                  "keys": [
                    { "label": "O" },
                    { "label": "P" },
                    { "label": "Q" },
                    { "label": "R" },
                    { "label": "S" },
                    { "label": "T" },
                    { "label": "U" },
                    { "label": "V" }
                  ]
                },
                {
                  "keys": [
                    { "label": "W" },
                    { "label": "X" },
                    { "label": "Y" },
                    { "label": "Z" },
                    {
                      "icon": "theme:KeyboardSpaceOnBitmap",
                      "focusIcon": "theme:KeyboardSpaceOffBitmap",
                      "strOut": "space"
                    },
                    {
                      "icon": "theme:KeyboardDeleteOnBitmap",
                      "focusIcon": "theme:KeyboardDeleteOffBitmap",
                      "strOut": "backspace"
                    },
                    {
                      "icon": "theme:KeyboardClearOnBitmap",
                      "focusIcon": "theme:KeyboardClearOffBitmap",
                      "strOut": "clear"
                    },
                    {
                      "label": "Aa",
                      "strOut": "UpperLower"
                    }
                  ]
                },
                {
                  "keys": [
                    { "label": "Prev" },
                    { "label": "Next", "disabled": 1 }
                  ]
                }
              ]
            },
            {
              "modes": "FullLower",
              "rows": [
                {
                  "keys": [
                    { "label": "0" },
                    { "label": "1" },
                    { "label": "2" },
                    { "label": "3" },
                    { "label": "4" },
                    { "label": "5" },
                    { "label": "6" },
                    { "label": "7" }
                  ]
                },
                {
                  "keys": [
                    { "label": "8" },
                    { "label": "9" },
                    { "label": "a" },
                    { "label": "b" },
                    { "label": "c" },
                    { "label": "d" },
                    { "label": "e" },
                    { "label": "f" }
                  ]
                },
                {
                  "keys": [
                    { "label": "g" },
                    { "label": "h" },
                    { "label": "i" },
                    { "label": "j" },
                    { "label": "k" },
                    { "label": "l" },
                    { "label": "m" },
                    { "label": "n" }
                  ]
                },
                {
                  "keys": [
                    { "label": "o" },
                    { "label": "p" },
                    { "label": "q" },
                    { "label": "r" },
                    { "label": "s" },
                    { "label": "t" },
                    { "label": "u" },
                    { "label": "v" }
                  ]
                },
                {
                  "keys": [
                    { "label": "w" },
                    { "label": "x" },
                    { "label": "y" },
                    { "label": "z" },
                    {
                      "icon": "theme:KeyboardSpaceOnBitmap",
                      "focusIcon": "theme:KeyboardSpaceOffBitmap",
                      "strOut": "space"
                    },
                    {
                      "icon": "theme:KeyboardDeleteOnBitmap",
                      "focusIcon": "theme:KeyboardDeleteOffBitmap",
                      "strOut": "backspace"
                    },
                    {
                      "icon": "theme:KeyboardClearOnBitmap",
                      "focusIcon": "theme:KeyboardClearOffBitmap",
                      "strOut": "clear"
                    },
                    {
                      "label": "Aa",
                      "strOut": "UpperLower"
                    }
                  ]
                },
                {
                  "keys": [
                    { "label": "Prev" },
                    { "label": "Next", "disabled": 1 }
                  ]
                }
              ]
            }
          ]
        }
      ]
    }
    

### WiFi Keyboard

This example shows the Key Definition File for the WiFi keyboard used by the Roku OS. That keyboard has four Sections. Each Section supports one or more modes with the modes being associated with one or more Grid objects. Each Grid ha four Row's with varying numbers of keys.

The examples below show the keyboard in "ABC123Lower" mode as well as "AccentsUpper" mode. Note the following:

*   The leftmost section does not change its Grid for different modes. In that case, the Section has a single Grid with its mode set to an array of all of the mode names.
*   In the "SymbolsUpper" mode, the third Section has some blank keys in the bottom two rows.

![roku815px - wifi-keyboard-1-alphanum-kdf](https://image.roku.com/ZHZscHItMTc2/wifi-keyboard-1-alphanum-kdf.jpg)

![roku815px - wifi-keyboard-2-symbols-kdf](https://image.roku.com/ZHZscHItMTc2/wifi-keyboard-2-symbols-kdf.jpg)

    {
      "keyboardWidthFHD": 1368,
      "keyboardHeightFHD": 336,
      "keyboardWidthHD": 912,
      "keyboardHeightHD": 224,
      "sections": [
        {
          "sectionWidthFHD": 180,
          "sectionWidthHD": 120,
          "grids": [
            {
              "rows": [
                {
                  "keys": [
                    {
                      "icon": "theme:DKB_ShiftKeyBitmap",
                      "focusIcon": "theme:DKB_ShiftKeyFocusBitmap",
                      "strOut": "shift"
                    }
                  ]
                },
                {
                  "keys": [
                    {
                      "icon": "theme:DKB_SpaceKeyBitmap",
                      "focusIcon": "theme:DKB_SpaceKeyFocusBitmap",
              "strOut": "space"
                    }
                  ]
                },
                {
                  "keys": [
                    {
                      "icon": "theme:DKB_DeleteKeyBitmap",
                      "focusIcon": "theme:DKB_DeleteKeyFocusBitmap",
              "autoRepeat": 1,
                      "strOut": "backspace"
                    }
                  ]
                },
                {
                  "keys": [
                    {
                      "icon": "theme:DKB_LeftKeyBitmap",
                      "focusIcon": "theme:DKB_LeftKeyFocusBitmap",
                      "strOut": "left"
                    },
                    {
                      "icon": "theme:DKB_RightKeyBitmap",
                      "focusIcon": "theme:DKB_RightKeyFocusBitmap",
                      "strOut": "right"
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "sectionWidthFHD": 630,
          "sectionWidthHD": 420,
          "grids": [
            {
              "modes": "ABC123Lower",
              "rows": [
                {
                  "keys": [
                    { "label": "a" },
                    { "label": "b" },
                    { "label": "c" },
                    { "label": "d" },
                    { "label": "e" },
                    { "label": "f" },
                    { "label": "g" }
                  ]
                },
                {
                  "keys": [
                    { "label": "h" },
                    { "label": "i" },
                    { "label": "j" },
                    { "label": "k" },
                    { "label": "l" },
                    { "label": "m" },
                    { "label": "n" }
                  ]
                },
                {
                  "keys": [
                    { "label": "o" },
                    { "label": "p" },
                    { "label": "q" },
                    { "label": "r" },
                    { "label": "s" },
                    { "label": "t" },
                    { "label": "u" }
                  ]
                },
                {
                  "keys": [
                    { "label": "v" },
                    { "label": "w" },
                    { "label": "x" },
                    { "label": "y" },
                    { "label": "z" },
                    { "label": "-" },
                    { "label": "_" }
                  ]
                }
              ]
            },
            {
              "modes": ["ABC123Upper", "ABC123Shift" ],
              "rows": [
                {
                  "keys": [
                    { "label": "A" },
                    { "label": "B" },
                    { "label": "C" },
                    { "label": "D" },
                    { "label": "E" },
                    { "label": "F" },
                    { "label": "G" }
                  ]
                },
                {
                  "keys": [
                    { "label": "H" },
                    { "label": "I" },
                    { "label": "J" },
                    { "label": "K" },
                    { "label": "L" },
                    { "label": "M" },
                    { "label": "N" }
                  ]
                },
                {
                  "keys": [
                    { "label": "O" },
                    { "label": "P" },
                    { "label": "Q" },
                    { "label": "R" },
                    { "label": "S" },
                    { "label": "T" },
                    { "label": "U" }
                  ]
                },
                {
                  "keys": [
                    { "label": "V" },
                    { "label": "W" },
                    { "label": "X" },
                    { "label": "Y" },
                    { "label": "Z" },
                    { "label": "-" },
                    { "label": "_" }
                  ]
                }
              ]
            },
            {
              "modes": "SymbolsLower",
              "rows": [
                {
                  "keys": [
                    { "label": "!" },
                    { "label": "?" },
                    { "label": "\u002A" },
                    { "label": "\u0023" },
                    { "label": "\u0024" },
                    { "label": "\u0025" },
                    { "label": "\u005E" }
                  ]
                },
                {
                  "keys": [
                    { "label": "\u0026" },
                    { "label": "\u002c" },
                    { "label": "\u003A" },
                    { "label": "\u003B" },
                    { "label": "\u0060" },
                    { "label": "\u0027" },
                    { "label": "\u0022" }
                  ]
                },
                {
                  "keys": [
                    { "label": "\u0028" },
                    { "label": "\u0029" },
                    { "label": "\u007B" },
                    { "label": "\u007D" },
                    { "label": "\u005B" },
                    { "label": "\u005D" },
                    { "label": "\u007E" }
                  ]
                },
                {
                  "keys": [
                    { "label": "\u00A1" },
                    { "label": "\u00BF" },
                    { "label": "\u003C" },
                    { "label": "\u003E" },
                    { "label": "\u007C" },
                    { "label": "\u005C" },
                    { "label": "\u002F" }
                  ]
                }
              ]
            },
            {
              "modes": ["SymbolsUpper", "SymbolsShift"],
              "rows": [
                {
                  "keys": [
                    { "label": "\u2022" },
                    { "label": "\u00B7" },
                    { "label": "\u00A2" },
                    { "label": "\u00A3" },
                    { "label": "\u00A5" },
                    { "label": "\u20AC" },
                    { "label": "\u00A7" }
                  ]
                },
                {
                  "keys": [
                    { "label": "\u00AE" },
                    { "label": "\u00A9" },
                    { "label": "\u2122" },
                    { "label": "\u00AB" },
                    { "label": "\u00BB" },
                    { "label": "\u2039" },
                    { "label": "\u203A" }
                  ]
                },
                {
                  "keys": [
                    { "label": "\u2020" },
                    { "label": "\u2021" },
                    { "label": "\u0192" },
                    { "label": "\u00B6" },
                    { "label": "\u00B9" },
                    { "label": "\u00B2" },
                    { "label": "\u00B3" }
                  ]
                },
                {
                  "keys": [
                    { "label": "\u00BA" },
                    { "label": "\u00B0" },
                    { "label": "\u00AA" },
                    { "label": "\u2026" },
                    {                   },
                    {                   },
                    {                   }
                  ]
                }
              ]
            },
            {
              "modes": "AccentsLower",
              "rows": [
                {
                  "keys": [
                    { "label": "\u00E0" },
                    { "label": "\u00E1" },
                    { "label": "\u00E2" },
                    { "label": "\u00E3" },
                    { "label": "\u00E4" },
                    { "label": "\u00E5" },
                    { "label": "\u00E6" }
                  ]
                },
                {
                  "keys": [
                    { "label": "\u00E8" },
                    { "label": "\u00E9" },
                    { "label": "\u00EA" },
                    { "label": "\u00EB" },
                    { "label": "\u00EC" },
                    { "label": "\u00ED" },
                    { "label": "\u00EE" }
                  ]
                },
                {
                  "keys": [
                    { "label": "\u00EF" },
                    { "label": "\u00F2" },
                    { "label": "\u00F3" },
                    { "label": "\u00F4" },
                    { "label": "\u00F5" },
                    { "label": "\u00F6" },
                    { "label": "\u00F8" }
                  ]
                },
                {
                  "keys": [
                    { "label": "\u0153" },
                    { "label": "\u00F9" },
                    { "label": "\u00FA" },
                    { "label": "\u00FB" },
                    { "label": "\u00FC" },
                    { "label": "\u00E7" },
                    { "label": "\u00F1" }
                  ]
                }
              ]
            },
            {
              "modes": ["AccentsUpper", "AccentsShift"],
              "rows": [
                {
                  "keys": [
                    { "label": "\u00C0" },
                    { "label": "\u00C1" },
                    { "label": "\u00C2" },
                    { "label": "\u00C3" },
                    { "label": "\u00C4" },
                    { "label": "\u00C5" },
                    { "label": "\u00C6" }
                  ]
                },
                {
                  "keys": [
                    { "label": "\u00C8" },
                    { "label": "\u00C9" },
                    { "label": "\u00CA" },
                    { "label": "\u00CB" },
                    { "label": "\u00CC" },
                    { "label": "\u00CD" },
                    { "label": "\u00CE" }
                  ]
                },
                {
                  "keys": [
                    { "label": "\u00CF" },
                    { "label": "\u00D2" },
                    { "label": "\u00D3" },
                    { "label": "\u00D4" },
                    { "label": "\u00D5" },
                    { "label": "\u00D6" },
                    { "label": "\u00D8" }
                  ]
                },
                {
                  "keys": [
                    { "label": "\u0152" },
                    { "label": "\u00D9" },
                    { "label": "\u00DA" },
                    { "label": "\u00DB" },
                    { "label": "\u00DC" },
                    { "label": "\u00C7" },
                    { "label": "\u00D1" }
                  ]
                }
              ]
            }
          ]
        },
        {
          "sectionWidthFHD": 270,
          "sectionWidthHD": 180,
          "grids": [
            {
              "modes": ["ABC123Lower", "ABC123Upper", "ABC123Shift"],
              "rows": [
                {
                  "keys": [
                    { "label": "1" },
                    { "label": "2" },
                    { "label": "3" }
                  ]
                },
                {
                  "keys": [
                    { "label": "4" },
                    { "label": "5" },
                    { "label": "6" }
                  ]
                },
                {
                  "keys": [
                    { "label": "7" },
                    { "label": "8" },
                    { "label": "9" }
                  ]
                },
                {
                  "keys": [
                    { "label": "@" },
                    { "label": "." },
                    { "label": "0" }
                  ]
                }
              ]
            },
            {
              "modes": "SymbolsLower",
              "rows": [
                {
                  "keys": [
                    { "label": "\u00B4" },
                    { "label": "\u02C6" },
                    { "label": "\u02DC" }
                  ]
                },
                {
                  "keys": [
                    { "label": "\u00A8" },
                    { "label": "\u00AF" },
                    { "label": "\u00B8" }
                  ]
                },
                {
                  "keys": [
                    { "label": "\u003D" },
                    { "label": "\u002B" },
                    { "label": "\u00D7" }
                  ]
                },
                {
                  "keys": [
                    { "label": "\u00F7" },
                    { "label": "\u00B1" },
                    { "label": "\u2030" }
                  ]
                }
              ]
            },
            {
              "modes": ["SymbolsUpper", "SymbolsShift"],
              "rows": [
                {
                  "keys": [
                    { "label": "\u00BC" },
                    { "label": "\u00BD" },
                    { "label": "\u00BE" }
                  ]
                },
                {
                  "keys": [
                    { "label": "\u201C" },
                    { "label": "\u201D" },
                    { "label": "\u201E" }
                  ]
                },
                {
                  "keys": [
                    { "label": "\u2018" },
                    { "label": "\u2019" },
                    { "label": "\u201A" }
                  ]
                },
                {
                  "keys": [
                    { "label": "\u2013" },
                    { "label": "\u2014" },
                    {                   }
                  ]
                }
              ]
            },
            {
              "modes": "AccentsLower",
              "rows": [
                {
                  "keys": [
                    { "label": "\u00FD" },
                    { "label": "\u00FF" },
                    { "label": "\u0161" }
                  ]
                },
                {
                  "keys": [
                    { "label": "\u017E" },
                    { "label": "\u00F0" },
                    { "label": "\u00FE" }
                  ]
                },
                {
                  "keys": [
                    { "label": "\u00DF" },
                    {                   },
                    {                   }
                  ]
                },
                {
                  "keys": [
                    {                   },
                    {                   },
                    {                   }
                  ]
                }
              ]
            },
            {
              "modes": ["AccentsUpper", "AccentsShift"],
              "rows": [
                {
                  "keys": [
                    { "label": "\u00DD" },
                    { "label": "\u0178" },
                    { "label": "\u0160" }
                  ]
                },
                {
                  "keys": [
                    { "label": "\u017D" },
                    { "label": "\u00D0" },
                    { "label": "\u00DE" }
                  ]
                },
                {
                  "keys": [
                    {                   },
                    {                   },
                    {                   }
                  ]
                },
                {
                  "keys": [
                    {                   },
                    {                   },
                    {                   }
                  ]
                }
              ]
            }
          ]
        },
        {
          "sectionWidthFHD": 180,
          "sectionWidthHD": 120,
          "grids": [
            {
          "modes": ["ABC123Lower", "ABC123Shift" ],
              "rows": [
                {
                  "keys": [
                    {
                      "icon": "theme:DKB_CapsModOffKeyBitmap",
                      "focusIcon": "theme:DKB_CapsModOffKeyFocusBitmap",
                      "strOut": "capslock"
                    }
                  ]
                },
                {
                  "keys": [
                    {
                      "icon": "theme:DKB_ABC123ModOnKeyBitmap",
                      "focusIcon": "theme:DKB_ABC123ModOnKeyFocusBitmap",
              "strOut": "abc123"
                    }
                  ]
                },
                {
                  "keys": [
                    {
                      "icon": "theme:DKB_SymbolsModOffKeyBitmap",
                      "focusIcon": "theme:DKB_SymbolsModOffKeyFocusBitmap",
                      "strOut": "symbols"
                    }
                  ]
                },
                {
                  "keys": [
                    {
                      "icon": "theme:DKB_AccentsModOffKeyBitmap",
                      "focusIcon": "theme:DKB_AccentsModOffKeyFocusBitmap",
                      "strOut": "accents"
                    }
                  ]
                }
              ]
            },
            {
          "modes": "ABC123Upper",
              "rows": [
                {
                  "keys": [
                    {
                      "icon": "theme:DKB_CapsModOnKeyBitmap",
                      "focusIcon": "theme:DKB_CapsModOnKeyFocusBitmap",
                      "strOut": "capslock"
                    }
                  ]
                },
                {
                  "keys": [
                    {
                      "icon": "theme:DKB_ABC123ModOnKeyBitmap",
                      "focusIcon": "theme:DKB_ABC123ModOnKeyFocusBitmap",
              "strOut": "abc123"
                    }
                  ]
                },
                {
                  "keys": [
                    {
                      "icon": "theme:DKB_SymbolsModOffKeyBitmap",
                      "focusIcon": "theme:DKB_SymbolsModOffKeyFocusBitmap",
                      "strOut": "symbols"
                    }
                  ]
                },
                {
                  "keys": [
                    {
                      "icon": "theme:DKB_AccentsModOffKeyBitmap",
                      "focusIcon": "theme:DKB_AccentsModOffKeyFocusBitmap",
                      "strOut": "accents"
                    }
                  ]
                }
              ]
            },
            {
          "modes": ["SymbolsLower", "SymbolsShift"],
              "rows": [
                {
                  "keys": [
                    {
                      "icon": "theme:DKB_CapsModOffKeyBitmap",
                      "focusIcon": "theme:DKB_CapsModOffKeyFocusBitmap",
                      "strOut": "capslock"
                    }
                  ]
                },
                {
                  "keys": [
                    {
                      "icon": "theme:DKB_ABC123ModOffKeyBitmap",
                      "focusIcon": "theme:DKB_ABC123ModOffKeyFocusBitmap",
              "strOut": "abc123"
                    }
                  ]
                },
                {
                  "keys": [
                    {
                      "icon": "theme:DKB_SymbolsModOnKeyBitmap",
                      "focusIcon": "theme:DKB_SymbolsModOnKeyFocusBitmap",
                      "strOut": "symbols"
                    }
                  ]
                },
                {
                  "keys": [
                    {
                      "icon": "theme:DKB_AccentsModOffKeyBitmap",
                      "focusIcon": "theme:DKB_AccentsModOffKeyFocusBitmap",
                      "strOut": "accents"
                    }
                  ]
                }
              ]
            },
            {
          "modes": "SymbolsUpper",
              "rows": [
                {
                  "keys": [
                    {
                      "icon": "theme:DKB_CapsModOnKeyBitmap",
                      "focusIcon": "theme:DKB_CapsModOnKeyFocusBitmap",
                      "strOut": "capslock"
                    }
                  ]
                },
                {
                  "keys": [
                    {
                      "icon": "theme:DKB_ABC123ModOffKeyBitmap",
                      "focusIcon": "theme:DKB_ABC123ModOffKeyFocusBitmap",
              "strOut": "abc123"
                    }
                  ]
                },
                {
                  "keys": [
                    {
                      "icon": "theme:DKB_SymbolsModOnKeyBitmap",
                      "focusIcon": "theme:DKB_SymbolsModOnKeyFocusBitmap",
                      "strOut": "symbols"
                    }
                  ]
                },
                {
                  "keys": [
                    {
                      "icon": "theme:DKB_AccentsModOffKeyBitmap",
                      "focusIcon": "theme:DKB_AccentsModOffKeyFocusBitmap",
                      "strOut": "accents"
                    }
                  ]
                }
              ]
            },
            {
          "modes": ["AccentsLower", "AccentsShift"],
              "rows": [
                {
                  "keys": [
                    {
                      "icon": "theme:DKB_CapsModOffKeyBitmap",
                      "focusIcon": "theme:DKB_CapsModOffKeyFocusBitmap",
                      "strOut": "capslock"
                    }
                  ]
                },
                {
                  "keys": [
                    {
                      "icon": "theme:DKB_ABC123ModOffKeyBitmap",
                      "focusIcon": "theme:DKB_ABC123ModOffKeyFocusBitmap",
              "strOut": "abc123"
                    }
                  ]
                },
                {
                  "keys": [
                    {
                      "icon": "theme:DKB_SymbolsModOffKeyBitmap",
                      "focusIcon": "theme:DKB_SymbolsModOffKeyFocusBitmap",
                      "strOut": "symbols"
                    }
                  ]
                },
                {
                  "keys": [
                    {
                      "icon": "theme:DKB_AccentsModOnKeyBitmap",
                      "focusIcon": "theme:DKB_AccentsModOnKeyFocusBitmap",
                      "strOut": "accents"
                    }
                  ]
                }
              ]
            },
            {
          "modes": "AccentsUpper",
              "rows": [
                {
                  "keys": [
                    {
                      "icon": "theme:DKB_CapsModOnKeyBitmap",
                      "focusIcon": "theme:DKB_CapsModOnKeyFocusBitmap",
                      "strOut": "capslock"
                    }
                  ]
                },
                {
                  "keys": [
                    {
                      "icon": "theme:DKB_ABC123ModOffKeyBitmap",
                      "focusIcon": "theme:DKB_ABC123ModOffKeyFocusBitmap",
              "strOut": "abc123"
                    }
                  ]
                },
                {
                  "keys": [
                    {
                      "icon": "theme:DKB_SymbolsModOffKeyBitmap",
                      "focusIcon": "theme:DKB_SymbolsModOffKeyFocusBitmap",
                      "strOut": "symbols"
                    }
                  ]
                },
                {
                  "keys": [
                    {
                      "icon": "theme:DKB_AccentsModOnKeyBitmap",
                      "focusIcon": "theme:DKB_AccentsModOnKeyFocusBitmap",
                      "strOut": "accents"
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    }
    

### Email Keyboard with pop-up suggestions

This example uses the same Key Definition File as the WiFi keyboard above, but with KeySuggestions added for the ampersand key. The suggestions pop-up is set to trigger when the key is focused for a short amount of time as well as when the key is selected.

![roku815px - email-keyboard-kdf](https://image.roku.com/ZHZscHItMTc2/email-keyboard-kdf.jpg)

    {
      "keyboardWidthFHD": 1368,
      "keyboardHeightFHD": 336,
      "keyboardWidthHD": 912,
      "keyboardHeightHD": 224,
     "sections": [
        {
          "sectionWidthFHD": 180,
          "sectionWidthHD": 120,
          "grids": [
            {
              "rows": [
                {
                  "keys": [
                    {
                      "icon": "theme:DKB_ShiftKeyBitmap",
                      "focusIcon": "theme:DKB_ShiftKeyFocusBitmap",
                      "strOut": "shift"
                    }
                  ]
                },
                {
                  "keys": [
                    {
                      "icon": "theme:DKB_SpaceKeyBitmap",
                      "focusIcon": "theme:DKB_SpaceKeyFocusBitmap",
              "strOut": "space"
                    }
                  ]
                },
                {
                  "keys": [
                    {
                      "icon": "theme:DKB_DeleteKeyBitmap",
                      "focusIcon": "theme:DKB_DeleteKeyFocusBitmap",
              "autoRepeat": 1,
                      "strOut": "backspace"
                    }
                  ]
                },
                {
                  "keys": [
                    {
                      "icon": "theme:DKB_LeftKeyBitmap",
                      "focusIcon": "theme:DKB_LeftKeyFocusBitmap",
                      "strOut": "left"
                    },
                    {
                      "icon": "theme:DKB_RightKeyBitmap",
                      "focusIcon": "theme:DKB_RightKeyFocusBitmap",
                      "strOut": "right"
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "sectionWidthFHD": 630,
          "sectionWidthHD": 420,
          "grids": [
            {
              "modes": "ABC123Lower",
              "rows": [
                {
                  "keys": [
                    { "label": "a" },
                    { "label": "b" },
                    { "label": "c" },
                    { "label": "d" },
                    { "label": "e" },
                    { "label": "f" },
                    { "label": "g" }
                  ]
                },
                {
                  "keys": [
                    { "label": "h" },
                    { "label": "i" },
                    { "label": "j" },
                    { "label": "k" },
                    { "label": "l" },
                    { "label": "m" },
                    { "label": "n" }
                  ]
                },
                {
                  "keys": [
                    { "label": "o" },
                    { "label": "p" },
                    { "label": "q" },
                    { "label": "r" },
                    { "label": "s" },
                    { "label": "t" },
                    { "label": "u" }
                  ]
                },
                {
                  "keys": [
                    { "label": "v" },
                    { "label": "w" },
                    { "label": "x" },
                    { "label": "y" },
                    { "label": "z" },
                    { "label": "-" },
                    { "label": "_" }
                  ]
                }
              ]
            },
            {
              "modes": ["ABC123Upper", "ABC123Shift" ],
              "rows": [
                {
                  "keys": [
                    { "label": "A" },
                    { "label": "B" },
                    { "label": "C" },
                    { "label": "D" },
                    { "label": "E" },
                    { "label": "F" },
                    { "label": "G" }
                  ]
                },
                {
                  "keys": [
                    { "label": "H" },
                    { "label": "I" },
                    { "label": "J" },
                    { "label": "K" },
                    { "label": "L" },
                    { "label": "M" },
                    { "label": "N" }
                  ]
                },
                {
                  "keys": [
                    { "label": "O" },
                    { "label": "P" },
                    { "label": "Q" },
                    { "label": "R" },
                    { "label": "S" },
                    { "label": "T" },
                    { "label": "U" }
                  ]
                },
                {
                  "keys": [
                    { "label": "V" },
                    { "label": "W" },
                    { "label": "X" },
                    { "label": "Y" },
                    { "label": "Z" },
                    { "label": "-" },
                    { "label": "_" }
                  ]
                }
              ]
            },
            {
              "modes": "SymbolsLower",
              "rows": [
                {
                  "keys": [
                    { "label": "!" },
                    { "label": "?" },
                    { "label": "\u002A" },
                    { "label": "\u0023" },
                    { "label": "\u0024" },
                    { "label": "\u0025" },
                    { "label": "\u005E" }
                  ]
                },
                {
                  "keys": [
                    { "label": "\u0026" },
                    { "label": "\u002c" },
                    { "label": "\u003A" },
                    { "label": "\u003B" },
                    { "label": "\u0060" },
                    { "label": "\u0027" },
                    { "label": "\u0022" }
                  ]
                },
                {
                  "keys": [
                    { "label": "\u0028" },
                    { "label": "\u0029" },
                    { "label": "\u007B" },
                    { "label": "\u007D" },
                    { "label": "\u005B" },
                    { "label": "\u005D" },
                    { "label": "\u007E" }
                  ]
                },
                {
                  "keys": [
                    { "label": "\u00A1" },
                    { "label": "\u00BF" },
                    { "label": "\u003C" },
                    { "label": "\u003E" },
                    { "label": "\u007C" },
                    { "label": "\u005C" },
                    { "label": "\u002F" }
                  ]
                }
              ]
            },
            {
              "modes": ["SymbolsUpper", "SymbolsShift"],
              "rows": [
                {
                  "keys": [
                    { "label": "\u2022" },
                    { "label": "\u00B7" },
                    { "label": "\u00A2" },
                    { "label": "\u00A3" },
                    { "label": "\u00A5" },
                    { "label": "\u20AC" },
                    { "label": "\u00A7" }
                  ]
                },
                {
                  "keys": [
                    { "label": "\u00AE" },
                    { "label": "\u00A9" },
                    { "label": "\u2122" },
                    { "label": "\u00AB" },
                    { "label": "\u00BB" },
                    { "label": "\u2039" },
                    { "label": "\u203A" }
                  ]
                },
                {
                  "keys": [
                    { "label": "\u2020" },
                    { "label": "\u2021" },
                    { "label": "\u0192" },
                    { "label": "\u00B6" },
                    { "label": "\u00B9" },
                    { "label": "\u00B2" },
                    { "label": "\u00B3" }
                  ]
                },
                {
                  "keys": [
                    { "label": "\u00BA" },
                    { "label": "\u00B0" },
                    { "label": "\u00AA" },
                    { "label": "\u2026" },
                    {                   },
                    {                   },
                    {                   }
                  ]
                }
              ]
            },
            {
              "modes": "AccentsLower",
              "rows": [
                {
                  "keys": [
                    { "label": "\u00E0" },
                    { "label": "\u00E1" },
                    { "label": "\u00E2" },
                    { "label": "\u00E3" },
                    { "label": "\u00E4" },
                    { "label": "\u00E5" },
                    { "label": "\u00E6" }
                  ]
                },
                {
                  "keys": [
                    { "label": "\u00E8" },
                    { "label": "\u00E9" },
                    { "label": "\u00EA" },
                    { "label": "\u00EB" },
                    { "label": "\u00EC" },
                    { "label": "\u00ED" },
                    { "label": "\u00EE" }
                  ]
                },
                {
                  "keys": [
                    { "label": "\u00EF" },
                    { "label": "\u00F2" },
                    { "label": "\u00F3" },
                    { "label": "\u00F4" },
                    { "label": "\u00F5" },
                    { "label": "\u00F6" },
                    { "label": "\u00F8" }
                  ]
                },
                {
                  "keys": [
                    { "label": "\u0153" },
                    { "label": "\u00F9" },
                    { "label": "\u00FA" },
                    { "label": "\u00FB" },
                    { "label": "\u00FC" },
                    { "label": "\u00E7" },
                    { "label": "\u00F1" }
                  ]
                }
              ]
            },
            {
              "modes": ["AccentsUpper", "AccentsShift"],
              "rows": [
                {
                  "keys": [
                    { "label": "\u00C0" },
                    { "label": "\u00C1" },
                    { "label": "\u00C2" },
                    { "label": "\u00C3" },
                    { "label": "\u00C4" },
                    { "label": "\u00C5" },
                    { "label": "\u00C6" }
                  ]
                },
                {
                  "keys": [
                    { "label": "\u00C8" },
                    { "label": "\u00C9" },
                    { "label": "\u00CA" },
                    { "label": "\u00CB" },
                    { "label": "\u00CC" },
                    { "label": "\u00CD" },
                    { "label": "\u00CE" }
                  ]
                },
                {
                  "keys": [
                    { "label": "\u00CF" },
                    { "label": "\u00D2" },
                    { "label": "\u00D3" },
                    { "label": "\u00D4" },
                    { "label": "\u00D5" },
                    { "label": "\u00D6" },
                    { "label": "\u00D8" }
                  ]
                },
                {
                  "keys": [
                    { "label": "\u0152" },
                    { "label": "\u00D9" },
                    { "label": "\u00DA" },
                    { "label": "\u00DB" },
                    { "label": "\u00DC" },
                    { "label": "\u00C7" },
                    { "label": "\u00D1" }
                  ]
                }
              ]
            }
          ]
        },
        {
          "sectionWidthFHD": 270,
          "sectionWidthHD": 180,
          "grids": [
            {
              "modes": ["ABC123Lower", "ABC123Upper", "ABC123Shift"],
              "rows": [
                {
                  "keys": [
                    { "label": "1" },
                    { "label": "2" },
                    { "label": "3" }
                  ]
                },
                {
                  "keys": [
                    { "label": "4" },
                    { "label": "5" },
                    { "label": "6" }
                  ]
                },
                {
                  "keys": [
                    { "label": "7" },
                    { "label": "8" },
                    { "label": "9" }
                  ]
                },
                {
                  "keys": [
                    {
                      "label": "@",
                      "suggestions": {
                          "options": [ "@aol.com", "@msn.com", "@yahoo.com", "@mac.com", "@gmail.com", "@roku.com" ],
                  "triggers": [ "hover", "select" ]
                       }
                    },
                    { "label": "." },
                    { "label": "0" }
                  ]
                }
              ]
            },
            {
              "modes": "SymbolsLower",
              "rows": [
                {
                  "keys": [
                    { "label": "\u00B4" },
                    { "label": "\u02C6" },
                    { "label": "\u02DC" }
                  ]
                },
                {
                  "keys": [
                    { "label": "\u00A8" },
                    { "label": "\u00AF" },
                    { "label": "\u00B8" }
                  ]
                },
                {
                  "keys": [
                    { "label": "\u003D" },
                    { "label": "\u002B" },
                    { "label": "\u00D7" }
                  ]
                },
                {
                  "keys": [
                    { "label": "\u00F7" },
                    { "label": "\u00B1" },
                    { "label": "\u2030" }
                  ]
                }
              ]
            },
            {
              "modes": ["SymbolsUpper", "SymbolsShift"],
              "rows": [
                {
                  "keys": [
                    { "label": "\u00BC" },
                    { "label": "\u00BD" },
                    { "label": "\u00BE" }
                  ]
                },
                {
                  "keys": [
                    { "label": "\u201C" },
                    { "label": "\u201D" },
                    { "label": "\u201E" }
                  ]
                },
                {
                  "keys": [
                    { "label": "\u2018" },
                    { "label": "\u2019" },
                    { "label": "\u201A" }
                  ]
                },
                {
                  "keys": [
                    { "label": "\u2013" },
                    { "label": "\u2014" },
                    {                   }
                  ]
                }
              ]
            },
            {
              "modes": "AccentsLower",
              "rows": [
                {
                  "keys": [
                    { "label": "\u00FD" },
                    { "label": "\u00FF" },
                    { "label": "\u0161" }
                  ]
                },
                {
                  "keys": [
                    { "label": "\u017E" },
                    { "label": "\u00F0" },
                    { "label": "\u00FE" }
                  ]
                },
                {
                  "keys": [
                    { "label": "\u00DF" },
                    {                   },
                    {                   }
                  ]
                },
                {
                  "keys": [
                    {                   },
                    {                   },
                    {                   }
                  ]
                }
              ]
            },
            {
              "modes": ["AccentsUpper", "AccentsShift"],
              "rows": [
                {
                  "keys": [
                    { "label": "\u00DD" },
                    { "label": "\u0178" },
                    { "label": "\u0160" }
                  ]
                },
                {
                  "keys": [
                    { "label": "\u017D" },
                    { "label": "\u00D0" },
                    { "label": "\u00DE" }
                  ]
                },
                {
                  "keys": [
                    {                   },
                    {                   },
                    {                   }
                  ]
                },
                {
                  "keys": [
                    {                   },
                    {                   },
                    {                   }
                  ]
                }
              ]
            }
          ]
        },
        {
          "sectionWidthFHD": 180,
          "sectionWidthHD": 120,
          "grids": [
            {
          "modes": ["ABC123Lower", "ABC123Shift" ],
              "rows": [
                {
                  "keys": [
                    {
                      "icon": "theme:DKB_CapsModOffKeyBitmap",
                      "focusIcon": "theme:DKB_CapsModOffKeyFocusBitmap",
                      "strOut": "capslock"
                    }
                  ]
                },
                {
                  "keys": [
                    {
                      "icon": "theme:DKB_ABC123ModOnKeyBitmap",
                      "focusIcon": "theme:DKB_ABC123ModOnKeyFocusBitmap",
              "strOut": "abc123"
                    }
                  ]
                },
                {
                  "keys": [
                    {
                      "icon": "theme:DKB_SymbolsModOffKeyBitmap",
                      "focusIcon": "theme:DKB_SymbolsModOffKeyFocusBitmap",
                      "strOut": "symbols"
                    }
                  ]
                },
                {
                  "keys": [
                    {
                      "icon": "theme:DKB_AccentsModOffKeyBitmap",
                      "focusIcon": "theme:DKB_AccentsModOffKeyFocusBitmap",
                      "strOut": "accents"
                    }
                  ]
                }
              ]
            },
            {
          "modes": "ABC123Upper",
              "rows": [
                {
                  "keys": [
                    {
                      "icon": "theme:DKB_CapsModOnKeyBitmap",
                      "focusIcon": "theme:DKB_CapsModOnKeyFocusBitmap",
                      "strOut": "capslock"
                    }
                  ]
                },
                {
                  "keys": [
                    {
                      "icon": "theme:DKB_ABC123ModOnKeyBitmap",
                      "focusIcon": "theme:DKB_ABC123ModOnKeyFocusBitmap",
              "strOut": "abc123"
                    }
                  ]
                },
                {
                  "keys": [
                    {
                      "icon": "theme:DKB_SymbolsModOffKeyBitmap",
                      "focusIcon": "theme:DKB_SymbolsModOffKeyFocusBitmap",
                      "strOut": "symbols"
                    }
                  ]
                },
                {
                  "keys": [
                    {
                      "icon": "theme:DKB_AccentsModOffKeyBitmap",
                      "focusIcon": "theme:DKB_AccentsModOffKeyFocusBitmap",
                      "strOut": "accents"
                    }
                  ]
                }
              ]
            },
            {
          "modes": ["SymbolsLower", "SymbolsShift"],
              "rows": [
                {
                  "keys": [
                    {
                      "icon": "theme:DKB_CapsModOffKeyBitmap",
                      "focusIcon": "theme:DKB_CapsModOffKeyFocusBitmap",
                      "strOut": "capslock"
                    }
                  ]
                },
                {
                  "keys": [
                    {
                      "icon": "theme:DKB_ABC123ModOffKeyBitmap",
                      "focusIcon": "theme:DKB_ABC123ModOffKeyFocusBitmap",
              "strOut": "abc123"
                    }
                  ]
                },
                {
                  "keys": [
                    {
                      "icon": "theme:DKB_SymbolsModOnKeyBitmap",
                      "focusIcon": "theme:DKB_SymbolsModOnKeyFocusBitmap",
                      "strOut": "symbols"
                    }
                  ]
                },
                {
                  "keys": [
                    {
                      "icon": "theme:DKB_AccentsModOffKeyBitmap",
                      "focusIcon": "theme:DKB_AccentsModOffKeyFocusBitmap",
                      "strOut": "accents"
                    }
                  ]
                }
              ]
            },
            {
          "modes": "SymbolsUpper",
              "rows": [
                {
                  "keys": [
                    {
                      "icon": "theme:DKB_CapsModOnKeyBitmap",
                      "focusIcon": "theme:DKB_CapsModOnKeyFocusBitmap",
                      "strOut": "capslock"
                    }
                  ]
                },
                {
                  "keys": [
                    {
                      "icon": "theme:DKB_ABC123ModOffKeyBitmap",
                      "focusIcon": "theme:DKB_ABC123ModOffKeyFocusBitmap",
              "strOut": "abc123"
                    }
                  ]
                },
                {
                  "keys": [
                    {
                      "icon": "theme:DKB_SymbolsModOnKeyBitmap",
                      "focusIcon": "theme:DKB_SymbolsModOnKeyFocusBitmap",
                      "strOut": "symbols"
                    }
                  ]
                },
                {
                  "keys": [
                    {
                      "icon": "theme:DKB_AccentsModOffKeyBitmap",
                      "focusIcon": "theme:DKB_AccentsModOffKeyFocusBitmap",
                      "strOut": "accents"
                    }
                  ]
                }
              ]
            },
            {
          "modes": ["AccentsLower", "AccentsShift"],
              "rows": [
                {
                  "keys": [
                    {
                      "icon": "theme:DKB_CapsModOffKeyBitmap",
                      "focusIcon": "theme:DKB_CapsModOffKeyFocusBitmap",
                      "strOut": "capslock"
                    }
                  ]
                },
                {
                  "keys": [
                    {
                      "icon": "theme:DKB_ABC123ModOffKeyBitmap",
                      "focusIcon": "theme:DKB_ABC123ModOffKeyFocusBitmap",
              "strOut": "abc123"
                    }
                  ]
                },
                {
                  "keys": [
                    {
                      "icon": "theme:DKB_SymbolsModOffKeyBitmap",
                      "focusIcon": "theme:DKB_SymbolsModOffKeyFocusBitmap",
                      "strOut": "symbols"
                    }
                  ]
                },
                {
                  "keys": [
                    {
                      "icon": "theme:DKB_AccentsModOnKeyBitmap",
                      "focusIcon": "theme:DKB_AccentsModOnKeyFocusBitmap",
                      "strOut": "accents"
                    }
                  ]
                }
              ]
            },
            {
          "modes": "AccentsUpper",
              "rows": [
                {
                  "keys": [
                    {
                      "icon": "theme:DKB_CapsModOnKeyBitmap",
                      "focusIcon": "theme:DKB_CapsModOnKeyFocusBitmap",
                      "strOut": "capslock"
                    }
                  ]
                },
                {
                  "keys": [
                    {
                      "icon": "theme:DKB_ABC123ModOffKeyBitmap",
                      "focusIcon": "theme:DKB_ABC123ModOffKeyFocusBitmap",
              "strOut": "abc123"
                    }
                  ]
                },
                {
                  "keys": [
                    {
                      "icon": "theme:DKB_SymbolsModOffKeyBitmap",
                      "focusIcon": "theme:DKB_SymbolsModOffKeyFocusBitmap",
                      "strOut": "symbols"
                    }
                  ]
                },
                {
                  "keys": [
                    {
                      "icon": "theme:DKB_AccentsModOnKeyBitmap",
                      "focusIcon": "theme:DKB_AccentsModOnKeyFocusBitmap",
                      "strOut": "accents"
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    }
    

### Full Keyboard with Extended Action Section

This example starts with the same Key Definition File used for the WiFi keyboard above, but adds a 5th Section that includes additional action keys. The _rows_ array for that Section's Grid contains 4 elements. The 1st, 2nd and 4th Row's in that array contain a single Key (Close, Clear and Continue). The 3rd element of that array is a null Row. This causes a gap to be left between the 2nd and 4th rows of that Section. See the Section near of the bottom of the Key Definition File to see how a null Row is specified in the Grid's _rows_ array.

![roku815px - extended-action-keyboard-kdf](https://image.roku.com/ZHZscHItMTc2/extended-action-keyboard-kdf.jpg)

    {
      "keyboardWidthFHD": 1584,
      "keyboardHeightFHD": 336,
      "keyboardWidthHD": 1056,
      "keyboardHeightHD": 224,
      "sections": [
        {
          "sectionWidthFHD": 180,
          "sectionWidthHD": 120,
          "grids": [
            {
              "rows": [
                {
                  "keys": [
                    {
                      "icon": "theme:DKB_ShiftKeyBitmap",
                      "focusIcon": "theme:DKB_ShiftKeyFocusBitmap",
                      "strOut": "shift"
                    }
                  ]
                },
                {
                  "keys": [
                    {
                      "icon": "theme:DKB_SpaceKeyBitmap",
                      "focusIcon": "theme:DKB_SpaceKeyFocusBitmap",
              "strOut": "space"
                    }
                  ]
                },
                {
                  "keys": [
                    {
                      "icon": "theme:DKB_DeleteKeyBitmap",
                      "focusIcon": "theme:DKB_DeleteKeyFocusBitmap",
              "autoRepeat": 1,
                      "strOut": "backspace"
                    }
                  ]
                },
                {
                  "keys": [
                    {
                      "icon": "theme:DKB_LeftKeyBitmap",
                      "focusIcon": "theme:DKB_LeftKeyFocusBitmap",
                      "strOut": "left"
                    },
                    {
                      "icon": "theme:DKB_RightKeyBitmap",
                      "focusIcon": "theme:DKB_RightKeyFocusBitmap",
                      "strOut": "right"
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "sectionWidthFHD": 630,
          "sectionWidthHD": 420,
          "grids": [
            {
              "modes": "ABC123Lower",
              "rows": [
                {
                  "keys": [
                    { "label": "a" },
                    { "label": "b" },
                    { "label": "c" },
                    { "label": "d" },
                    { "label": "e" },
                    { "label": "f" },
                    { "label": "g" }
                  ]
                },
                {
                  "keys": [
                    { "label": "h" },
                    { "label": "i" },
                    { "label": "j" },
                    { "label": "k" },
                    { "label": "l" },
                    { "label": "m" },
                    { "label": "n" }
                  ]
                },
                {
                  "keys": [
                    { "label": "o" },
                    { "label": "p" },
                    { "label": "q" },
                    { "label": "r" },
                    { "label": "s" },
                    { "label": "t" },
                    { "label": "u" }
                  ]
                },
                {
                  "keys": [
                    { "label": "v" },
                    { "label": "w" },
                    { "label": "x" },
                    { "label": "y" },
                    { "label": "z" },
                    { "label": "-" },
                    { "label": "_" }
                  ]
                }
              ]
            },
            {
              "modes": ["ABC123Upper", "ABC123Shift" ],
              "rows": [
                {
                  "keys": [
                    { "label": "A" },
                    { "label": "B" },
                    { "label": "C" },
                    { "label": "D" },
                    { "label": "E" },
                    { "label": "F" },
                    { "label": "G" }
                  ]
                },
                {
                  "keys": [
                    { "label": "H" },
                    { "label": "I" },
                    { "label": "J" },
                    { "label": "K" },
                    { "label": "L" },
                    { "label": "M" },
                    { "label": "N" }
                  ]
                },
                {
                  "keys": [
                    { "label": "O" },
                    { "label": "P" },
                    { "label": "Q" },
                    { "label": "R" },
                    { "label": "S" },
                    { "label": "T" },
                    { "label": "U" }
                  ]
                },
                {
                  "keys": [
                    { "label": "V" },
                    { "label": "W" },
                    { "label": "X" },
                    { "label": "Y" },
                    { "label": "Z" },
                    { "label": "-" },
                    { "label": "_" }
                  ]
                }
              ]
            },
            {
              "modes": "SymbolsLower",
              "rows": [
                {
                  "keys": [
                    { "label": "!" },
                    { "label": "?" },
                    { "label": "\u002A" },
                    { "label": "\u0023" },
                    { "label": "\u0024" },
                    { "label": "\u0025" },
                    { "label": "\u005E" }
                  ]
                },
                {
                  "keys": [
                    { "label": "\u0026" },
                    { "label": "\u002c" },
                    { "label": "\u003A" },
                    { "label": "\u003B" },
                    { "label": "\u0060" },
                    { "label": "\u0027" },
                    { "label": "\u0022" }
                  ]
                },
                {
                  "keys": [
                    { "label": "\u0028" },
                    { "label": "\u0029" },
                    { "label": "\u007B" },
                    { "label": "\u007D" },
                    { "label": "\u005B" },
                    { "label": "\u005D" },
                    { "label": "\u007E" }
                  ]
                },
                {
                  "keys": [
                    { "label": "\u00A1" },
                    { "label": "\u00BF" },
                    { "label": "\u003C" },
                    { "label": "\u003E" },
                    { "label": "\u007C" },
                    { "label": "\u005C" },
                    { "label": "\u002F" }
                  ]
                }
              ]
            },
            {
              "modes": ["SymbolsUpper", "SymbolsShift"],
              "rows": [
                {
                  "keys": [
                    { "label": "\u2022" },
                    { "label": "\u00B7" },
                    { "label": "\u00A2" },
                    { "label": "\u00A3" },
                    { "label": "\u00A5" },
                    { "label": "\u20AC" },
                    { "label": "\u00A7" }
                  ]
                },
                {
                  "keys": [
                    { "label": "\u00AE" },
                    { "label": "\u00A9" },
                    { "label": "\u2122" },
                    { "label": "\u00AB" },
                    { "label": "\u00BB" },
                    { "label": "\u2039" },
                    { "label": "\u203A" }
                  ]
                },
                {
                  "keys": [
                    { "label": "\u2020" },
                    { "label": "\u2021" },
                    { "label": "\u0192" },
                    { "label": "\u00B6" },
                    { "label": "\u00B9" },
                    { "label": "\u00B2" },
                    { "label": "\u00B3" }
                  ]
                },
                {
                  "keys": [
                    { "label": "\u00BA" },
                    { "label": "\u00B0" },
                    { "label": "\u00AA" },
                    { "label": "\u2026" },
                    {                   },
                    {                   },
                    {                   }
                  ]
                }
              ]
            },
            {
              "modes": "AccentsLower",
              "rows": [
                {
                  "keys": [
                    { "label": "\u00E0" },
                    { "label": "\u00E1" },
                    { "label": "\u00E2" },
                    { "label": "\u00E3" },
                    { "label": "\u00E4" },
                    { "label": "\u00E5" },
                    { "label": "\u00E6" }
                  ]
                },
                {
                  "keys": [
                    { "label": "\u00E8" },
                    { "label": "\u00E9" },
                    { "label": "\u00EA" },
                    { "label": "\u00EB" },
                    { "label": "\u00EC" },
                    { "label": "\u00ED" },
                    { "label": "\u00EE" }
                  ]
                },
                {
                  "keys": [
                    { "label": "\u00EF" },
                    { "label": "\u00F2" },
                    { "label": "\u00F3" },
                    { "label": "\u00F4" },
                    { "label": "\u00F5" },
                    { "label": "\u00F6" },
                    { "label": "\u00F8" }
                  ]
                },
                {
                  "keys": [
                    { "label": "\u0153" },
                    { "label": "\u00F9" },
                    { "label": "\u00FA" },
                    { "label": "\u00FB" },
                    { "label": "\u00FC" },
                    { "label": "\u00E7" },
                    { "label": "\u00F1" }
                  ]
                }
              ]
            },
            {
              "modes": ["AccentsUpper", "AccentsShift"],
              "rows": [
                {
                  "keys": [
                    { "label": "\u00C0" },
                    { "label": "\u00C1" },
                    { "label": "\u00C2" },
                    { "label": "\u00C3" },
                    { "label": "\u00C4" },
                    { "label": "\u00C5" },
                    { "label": "\u00C6" }
                  ]
                },
                {
                  "keys": [
                    { "label": "\u00C8" },
                    { "label": "\u00C9" },
                    { "label": "\u00CA" },
                    { "label": "\u00CB" },
                    { "label": "\u00CC" },
                    { "label": "\u00CD" },
                    { "label": "\u00CE" }
                  ]
                },
                {
                  "keys": [
                    { "label": "\u00CF" },
                    { "label": "\u00D2" },
                    { "label": "\u00D3" },
                    { "label": "\u00D4" },
                    { "label": "\u00D5" },
                    { "label": "\u00D6" },
                    { "label": "\u00D8" }
                  ]
                },
                {
                  "keys": [
                    { "label": "\u0152" },
                    { "label": "\u00D9" },
                    { "label": "\u00DA" },
                    { "label": "\u00DB" },
                    { "label": "\u00DC" },
                    { "label": "\u00C7" },
                    { "label": "\u00D1" }
                  ]
                }
              ]
            }
          ]
        },
        {
          "sectionWidthFHD": 270,
          "sectionWidthHD": 180,
          "grids": [
            {
              "modes": ["ABC123Lower", "ABC123Upper", "ABC123Shift"],
              "rows": [
                {
                  "keys": [
                    { "label": "1" },
                    { "label": "2" },
                    { "label": "3" }
                  ]
                },
                {
                  "keys": [
                    { "label": "4" },
                    { "label": "5" },
                    { "label": "6" }
                  ]
                },
                {
                  "keys": [
                    { "label": "7" },
                    { "label": "8" },
                    { "label": "9" }
                  ]
                },
                {
                  "keys": [
                    { "label": "@" },
                    { "label": "." },
                    { "label": "0" }
                  ]
                }
              ]
            },
            {
              "modes": "SymbolsLower",
              "rows": [
                {
                  "keys": [
                    { "label": "\u00B4" },
                    { "label": "\u02C6" },
                    { "label": "\u02DC" }
                  ]
                },
                {
                  "keys": [
                    { "label": "\u00A8" },
                    { "label": "\u00AF" },
                    { "label": "\u00B8" }
                  ]
                },
                {
                  "keys": [
                    { "label": "\u003D" },
                    { "label": "\u002B" },
                    { "label": "\u00D7" }
                  ]
                },
                {
                  "keys": [
                    { "label": "\u00F7" },
                    { "label": "\u00B1" },
                    { "label": "\u2030" }
                  ]
                }
              ]
            },
            {
              "modes": ["SymbolsUpper", "SymbolsShift"],
              "rows": [
                {
                  "keys": [
                    { "label": "\u00BC" },
                    { "label": "\u00BD" },
                    { "label": "\u00BE" }
                  ]
                },
                {
                  "keys": [
                    { "label": "\u201C" },
                    { "label": "\u201D" },
                    { "label": "\u201E" }
                  ]
                },
                {
                  "keys": [
                    { "label": "\u2018" },
                    { "label": "\u2019" },
                    { "label": "\u201A" }
                  ]
                },
                {
                  "keys": [
                    { "label": "\u2013" },
                    { "label": "\u2014" },
                    {                   }
                  ]
                }
              ]
            },
            {
              "modes": "AccentsLower",
              "rows": [
                {
                  "keys": [
                    { "label": "\u00FD" },
                    { "label": "\u00FF" },
                    { "label": "\u0161" }
                  ]
                },
                {
                  "keys": [
                    { "label": "\u017E" },
                    { "label": "\u00F0" },
                    { "label": "\u00FE" }
                  ]
                },
                {
                  "keys": [
                    { "label": "\u00DF" },
                    {                   },
                    {                   }
                  ]
                },
                {
                  "keys": [
                    {                   },
                    {                   },
                    {                   }
                  ]
                }
              ]
            },
            {
              "modes": ["AccentsUpper", "AccentsShift"],
              "rows": [
                {
                  "keys": [
                    { "label": "\u00DD" },
                    { "label": "\u0178" },
                    { "label": "\u0160" }
                  ]
                },
                {
                  "keys": [
                    { "label": "\u017D" },
                    { "label": "\u00D0" },
                    { "label": "\u00DE" }
                  ]
                },
                {
                  "keys": [
                    {                   },
                    {                   },
                    {                   }
                  ]
                },
                {
                  "keys": [
                    {                   },
                    {                   },
                    {                   }
                  ]
                }
              ]
            }
          ]
        },
        {
          "sectionWidthFHD": 180,
          "sectionWidthHD": 120,
          "grids": [
            {
          "modes": ["ABC123Lower", "ABC123Shift" ],
              "rows": [
                {
                  "keys": [
                    {
                      "icon": "theme:DKB_CapsModOffKeyBitmap",
                      "focusIcon": "theme:DKB_CapsModOffKeyFocusBitmap",
                      "strOut": "capslock"
                    }
                  ]
                },
                {
                  "keys": [
                    {
                      "icon": "theme:DKB_ABC123ModOnKeyBitmap",
                      "focusIcon": "theme:DKB_ABC123ModOnKeyFocusBitmap",
              "strOut": "abc123"
                    }
                  ]
                },
                {
                  "keys": [
                    {
                      "icon": "theme:DKB_SymbolsModOffKeyBitmap",
                      "focusIcon": "theme:DKB_SymbolsModOffKeyFocusBitmap",
                      "strOut": "symbols"
                    }
                  ]
                },
                {
                  "keys": [
                    {
                      "icon": "theme:DKB_AccentsModOffKeyBitmap",
                      "focusIcon": "theme:DKB_AccentsModOffKeyFocusBitmap",
                      "strOut": "accents"
                    }
                  ]
                }
              ]
            },
            {
          "modes": "ABC123Upper",
              "rows": [
                {
                  "keys": [
                    {
                      "icon": "theme:DKB_CapsModOnKeyBitmap",
                      "focusIcon": "theme:DKB_CapsModOnKeyFocusBitmap",
                      "strOut": "capslock"
                    }
                  ]
                },
                {
                  "keys": [
                    {
                      "icon": "theme:DKB_ABC123ModOnKeyBitmap",
                      "focusIcon": "theme:DKB_ABC123ModOnKeyFocusBitmap",
              "strOut": "abc123"
                    }
                  ]
                },
                {
                  "keys": [
                    {
                      "icon": "theme:DKB_SymbolsModOffKeyBitmap",
                      "focusIcon": "theme:DKB_SymbolsModOffKeyFocusBitmap",
                      "strOut": "symbols"
                    }
                  ]
                },
                {
                  "keys": [
                    {
                      "icon": "theme:DKB_AccentsModOffKeyBitmap",
                      "focusIcon": "theme:DKB_AccentsModOffKeyFocusBitmap",
                      "strOut": "accents"
                    }
                  ]
                }
              ]
            },
            {
          "modes": ["SymbolsLower", "SymbolsShift"],
              "rows": [
                {
                  "keys": [
                    {
                      "icon": "theme:DKB_CapsModOffKeyBitmap",
                      "focusIcon": "theme:DKB_CapsModOffKeyFocusBitmap",
                      "strOut": "capslock"
                    }
                  ]
                },
                {
                  "keys": [
                    {
                      "icon": "theme:DKB_ABC123ModOffKeyBitmap",
                      "focusIcon": "theme:DKB_ABC123ModOffKeyFocusBitmap",
              "strOut": "abc123"
                    }
                  ]
                },
                {
                  "keys": [
                    {
                      "icon": "theme:DKB_SymbolsModOnKeyBitmap",
                      "focusIcon": "theme:DKB_SymbolsModOnKeyFocusBitmap",
                      "strOut": "symbols"
                    }
                  ]
                },
                {
                  "keys": [
                    {
                      "icon": "theme:DKB_AccentsModOffKeyBitmap",
                      "focusIcon": "theme:DKB_AccentsModOffKeyFocusBitmap",
                      "strOut": "accents"
                    }
                  ]
                }
              ]
            },
            {
          "modes": "SymbolsUpper",
              "rows": [
                {
                  "keys": [
                    {
                      "icon": "theme:DKB_CapsModOnKeyBitmap",
                      "focusIcon": "theme:DKB_CapsModOnKeyFocusBitmap",
                      "strOut": "capslock"
                    }
                  ]
                },
                {
                  "keys": [
                    {
                      "icon": "theme:DKB_ABC123ModOffKeyBitmap",
                      "focusIcon": "theme:DKB_ABC123ModOffKeyFocusBitmap",
              "strOut": "abc123"
                    }
                  ]
                },
                {
                  "keys": [
                    {
                      "icon": "theme:DKB_SymbolsModOnKeyBitmap",
                      "focusIcon": "theme:DKB_SymbolsModOnKeyFocusBitmap",
                      "strOut": "symbols"
                    }
                  ]
                },
                {
                  "keys": [
                    {
                      "icon": "theme:DKB_AccentsModOffKeyBitmap",
                      "focusIcon": "theme:DKB_AccentsModOffKeyFocusBitmap",
                      "strOut": "accents"
                    }
                  ]
                }
              ]
            },
            {
          "modes": ["AccentsLower", "AccentsShift"],
              "rows": [
                {
                  "keys": [
                    {
                      "icon": "theme:DKB_CapsModOffKeyBitmap",
                      "focusIcon": "theme:DKB_CapsModOffKeyFocusBitmap",
                      "strOut": "capslock"
                    }
                  ]
                },
                {
                  "keys": [
                    {
                      "icon": "theme:DKB_ABC123ModOffKeyBitmap",
                      "focusIcon": "theme:DKB_ABC123ModOffKeyFocusBitmap",
              "strOut": "abc123"
                    }
                  ]
                },
                {
                  "keys": [
                    {
                      "icon": "theme:DKB_SymbolsModOffKeyBitmap",
                      "focusIcon": "theme:DKB_SymbolsModOffKeyFocusBitmap",
                      "strOut": "symbols"
                    }
                  ]
                },
                {
                  "keys": [
                    {
                      "icon": "theme:DKB_AccentsModOnKeyBitmap",
                      "focusIcon": "theme:DKB_AccentsModOnKeyFocusBitmap",
                      "strOut": "accents"
                    }
                  ]
                }
              ]
            },
            {
          "modes": "AccentsUpper",
              "rows": [
                {
                  "keys": [
                    {
                      "icon": "theme:DKB_CapsModOnKeyBitmap",
                      "focusIcon": "theme:DKB_CapsModOnKeyFocusBitmap",
                      "strOut": "capslock"
                    }
                  ]
                },
                {
                  "keys": [
                    {
                      "icon": "theme:DKB_ABC123ModOffKeyBitmap",
                      "focusIcon": "theme:DKB_ABC123ModOffKeyFocusBitmap",
              "strOut": "abc123"
                    }
                  ]
                },
                {
                  "keys": [
                    {
                      "icon": "theme:DKB_SymbolsModOffKeyBitmap",
                      "focusIcon": "theme:DKB_SymbolsModOffKeyFocusBitmap",
                      "strOut": "symbols"
                    }
                  ]
                },
                {
                  "keys": [
                    {
                      "icon": "theme:DKB_AccentsModOnKeyBitmap",
                      "focusIcon": "theme:DKB_AccentsModOnKeyFocusBitmap",
                      "strOut": "accents"
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "sectionWidthFHD": 180,
          "sectionWidthHD": 120,
          "grids": [
            {
              "rows": [
                {
                  "keys": [
                    {
                      "label": "Close",
                      "strOut": "close"
                    }
                  ]
                },
                {
                  "keys": [
                    {
                      "label": "Clear",
              "strOut": "clear"
                    }
                  ]
                },
                {
                },
                {
                  "keys": [
                    {
                      "label": "Continue",
                      "strOut": "continue"
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    }

roUniversalControlEvent
=======================

The roScreen object sends the roUniversalControlEvent with the following related methods. If an app constrains the events processed to just the roUniversalControlEvent, the app will work with any controller. The GetID(), GetChar(), GetKey(), and IsPress() methods can be used instead of parsing the GetInt() return value to more effectively distinguish between remote control and keyboard key presses, and the key press and release events.

Supported methods
-----------------

### GetInt() as Integer

Returns an integer representing pressed or released keys on the remote. This table can be accessed at runtime by calling `bslCore.brs: bslUniversalControlEventCodes()`:

| Button | When Pressed | When Released |
| --- | --- | --- |
| Back | 0   | 100 |
| Up  | 2   | 102 |
| Down | 3   | 103 |
| Left | 4   | 104 |
| Right | 5   | 105 |
| Select | 6   | 106 |
| Instant Replay | 7   | 107 |
| Rewind | 8   | 108 |
| Fast Forward | 9   | 109 |
| Info | 10  | 110 |
| Play | 13  | 113 |

### GetKey() as Integer

Returns the ID of the remote button that generated an event.

### GetRemoteID() as String

Returns an identifier associated with the type and ID of the remote control that generated the event. For example, if multiple wireless remotes are paired, this may be used to distinguish the event sources. Some remote controls, such as IR remotes, can not be distinguished using this API.

### GetID() as Integer

Returns the ID of the remote button or character value represented by the event. Values 0x20..0x10FFFF represent a Unicode character value. Other values represent a remote button ID. GetID() returns the same value for a release event as for the press event.

### IsPress() as Boolean

Checks whether a press event has occurred. This method returns true if a press event has occurred; otherwise, it returns false.

### GetChar() as Integer

Returns the Unicode character value generated by a keyboard key press event.

VoiceTextEditBox
================

Extends [TextEditBox](/docs/references/scenegraph/widget-nodes/texteditbox.md)

The **VoiceTextEditBox** node is similar to the [legacy **TextEditBox** node](/docs/references/scenegraph/widget-nodes/texteditbox.md), but with additional voice entry functionality. Only one voice-enabled **VoiceTextEditBox** node may be on the screen at a time. If another VoiceTextEditBox is rendered on the screen, its voice functionality is disabled implicitly.

Fields
------

| Field | Type | Default | Access Permission | Description |
| --- | --- | --- | --- | --- |
| voiceEnabled | boolean | false | READ\_WRITE | Enables the text box to be voice-enabled. In this case, it will display a mic icon and have a voice UI with voice hints. |
| voiceToolTipWidth | float | FHD: 321HD: 214 | READ\_WRITE | The maximum width of the voice hint tootip. The height scales based on the specified width. |
| voiceEntryType | string | "generic" | READ\_WRITE | The type of voice entry mode to be used:  <br><br>*   "email": letter-by-letter dictation for emails.<br>*   "numeric": letter-by-letter dictation for PIN codes, zip codes, and other numeric input.<br>*   "alphanumeric": letter-by-letter dication for street addresses or other sequences of numbers and letters.<br>*   "generic": Full word input for search queries or other sequences of numbers, letters and symbols.<br>*   "password": letter-by-letter dication for passwords. |
| isDictating | boolean | false | READ-ONLY | Checks whether the user is currently dictating to the keyboard. |
| voiceInputRegexFilter | string | ""  | WRITE-ONLY | Specify which characters may or may not be entered on the keyboard via dictation. For example, setting this field to "^\[A-Za-z0-9\_-\]\*$" prevents any special characters from being entered. |

ContentNode
===========

Extends [**Node**](/docs/references/scenegraph/node.md)

The ContentNode class allows you to specify the data used to configure a node or component. Many nodes and components require a ContentNode as the specification of their content field in order to be properly configured. In general, lists, grids, and panels require a ContentNode for configuration. The data included in a ContentNode can be data such as the text for labels in the node or component, and the spacing between items in a list, grid, or panel, including data to create custom lists, grids, and panels. The reference information for every node or component that requires a ContentNode includes a section that details the requirements of the ContentNode for that node or component.

ContentNodes defined as the specification for a node or component content field are typically structured as one ContentNode parent node, with a hierarchy of child nodes that specify the actual data, and sections of data if needed. For example, a [LabelList](/docs/references/scenegraph/list-and-grid-nodes/labellist.md "LabelList") node can have several sections that divide the entire list, each with their own section heading, and specific items in that section of the list. The ContentNode for that LabelList node should have two levels of child ContentNodes, one level for the data to configure the list sections, and then another level of child ContentNodes for the data for each item in that list section.

A ContentNode can also be used to specify the data for custom components with defined interfaces, and for nodes and components that require [Content Meta-Data](/docs/developer-program/getting-started/architecture/content-metadata.md " Content Meta-Data"). Also, you should use a ContentNode for complex structures of data for your application rather than associative arrays. ContentNode objects are passed by reference in the application, while associative array objects are copied. For large complex data structures, passing ContentNode objects is much quicker than passing the equivalent associative array object. You can use associative arrays for simpler data structures with just a few fixed members.

> All of the attributes listed in [Content Meta-Data](/docs/developer-program/getting-started/architecture/content-metadata.md "Content Meta-Data") can be set as fields in a Content node. However, when creating a Content node, the fields themselves are not created until the valid attributes are set as fields, using either assignment (=), or set using [setField()](/docs/references/brightscript/interfaces/ifsgnodefield.md#setfieldfieldname-as-string-value-as-object-as-boolean "setField") or [setFields()](/docs/references/brightscript/interfaces/ifsgnodefield.md#setfieldsfields-as-object-as-boolean. "setFields()")

### Creating ContentNodes

To create a ContentNode object and populate it with data, you can define the ContentNode in XML markup, or create it using BrightScript. In both cases, you will usually be first creating or defining a parent ContentNode, then creating or defining children ContentNodes below the parent, with possibly other levels of children ContentNodes.

As an example, to define a ContentNode with one level of children ContentNodes, you should generally:

    <ContentNode role= or id= >
      <ContentNode content_meta-data_attribute = "attribute" ... />
      ...
    </ContentNode>
    

The parent ContentNode is defined with either an XML role attribute or an id field, depending on how you want to assign or use the content data. For the nodes classes that have a content field that is to be assigned a ContentNode, such as LabelList nodes, the parent ContentNode should be defined as a child node of the node:

    <LabelList  id = "labellist" >
      <ContentNode  role = "content" >
        <ContentNode title = "Renderable Nodes" description = "Basic Nodes That Show Things" />
        <ContentNode title = "Z-Order/Parent-Child" description = "SceneGraph Tree Order Matters" />
        <ContentNode title = "Animations" description = "Moving Stuff Around and Flashing Lights" />
        <ContentNode title = "Events and Observers" description = "Reacting When Stuff Happens" />
      </ContentNode>
    </LabelList>
    

In other cases, you can just use the id field to allow you to access the ContentNode later as an object for any purpose. In both cases, define additional ContentNodes with content fields as children of the parent ContentNode.

To create a ContentNode in BrightScript, you should generally:

1.  Create the ContentNode object using createObject()
2.  Create child ContentNode objects using createChild()
3.  Assign the data to the field(s) of each ContentNode child object

As follows:

    ContentNode_object = createObject("RoSGNode","ContentNode")
    ContentNode_child_object = ContentNode_object.createChild("ContentNode")
    ContentNode_child_object.field_name = data
    ...
    

### Assigning ContentNode Data To Nodes/Components

For nodes and components that require a ContentNode as the specification of their content field, you can define it as a child of the node or component in XML markup using the role attribute, or just assign the ContentNode object to the content field as follows:

    NodeComponent.content = ContentNode_object
    

For other nodes and components that don't require a ContentNode, you can use getChild() or a similar function to locate the specific child ContentNode object that contains the data you want to assign to a particular node/component field:

    ContentNode_child_object = ContentNode_object.getChild(child_number)
    NodeComponent.field_name = ContentNode_child_object.field_name
    

> If you are assigning a component node field with child elements of a ContentNode, you should create the ContentNode and all child elements, then assign the ContentNode to the component node field. It is more efficient than creating a ContentNode, assigning the ContentNode to the component node field, then creating and assigning each child element using getChild(). This is particularly true when creating and assigning ContentNode data in different threads, which can be very inefficient. Also avoid getting individual data items or child elements repeatedly if it is more efficient to copy the data value locally and avoid the repetitive object accesses, particularly in two different threads.

### Example

The following creates a component with a LabelList node populated with some specific content. To configure the content, a ContentNode is created for the content field of the LabelList node. The LabelList node is divided into several sections, so for each section, a child ContentNode object is added to the parent ContentNode using the addSection() function. Then the individual items in each section of the list are added as child nodes of the section ContentNode object using the addItem() function. The functions access the global variables for the ContentNode object reference m.content for the parent ContentNode, and m.sectionContent for the section ContentNodes.

#### ContentNode Class Example

    <?xml version = "1.0" encoding = "utf-8" ?>
    
    <!--********** Copyright 2015 Roku Corp.  All Rights Reserved. **********-->
    
    <component name = "NodeSelectionList" extends = "Group" initialFocus = "coreList" >
    
      <script type="text/brightscript" >
    
        <![CDATA[
    
        sub init()
          m.list = m.top.FindNode("coreList")
    
          m.content = createObject("RoSGNode","ContentNode")
    
          addSection("Renderable Nodes")
          addItem("Rectangle")
          addItem("Rotated Rectangle")
          addItem("Label")
          addItem("Poster")
          addItem("Video")
          addItem("Video Zoom")
    
          addSection("Animation Nodes")
          addItem("Animation Vector 2D Interpolator")
          addItem("Animation Color Interpolator")
          addItem("Animation Float Interpolator")
          addItem("Sequential Animation")
          addItem("Parallel Animation")
          addItem("Fade-In Animation")
          addItem("Fade-Out Animation")
    
          addSection("Control Nodes")
          addItem("Timer")
    
          addSection("Lists and Grids")
          addItem("Poster Grid")
          addItem("Markup Grid")
    
          m.list.content = m.content
    
          m.top.setFocus(true)
        end sub
    
        sub addSection(sectiontext as string)
          m.sectionContent = m.content.createChild("ContentNode")
          m.sectionContent.CONTENTTYPE = "SECTION"
          m.sectionContent.TITLE = sectiontext
        end sub
    
        sub addItem(itemtext as string)
          item = m.sectionContent.createChild("ContentNode")
          item.title = itemtext
        end sub
    
        ]]>
    
      </script>
    
      <children>
    
        <LabelList
          id = "coreList"
          translation = "[ 160, 92 ]"
          itemSize = "[ 440, 48 ]"
          itemSpacing = "[ 0, 0 ]"
          sectionDividerHeight = "48.0"
          sectionDividerFont = "font:MediumBoldSystemFont"
          sectionDividerTextColor = "0x880088FF" />
    
      </children>
    
    </component>
    

Fields
------

All of the attributes listed in [Content Meta-Data](/docs/developer-program/getting-started/architecture/content-metadata.md "Content Meta-Data") are accessible as fields using dot (.) notation on a ContentNode object. For example, for a ContentNode object iteminfo, the Content Meta-Data Description attribute can be read or written as follows:

    iteminfo.description
    

You can also access ContentNode attributes as fields using dot (.) notation if you add the attribute as an [<interface>](/docs/references/scenegraph/xml-elements/interface.md "<interface>") element field to an extended ContentNode component. For example, you could extend a ContentNode as a custom listitemcontent component with a componentname field to include an XML component name in a list item:

    <component  name = "listitemcontent" extends = "ContentNode" >
    
      <interface >
        <field id = "componentname" type = "string" />
      </interface>
    
    </component>
    

Then for a listitemcontent ContentNode object iteminfo, you can read or write the componentname field in the same way as if it were a Content Meta-Data attribute:

    iteminfo.componentname
    

> You can only use dot (.) notation to access ContentNode fields as attributes found in [Content Meta-Data](/docs/developer-program/getting-started/architecture/content-metadata.md "Content Meta-Data"), or defined as an [<interface>](/docs/references/scenegraph/xml-elements/interface.md "<interface>") element field in a custom ContentNode component.

Content feed video lesson
-------------------------

You can learn how to link the content metadata in your app's feed to a ContentNode by watching the [Creating the content feed](/videos/courses/rsg/debugging.md) video lesson in Roku's [SceneGraph: Build a Channel online video course](https://developer.roku.com/videos/courses/rsg/overview.md).

Sample app
----------

[ContentNodeExample](https://github.com/rokudev/samples/tree/master/ux%20components/control/ContentNodeExample) is a sample app demonstrating ContentNode in action.

PanelSet
========

Extends [**Group**](/docs/references/scenegraph/layout-group-nodes/group.md)

The PanelSet node provides the panel sliding behavior seen in the Roku home screen. The PanelSet node manages the position of a set of child Panel nodes, and implements the left and right panel sliding behavior. Once a Panel node has been added to a PanelSet node, it remains a child of the PanelSet node unless it is replaced by another Panel node, or slides completely off the right side of the screen.

The PanelSet node is designed to display two Panel nodes in most cases, one Panel node on the left and one on the right. When the PanelSet node has focus, and the user presses the **Left** (or **Back**) or **Right** remote control key, the panels slide to the left or right one position.

For example, suppose the PanelSet node has two Panel nodes as children, panel A and panel B. When the user presses the **Right** key, a new panel, panel C, should be created and added as a child of the PanelSet node. Adding a panel as a child of the PanelSet node causes all the panels to slide left one position, so that panel A is now offscreen to the left, panel B is in the left position, and panel C is in the right position. If the user presses the **Right** key again, a new panel, panel D, should be created and added as a child node of the PanelSet node. Adding panel D causes the panels to slide left again so that panels A and B are offscreen to the left, panel C is in the left position, and panel D is in the right position.

At this point, if the user presses the **Left** key (or **Back** key), the panels will slide one position to the _right_, _back_ towards the original home position, so panel D will slide offscreen to the right, panel C will slide to the right position, and panel B will slide to the left position (panel A is still offscreen to the left). When the sliding animation ends, since panel D is offscreen to the right, it is automatically removed as a child node of the PanelSet node.

#### Panel Layout

For consistency, it is recommended that panels be set to the default height. Similarly, panels should be set to one of four default width sizes. For each panel width, the default defines a corresponding left position for the panel. This is summarized in the table below, along with the default values for each of these fields:

| Panel Field | Panel Size | SD Value | HD Value |
| --- | --- | --- | --- |
| height | all | 403 | 605 |
| width | narrow | 218 | 388 |
|     | medium | 292 | 520 |
|     | wide | 363 | 645 |
|     | full | 520 | 940 |
| leftPosition | narrow | 60  | 105 |
|     | medium | 60  | 105 |
|     | wide | 63  | 112 |
|     | full | 100 | 170 |

Narrow panels should be paired with wide panels, so that both panels fit in the alloted region without overlapping the PanelSet node previous and next arrow indicators. Similarly, medium panels should be paired with medium panels. Only one full-screen width panel can be displayed at a time, so full-screen cause both left and right panels to slide on/offscreen when they are added to the PanelSet node.

When two panels are onscreen, a default gap is added between the left and right panels. For SD, the spacing is set to 20 pixels. For HD, the spacing is 30 pixels. The PanelSet node positions the left panel so that the panel origin is at (`leftPosition, 0`) in the PanelSet node coordinate system, where `leftPosition` is the value of the left Panel node `leftPosition` field. The PanelSet node positions the right panel so that the panel origin is at (`leftPosition leftWidth + spacing`), where `leftPosition` and `leftWidth` are the left panel `leftPosition` and `width` fields, and spacing is the default horizontal spacing attribute.

Note that the PanelSet node positions the origin of each Panel node coordinate system by setting the Panel node `translation` field, but it does not clip the panel to the rectangle defined by the Panel node `width` and `height` fields, so if the Panel node contains a child node with translation set to (`-10, -5`), that child will be rendered 10 pixels to the right and 5 pixels above the panel origin.

#### Child Management

The regular roSGNode child management interface, ifSGNodeChildren, is used for adding panels to the PanelSet node. Since adding children to the PanelSet node can trigger the panels to slide left, care must be taken to use those functions in the expected manner.

Typically, the first panel is created, the panel `focusedChild` field has an observer added, then the panel is added to the PanelSet node with `appendChild()`. Then focus is set on that panel, causing the `focusedChild` observer function to be called. The `focusedChild` observer function typically will create the second panel, add a `focusedChild` observer on that panel, then add the second panel to the PanelSet node with `appendChild()`, and so forth.

If any panel contains a list or grid, the typical usage is that when the list or grid panel is on the left, each list/grid item creates a different panel on the right. Typically, the list or grid `itemUnfocused` and `itemFocused` fields are observed. When the `itemUnfocused` field changes, the list or grid panel will hide the panel on the right, then when the `itemFocused` field changes, it will create a new panel for the newly focused list or grid item, and call `replaceChild()` to cause the old panel to be replaced by the new one.

The PanelSet node assumes that:

*   Only Panel nodes are added as PanelSet node children
*   Panels are added only using the `appendChild()` or `createChild()` roSGNode functions. The Panel node `leftPosition` field must be set prior to calling `appendChild()` or `createChild()`. Appending a child will trigger a PanelSet node slide action in most cases.
*   Panels can be replaced using the `replaceChild()` roSGNode function.
*   Panel children should never be removed from the PanelSet node using the `removeChild()` roSGNode function. The PanelSet node automatically removes Panel node children when they slide offscreen to the right.
*   The `insertChild()` and `removeChild()` roSGNode functions are never used.

Fields
------

| Field | Type | Default | Access Permission | Description |
| --- | --- | --- | --- | --- |
| width | float | 1280 | READ\_WRITE | Specifies the width of the PanelSet node. In most cases, this is set to the display width (such as 1280 for HD). |
| height | float | 605 | READ\_WRITE | Specifies the height of the PanelSet node. In most cases, this is set to the the display height minus the overhang height. |
| slideDuration | integer | 500 | READ\_WRITE | Milliseconds of the slide transition. The default is 1/2 second. |
| numPanels | integer | 0   | READ\_ONLY | Contains the current number of Panel nodes that are children of the PanelSet node. |
| isGoingBack | Boolean | false | READ\_ONLY | Set to true when the PanelSet node panels are sliding right, _back_ towards the original home position, as a result of a **Left** or **Back** key press. |

Sample app
----------

[PanelSetExample](https://github.com/rokudev/samples/tree/master/ux%20components/sliding%20panels/PanelSetExample) is a sample app demonstrating PanelSet in action.

ifHttpAgent
===========

The ifHttpAgent methods modify the way that URLs are accessed

Implemented by
--------------

| Name | Description |
| --- | --- |
| [roAppManager](/docs/references/brightscript/components/roappmanager.md "roAppManager") | The Application Manager APIs set application level attributes, which mostly affect the look-and-feel of the application |
| [roAudioPlayer](/docs/references/brightscript/components/roaudioplayer.md "roAudioPlayer") | The Audio Player object provides the ability to setup the playing of a series of audio streams |
| [roSGNode](/docs/references/brightscript/components/rosgnode.md "roSGNode") | The roSGNode object is the BrightScript equivalent of SceneGraph XML file node creation |
| [roTextureManager](/docs/references/brightscript/components/rotexturemanager.md "roTextureManager") | The Texture Manager provides a set of API's for managing an roBitmap cache. |
| [roTextureRequest](/docs/references/brightscript/components/rotexturerequest.md "roTextureRequest") | An roTextureRequest is used to make requests to the roTextureManager |
| [roUrlTransfer](/docs/references/brightscript/components/rourltransfer.md "roUrlTransfer") | A roUrlTransfer object transfers data to or from remote servers specified by URLs |
| [roVideoPlayer](/docs/references/brightscript/components/rovideoplayer.md "roVideoPlayer") | The roVideoPlayer component implements a video player with more programmatic control, but less user control than the roVideoScreen component |

Supported methods
-----------------

### AddHeader(name as String, value as String) as Boolean

Adds the specified HTTP header to the list of headers that will be sent in the HTTP request.

Certain well known headers such as User-Agent, Content-Length, and so on are automatically sent. The application may override the values for these headers if needed (for example, some servers may require a specific user agent string).

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| name | String | The name of the HTTP header to be added to the list of headers.  <br>  <br>If "x-roku-reserved-dev-id" is passed as the name, the value parameter is ignored and in its place, the devid of the currently running app is used as the value. This allows the developer's server to know which client app is talking to it.  <br>  <br>Any other headers with names beginning with "x-roku-reserved-" are reserved and may not be set. |
| value | String | The value of the HTTP header being added. |

#### Return Value

A flag indicating whether the HTTP header was successfully added.

### SetHeaders(nameValueMap as Object) as Boolean

#### Description

Sets the HTTP headers to be sent in the HTTP request.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| nameValueMap | Object | An associative array containing the HTTP headers and values to be included in the HTTP request.  <br>  <br>If "x-roku-reserved-dev-id" is passed as a key, the value parameter is ignored and in its place, the devid of the currently running app is used as the value. This allows the developer's server to know which client app is talking to it.  <br>  <br>Any other headers with names beginning with "x-roku-reserved-" are reserved and may not be set. |

#### Return Value

A flag indicating whether the HTTP header was successfully set.

### InitClientCertificates() as Boolean

#### Description

Initializes the object to be sent to the Roku client certificate.

> The Roku Developer Dashboard includes a link for downloading the [RokuTV Certification Authority](https://developer.roku.com/certificate). This CA can be passed to an app through this function.

#### Return Value

A flag indicating whether the object sent to to the Roku client certificate was successfully initialized.

### SetCertificatesFile(path as String) as Boolean

Set the certificates file used for SSL to the specified .pem file.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| path | String | The directory path of the .pem file to be used. |

#### Return Value

A flag indicating whether the certificate was successfully set.

### SetCertificatesDepth(depth as Integer) as Void

#### Description

Sets the maximum depth of the certificate chain that will be accepted.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| depth | Integer | The maximum depth to be used. |

### EnableCookies() as Void

#### Description

Enables any Set-Cookie headers returned from the request to be interpreted and the resulting cookies to be added to the cookie cache.

### GetCookies(domain as String, path as String) as Object

#### Descripton

Returns any cookies from the cookie cache that match the specified domain and path. Expired cookies are not returned.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| domain | String | The domain of the cookies to be retrieved. To match all domains, provide an empty string. |
| path | String | The path of the cookies to be retrieved. |
| secure  <br>  <br>_Available since Roku OS 12.0_ | Boolean | Indicates whether the cookie is to be retrieved via HTTPS (true) or HTTP (false). |

#### Return Value

An roArray of roAssociativeArrays, where each associative array represents a cookie. The roAssociativeArrays contain the following key-value pairs:

| Name | Type | Description |
| --- | --- | --- |
| Version | Integer | Cookie version number |
| Domain | String | Domain to which cookie applies |
| Path | String | Path to which cookie applies |
| Name | String | Name of the cookie |
| Value | String | Value of the cookie |
| Expires | roDateTime | Cookie expiration date, if any |

### AddCookies(cookies as Object) as Boolean

#### Description

Adds the specified cookies to the cookie cache.

#### Parameters

NameTypeDescriptioncookiesObjectAn roArray of roAssociativeArrays, where each associative array represents a cookie to be added. Each associative array must contain the following key-value pairs:

| Name | Type | Description |
| --- | --- | --- |
| Version | Integer | Cookie version number |
| Domain | String | Domain to which cookie applies |
| Path | String | Path to which cookie applies |
| Name | String | Name of the cookie |
| Value | String | Value of the cookie |
| Expires | roDateTime | Cookie expiration date, if any |
| Secure  <br>  <br>_Available since Roku OS 12.0_ | Boolean | Indicates whether the cookie is to be sent over HTTPS (true) or HTTP (false). |

#### Return Value

A flag indicating whether the cookies were successfully added to the cache.

### ClearCookies() as Void

#### Description

Removes all cookies from the cookie cache.

Server Side Configuration of SSL Mutual Authentication on Apache
----------------------------------------------------------------

1.  Create a Self-Signed CA (Certificate Authority) root Certificate
    
    *   Create the root CA private key (remember the password chosen). This is needed to sign new certificates.
        
    *   Create the root CA.
        
              openssl genrsa -out rootCA.key 4096
              openssl req -x509 -new -nodes -key rootCA.key -sha256 -days 825 -out rootCA.crt
            
        

2.  OpenSSL Server Cert
    
    *   Create the Web Server's key (remember the password chosen).
        
    *   Create the Web Server's Cert Req.
        
    *   Sign the Web Server's Cert Req with the CA Cert. In the _extfile_ keyword, provide the path to the config file.
        
              openssl genrsa -out <server>.key 2048
              openssl req -new -key <server>.key -out <server>.csr -config <server>.conf
              openssl x509 -req -in <server>.csr -CA rootCA.crt -CAkey rootCA.key -CAcreateserial -out <server>.crt -days 825 -sha256 -extfile <config_file_path> -extensions req_ext
            
        

        **Sample config file**: The following demonstrates a config file to be referenced by the *extfile* keyword
    
            [req]
            default_bits = 2048
            prompt = no
            default_md = sha256
            req_extensions = req_ext
            distinguished_name = dn
            [dn]
            C = <COUNTRY>
            ST = <STATE>
            L = <CITY>
            O = <ORGANIZATION>
            OU = <ORGANIZATIONAL_UNIT>
            emailAddress = <CONTACT>
            CN = <DOMAIN>.com
            [req_ext]
            subjectAltName = @alt_names
            [alt_names]
            DNS.1 = <DOMAIN>.com
            DNS.2 = <DOMAIN_ALT>.com
    

3.  Install Cert in Apache
    
    *   Optionally, you can remove the passwd from the keyfile if you don't want to enter the passwd for testWEB every time Apache starts
    *   Edit /etc/httpd/conf.d/ssl.conf
    *   Edit /etc/httpd/conf/httpd.conf
    *   Restart Apache

    # Install Cert in Apache
        sudo mkdir /etc/httpd/certs
        sudo cp /opt/openssl/testCA/server/certificates/testWEB.CRT /etc/httpd/certs
        sudo cp /opt/openssl/testCA/server/keys/testWEB.KEY /etc/httpd/certs
        sudo cp sudo cp /opt/openssl/testCA/CA/testCA.CRT /etc/httpd/certs
    
    # Remove the passwd from the keyfile (to avoid entering it for testWEB every time Apache starts)
        sudo cp /etc/httpd/certs/testWEB.KEY
        /etc/httpd/certs/testWEB.KEY.orig
        sudo openssl rsa -in /etc/httpd/certs/testWEB.KEY.orig -out /etc/httpd/certs/testWEB.KEY
    
    # Editing ssl.conf
    
    # Configure your server cert:
        SSLCertificateFile /etc/httpd/certs/testWEB.CRT
        SSLCertificateKeyFile /etc/httpd/certs/testWEB.KEY
    
    # Configure client cert authentication:
        SSLCACertificateFile /etc/httpd/certs/cacert.pem
    
    # from roku sdk
        SSLVerifyClient require
        SSLVerifyDepth 1
    
    # Editing httpd.conf
    
    # In <Directory> </Directory> tags where your video resides:`
    # Checking the x-roku-reserved-dev-id header value assures that it is
    # your package trying to connect to this directory.
    
    # You can find the dev-id of your brightscript package by going to the developer page on your Roku box, and selecting "Utilities".
    # On the "Utilities" page, select "Choose File", enter the passwd for that pkg, and click "Inspect"
    # Copy the value for the "Dev ID:" parameter and paste it here:
        SetEnvIf x-roku-reserved-dev-id 6bb22ba64125f6da56fa4b7d6f2199a970d06672 let_roku_in`
        SSLRequireSSL`
        Order Deny,Allow`
        Deny from all`
        Allow from env=let_roku_in`
    
    # Restarting Apache
        sudo service httpd restart
    

4.  Place your video in your Apache directory configured in step 3 above.
    
5.  Modify the simplevideoplayer application to access the secure video:
    
    *   Add the testCA.CRT (The Certificate Authority cert) file to the simplevideoplayer/source directory.
    *   In the appMain.brs:displyVideo() function, change the URL and video meta-data to match the video you put on your server in step 4).
    *   Right before the "video.SetContent(videoclip)" line, add the following calls:

          video.Addheader("x-roku-reserved-dev-id","")
          video.SetCertificatesFile("pkg:/source/testCA.CRT")
          video.InitClientCertificates()
    

6.  Test the authentication with and without the code in step 5 above. If any of the three authentication methods above are ommitted you should get access denied. Note that you cannot successfully access the video until you've built a package, uploaded it to the app store, and are running that app via an app code. A sideloaded app does not properly negotiate client certs or send the enforced dev-id value for the x-roku-reserved-dev-id header.

Reference overview
==================

The reference materials in this section provide developers with detailed syntactic and semantic information about the Roku platform's key development facilities – chiefly, the BrightScript scripting language and the SceneGraph framework. This section serves as a sort of encyclopedia for developers, who will frequently refer to it for information specific to different nodes, components, interfaces, events, or methods.

New developers
--------------

Developers new to Roku development are encouraged to read the following two sections before consulting the reference materials:

*   [BrightScript language reference](/docs/references/brightscript/language/brightscript-language-reference.md) — This section explains the fundamentals of Roku's scripting language, BrightScript, which is used to power all Roku apps. Here you'll find information about the BrightScript component architecture, global functions, reserved words, etc.
*   [SceneGraph core concepts](/docs/developer-program/core-concepts/core-concepts.md) — SceneGraph is the UI framework used to style all Roku apps. The core concepts section explains how to handle critical app operations such as data scoping, event handling, node and field observers, multi-thread operations, and much more.

Experienced developers
----------------------

For developers already acquainted with BrightScript and SceneGraph, information in the reference section helps answer such questions as:

*   Is this keyword or function/subroutine name spelled correctly?
*   Does a particular statement include all necessary clauses? Are there any optional clauses?
*   Does a given function/subroutine/method call include the proper number and type of arguments? What is the correct order of arguments? Which variant signatures are available?
*   Which default values are assumed in the absence of optional clauses or arguments?
*   What are the initial states of data structures?
*   How does a given statement or function/subroutine/method call affect its parameters or its environment? What can a programmer or troubleshooter expect after this entity's execution?
*   Does the feature depend on environmental preconditions for proper operation?
*   Does a particular interface include a method or attribute that serves purpose x? Which purpose(s) does method or attribute y serve?
*   What are typical error conditions that may occur when using a particular statement or function/subroutine/method, and how are those error situations indicated?
*   What is a typical or illustrative example of code to safely and properly use statement x, make call y, or access node z?
*   Which other aspects of the system are typically used in conjunction with – or are especially relevant to – a particular feature?
*   (How) Does the existence, behavior or structure of statement x, call y, or object/component z vary significantly with system version?

Aspects of the last question are specially covered in the separate [Deprecated APIs](/docs/references/deprecated-apis.md) document, which developers should revisit periodically, or whenever notified by Roku, in order to keep their channels current for certification purposes.

LabelList
=========

Extends [**ArrayGrid**](/docs/references/scenegraph/abstract-nodes/arraygrid.md)

The LabelList node class is a simple list class that can be used to display a list of items. Each item can include a text string and an optional icon positioned to the left of the text string.

The list items can be organized into sections that are demarcated by labelled horizontal divider lines between the sections.

In most cases, you will want to populate the content of a LabelList (or other similar components like PosterGrids, etc.) from a content feed, web service API, or some other dynamic data source. However, to illustrate the basics of how a LabelList is constructed and used, here is a simple example of creating a LabelList and populating it with static data. Static data in a LabelList may be useful for app screens such as settings or menus with fixed items.

**Static LabelList configuration**

    <LabelList
      id = "moviemenu"
      translation = "[160,92]"
      itemSize = "[440,48]" >
    
      <ContentNode id = "moviemenucontent" role = "content" >
    
        <ContentNode title = "Drama" />
        <ContentNode title = "Action" />
        <ContentNode title = "Horror" />
        <ContentNode title = "Comedy" />
    
      </ContentNode>
    
    </LabelList>
    

**Example**

This code renders the LabelList shown below.

In this screen shot, the user has scrolled down one item to highlight "Drama" showing the separator after the last list item.

![roku815px - LabelList-example1](https://image.roku.com/ZHZscHItMTc2/LabelList-example1.jpg "LabelList-example1")

Fields
------

FieldTypeDefaultAccess PermissionDescriptioncontentContentNodenoneREAD\_WRITESpecifies the content for the list. See [Data bindings](/docs/references/scenegraph/list-and-grid-nodes/labellist.md#data-bindings) below for more details.  
If the data contains section markers, section dividers will be drawn between each section. These section dividers may contain an icon and/or a string.itemSizevector2d\[0,0\]READ\_WRITESpecifies the width and height of each item in the listitemSpacingvector2d\[0,0\]READ\_WRITEThe second value of the vector specifies the vertical spacing between items in the list. The first value of the vector is ignored.numRowsinteger12READ\_WRITESpecifies the number of visible rows displayed. The actual number of rows may be more or less than the number of visible rows specified depending on the number of items in the list content.textHorizAlignoption stringleftREAD\_WRITESpecifies the horizontal alignment of the text in the list item area specified by the `itemSize` field value (the text is always centered vertically in the list item area). The possible options are:  
  

| Option | Effect |
| --- | --- |
| left | Text is left-aligned |
| right | Text is right-aligned |
| center | Text is center-aligned |

colorcolor0xddddddffREAD\_WRITESpecifies the text color for unfocused list itemsfocusedColorcolor0x262626ffREAD\_WRITESpecifies the text color for focused list itemsfontfontsystem defaultREAD\_WRITESpecifies the font for unfocused list itemsfocusedFontfontsystem defaultREAD\_WRITESpecifies the font for focused list itemsdrawFocusFeedbackBooleantrueREAD\_WRITESpecifies whether or not the focus indicator bitmap is displayeddrawFocusFeedbackOnTopBooleanfalseREAD\_WRITESpecifies whether the focus indicator bitmap is drawn below or on top of the list itemsvertFocusAnimationStylestringfixedFocusWrapREAD\_WRITESpecifies the how the focus indicator moves in a list of items in response to the remote direction pad Up and Down key presses. The possible values are:  
  

| Option | Effect |
| --- | --- |
| fixedFocusWrap | Causes the focus indicator to float up or down until it reaches the end of the list, at which point the focus indicator will stay fixed on the first or last item in the list, and the items will scroll up or down if there are items that were not visible. |
| floatingFocus | Causes the list to wrap around when the focus indicator reaches the first or last item in the list, as long as the list contains enough items to fill the list. If the list does not contain enough items to fill the list, the focus indicator will float up and down. |

focusRowinteger0READ\_WRITESpecifies the row that will have fixed focus if the `vertFocusAnimationStyle` field value is set to `fixedFocusWrap`.focusBitmapUriuriREAD\_WRITESpecifies the bitmap file used for the focus indicator when the list has focus. In most cases, this should be a 9-patch image that specifies both expandable regions as well as margins. Only set this field to specify a custom bitmap that differs in appearance from the default bitmap.focusFootprintBitmapUriuriREAD\_WRITESpecifies the bitmap file used for the focus indicator when the list does not have focus. In most cases, this should be a 9-patch image that specifies both expandable regions as well as margins. Only set this field to specify a custom bitmap that differs in appearance from the default bitmap.focusBitmapBlendColorcolor0xFFFFFFFFREAD\_WRITEBlend the graphic image specified by `focusBitmapUri` with the specified color. If set to the default, 0xFFFFFFFF, no color blending will occur. Set this field to show a focus indicator graphic image with a different color than the image specified by `focusBitmapUri.`focusFootprintBlendColorcolor0xFFFFFFFFREAD\_WRITEBlend the graphic image specified by `focusFootprintBitmapUri` with the specified color. If set to the default, 0xFFFFFFFF, no color blending will occur. Set this field to show a focus footprint indicator graphic image with a different color than the image specified by `focusFootprintBitmapUri`.wrapDividerBitmapUriuriREAD\_WRITESpecifies the bitmap file to use as a wrap divider, the visual separator between the last and first list items when the list wraps. In most cases, this should be a 9-patch image that specifies both expandable regions. Only set this field to specify a custom bitmap that differs in appearance from the default bitmap.wrapDividerHeightfloat0.0READ\_WRITESpecifies the height of the wrap divider, the visual separator between the last and first list items when the list wraps. The bitmap for the wrap divider is scaled to this height. The width of the wrap divider is set to the width of the list items as specified by the `itemSize` field width value.sectionDividerBitmapUriuriREAD\_WRITEIf the ContentNode specifies sections for a list or grid, specifies a custom bitmap to use as a visual divider between the sections of the list or grid. Only set this field to use a bitmap with a different appearance than the system default. For sections that do not include an icon or a title, the system default or custom bitmap specified as the `wrapDividerBitmapUri` field value is used for the section dividers. In most cases, you will want to use a 9-patch PNG bitmap with both expandable regions, which is the type of bitmap used as the system default.sectionDividerFontfontsystem defaultREAD\_WRITESpecifies the font for section divider labelssectionDividerTextColorcolor0xddddddffREAD\_WRITESpecifies the text color for section divider labelssectionDividerSpacingfloat10READ\_WRITEIf the ContentNode specifies sections for a list or grid, and the section dividers are specified to include an icon and/or a label, specifies the spacing between the icon, label, and section divider bitmap.sectionDividerHeightfloat40READ\_WRITESpecifies the height of the section dividers. The width of the section dividers is determined by the width of the list items as specified by the itemSize field width value.sectionDividerMinWidthfloat117READ\_WRITESpecifies the minimum width of the section divider bitmap. The section divider label will be ellipsized if necessary in order to ensure that the section divider bitmap meets the minimum width.sectionDividerLeftOffsetfloat0READ\_WRITENumber of pixels to offset the left edge of the section divider relative to the left edge of the list items.itemSelectedinteger0READ\_ONLY**Read-Only**  
When a list item is selected, itemSelected is set to the index of the selected item.itemFocusedinteger0READ\_ONLY**Read-Only**  
When a list item gains the key focus, set to the index of the focused item.itemUnfocusedinteger0READ\_ONLY**Read-Only**  
When a list item loses the key focus, set to the index of the unfocused item.jumpToIteminteger0WRITE\_ONLY**Write-Only**  
When set to a valid item index, this causes the list to immediately update so that the specified index moves into the focus position.animateToIteminteger0WRITE\_ONLY**Write-Only**  
When set to a valid item index, this causes the list to quickly scroll so that the specified index moves into the focus position.

Data bindings
-------------

The data model for the LabelList node should have a single ContentNode as the root node in its content field. The structure of the rest of the data model depends on whether or not the list items are to be grouped into sections.

**List Items Not Being Grouped Into Sections**

If the list items are not to be grouped into sections, one child ContentNode should be added to the root node for each item in the list (these child nodes can be thought of as _item nodes_). Item nodes should have their ContentNode attributes set as shown in the table below.

| Attribute | Type | Description |
| --- | --- | --- |
| `TITLE` | string | The label for the list item |
| `HDLISTITEMICONURL` | uri | The image file for the icon to be displayed to the left of the list item label when the list item is not focused |
| `HDLISTITEMICONSELECTEDURL` | uri | The image file for the icon to be displayed to the left of the list item label when the list item is focused |

**List Items Grouped into Sections**

If the list items are to be grouped into sections, one child ContentNode should be added to the root node for each section in the list (these child nodes can be thought of as _section roots_). Each section root should contain one child ContentNode for each item in the section (that is, item nodes). Each item ContentNode uses the same attributes as the item nodes when there are no sections, as shown in the table above.

The section root ContentNodes use the following attributes:

| Attribute | Type | Description |
| --- | --- | --- |
| `CONTENTTYPE` | string | Must be set to `SECTION` |
| `TITLE` | string | Label for the section divider |
| `HDGRIDPOSTERURL` | uri | The image file for the icon to be displayed to the left of the section label when the screen resolution is set to HD. |
| `SDGRIDPOSTERURL` | uri | The image file for the icon to be displayed to the left of the section label when the screen resolution is set to SD. |

Sample app
----------

[LabelListExample](https://github.com/rokudev/samples/tree/master/ux%20components/lists%20and%20grids/LabelListExample) is a sample app demonstrating LabelList in action.

roFloat
=======

roFloat is the object equivalent for intrinsic type 'Float'.

This is useful in the following situations:

*   If any object exposes the ifFloat interface, that object can be used in any expression that expects an intrinsic value.

Supported interfaces
--------------------

*   [ifFloat](/docs/references/brightscript/interfaces/iffloat.md "ifFloat")
*   [ifToStr](/docs/references/brightscript/interfaces/iftostr.md "ifToStr")

App localization
================

Publishers can distribute their content across the world through the [Streaming Store](https://channelstore.roku.com/). The Streaming Store includes all of North America, many countries in Latin America, and several countries in Europe. The Roku development platform makes it easy to broadly disseminate content; however, publishers should consider localization in the development, distribution, engagement, and monetization of their apps.

Roku has Streaming Stores in the following countries:

| North America | Europe | Latin America | Asia Pacific |
| --- | --- | --- | --- |
| *   United States<br>*   Canada | *   United Kingdom<br>*   Ireland<br>*   Germany | *   Argentina<br>*   Brazil<br>*   Chile<br>*   Colombia<br>*   Costa Rica<br>*   El Salvador<br>*   Guatemala<br>*   Honduras<br>*   Mexico<br>*   Nicaragua<br>*   Panama<br>*   Peru | Australia |

Development
-----------

The Roku platform supports the distribution of a single package file across multiple streaming stores. This means that developers only need to build and maintain one app and then handle localization in the application's code. For example, the app can be programmed to have a localized user experience, including multi-language support for the UI (labels, menus, and dialogs) and content metadata (titles and descriptions), and it can control the availability of content for different regions. In addition, the app UI can link to a privacy policy URL corresponding to the country associated with the user's Roku customer account.

To do this, developers can [get the external IP address of a Roku device](/docs/references/brightscript/interfaces/ifdeviceinfo.md#getexternalip-as-string) client-side, and return it back to the app's backend server. In the backend, the app can get the country ranges mapped to the IP address in order to present a localized experience and determine which content to show and allow access to customers.

Distribution
------------

The [Roku Developer Dashboard](https://developer.roku.com/developer) is the central hub for creating, configuring, certification testing, and distributing apps. The dashboard enables publishers to select in which countries to distribute an app. In addition, the dashboard presents a number of options that enable the app to be localized in the Streaming Store. Aspects of a Streaming Store listing that may be localized include metadata such as the app name and description, the app poster, and screenshots. Providing localized version of this application metadata will offer users of all language preferences the opportunity to learn more about your app before installing it.

Engagement
----------

### Roku Search multi-language and multi-regional support

[Roku Search](/docs/developer-program/discovery/search/implementing-search.md) supports English, Spanish, Portuguese, and German. Apps participating in Roku Search can provide [localized search feeds](/docs/specs/search/search-feed.md#multiregion-and-multilanguage-support) to further increase the discoverability of their content. For example, providing a search feed in Spanish makes the app's content available in queries made on devices with their language set to Spanish, as well as devices located in Streaming Stores where Spanish is the primary language (for example, most countries in Latin America).

### Multi-regional display and video ad targeting

Apps can be further promoted globally with Roku home screen banner ads, Roku screensaver ads, and video ads. Roku's [self-serve promotion tool](/docs/features/engagement/self-serve-promotions.md) lets apps programmatically purchase ads in order to drive installs, increase viewership, and reach more users. Apps may run home screen banner ads and Roku screensaver ads in a gowing number of countries (see the [documentation](/docs/features/engagement/self-serve-promotions.md) for the list of eligible countries).

Monetization
------------

### Regional availability of in-app products

Apps offering subscriptions and one-time purchases (movie rentals, pay-per-views, special events, and so on) can program the app to control the availability of in-app products in different regions. For example, an app may only be able to legally distribute content in a specific set of countries. To do this, apps can use the ChannelStore [**getUserRegionData**](/docs/references/scenegraph/control-nodes/channelstore.md#getuserregiondata) command to determine the country associated with the user's Roku account, and then implement business logic to filter the results of the ChannelStore [**getCatalog** command](/docs/references/scenegraph/control-nodes/channelstore.md#getcatalog) to only display products that should be available for that country.

### Localized in-app product names

Apps can also localize the names of their [in-app products](/docs/developer-program/roku-pay/quickstart/in-channel-products.md) (the name that is displayed to customers in the app's on-device purchasing workflow and in subscription emails sent by Roku). This helps customers identify the subscriptions and content they have purchased and reduces potential refund requests from unrecognizable charges.

### Currency conversions

While localizing product names is a manual process, Roku Pay automatically handles currency conversions and displays prices in the currency associated with the Streaming Store in which the device is located. For example, if a device is located in Brazil, the price of an in-app product that is $9.99 USD is displayed as R$24.9 BRL (Brazilan Real). Apps may also elect to independently handle currency conversion. To do this, apps can create in-app products for each country and filter out products based on the country in which the device is located (using the [ifDeviceInfo.GetCountryCode()](/docs/references/brightscript/interfaces/ifdeviceinfo.md#getcountrycode-as-string) method).

Samples
=======

The [Roku Developers GitHub repo](https://github.com/rokudev) provides a large selection of sample app code. Repos from SceneGraph nodes and implementations, to full integrated master sample apps, are briefly described below.

> After mastering the basics, you might want to look next at the following SceneGraph examples.
> 
> *   Roku SceneGraph (RSG) components: Building block components for configuring and rendering the app UI from scratch (refer to the [scenegraph-master-sample](https://github.com/rokudev/scenegraph-master-sample))
>     
> *   SceneGraph Developer Extensions (SGDEX) views: Full screen components to save the effort of building from scratch (refer to the [SceneGraphDeveloperExtensions](https://github.com/rokudev/SceneGraphDeveloperExtensions))
>     

Featured Samples
----------------

| Category | GitHub link | Description |
| --- | --- | --- |
| Basic | [hello-world](https://github.com/rokudev/hello-world) | Simple sample app to try out sideloading |
|     | [samples](https://github.com/rokudev/samples) | More elaborate sample apps for learning |
| SceneGraph | [scenegraph-master-sample](https://github.com/rokudev/scenegraph-master-sample) | Guide to building a basic, high-performance Roku app that passes certification |
|     | [SceneGraphDeveloperExtensions](https://github.com/rokudev/SceneGraphDeveloperExtensions) | Pre-built, reusable Roku SceneGraph (RSG) components to enable rapid development of apps that follow a consistent UX paradigm |
|     | [RAF4RSG-sample](https://github.com/rokudev/RAF4RSG-sample) | Sample demonstrating the Roku Advertising Framework in SceneGraph |
|     | [tv-safe-zone-overlay](https://github.com/rokudev/tv-safe-zone-overlay) | Function to overlay the current UI in a SceneGraph scene with a transparent safety zone overlay |
|     | [simple-videoplayer-channel](https://github.com/rokudev/simple-videoplayer-channel) | SimpleVideoPlayer app remastered in SceneGraph |
|     | [sgnodes-all-demo](https://github.com/rokudev/sgnodes-all-demo) | Demonstrates how the `sgnodes all` SceneGraph debug console command (port 8080) returns the reference counts held by the Roku OS (osref) and the app itself (bscref); used in conjunction with the [console debugger](/docs/developer-program/debugging/debugging-channels.md) |
| Advanced | [hero-grid-channel](https://github.com/rokudev/hero-grid-channel) | Sample app with sliding hero row and a grid of content below |
|     | [tv-safe-zone-channel](https://github.com/rokudev/tv-safe-zone-channel) | App that demonstrates the TV safe zones for Titles and Action in the UI |
|     | [trickplay-samples](https://github.com/rokudev/trickplay-samples) | Samples that use BIF/thumbnails during trick play |
|     | [custom-playback-channel](https://github.com/rokudev/custom-playback-channel) | List of content displayed with video continuously playing |
|     | [multi-live-channel](https://github.com/rokudev/multi-live-channel) | App example of live TV in addition to multiple live streams support |
| Authentication | [on-device-authentication](https://github.com/rokudev/on-device-authentication) | Authenticate customers and validate their access to content when they sign in to an app from their Roku devices, without requiring them to visit an external webpage |
| Voice | [transport-control](https://github.com/rokudev/transport-control) | Handle voice commands in an app |
|     | [dynamic-voice-enabled-keyboards](https://github.com/rokudev/dynamic-voice-enabled-keyboards) | Create and configure dynamic voice-enabled keyboards |
| Dialogs | [standard-dialog-framework](https://github.com/rokudev/standard-dialog-framework) | Create built-in and custom dialogs with Roku's Standard Dialog Framework |
| Deep Linking | [deep-Linking-samples](https://github.com/rokudev/deep-Linking-samples) | Learn about Deep Linking and roInput Messaging |
| Podcast | [podcast-player-channel](https://github.com/rokudev/podcast-player-channel) | Fully working podcast player app - accepts an MRSS feed and parses artwork and playlist |
| ChannelStore | [channelstore-node-tvod-sample](https://github.com/rokudev/channelstore-node-tvod-sample) | Sample demonstrating how to set up transactional purchases using the ChannelStore node |
|     | [rochannelstore-tvod-sample](https://github.com/rokudev/rochannelstore-tvod-sample) | Sample demonstrating how to set up transactional purchases using the roChannelStore component |
| Audio | [dolby-audio-sample](https://github.com/rokudev/dolby-audio-sample) | Collection of Dolby test content available in different streaming protocols |
| Screensaver | [animated-screensaver](https://github.com/rokudev/animated-screensaver) | Screensaver demonstrating poster animations across the screen |
|     | [home-screensaver](https://github.com/rokudev/home-screensaver) | Screensaver that displays the icons of installed apps |
|     | [fading-screensaver](https://github.com/rokudev/fading-screensaver) | Screensaver demonstrating fading animations |
|     | [quadrant-screensaver](https://github.com/rokudev/quadrant-screensaver) | Screensaver demonstrating a quadrant transition animation |
| Testing | [unit-testing-framework](https://github.com/rokudev/unit-testing-framework) | Tool for automating and testing Roku apps |
|     | [automated-channel-testing](https://github.com/rokudev/automated-channel-testing) | Roku Automated App Testing: Selenium-based WebDriver + Robot Framework + JS Framework + Samples |
|     | [notification-receiver-sample](https://github.com/rokudev/notification-receiver-sample) | Sample application in Java for receiving notifications from Roku |
|     | [remote-debugger](https://github.com/rokudev/remote-debugger) | Python-based remote debugger demonstrating the BrightScript debug protocol |
|     | [debug-protocol-vscode-ext-beta](https://github.com/rokudev/debug-protocol-vscode-ext-beta) | VSCode extension for debugging apps with the BrightScript remote network debug protocol |
|     | [manifestData-sample](https://github.com/rokudev/manifestData-sample) | Sample showing how to use the Video node's manifestData field to detect the periods in a DASH manifest before they are played back |

Downloading server content
==========================

Various types of content material can be downloaded from your server to a SceneGraph application. Many of the renderable nodes include a `uri` field that allows you specify the URI of a graphical image file or other content on your server. Setting this field causes the node to automatically download the content to the SceneGraph node, and for graphical images, be rendered on the display screen according the configuration of the node.

For many nodes that require more complex data, a `content` field is provided. This special field is designed to be assigned the value of a Content node node that you configure to contain the data required for the node.

Configuring a content node for static content
---------------------------------------------

Generally, you'll want to download dynamic content for your application from your server. But to simply illustrate how to set up a ContentNode for a node requiring data, the following shows setting a ContentNode as a child of a LabelList node requiring the data using the `role` attribute. The example makes clear the hierarchal relationship required for the `content` field of a LabelList node, with a parent ContentNode and several child ContentNodes for the list item text. The `role` attribute automatically assigns the ContentNode to the `content` field of the LabelList node, and the SceneGraph application shows the text strings in the child ContentNodes as the items of the list.

**Static ContentNode configuration**

    <LabelList
      id = "moviemenu"
      translation = "[160,92]"
      itemSize = "[440,48]" > 
    
      <ContentNode id = "moviemenucontent" role = "content" >
    
        <ContentNode title = "Comedy" />
        <ContentNode title = "Drama" />
        <ContentNode title = "Action" />
        <ContentNode title = "Horror" />
    
      </ContentNode>
    
    </LabelList>
    

Configuring a ContentNode with dynamic content
----------------------------------------------

The ContentNode can be configured in a Task node when you want to download dynamic data from your server to the ContentNode node. To do this, you must write BrightScript code in the Task node to create the parent ContentNode and the hierarchy of child ContentNodes required for your application.

In a Task node, you can use the BrightScript roUrlTransfer component to read the content data from your server. If the data is contained in JSON or XML formats, you can then use the corresponding BrightScript parsing functions and components to configure a ContentNode with the content data. The BrightScript JSON/XML parsing loop should be set up to terminate when the **Task** node <interface> field for the target ContentNode is fully configured with new data, to allow an `observeField()` function set in the component that requires the data to trigger a callback function to assign the data to the target node.

For example, the following Task node downloads a list of strings to be used as text for a LabelList node. The Task node includes two <interface> fields, one for the URI of the content data (`uri`), and another for the ContentNode that will be configured with the data (`content`). When an XML component requires a list of strings for a LabelList node, the component can set the `control` field of the Task node object to `RUN`. This sends the specified <interface> field values to the Task node, in this case the URI of the content data, and starts the Task node. The Task node then downloads an XML file with the content data from the specified URI, parses the XML data, and creates a parent ContentNode, and child ContentNodes for each string. When the ContentNode node is configured with all the strings in the XML file, it is assigned to the ContentNode object reference set in the <interface> field. This change in the field value triggers the `observeField()` callback function in the component XML file to add the strings to the LabelList node `content` field.

First, here's the XML file the example Task node downloads from the server and parses:

**Example server XML file**

    <?xml version = "1.0" encoding = "UTF-8" standalone="yes" ?>
    
    <listcontent>
    
      <item text = "Comedy" />
      <item text = "Drama" />
      <item text = "Action" />
      <item text = "Horror" /> 
    
    </listcontent>
    

And here is how the component XML file configures and starts the Task node process, including setting the `observeField()` function to trigger a callback function to display the LabelList node after the content data is downloaded:

**Example Task node configuration and launch**

    m.getHomeOptionsList = createObject("roSGNode", "getLabelListContent")
    m.getHomeOptionsList.setField("uri", "http://www.sdktestinglab.com/homeoptionslistcontent.xml")
    m.getHomeOptionsList.observeField("content", "showhomeoptionslist")
    m.getHomeOptionsList.functionName = "showhomeoptionslist"
    m.getHomeOptionsList.control = "RUN"
    

And here's the actual Task node itself that does the work of downloading the server XML file, parsing the XML content data, and configuring a ContentNode with the data:

**Downloading LabelList node content**

    <?xml version = "1.0" encoding = "utf-8" ?>
    
    <!--********** Copyright 2015 Roku Corp.  All Rights Reserved. **********-->
    
    <component name = "getLabelListContent" extends = "Task" >
    
    <interface>
      <field id = "uri" type = "uri" />
      <field id = "content" type = "node" />
    </interface> 
    
    <script type = "text/brightscript" >
    
      <![CDATA[
    
      sub init()
        m.top.functionName = "getContent"
      end sub
    
      sub getContent()
        content = createObject("roSGNode", "ContentNode")
        contentxml = createObject("roXMLElement")
    
        readInternet = createObject("roUrlTransfer")
        readInternet.setUrl(m.top.uri)
        contentxml.parse(readInternet.GetToString())
    
        if contentxml.getName() = "listcontent"
          for each item in contentxml.GetNamedElements("item")
            attributes = item.getAttributes()
            item = {
              text: attributes.text
              }
            listitem = content.createChild("ContentNode")
            listitem.title = item.text
          end for
        end if
    
        m.top.content = content
      end sub
    
      ]]>
    
      </script>
    
    </component>
    

Note that this example could be used to download strings for any LabelList node, or for that matter, any node that requires a simple list of strings as the required content for the node. For more complex data requirements, the XML parsing loop in the example could be expanded to include any Content Metadata attributes required for the node (and of course, contained in the server XML file).

SoundEffect
===========

Extends [**Node**](/docs/references/scenegraph/node.md)

The SoundEffect node class is used to play audio sound effects that can be triggered from events that occur in the UI. Typically, these sound effects are short audio clips, but there is no inherent limit on their length. Currently, up to four simultaneous sounds can be playing at any time, in addition to audio from streaming content and TextToSpeech audio.

Files can be installed locally as part of the package file or dynamically downloaded from the network. All files must be WAV (i.e. PCM) format.

For local files, the convention is to include the WAV files in a directory named "sounds".

For downloaded files, a least-recently-used (LRU) mechanism is used to keep the most recently downloaded/played sounds in temporary storage on the device. If the limits on the maximum number/size of downloaded sounds is exceeded, the least recently used sounds are removed from temporary storage. They will be automatically reloaded the next time the control field is set to "play".

A sample demonstrating how to use the SoundEffect node can be found here: [SimpleSoundEffect](https://github.com/rokudev/samples/blob/master/media/SimpleSoundEffect)

Fields
------

FieldTypeDefaultAccess PermissionDescriptionuriuriREAD\_WRITESpecifies the URI of the WAV file. Sounds included as part of the application package can be referenced using the `pkg:/sounds` prefix. This may also specify the location of a WAV file on a remote server.controloption stringnoneREAD\_WRITESet to control the audio playback. Getting the value of this field returns the most recent value set, or none if no value has been set.  
  

| Option | Effect |
| --- | --- |
| none | No effect |
| play | Start playing the audio. If the audio is already playing, it will be restarted.  <br>  <br>If the `loadStatus` field is not "ready", the sound will not be played and the `state` field will be set to "notready".  <br>  <br>For networked files with the `loadStatus` field set to "flushed", setting `control` to "play" will automatically trigger a reload of the network file, but will not result in the sound being played, due to the time it takes to download the file again. In this case, the sound can be played once the `loadStatus` field changes from "flushed" to "ready" |
| stop | If the audio is playing, stop playing the audio. If the audio is not playing, no effect. |

statevalue stringnoneREAD\_ONLYCan be used to track the progress of current state of local and networked sound files When the field value changes to ready, the sound is ready to be played. The possible values are:  
  

| Value | Meaning |
| --- | --- |
| none | No current playback state |
| playing | Audio is currently playing. |
| stopped | The audio playback was stopped by setting control to "stop". The state will also be set to "stopped" if audio was playing and the uri is changed. |
| finished | The audio playback reached the end of the audio |
| toomanysounds | Control was to "play" while there were already the maximum number of SoundEffect sounds playing. Currently, this limit is 4. |
| notready | The sound file is not on the device. This is set in response to the control field being set to "play".  <br>  <br>For local WAV files included in a package file, it will be occur if the path to the file is not correct, or if the file is not a valid WAV file.  <br>  <br>For network-accessed WAV files, this indicates one of these three conditions is true:  <br>  <br><br>*   The file has been requested, but is not finished downloading. In this case, the `loadStatus` field will be set to "loading".<br>*   The file request has completed, but the URL is incorrect or the downloaded file is not a valid WAV filed. In this case, the `loadStatus` field will be set to "failed"<br>*   The file has previously been downloaded, but has been flushed from the LRU cache. In this case, the `loadStatus` field will be set to "flushed". |

loadStatusvalue stringnoneREAD\_ONLYIndicates the status of the sound file.  
  

| Value | Meaning |
| --- | --- |
| none | No file has been requested. |
| loading | (network files only) The file has been requested and is being downloaded. |
| ready | The file is ready to be played (i.e. it is on the device and is a valid WAV file). |
| failed | The file path or URI is incorrect or refers to a file that is not a valid WAV file. |
| flushed | (network files only) The file was ready, but has been deleted from the LRU cache. Setting the `control` field to play will cause the file to be automatically reloaded, but not be played upon completion. |

volumeinteger50READ\_WRITEThe volume is a number between 0 and 100 (percentage of full volume). 50 should be used for normal volume.

MultiStyleLabel
===============

Extends [**LabelBase**](/docs/references/scenegraph/label-nodes/label-base.md)

The MultiStyleLabel node class is used to create labels with mixed styles. For example, this node can be used to create a single label with plain and bold text, different fonts, and/or multiple colors.

![roku815px - img](https://image.roku.com/ZHZscHItMTc2/emoji-multistylelabel.jpg)

Fields
------

Fields derived from the [Group](/docs/references/scenegraph/layout-group-nodes/group.md#fields "Fields") and [LabelBase](/docs/references/scenegraph/label-nodes/label-base.md#fields) classes can be used.

| Field | Type | Description |
| --- | --- | --- |
| drawingStyles | associative array of associative arrays | Defines the size, URI, and color of a font style. This field may contain one or more font styles. |

Example
-------

The MultiStyleLabel **drawingStyles** field contains one or more associative arrays that represent font styles. Each font style contains **fontSize**, **fontUri**, and **color** properties.

The MultiStyleLabel **text** field uses a simple markup style. Markup tags with the names of the styles defined in the **drawingStyles** field are used to delineate the boundaries of the label text to be rendered in that specific style.

    m.MultiStyleLabel.drawingStyles = {
    
        "HandprintedRed": {
            "fontSize": 36
            "fontUri": "pkg:/fonts/vSHandprinted.otf"
            "color": "#FF0000FF"
        }
            "HandprintedGreen": {
                "fontSize": 36
                "fontUri": "pkg:/fonts/vSHandprinted.otf"
                "color": "#00FF00FF"
        }
        "default": {
            "fontSize": 36
            "fontUri": "font:LargeSystemFont"
            "color": "#000000FF"
        }
    }
    
    m.MultiStyleLabel.text = "Default Text <HandprintedRed>Red text followed by</HandprintedRed><HandprintedGreen>more text in a funny style thaty the world has never seen before...</HandprintedGreen>"
    

Sample app
----------

You can download and install a [sample app](https://github.com/rokudev/samples/tree/master/ux%20components/screen%20elements/renderable%20nodes/MultiStyleLabelExample) that demonstrates how to use the MultiStyleLabel node.

ifSGNodeBoundingRect
====================

The ifSGNodeBoundingRect interface can be used to query the bounding rectangle of subject node. The ifSGNodeBoundingRect interface methods return a node bounding rectangle as an associative array with four elements:

| Name | Value |
| --- | --- |
| x   | x-coordinate of the origin of the bounding rectangle |
| y   | y-coordinate of the origin of the bounding rectangle |
| width | width of the bounding rectangle |
| height | height of the bounding rectangle |

> These methods return the bounding rectangle dimensions and location of component objects at the time they are called. If they are called before an object is fully constructed, such as before all graphical images have been loaded, they will return the dimensions and location at the time of the call, which may not be the correct values for placing the component object properly. To ensure that your screen has the component objects located as you intended, make sure you call these methods after the component object is fully constructed. For example, if the component object relies on loading graphical images to construct its appearance, it is best to use these methods as part of an observer callback function triggered by the image loading field events, such as the loadStatus field of the Poster node.

Implemented by
--------------

| Name | Description |
| --- | --- |
| [roSGNode](/docs/references/brightscript/components/rosgnode.md) | The roSGNode object is the BrightScript equivalent of SceneGraph XML file node creation |

Supported methods
-----------------

### boundingRect() as Dynamic

#### Description

Returns the node bounding rectangle. The bounding rectangle of a node is the axis-aligned rectangle computed by transforming the local bounding rectangle of the node by the node transformation matrix. The resulting rectangle corresponds to the node local bounding rectangle transformed into its parent node local coordinate system.

#### Return Value

An associative array with the node bounding rectangle.

### localBoundingRect() as Dynamic

#### Description

Returns the node local bounding rectangle. The local bounding rectangle of a node is the axis-aligned rectangle, that includes the union of the bounding rectangle of the geometry of the node, and the bounding rectangles of all of the node children, transformed into the local coordinate system of the node.

#### Return Value

An associative array with the node local bounding rectangle.

### sceneBoundingRect() as Dynamic

#### Description

Returns the bounding rectangle for scene components (component nodes extended from a [Scene](/docs/references/scenegraph/scene.md "Scene") or [OverhangPanelSetScene](/docs/references/scenegraph/sliding-panels-nodes/overhangpanelsetscene.md "OverhangPanelSetScene") node class).

If this method is called before any child components have been added to the **Scene** component, or the child components are smaller than the **Scene** component, this is the screen dimensions of the user interface, so can be used to automatically create a bounding rectangle for the specified display user interface dimensions (SD, HD, FHD), to locate and dimension child components within the screen.

If this method is called after child components have been added that are larger than the **Scene** component, the returned bounding rectangle will be larger than the user interface dimensions.

#### Return Value

An associative array with the bounding rectangle.

### ancestorBoundingRect(ancestor as roSGNode) as Dynamic

#### Description

Returns the bounding rectangle of this node and all of its children in the Scene's root coordinate system, including any transformation specified in the Scene node.

In most cases, this will result in the bounding rectangle expressed in display coordinates.

If the node is not connected to a Scene node, this will return the same value as the [boundingRect()](#boundingrect-as-dynamic) method.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| ancestor | roSGNode | The ancestor of the subject node. |

#### Return Value

An associative array with the bounding rectangle and all of its children in the Scene's root coordinate system.

### localSubBoundingRect(itemnumber as String) as Dynamic

#### Description

Returns the local bounding rectangle of this node's identified sub part in the node's local coordinate system. If the subpart does not exist, the node's local bounding rectangle is returned.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| itemnumber | String | The _itemnumber_ parameter may contain one of the following strings:<br><br>*   itemX: where X is the index of an item in an ArrayGrid's data model (for example, **item17** is the 17th item in the data model).<br>*   itemX\_Y: where X is the index of the row and Y is the index of an item in that row in a RowList's data model (for example, **item4\_11** is the 11th item in row 4 of the data model).<br>*   focusItem: Gets the bounding rect of the ArrayGrid's focused item.<br>*   focusIndicator: Gets the bounding rect of the ArrayGrid's focus indicator (for example, the focus ring or list highlight). |

#### Return Value

An associative array with the local bounding rectangle of the node's identified sub part.

### subBoundingRect(itemnumber as String) as Dynamic

#### Description

Returns the bounding rectangle of this node's identified sub part, as transformed by this node's transformation matrix, in its parent node's coordinate system. If the subpart does not exist, the node's bounding rectangle is returned.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| itemnumber | String | The _itemnumber_ parameter may contain one of the following strings:<br><br>*   itemX: where X is the index of an item in an ArrayGrid's data model (for example, **item17** is the 17th item in the data model).<br>*   itemX\_Y: where X is the index of the row and Y is the index of an item in that row in a RowList's data model (for example, **item4\_11** is the 11th item in row 4 of the data model).<br>*   focusItem: Gets the bounding rect of the ArrayGrid's focused item.<br>*   focusIndicator: Gets the bounding rect of the ArrayGrid's focus indicator (for example, the focus ring or list highlight). |

#### Return Value

An associative array with the bounding rectangle.

### sceneSubBoundingRect(itemnumber as String) as Dynamic

#### Description

Returns the bounding rectangle of this node's subpart in its Scene's coordinate system If the subpart does not exist or if the node is not an ancestor of a Scene node, this will return the node's bounding rectangle.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| itemnumber | String | The _itemnumber_ parameter may contain one of the following strings:<br><br>*   itemX: where X is the index of an item in an ArrayGrid's data model (for example, **item17** is the 17th item in the data model).<br>*   itemX\_Y: where X is the index of the row and Y is the index of an item in that row in a RowList's data model (for example, **item4\_11** is the 11th item in row 4 of the data model).<br>*   focusItem: Gets the bounding rect of the ArrayGrid's focused item.<br>*   focusIndicator: Gets the bounding rect of the ArrayGrid's focus indicator (for example, the focus ring or list highlight). |

#### Return Value

An associative array with the bounding rectangle.

| Name | Return Type | Parameters | Return Value | Description |
| --- | --- | --- | --- | --- |
| sceneSubBoundingRect | Dynamic | ${sceneSubBoundingRect} | Bounding rectangle |     |

### ancestorSubBoundingRect(itemnumber as String, ancestor as roSGNode) as Object

#### Description

Returns the bounding rectangle of this node's subpart into the specified ancestor' s coordinate system. If the subpart does not exist or if the node is not an ancestor of the specified node, this will return the node's bounding rectangle

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| itemnumber | String | The _itemnumber_ parameter may contain one of the following strings:<br><br>*   itemX: where X is the index of an item in an ArrayGrid's data model (for example, **item17** is the 17th item in the data model).<br>*   itemX\_Y: where X is the index of the row and Y is the index of an item in that row in a RowList's data model (for example, **item4\_11** is the 11th item in row 4 of the data model).<br>*   focusItem: Gets the bounding rect of the ArrayGrid's focused item.<br>*   focusIndicator: Gets the bounding rect of the ArrayGrid's focus indicator (for example, the focus ring or list highlight). |
| ancestor | roSGNode | The ancestor of the subject node. |

#### Return Value

An associative array with the bounding rectangle.

Example: Illustrating Bounding Rectangles
-----------------------------------------

We start with the following code example:

The scene has the following parenting structure:

    Scene
    RectangleGroup
    Rectangle (Green)
    Rectangle (Yellow)
    <Scene>
      <Group id="RectGroup" translation="[100, 50]" >
            <Rectangle id="GreenRect" width="100" height="150" color="0x00FF00FF" translation="[200, 75]" >
                <Rectangle id="YellowRect" width="150" height="250" color="0xFFFF00FF" translation="[200,100]" rotation="-0.45"/>
            </Rectangle>
       </Group>
    </Scene>
    

Initially, the illustration shows the local coordinates systems of each of these nodes.

![roku815px - rectangle-group1](https://image.roku.com/ZHZscHItMTc2/rectangle-group1.png "rectangle-group1")

The next illustration shows the Yellow rectangle's localBoundingRect().

![roku815px - rectangle-group2](https://image.roku.com/ZHZscHItMTc2/rectangle-group2.png "rectangle-group2")

The next illustration shows the Yellow rectangle's boundingRect(), which is relative to it's parent's coordinate system.

![roku815px - rectangle-group3](https://image.roku.com/ZHZscHItMTc2/rectangle-group3.png "rectangle-group3")

The next illustration shows the Yellow rectangle's sceneBoundingRect(), which is relative to the Scene's coordinate system.

![roku815px - rectangle-group4](https://image.roku.com/ZHZscHItMTc2/rectangle-group4.png "rectangle-group4")

The next illustration shows the localBoundingRect() of the Green rectangle, that includes the union of the Green rectangle's local rectangle and the boundingRect() of it's child. This rectangle is relative to the Green rectangle's local coordinate system.

> Note that this is the smallest, screen-aligned rectangle the encloses both the Green and Yellow rectangle.

![roku815px - rectangle-group5](https://image.roku.com/ZHZscHItMTc2/rectangle-group5.png "rectangle-group5")

The next illustration shows the boundingRect() of the Green rectangle, which is relative to its parent Group's coordinate system.

![roku815px - rectangle-group6](https://image.roku.com/ZHZscHItMTc2/rectangle-group6.png "rectangle-group6")

The last illustration shows the Green rectangle's sceneBoundingRect(), which is relative to the Scene's coordinate system.

![roku815px - rectangle-group7](https://image.roku.com/ZHZscHItMTc2/rectangle-group7.png "rectangle-group7")

Standard dialog framework
=========================

As part of the Roku OS 10.0 release, Roku's standard dialog framework enables developers to use new pre-built modal pop-up dialogs and build custom ones. Dialogs are used to display information to users that require their immediate attention (for example, selecting a subscription product, entering credentials or account information, informing the user that a screen is loading, and so on). These new pre-built and custom standard keyboards are summarized as follows:

*   **New pre-built message, keyboard, pin pad, and progress dialogs**. These new dialogs feature updated graphics and color palette support that enable developers to provide a consistent user experience across the dialogs in their app (and across the Roku platform as developers can easily adopt the new design of Roku OS system dialogs). In addition, the keyboard and pin pad dialogs include voice entry support for faster customer sign-ups and sign-ins. These new dialog nodes deprecate the [legacy versions](/docs/references/scenegraph/dialog-nodes/dialog.md).

*   **Developer-defined custom dialogs**. Developers can design custom dialogs that may include a combination of text, buttons, bulleted lists, keyboards, loading indicators, and other building blocks. Custom dialogs also include all the features provided by the pre-built dialogs (voice, custom layout, and graphics). This provides developers with the flexibility to build and configure dialogs to meet their app's requirements.

Structure
---------

A StandardDialog contains a background image drawn under the dialog contents. The dialog contents include a vertical column containing the following areas (from top to bottom): title area, content area, button area. Each area is optional, which means a dialog may contain one to all three areas. A dialog may only have a single title area and button area, but it may have multiple content areas. The width of the title area, button area, and the sum of the widths of the content areas are always equal.

*   **Title Area**. The title area is drawn at the top of the dialog. It always contains a primary title that consists of a single line of text that briefly describes the purpose of the dialog. The title area may also include optional icons that appear left or right justified. A dialog may only have a single title area, and the title area is optional.

*   **Content Area**. A content area is a vertical column of content items. The Content Items may include static information, such as a block of text, a bullet list or a progress indicator, or dynamic objects such as a pin pad or a keyboard. A dialog may have one or content areas, and the content area is optional.

*   **Button Areas**. The button area contains a vertical-arranged set of buttons. Buttons in a dialog are typically used to confirm or cancel the dialog's operation or to advance forward/backward through a multistep process. A dialog may only have a single button area, and the button area is optional.

![roku815px - Basic Dialog](https://image.roku.com/ZHZscHItMTc2/BasicDialog.jpg)

Summary
-------

### Pre-built dialog hierarchy and examples

The pre-built message, keyboard, pin pad, and progress dialogs inherit their basic properties from the **StandardDialog** node class, which extends the **Group** node. The following table summarizes the standard dialog nodes and their hierarchy:

| Node | Description | Example |
| --- | --- | --- |
| Group |     |     |
| ++ StandardDialog | Defines the width, height, color palette, button selected, and button focused fields that are inherited by its child nodes. |     |
| ++++ StandardMessageDialog | Displays a message to the user. | ![roku400px - standard-message-dialog](https://image.roku.com/ZHZscHItMTc2/standard-message-dialog.jpg) |
| ++++ StandardKeyboardDialog | Enables text and voice entry of strings consisting of alphanumeric characters as well as many commonly used symbols. | ![roku400px - keyboard-dialog](https://image.roku.com/ZHZscHItMTc2/keyboard-dialog.jpg) |
| ++++ StandardPinPadDialog | Enables text and voice entry of numeric digits—typically, short numeric PIN codes. | ![roku400px - pin-pad](https://image.roku.com/ZHZscHItMTc2/pin-pad-dialog-v3.jpg) |
| ++++ StandardProgressDialog | Displays a spinning progress indicator that includes a short progress message to the user. | ![roku400px - progress-dialog](https://image.roku.com/ZHZscHItMTc2/progress-dialog.jpg) |

### Custom dialog hierarchy and examples

As described in the dialog structure overview, a dialog contains three areas: title, content, and button. Additionally, a custom dialog may include a side card, which is a freeform area to the right or left side of the dialog that is used for displaying decorative images or annotative text.

Each of these areas has a corresponding node for building a custom dialog: **StdDlgTitleArea**, **StdDlgContentArea**, **StdDlgButtonArea**, and **StdDlgSideCardArea**. Each of these nodes inherits its functionality from the **StdDlgAreaBase** node, which extends the **Group** node.

*   The **StdDlgTitleArea** node does not contain any child nodes. It displays the title and/or icons at the top of the dialog.

*   The **StdDlgContentArea** node may contain a number of content items such as a block of text, a bullet list or a progress indicator, or dynamic objects such as a pin pad or a keyboard. Each of these content items has a corresponding node that inherits its basic functionality from the **StdDlgItemBase** node. For example, the text block has a **StdDlgTextItem** node, the keyboard has a **StdDlgKeyboardItem** node, and so on.

*   The **StdDlgButtonArea** node may contain a single **StdDlgButton** node.

*   The **StdDlgSideCardArea** node may contain one or SceneGraph nodes (for example, a [Poster](/docs/references/scenegraph/renderable-nodes/poster.md) node for displaying an image or a [Label](/docs/references/scenegraph/label-nodes/label.md) node for displaying text).

The following table summarizes the standard dialog nodes used to build custom dialogs and their hierarchy. For completeness, the content items and buttons that may be included in the **StdDlgContentArea** and **StdDlgButtonArea** nodes are listed; however, they do not inherit any properties from the nodes.

NodeDescriptionGroup++ StdDlgAreaBaseProvides common functionality for the **StdDlgTitleArea**, **StdDlgContentArea** and **StdDlgButtonArea** classes.++++ StdDlgTitleAreaContains the title information and/or icons at the top of the dialog.++++ StdDlgContentAreaContains the main body of the dialog, which may include zero to multiple content area items (**StdDlgItemBase** nodes), which are as follows:

| Node | Description | Example |
| --- | --- | --- |
| StdDlgItemBase | Provides common functionality for all content area items. |     |
| ++StdDlgItemGroup | Visually groups a set of StdDlgAreaBase child nodes in a custom dialog |     |
| ++StdDlgActionCardItem | Highlights the StdDlgItemBase child nodes in the content area of a custom dialog. | ![roku400px - StdDlgBulletTextItem](https://image.roku.com/ZHZscHItMTc2/action-cards-example.png) |
| ++ StdDlgBulletTextItem | A bulleted list of text. | ![roku400px - StdDlgBulletTextItem](https://image.roku.com/ZHZscHItMTc2/StdDlgBulletTextItem-v2.jpg) |
| ++ StdDlgDeterminateProgressItem | A progress indicator that represents the percentage of the progress that has been completed. | ![roku400px - std-dlg-determinate-progress-item](https://image.roku.com/ZHZscHItMTc2/std-dlg-determinate-progress-item-2.jpg) |
| ++ StdDlgGraphicItem | An image with an optional text label. | ![roku400px - v](https://image.roku.com/ZHZscHItMTc2/std-dlg-graphic-item.jpg) |
| ++ StdDlgKeyboardItem | Either a keyboard or PIN pad for the text and voice entry of alphanumeric/symbol strings or numeric digits (typically, short numeric PIN codes), respectively. | ![roku400px - std-dlg-keyboard-item](https://image.roku.com/ZHZscHItMTc2/std-dlg-keyboard-item.jpg) |
| ++ StdDlgMultiStyleTextItem | A line of text with multiple styles (for example, plain and bold characters, different fonts, multiple colors, and/or emojis). | ![roku400px - std-dlg-progress-item](https://image.roku.com/ZHZscHItMTc2/stdDlgMultiStyleTextItem-green-text.png) |
| ++ StdDlgProgressItem | A spinning progress indicator for tasks that take an indeterminate amount of time. | ![roku400px - std-dlg-progress-item](https://image.roku.com/ZHZscHItMTc2/std-dlg-progress-item.jpg) |
| ++ StdDlgTextItem | A block of text. | ![roku400px - std-dlg-text-item](https://image.roku.com/ZHZscHItMTc2/std-dlg-text-item.jpg) |
| ++ StdDlgCustomItem | A free-form custom item. | ![roku400px - custom-item-roku250px](https://image.roku.com/ZHZscHItMTc2/std-dlg-custom-item-multi-column.jpeg) |

++++ StdDlgButtonAreaContains any buttons (**StdDlgButton** nodes) in the button area located at the bottom of the dialog:++++ StdDlgSideCardAreaA freeform area to the right or left side of a custom standard framework dialog that contains decorative images or annotative text.

Code examples
-------------

The following sections demonstrate the SceneGraph and/or BrightScript code that could be used to create the following confirmation dialog using pre-built and custom standard dialog nodes:

![roku400px - button-dialog](https://image.roku.com/ZHZscHItMTc2/button-dialog.jpg)

### Creating a pre-built dialog

To create the confirmation dialog with a pre-built StandardDialog node and detect button events, the following BrightScript code could be used:

##### BrightScript

    sub showAccountDialog()
        ' set up the dialog
        m.accountDialog = createObject("roNode", "StandardMessageDialog")
        m.accountDialog.title = "Let's create your account!"
        m.accountDialog.message = [ "Sign up for a free account to start streaming today." ]
        m.accountDialog.buttons = [ "Continue", "Cancel" ]
    
        ' observe the dialog's buttonSelected field to handle button selections
        m.accountDialog.observeFieldScoped("buttonSelected", "onButtonSelected")
    
        ' display the dialog
        scene.dialog = m.accountDialog
    end sub
    
    'detect button events
    sub onButtonSelected()
    ' use the dialogs buttonSelected field to perform the appropriate action
        if m.accountDialog.buttonSelected = 0
            doContinueAction()
        else if m.accountDialog.buttonSelected = 1
            doCancelAction()
        end if
    end sub
    

### Creating a custom dialog

To create the confirmation dialog with a custom standard dialog and detect button events, the following SceneGraph and BrightScript code could be used:

##### SceneGraph

    <?xml version="1.0" encoding="utf-8" ?>
    <component name="AccountDialog" extends="StandardDialog" >
        <children>
            <StdDlgTitleArea primaryTitle="Let's create your account!" />
            <StdDlgContentArea>
                <StdDlgTextItem text="Sign up for a free account to start streaming today." />
            </StdDlgContentArea>
            <StdDlgButtonArea id="buttonArea">
                <StdDlgButton text="Continue" />
                <StdDlgButton text="Cancel" />
            </StdDlgButtonArea>
        </children>
    </component>
    

##### BrightScript

    sub showAccountDialog()
        ' set up the dialog
        m.accountDialog = createObject("roNode", "AccountDialog")
    
        ' functions that are typically in the code that creates dialog (not in component's  scripts)
    
        ' observe the dialog's buttonSelected field to handle button selections
        m.accountDialog.observeFieldScoped("buttonSelected", "onButtonSelected")
    
        ' display the dialog
        scene.dialog = m.accountDialog
    end sub
    
    'detect button events
    sub onButtonSelected()
    ' use the dialogs buttonSelected field to perform the appropriate action
        if m.accountDialog.buttonSelected = 0
            doContinueAction()
        else if m.accountDialog.buttonSelected = 1
            doCancelAction()
        end if
    end sub
    

Layout algorithm
----------------

Based on the width of the StandardDialog node, the node's layout algorithm automatically determines the widths and heights of its constituent parts (**StdDlgTitleArea**, **StdDlgContentArea**, and **StdDlgButtonArea**). Those results are used to determine the overall height of the dialog and the width/height/position of each part.

Dialogs should generally be designed to always fit onscreen for the specified width. However, if the specified dialog width generates a dialog with a height that does not fit onscreen, one or more of the dialog parts may be placed into a scrolling region. This enables the user to see the entire contents of the dialog. The algorithm to adapt such dialogs to support a scrollable region will try the following:

1.  If a content area item is marked as scrollable, it will be put into a scrolling container with a height equal to the max dialog height minus the sum of the heights and spacings of the title area, button area, and other content area items (scrollingContainerHeight = maxDialogHeight - \[titleAreaHeightSpacing + contentAreaItemsHeightSpacing + buttonAreaHeightSpacing\]). Typically, only one content area item is marked as scrollable, but if multiple items are marked as such, the scrollable item that has the largest height is the one converted into a scrolling region.

2.  If step 1 fails (or no items are marked as scrollable), the entire content area is placed into a scrolling container.

3.  If both steps 1 and 2 fail (or the dialog does not have a content area), the number of visible buttons shown is automatically decreased and the button area is configured for scrolling up/down. At least three buttons are always shown.

4.  If all steps fail, both the content area and the button area will automatically be configured to support scrolling.

> None of these options guarantees a successful dialog layout. If a dialog has too many buttons and/or too much content, the layout algorithm will try to fit the dialog onscreen; however, in some cases, it may not be possible.

Color palettes
--------------

By default, the StandardDialog node uses a default color palette consisting of shades of gray, as demonstrated in the dialog images displayed throughout this document. The default color palette can be overridden for a single dialog or all the dialogs in an app:

1.  **Setting the color palette for a single dialog**: Set the dialog's palette field to an **RSGPalette** node that defines the colors to be used.

2.  **Setting the color palette for all dialogs (recommended)**: Create an **RSGPalette** node and assign it to the Scene's palette field. This ensures that all the dialogs in the app have a consistent appearance because the Scene's palette is used for all StandardDialog nodes, unless overridden in an individual dialog. Overriding the Scene's palette is typically done in the **init()** function of a custom RSG component that extends the Scene node.

For more information about how StandardDialog nodes used the RSGPalette colors, see the [StandardDialog](/docs/references/scenegraph/standard-dialog-framework-nodes/standard-dialog.md "StandardDialog")'s palette field.

##### Example

The following BrightScript code demonsrates how to create an **RSGPalette** node with green colors and assign it to the Scene's palette field. The resulting dialog is displayed below the code.

    m.greenPalette = createObject("roSGNode", "RSGPalette")
    m.greenPalette.colors = {DialogBackgroundColor: "0x003000FF",
                             DialogItemColor: "0x00EF00FF",
                             DialogTextColor: "0x00EF00FF",
                             DialogFocusColor: "0x00EF00FF",
                             DialogFocusItemColor: "0x007E00FF",
                             DialogSecondaryTextColor: "0x00EF0066",
                             DialogSecondaryItemColor: "0x80FF804D",
                             DialogInputFieldColor: "0x80FF8080",
                             DialogKeyboardColor: "0x80FF804D",
                             DialogFootprintColor: "0x80FF804D" }
    
      scene.palette = m.greenPalette
    

![roku400px - BasicDialogWithGreenPalette](https://image.roku.com/ZHZscHItMTc2/BasicDialogWithGreenPalette.jpg)

Sample app
----------

You can download and install a [sample app](https://github.com/rokudev/standard-dialog-framework) that demonstrates how to create built-in and custom dialogs with the Standard Dialog Framework. This sample app includes examples for the built-in standard keyboard, PINpad, and message dialogs, and custom dialogs featuring the standard dialog building blocks such as the keyboard, text and bullet text, and progress loaders.

Video
=====

Extends [**Group**](/docs/references/scenegraph/layout-group-nodes/group.md)

The Video node class provides a controlled play of live or VOD video.

The Video node includes a wide variety of internal nodes to support trick play, playback buffering indicators, and so forth. Playback buffering indicators, to indicate buffering before initial playback as well as re-buffering, use an internal instance of a ProgressBar node. For trick play, an internal instance of a TrickPlayBar node is provided. For display of BIF images for DVD-like chapter selection, an internal instance of a BIFDisplay node is provided.

Starting from Roku OS 8, the behavior of the Roku system overlay is such that the system overlay now slides in whenever the \* button is pressed, the Video node is in focus, and the app does not have its OnKeyEvent() handler fired. When the Video node is not in focus, the system overlay does not slide in and the OnKeyEvent() handler is fired.

Fields
------

### Playback fields

To set the specific video playback parameters for a particular video, set the [Content Meta-Data](/docs/developer-program/getting-started/architecture/content-metadata.md) attributes for the video in a [ContentNode](/docs/references/scenegraph/control-nodes/contentnode.md) node, and assign the ContentNode to the `content` field of the Video node.

Video playback can then be controlled by setting the value of the `control` field, such as setting the field value to `play` to begin playback.

The `control` field includes a `prebuffer` option, which allows the video to begin buffering without showing the video. You can use this option to begin buffering of a video before a user has actually selected and started the video, such as when the user is looking at information about various video offerings in a list or grid or another type of UI element. This can eliminate much or all of the apparent delay in starting the video due to buffering the video for the user. For example, you could set the `control` field value to `prebuffer` in a callback function triggered by the `itemFocused` events that occur as a user scrolls down a list of video offerings that also display information about each video. When the user makes the selection, you can begin the actual video playback by setting the `control` field value to `play` in a callback function triggered by the `itemSelected` event for the list.

FieldTypeDefaultAccess PermissionDescriptioncontentContentNodeNULLREAD\_WRITEThe ContentNode with the [Content Meta-Data](/docs/developer-program/getting-started/architecture/content-metadata.md) for the video, or a video playlist (a sequence of videos) to be played.  
  
If a video playlist is to be played, the children of this ContentNode comprise the playlist, and each ContentNode child must have all attributes required to play that video. For example, if the videos "A" and "B" are to be played, three ContentNodes must be created: the parent ContentNode (which is largely ignored), one ContentNode child for "A," and one ContentNode child for "B." The parent node is set into this content field, and when video playback is started, all of its children will be played in sequence. Any changes made to the playlist after playback has started are ignored. See the `contentIsPlaylist` and `contentIndex` fields, for more information on playlists.playStartInforoAssociativeArrayREAD\_ONLYProvides timing measurements related to the start of video playback. All measurements are in seconds.  
  
The roAssociativeArray contains the following fields:  
  

| Field | Type | Access Permission | Description |
| --- | --- | --- | --- |
| total\_dur | float | READ\_ONLY | Total video start duration. |
| manifest\_dur | float | READ\_ONLY | Manifest download and parsing. |
| drm\_load\_dur | float | READ\_ONLY | DRM system initialization. |
| drm\_lic\_acq\_dur | float | READ\_ONLY | License acquisition. This typically includes interactions with the license server. |
| prebuf\_dur | float | READ\_ONLY | Prebuffer content. |
| manifest\_start | Float | READ\_ONLY | Point at which manifest download and parsing begins. |
| drm\_load\_start | Float | READ\_ONLY | Point at which DRM system initialization begins. |
| drm\_lic\_acq\_start | Float | READ\_ONLY | Point at which license acquisition begins. |
| prebuf\_start | Float | READ\_ONLY | Point at which content pre-buffering begins. |

  

> The \_start fields correspond to the similarly named \_dur (duration) fields in this structure. In each case, the \_start point is the number of milliseconds elapsed from the initialization of the media player (t=0.000). If required, ending points for each interval can be derived from its associated starting-point and duration.

licenseStatusroAssociativeArrayREAD\_ONLIndicates whether the DRM license was acquired. If a failure occurs, this field provides additional details about the error. The roAssociativeArray contains the following fields:  
  

| Key | Type | Value |
| --- | --- | --- |
| response | string | The server response. If a license is not retrieved, the response is empty and the HTTP response code is returned instead. |
| status | string | The HTTP response code. |
| keysystem | string | The DRM technology used. |
| duration | string | The total time elapsed in sending a request to the license server and receiving a response (in milliseconds). |

  
contentIsPlaylistBooleanfalseREAD\_WRITEIf set to true, enables video playlists (a sequence of videos to be played). See the `content` and `contentIndex` field for more information on playlists.contentIndexinteger\-1READ\_ONLYThe index of the video in the video playlist that is currently playing. Generally, you would only want to check this field if video playlists are enabled (by setting the `contentIsPlaylist` field to true), but it is set to 0 when a single video is playing, and video playlists are not enabled.nextContentIndexinteger\-1READ\_WRITEIf the `contentIsPlaylist` field is set to true to enable video playlists, sets the index of the next video in the playlist to be played. Setting this field does not immediately change the video being played, but takes effect when the current video is completed or skipped. By default, this value is -1, which performs the default index increment operation. After the video specified by the index in this field begins playing, the field is set to the default -1 again, so the next video played will be set by the default index increment operation unless the field is set again to a different index.controloption stringnoneREAD\_WRITESets the desired play state for the video, such as starting or stopping the video play. Getting the value of this field returns the most recent value set, or none if no value has been set. To dynamically monitor the actual state of the video, see the `state` field.  
  
The play and stop commands to commence and discontinue playback should not be used to implement trick modes like rewind, or replay. For that use the `seek` field.  
  

| Option | Effect |
| --- | --- |
| none | No play state set |
| play | Start video play |
| stop | Stop video play |
| pause | Pause video play |
| resume | Resume video play after a pause |
| replay | Replay video |
| prebuffer | Starts buffering the video stream before the Video node actually begins playback. Only one video stream can be buffering in the application at any time. Setting the `control` field to `prebuffer` for another video stream after setting `prebuffer` for a previous video stream stops the buffering of the previous video stream. |
| skipcontent | Skip the currently-playing content and begin playing the next content in the playlist. If the content is not a playlist, or if the current content is the end of the playlist, this will end playback. |

asyncStopSemantics  
  
_Available since Roku OS 12.5_booleanfalseWRITEIndicates whether the "STOP" command is executed asynchronously (true) or synchronously (false).  
  
By default, the STOP command is executed synchronously, which blocks the UI thread. Enabling this field makes the STOP command non-blocking, which enables the video to be switched faster.  
  
When this field is enabled, the `state` field is set to "stopping" when the asynnchronous stop begins. The `state` field then changes to "stopped" once the stop has been completed.  
  
Any other media player component calls on the UI thread that require the Video node to be re-instantiated should be blocked until the asynnchronous stop has been completed (for example, updating the `control` field to "Play" or "Prebuffer" or updating the `seek` field). This is because a video node in the "stopping" state is still using the underlying media player, which is not available at that time. As a result, performing these types of operations on a different video while in the "stopping" state may result in a playback failure.statevalue stringnoneREAD\_ONLYDescribes the current video play state, such as if the video play has been paused.  
  

| Value | Meaning |
| --- | --- |
| none | No current play state |
| buffering | Video stream is currently buffering |
| playing | Video is currently playing |
| paused | Video is currently paused |
| stopping  <br>  <br>_Available since Roku OS 12.5_ | Video is in the process of being stopped. This value is only returned if the `asyncStopSemantics` field is enabled. |
| stopped | Video is currently stopped |
| finished | Video has successfully completed playback |
| error | An error has occurred in the video play. The error code, message, and diagnostics can be found in the `errorCode`, `errorMsg`, and `errorStr` fields respectively. |

errorCodeinteger0READ\_ONLYThe error code associated with the video play error set in the `state` field:

*   0 no error
*   \-1 network error (server down or unresponsive, server is unreachable, network setup problem on the client).
*   \-2 connection timed out
*   \-3 unknown/unspecified or generic Error
*   \-4 empty list; no streams were specified to play
*   \-5 media error; the media format is unknown or unsupported
*   \-6 DRM error

  
Use the **errorStr** and and **errorInfo** fields for more descriptive diagnostic information to help identify and resolve the cause of the error.errorMsgstringREAD\_ONLYAn error message describing the video play error set in the `state` field.  
  
Use the **errorStr** and and **errorInfo** fields for more descriptive diagnostic information to help identify and resolve the cause of the error.errorStrstringREAD\_ONLYA diagnostic message to help resolve the video play error set in the `state` field.  
  
The format of the errorStr is as follows: category:{category\_name}:error:{error\_code}:ignored:{0|1}:{source}:{source\_name}:{additional catcher comment}:{error\_string}:extra:{error\_attributes}  
  

| errorStr Field | Type | Description |
| --- | --- | --- |
| category\_name | string | The type of error, which includes: "http", "drm", "mediaerror", or "mediaplayer". |
| error\_code | integer | The unique code associated with the error. |
| ignored | integer | Indicates whether the error generated an exception (0) or was ignored resulting in the next item in the content list being played (1). |
| source | string | The module that generated the error. |
| source\_name | string | The module that generated the error. |
| additional catcher comment | string | Typically, the comment added when the exception is caught. |
| error\_string | string | A text message describing the video play error. |
| error\_attributes | string | The error attribute, which includes the clipId (the unique ID of the clip that failed to play). |

errorInforoAssociativeArrayREAD\_ONLYA diagnostic message to help resolve the video play error set in the `state` field.  
  
The roAssociativeArray contains the following fields:  
  

| Field | Type | Description |
| --- | --- | --- |
| clipId | integer | The unique ID for the clip |
| ignored | integer | Indicates whether the error generated an exception (0) or was ignored resulting in the next item in the content list being played (1). |
| source | string | The module that generated the error. |
| category | String | The type of error, which includes: "http", "drm", "mediaerror", or "mediaplayer". |
| errcode | integer | The internal Roku code associated with the error. Use the **dbgmsg** field for debugging. |
| dbgmsg | string | A verbose debug message that can help identify the root cause of the error. |
| drmerrcode | integer | The error code returned by the DRM system, if any, when a video player error occurs |

decoderStatsroAssociativeArray{}READ\_ONLYProvides the following video decoder statistics related to the start of video playback:  
  

| Key | Type | Value |
| --- | --- | --- |
| renderCount | integer | The number of frames that have been rendered since playback was started. This value is incremented each time a new frame is rendered |
| repeatCount | integer | The number of frames that have been repeated since playback was started.This value is incremented each time a new frame is not available in time and the current frame is rendered an additional frame period. |
| frameDropCount | integer | The number of frames that have been dropped since playback was started.This value is incremented each time the presentation time of a decoded frame is too old to be rendered and the next frame is rendered instead. |
| streamErrorCount | integer | The number of bitstream errors since playback was started.This value is incremented each time the decoder detects a bitstream error. |

  
  
Set the **enableDecoderStats** field to true to enable updates to this field.enableDecoderStatsbooleanfalseREAD\_WRITEEnables updates to the **decoderStats** field.playbackActionButtonsroArray of roAssociativeArrays\[\]READ\_WRITEComponent that shows the buttons and other specified UI elements on the pause screen at the start of playback. Each element in the array has following fields:  
  

| Field | Type | Default | Description |
| --- | --- | --- | --- |
| text | string | system default | Text for the button label |
| icon | uri | ""  | A 9-patch or PNG of the icon to be displayed when the button does not have. |
| focusIcon | uri | ""  | A 9-patch or PNG of the icon to be displayed when the button has focus. |
| buttonIsDisabled | Boolean | false | Controls whether the button is disabled (true) or enabled (false). A disabled button is skipped and does not have focus while the user navigates the different playback action buttons with the directional pad on the Roku remote control. |

playbackActionButtonSelectedinteger0READ\_WRITEThe index of the button that is selected in the **playbackActionButtons** field.playbackActionButtonFocusedinteger0READ\_WRITEThe index of the button that has focus in the **playbackActionButtons** field.playbackActionButtonFocusedTextFontFontSmallBoldSystemFontWRITESpecifies the font of the button label when the button has key focus.playbackActionButtonUnfocusedTextFontFontSmallSystemFontWRITESpecifies the font of the button label when the button does not have key focus.playbackActionButtonFocusedTextColorColorOX121212FFWRITESpecifies the color of the button label text when the button has key focus.playbackActionButtonUnfocusedTextColorColor0xEFEFEFFFWRITESpecifies the color of the button label text when the button does not have key focus.playbackActionButtonFocusIndicatorBlendColorColor\-WRITESpecifies the button background color when the button has key focus.subtitleSelectionPreferences  
  
(_Available since Roku OS 12.5_)roAssociativeArray{ }WRITE\_ONLYThe significance and priority order of the attributes and values for the subtitle tracks available in the video stream.  
  
Provide the attribute fields from highest to lowest significance (for example, if **language** should take precedence over all other attributes, list it first). For the subtitle track languages, provide the language codes from highest to lowest priority (for example, if Spanish for Latin America and the Caribbean \["es-419"\] has precedence over Spanish \["es"\], list the language codes in the following order: \["es-419", "es"\].  
FieldTypeDescriptionvaluesroAssociativeArraySpecify values for the following subtitle track attributes. List the attributes from highest to lowest significance.  

| Field | Type | Description |
| --- | --- | --- |
| language | array of Strings | A list of language (ISO-639)/country (ISO-3166) codes for the subtitles. List the language codes in priority order (highest to lowest). |
| caption | array of Strings | A flag indicating whether captions exist for the video stream. This is equivalent to the HLS "public.accessibility.transcribes-spoken-dialog" characteristic. |
| descriptive | array of Strings | A flag indicating whether descriptives exist for the music and sounds in the video stream. This is equivalent to the HLS "public.accessibility.describes-music-and-sound" characteristic. |
| easyReader | array of Strings | A flag indicating whether subtitles are easy to read. |

overrideSystembooleanSpecify whether to use the app's preferences over the system preferences (true) or use the app's preferences only when the system preferences do not match any of the available tracks (false), which allows the app to provide additional rules in this case. The default value is false.  
  
**Example**  

    video.subtitleSelectionPreferences = { values: [
        { language: ["es-419", "es", "es-*", "fr", "en-US", "en-UK", "en"] },
        { caption: "true" },
        { descriptive: ["false"] },
        { easyReader: "true" } ],
        overrideSystem: true }
    

  
**Explanation**  
  
The subititle language with the highest priority is "es" with a country code of "419". The next highest priority language is "es" with no country code, and then "es" with any country code.audioSelectionPreferences  
  
(_Available since Roku OS 12.5_)roAssociativeArray{ }WRITE\_ONLYThe significance and priority order of the attributes and values for the audio tracks available in the video stream.  
  

> A language matching any country code does not match a track that specifies the same language but with no country code.

  
Provide the attribute fields from highest to lowest significance (for example, if the **language** should take precedence over the **description**, list **language** first. For the audio track languages, provide the language code values from highest to lowest priority (for example, if English for the United States \["en-US"\] has precedence over English for the United Kingdom \["en-UK"\], list the language codes in the following order: \["en-US", "en-UK"\].  
  
FieldTypeDescriptionvaluesroAssociativeArraySpecify values for the following audio track attributes. List the attributes from highest to lowest significance.  

| Field | Type | Description |
| --- | --- | --- |
| language | array of Strings | A list of (ISO-639)/country (ISO-3166) codes for the audio track. List the languages in priority order (highest to lowest). |
| descriptive | array of Strings | A flag indicating whether descriptives exist for the video playing in the stream. This is equivalent to the HLS "public.accessibility.describes-video" characteristic. |

overrideSystembooleanSpecify whether to use the app's preferences over the system preferences (true) or use the app's preferences only when the system preferences do not match any of the available tracks (false), which allows the app to provide additional rules in this case. The default value is false.  
  
**Example**  

    video.audioSelectionPreferences = { values: [
        { language: ["en-US", "en-UK", "en", "en-*"] },
        { descriptive: "false" } ],
        overrideSystem: true }
    

  
**Explanation**  
  
The audio language with the highest priority is "en-US". The next highest priority language is "en-UK", then "en" with no country code, and finally "en" with any country code.

### Trickplay fields

FieldTypeDefaultAccess PermissionDescriptiondurationtime0READ\_ONLYThe duration of the video being played, specified in seconds. This becomes valid when playback begins and may change if the video is dynamic content, such as a live event.loopBooleanfalseREAD\_WRITEIf set to true, the video or video playlist (if the `contentIsPlaylist` field is set to true to enable video playlists) will be restarted from the beginning after the end is reached.positiontimeinvalidREAD\_ONLYTime of the current position in the stream. Either UTC time or elapsed since start of stream depending on content type.  
  
As of Roku OS 9.3, when the video is paused, the position is recorded for that pause event. This means that playing, pausing, and resuming a video generates three separate positions.positionInforoAssociativeArrayinvalidREAD\_ONLYContains the following fields that provide information about the last rendered video and audio samples.  
  

| Field | Type | Default | Access Permission | Description |
| --- | --- | --- | --- | --- |
| audio | double | invalid | READ\_ONLY | Position of the last rendered audio sample, specified in seconds |
| clip\_id | integer | invalid | READ\_ONLY | The unique ID of the clip |
| epoch | integer | invalid | READ\_ONLY | 0 means positions are relative to videoStart; 1 means that positions are utc |
| video | double | invalid | READ\_ONLY | Position of the last rendered video sample, specified in seconds |

clipIdinteger0READ\_ONLYThe clip ID of the currently playing track.notificationIntervaltime0.5READ\_WRITEThe interval between notifications to observers of the position field, specified as the number of seconds. If the value is 0, no notifications are delivered. This value may be read or modified at any time.seektimeinvalidWRITE\_ONLYSets the current position in the video. The value is the number seconds from the beginning of the stream, specified as a double.seekModestring"default"READ\_WRITEDetermines the desired level of accuracy for seek behavior:  

| Value | Meaning |
| --- | --- |
| default | Seek to the closest sync frame (segment, or I-frame of a multi-frame segment) that is earlier than the requested seek time. |
| accurate | Seek to the exact time requested if platform support (video decoder step function) is available. |

  
autoplayAfterSeekbooleantrueREAD\_WRITEEnables video content to automatically play after rebuffering. Setting this flag to false disables this default behavior.timedMetaDataassociative array{ }READ\_ONLYThe most recent timed meta data that has been decoded from the video stream. Only meta data with a key that matches an entry in timedMetaDataSelectionKeys will be set into this field. The value of this field is an associative array which contains arbitrary keys and values, as found in the video stream.timedMetaData2associative array{ }READ\_ONLYThis field contains all the same information included in the **timedMetaData** field and the following additional fields:  

| Key | Type | Value |
| --- | --- | --- |
| data | associative array | The values from the stream's metadata tag, as defined by video provider. |
| position | time | The Presentation Time Stamp (PTS) when the tag was seen. |
| source | enum | This may be one of the following string values: ${source-enum-list} |

timedMetaDataSelectionKeysarray of strings\[ \]READ\_WRITEIf the video stream contains timed meta data such as ID3 tags, any meta data with a key matching an entry in this array is set into the timedMetaData field.  
  
For EMSG data, if any entry in this array is "\*", then all timed meta data is selected.  
  
HLS tags must be defined separately.streamInfoassociative arrayinvalidREAD\_ONLYInformation about the video stream that is currently playing or buffering.  
  

| Key | Type | Value |
| --- | --- | --- |
| isUnderrun | Boolean | If true, the stream was downloaded due to an underrun |
| isResume | Boolean | If true, playback was resumed after trickplay |
| measuredBItrate | Integer | The measured bitrate (bps) of the network when the stream was selected |
| streamBitrate | Integer | The bitrate of the stream |
| streamUrl | URI | The URL of the stream |

completedStreamInfoassociative arrayinvalidREAD\_ONLYInformation about the video stream that most recently completed playing, due to an error, user action, or end of the stream. The associative array consists of the same keys as for the `streaminfo` field, with one additional key, `isFullResult`, a Boolean type that, if true indicates the `stream` played to completion, or if false, was interrupted by an error or user action. This field is set prior to the `state` field being changed, so `state` field observer callback functions can assume that the associative array values are valid when the state field changes.timeToStartStreamingtime0READ\_ONLYThe time in seconds from playback being started until the video actually began playing. The minimum valid value is 1 millisecond, and this is only valid if the current value of the `state` field is `playing`. When the state field value is not `playing`, the value will be 0. This field is updated prior to the `state` field changing, so `state` field observer callback functions can assume this field is valid after the `state` field value changes to `playing`.bufferingStatusassociative arrayinvalidREAD\_ONLYContains information about stream buffering progress and status. This field is valid only while buffering is in progress, both at stream startup or when re-buffering is required. Observers will be notified when any element of the array changes, and also when buffering is complete and the field itself becomes invalid. The array contains the following name - value pairs.  
  

| Value | Meaning |
| --- | --- |
| percentage | Percent buffering complete as an integer. |
| isUnderrun | Boolean value indicating if a stream underrun occurred. |
| prebufferDone | A boolean value that indicates whether the player has buffered enough data to allow the player to begin playing immediately should "control" be set to "play." |
| actualStart | A time value that is automatically set when prebufferDone becomes true, specifying the actual time from which playback will resume. This may vary from the time requested in the content node's playStart field, depending on the capabilities of the player and the seekMode setting. |

  

> While it is possible to use the Video node seek field to specify the seek time, it is recommended that apps do the following:
> 
> 1.  Set the content node field playStart in seek-to-pause scenarios.
> 2.  In the video node, set "control" to "prebuffer".
> 3.  Wait for "prebufferDone" to become "true".
> 4.  Check "actualStart" (if desired).
> 5.  Set "control" to "play".

videoFormatstringREAD\_ONLYContains the format of the currently playing video stream.  
  

| Value | Meaning |
| --- | --- |
| ""  | No stream playing |
| none | Stream contains no playable video |
| unknown | Stream contains unknown video |
| hevc | ISO/IEC 23008-2, H.265, HEVC |
| hevc\_b | ISO/IEC 23008-2 Annex-B, H.265, HEVC |
| mpeg1 | ISO/IEC 11172-2, MPEG-1 part 2, H.261 |
| mpeg2 | ISO/IEC 13818-2, MPEG-2 part 2, H.262 |
| mpeg4\_2 | ISO/IEC 14496-2, MPEG-4 part 2, H.263 |
| mpeg4\_10b | ISO/IEC 14496-10, MPEG-4 part 10 Annex-B, H.264, vc-1 |
| mpeg4\_15 | ISO/IEC 14496-15, MPEG-4 part 15, H.264, vc-1 |
| AVC vc1 | vc-1 |
| wmv | Microsoft Windows Media Video |
| vp8 | VP8 codec |
| vp9 | VP9 codec |

pauseBufferStarttime0READ\_ONLYThe beginning position of the video buffered when paused. This field is only valid for live video.pauseBufferEndtime0READ\_ONLYThe ending position of the video buffered when paused. This field is only valid for live video.pauseBufferPositiontime0READ\_ONLYThe current presentation position of the video buffered when paused. This field is only valid for live video.pauseBufferOverflowBooleanfalseREAD\_ONLYIndicates that the video buffer was not able to save all video since being paused. This field is only valid for live video.streamingSegmentassociative array{ }READ\_ONLYInformation about the video segment that is currently streaming. This is only meaningful for segmented video transports, such as DASH and HLS. The associative array has the following entries:  
  

| Key | Type | Value |
| --- | --- | --- |
| segBitrateBps | integer | Bitrate of the segment in bits per second |
| segSequence | integer | The sequence number of the segment in the video |
| segStart | time | The start time of the segment from the start of the video, specified in seconds |
| segUrl | string | URL of the segment |
| SegType | integer | Type of data in the segment: 1=audio, 2=video, 3=captions, 0=mux |
| Path | string | A path indicating the Period, AdaptationSet and Representation that is played. This is in UNIX directory notation as: /// |
| Width | integer | For video segments, the width of the encoded video picture |
| Height | integer | For video segments, the height of the encoded video picture |

downloadedSegmentassociative arrayinvalidREAD\_ONLYInformation about the video segment that was just downloaded. This is only meaningful for segmented video transports, such as DASH and HLS. The associative array has the following entries:  
  

| Key | Type | Value |
| --- | --- | --- |
| Status | integer | Status of the download: 0 = success, nonzero = error |
| SegSequence | integer | Stream segment sequence number |
| SegUrl | string | Stream segment URL (i.e., .ts file for HLS, stream fragment URL for smooth) |
| DownloadDuration | integer | Amount of time spent downloading the segment, in milliseconds |
| SegSize | integer | Segment size, in bytes |
| SegType | integer | Type of data in the segment: 1=audio, 2=video, 3=captions, 0=mux |
| BitrateBPS | integer | Bitrate of the segment, in bits per second |
| SegStart | time | The start time of the segment from the start of the video, specified in seconds |
| SegDuration | string | The duration of the segment in milliseconds. |
| Path | string | A path indicating the Period, AdaptationSet and Representation that is played. This is in UNIX directory notation as: /// |
| Width | integer | For video segments, the width of the encoded video picture |
| Height | integer | For video segments, the height of the encoded video picture |
| HdrMode | Indicates the HDR format of the content, which may be one of the following values:<br><br>*   0: UNKNOWN<br>*   1: NONE (SDR)<br>*   2: HDR10<br>*   3: DOLBY\_VISION<br>*   4: HLG10<br>*   5: HDR10\_PLUS<br>*   6: SL\_HDR2 |     |
| Latency | The time, in milliseconds, between the current live edge (or most recent available media segment on the CDN) and the segment currently being played. |     |

enableLiveAvailabilityWindowBooleanFalseREAD\_WRITEEnables the scrubbing of the trickplay bar during the availability window of live linear streams.enableThumbnailTilesDuringLiveBooleanFalseREAD\_WRITEEnables the **thumbnailTiles** field to be set and updated in the case of live HLS and DASH streams, which contain thumbnails as the thumbnails become available.  
  
By default and when this is set to false, the **thumbnailTiles** field is not written during live streams to maintain backwards compatibility with older applications and to avoid performance or memory issues. This is becuase they might not be expecting constant updates to the **thumbnailTiles** field if they were written to handle VOD streams, which rarely update the **thumbnailTiles** field.thumbnailTilesroAssociativeArray\[\]READ\_WRITEContains the information about HLS and DASH standard thumbnail tiles as they are discovered within the manifest for streams which contain them.  
  
This field was first introduced (for VOD only) starting in Roku OS 9.1. Starting with Roku OS 11.0, the app can enable this field for HLS and DASH live streams containing standard thumbnails by setting enableThumbnailTilesDuringLive to true.  
  

> For Roku OS releases before 9.4, the **thumbnailTiles** associative array has the following structure: {tile\_id: tile\_set} (string to associative array)
> 
> For Roku OS 9.4 and later, the **thumbnailTiles** associative array has the following structure: {tile\_id: \[tile\_set, tile\_set, tile\_set,...\]}(string to array of associative arrays). This format allows discontinuous tile\_sets of the same resolution to be grouped together as a "choice" for display.

  
  
The **tile\_id** field is a unique string identifier for the **tile\_set**, which is an associative array containing the attributes of the tile set as well as information about the thumbnails.  
  
The **tile\_set** field contains the following fields:  
  

| Field | Type | Default | Description |
| --- | --- | --- | --- |
| htiles | integer | 0   | Horizontal number of thumbnails in a tile (columns.) |
| vtiles | integer | 0   | Vertical number of thumbnails in a tile (rows.) |
| width | integer | 0   | Number of horizontal pixels in a thumbnail (this is not the tile as the one in the DASH spec). |
| height | integer | 0   | Number of vertical pixels in a thumbnail (this is not the same tile as the one in the DASH spec). |
| bandwidth | integer | 0   | Max tile size in bits / duration. |
| duration | float | 0.0 | Duration of one tile in seconds (assuming a full tile). |
| initial\_time | float | 0.0 | Presentation start time of current **tile\_set** in seconds. Thumbnails in tiles beginning before this time should be skipped, and the first relevant thumbnail duration should be updated accordingly. |
| final\_time | float | 0.0 | End time of current tile\_set in seconds. |
| tiles | roArray | \[\] | Contains information about each tile in the **tile\_set**. This contains the following fields:  <br><br>*   url (index 0). A string with the URL of the tile.<br>*   start\_time (index 1). A float with the start time of the tile in seconds.<br/<br>*   format (index 2). Typically, an empty string, but it may contain the tile format "jpeg", "png", and so on. |

trickPlayBackgroundOverlayuri""WRITEThe background overlay to be displayed whenever the playback UI is visible during the video playback experience.

### UI fields

FieldTypeDefaultAccess PermissionDescriptionwidthfloat0.0READ\_WRITESets the width of the video play window in pixels. If set to 0.0 (the default), the video play window is set to the width of the entire display screen.heightfloat0.0READ\_WRITESets the height of the video play window in pixels. If set to 0.0 (the default), the video play window is set to the height of the entire display screen.enableUIBooleantrueREAD\_WRITEIf set to true (the default), the entire Video node user interface (such as ProgressBar and TrickPlayBar nodes, and BIF navigation) appear in response to stream events and remote control key presses.  
  
If set to false, most of the Video node user interface will not be shown, and the application is expected to implement the UI. The one exception is the closed-caption dialog, which always appears when the video is playing fullscreen (either full height or full width) and the user presses the Options (\*) button.  
  
When using the [Roku Advertising Framework (RAF)](/docs/developer-program/advertising/roku-advertising-framework.md), the RAF library may temporarily set this field to false while playing ads.enableTrickPlayBooleantrueREAD\_WRITE**Controls whether trickplay is allowed during playback. When set to false the user trickplay buttons on the remote will have no effect. This only applies when enableUI is set to true.**bifDisplayBifDisplay nodeinternal instance defaultREAD\_WRITEComponent that displays BIFs and allows navigation. The fields of this internal node are as follows:  
  

| Field | Type | Default | Use |
| --- | --- | --- | --- |
| frameBgBlendColor | color | 0xFFFFFFFF | A color to be blended with the image displayed behind individual BIF images displayed on the screen. The blending is performed by multiplying this value with each pixel in the image. If not changed from the default value, no blending will take place. |
| frameBgImageUri | uri | ""  | The URI of an image to be displayed behind individual frames on the screen. The actual frame image is displayed opaquely on top of this background, so only the outer edges of this image are visible. Because of that, this background image typically appears as a border around the video frame. If the frameBgBlendColor field is set to a value other than the default, that color will be blended with the background image. |
| getNearestFrame | time | invalid | **Write-Only**  <br>Requests the nearest BIF to the time specified. This would normally be an offset from the current playback position. The getNearestFrame request is passed to the BifCache which uses the getNearestFrame() method implemented on all BIF storage classes. Existing BifCache functionality is then used to retrieve the bitmap data and load it into the texture manager. |
| nearestFrame | string | ""  | **Read-Only**  <br>Contains the URI of the requested BIF. The returned URIs will be of the form 'memory://BIF_%d_%d'. These URIs can then be used directly in the 'uri' field of a Poster SGN (or similar). |

trickPlayBarTrickPlayBar nodeinternal instance defaultREAD\_WRITEThe visible TrickPlayBar node. The fields of this internal node are as follows:  
  

| Field | Type | Default | Use |
| --- | --- | --- | --- |
| currentTimeMarkerBlendColor | color | 0xFFFFFFFF | This is blended with the marker for the current playback position. This is typically a small vertical bar displayed in the TrickPlayBar node when the user is fast-forwarding or rewinding through the video. |
| textColor | color | system default | Sets the color of the text next to the trickPlayBar node indicating the time elapsed/remaining. |
| thumbBlendColor | color | 0xFFFFFFFF | Sets the blend color of the square image in the trickPlayBar node that shows the current position, with the current direction arrows or pause icon on top. The blending is performed by multiplying this value with each pixel in the image. If not changed from the default value, no blending will take place. |
| filledBarBlendColor | color | 0xFFFFFFFF | This color will be blended with the graphical image specified in the `filledBarImageUri` field. The blending is performed by multiplying this value with each pixel in the image. If not changed from the default value, no blending will take place. |
| liveFilledBarBlendColor | Color | 0xFFFFFFFF | The color of the trickplay progress bar to be blended with the **filledBarImageUri** for live linear streams. |
| filledBarImageUri | uri | ""  | A 9-patch or ordinary PNG of the bar that represents the completed portion of the work represented by this ProgressBar node. This is typically displayed on the left side of the track. This will be blended with the color specified by the `filledBarBlendColor` field, if set to a non-default value. |
| trackBlendColor | color | 0xFFFFFFFF | This color is blended with the graphical image specified by `trackImageUri` field. The blending is performed by multiplying this value with each pixel in the image. If not changed from the default value, no blending will take place. |
| trackImageUri | uri | ""  | A 9-patch or ordinary PNG of the track of the progress bar, which surrounds the filled and empty bars. This will be blended with the color specified by the `trackBlendColor` field, if set to a non-default value. |

bufferingBarProgressBar nodeinternal instance defaultREAD\_WRITEComponent that shows the progress of re-buffering, after video playback has started. The fields of this internal node are as follows:  
  

| Field | Type | Default | Use |
| --- | --- | --- | --- |
| width | float | system default | Sets a custom width for an instance of the ProgressBar node |
| height | float | system default | Sets a custom height for an instance of the ProgressBar node |
| emptyBarBlendColor | color | 0xFFFFFFFF | A color to be blended with the graphical image specified in the `emptyBarImageUri` field. The blending is performed by multiplying this value with each pixel in the image. If not changed from the default value, no blending will take place. |
| emptyBarImageUri | uri | ""  | A 9-patch or ordinary PNG of the bar presenting the remaining work to be done. This is typically displayed on the right side of the track, and is blended with the color specified in the `emptyBarBlendColor` field, if set to a non-default value. |
| filledBarBlendColor | color | 0xFFFFFFFF | This color will be blended with the graphical image specified in the `filledBarImageUri` field. The blending is performed by multiplying this value with each pixel in the image. If not changed from the default value, no blending will take place. |
| filledBarImageUri | uri | ""  | A 9-patch or ordinary PNG of the bar that represents the completed portion of the work represented by this ProgressBar node. This is typically displayed on the left side of the track. This will be blended with the color specified by the `filledBarBlendColor` field, if set to a non-default value. |
| trackBlendColor | color | 0xFFFFFFFF | This color is blended with the graphical image specified by `trackImageUri` field. The blending is performed by multiplying this value with each pixel in the image. If not changed from the default value, no blending will take place. |
| trackImageUri | uri | ""  | A 9-patch or ordinary PNG of the track of the progress bar, which surrounds the filled and empty bars. This will be blended with the color specified by the `trackBlendColor` field, if set to a non-default value. |
| percentage | integer | top | The percentage of the work that is done. Setting this field controls the visual appearance of the ProgressBar node. |

bufferingTextColorcolorsystem defaultREAD\_WRITEThe color of the text displayed near the buffering bar defined by the `bufferingBar` field, when the buffering bar is visible. If this is 0, the system default color is used. To set a custom color, set this field to a value other than 0x0.retrievingBarProgressBar nodeinternal instance defaultREAD\_WRITEComponent that shows the progress of initial retrieving of the video, prior to starting playback. The fields of this internal node are the same as for the `bufferingBar` field, which are the fields of the internal ProgressBar node.retrievingTextColorcolorsystem defaultREAD\_WRITEThe color of the text displayed near the retrieving bar, when the retrieving bar defined in the `retrievingBar` field is visible. If this is 0, the system default color is used. To set a custom color, set this field to a value other than 0x0.pivotNoderenderable node\-READ\_WRITEThe visible pivot node. This is a generic renderable node that can be used to display any component. This node is only displayed when video is paused.

### Closed caption fields

FieldTypeDefaultAccess PermissionDescriptionglobalCaptionModeoption stringOffREAD\_WRITESets the value of the global Roku closed-caption mode. This can be used to allow the user or the application to change the closed-caption mode in an application just before or during video playback. The possible options are:  
  

| Option | Effect |
| --- | --- |
| "Off" | Turns the global Roku closed-caption mode off. |
| "On" | Turns the global Roku closed-caption mode on. |
| "Instant replay" | Sets the global Roku closed-caption setting to display captions only during instant replay. |
| "When mute" | Sets the global Roku closed-caption setting to display captions only when the volume is muted. (This only applies to Roku TVs.) |

  
  
The app should set the `subtitleTrack` field regardless of the selected Caption Mode.suppressCaptionsbooleanfalseREAD\_WRITESuppresses the closed caption for the purpose of resolving conflicts in cases where UI elements are drawn.  
  
Note that most of the disabling/enabling of the captions are done by the Roku OS, including enabling closed caption for Instant Replay.subtitleTrackstringREAD\_WRITEThe identifier of the selected subtitle track. Subtitles may or may not be visible on the screen, depending upon the user's caption mode setting.  
  
Reading this field will return the identifier of the subtitle track selected by the user. Writing this the field will change the track.  
  
See also: [globalCaptionMode](#closed-caption-fields)currentSubtitleTrackstringREAD\_ONLYThe identifier of the selected subtitle track. Subtitles may or may not be visible on the screen, depending upon the user's caption mode setting.  
  
Reading this field will return the identifier of the subtitle track that is playing. When the user has not selected a track, the Roku media player will select a track based on the preferred caption language system setting.availableSubtitleTracksarray of associative arrays\[ \] empty arrayREAD\_ONLYThe list of subtitle tracks available in the video stream. The array is initially populated with the tracks specified in the Content Meta-Data, and additional tracks are added if they are detected by the digital video player. Each associative array has the following entries:  
  

| Key | Type | Value |
| --- | --- | --- |
| Description | string | Descriptive name of the subtitle track |
| Language | string | ISO 639-2 three-letter language code |
| TrackName | string | The track identifier. The value of this field may be used to select the subtitle track. |
| HasAccessibilityDescription  <br>  <br>_Available since Roku OS 13.0_ | boolean | HLS: represents "public.accessibility.describes-music-and-sound." |
| HasAccessibilityCaption  <br>  <br>_Available since Roku OS 13.0_ | boolean | HLS: represents "public.accessibility.transcribes-spoken-dialog."  <br>  <br>DASH: Subtitle track contains captions |
| HasAccessibilitySign  <br>  <br>_Available since Roku OS 13.0_ | boolean | DASH: Subtitle track contains a sign-language interpretation of an audio component info. |

captionStyleassociative arraysystem defaultREAD\_WRITEAllows apps to style closed captions. For any keys that are absent from the associative array, or for unexpected values, the Default value is assumed for that property. Following are the possible key names and values for this field:  
  

| Property | Possible Values |
| --- | --- |
| Text/Font | Default  <br>Serif Fixed Width  <br>Serif Proportional  <br>Sans Serif Fixed Width  <br>Sans Serif Proportional  <br>Casual  <br>Cursive  <br>Small Caps |
| Text/Effect | Default  <br>None  <br>Raised  <br>Depressed  <br>Uniform  <br>Drop shadow (left)  <br>Drop shadow (right) |
| Text/Size | Default  <br>Large  <br>Medium  <br>Small |
| Text/Color | Default  <br>White  <br>Black  <br>Red  <br>Green  <br>Blue  <br>Yellow  <br>Magenta  <br>Cyan |
| Text/Opacity | Default  <br>25%  <br>50%  <br>75%  <br>100% |
| Background/Color | Default  <br>White  <br>Black  <br>Red  <br>Green  <br>Blue  <br>Yellow  <br>Magenta  <br>Cyan |
| Background/Opacity | Default  <br>Off  <br>25%  <br>50%  <br>75%  <br>100% |
| Window/Color | Default  <br>White  <br>Black  <br>Red  <br>Green  <br>Blue  <br>Yellow  <br>Magenta  <br>Cyan |
| Window/Opacity | Default  <br>Off  <br>25%  <br>50%  <br>75%  <br>100% |

### Audio fields

FieldTypeDefaultAccess PermissionDescriptionmuteBooleanfalseREAD\_WRITESet to true to mute the audio of the video currently playing in the Video node. Set to false to restore audio.audioTrackstringREAD\_WRITEThe track identifier of the selected audio track.  
  
Reading this field will return the track identifier of the audio selected by the user.  
  
Writing this value will change the audio track. However, apps should not do this unless they are implementing their own track selection menu that users control. This is because the Roku OS selects the best track automatically based on preferred language setting on the device. See [Automatic audio track selection](#automatic-audio-track-selection) for more information.currentAudioTrackStringREAD\_ONLYThe track identifier of the audio being played. Reading this field will return the track that is being played, which may be different than the track being selected (for example, when the Roku media player cannot play a certain format).  
  
When the user has not selected an audio track, the platform will select a track based on the preferred audio language setting.availableAudioTracksarray of associative arrays\[ \] empty arrayREAD\_ONLYEach associative array has the following entries:  
  

| Key | Type | Value |
| --- | --- | --- |
| Language | string | ISO 639-2 three-letter language code |
| Name | string | Descriptive name of the audio track |
| Track | string | The track identifier. The value of this field may be used to select the audio track. |
| HasAccessibilityDescription  <br>  <br>_Available since Roku OS 13.0_ | boolean | HLS: represents "public.accessibility.describes-video."  <br>  <br>DASH: Audio track contains a textual description (intended for audio synthesis) or an audio description describing a visual component. |
| HasAccessibilityEAI  <br>  <br>_Available since Roku OS 13.0_ | boolean | DASH: Audio track contains an element for improved intelligibility of the dialogue \[Enhanced Audio Intelligibility\]. |

  
  
The field also retrieves audio description tracks which are typically seen on broadcast TV. An audio description track is mixed with the main audio track.seamlessAudioTrackSelection  
  
_Available since Roku OS 13.0_BooleanfalseREAD\_WRITEEnables apps to continuously play video when the audio track is switched. This feature currently supports HLS only.  
  

*   **true**: Continues video playback when the audio track changes (provided that HLS is being used and the audio format of the new audio track is the same as the original one). In this case, a brief period of no audio may occur while the audio tracks are switched.
*   **false**: Pauses video playback for approximately 1 second when the audio track changes (default behavior). In this case, a black screen and/or buffering appears while the audio tracks are switched.

  
  
To enable this feature, you must set this field before sending any command to the Video node. This field may not be changed during video playback.audioFormatstringREAD\_ONLYIn all other cases they shouldn't .Contains the format of the currently playing audio.  
  

| Value | Meaning |
| --- | --- |
| ""  | No stream playing |
| none | Stream contains no playable audio |
| unknown | Stream contains unknown audio |
| aac | ISO/IEC 14496-3, Advanced Audio Coding |
| aac\_adif | ISO/IEC 14496-3, Advanced Audio Coding, ADIF container |
| aac\_adts | ISO/IEC 14496-3, Advanced Audio Coding, ADTS container |
| aac\_latm | ISO/IEC 14496-3, Advanced Audio Coding, LATM container |
| ac3 | Dolby Digital |
| ac4 | Dolby Audio - AC-4 |
| alac | Apple Lossless |
| dts | DTS Coherent Acoustics |
| eac3 | Dolby Digital Plus |
| flac | Free Lossless Audio Codec |
| flac | Free Lossless Audio Codec |
| mat | Dolby Audio - TrueHD |
| mp3 | ISO/IEC 11172-3, MPEG Audio Layer III |
| pcm | linear PCM |
| vorbis | Ogg Vorbis |
| wma | Microsoft Windows Media Audio (sunset as of Roku OS 12.5) |
| wmapro | Microsoft Windows Media Pro Audio (sunset as of Roku OS 12.5) |

supplementaryAudioVolumeint50READ\_WRITESets the volume of the description tracks separately from the main audio track. The field value can range from 0 to 100.

#### Automatic audio track selection

If multiple audio tracks are available for video content, the Roku OS automatically selects the best track based on the preferred audio track settings on the device (language, country code, and descriptive setting) and the quality of the audio track (bitrate/format).

The user can manually set their preferred language in the **Settings > Audio > Audio preferred language** menu, and the country code and descriptive setting are automatically set when the user selects an audio track. The preferred language setting is also automatically updated when the user selects an audio track (the preferred language is set to the language of the selected track).

For example, if the user chooses Portuguese as their preferred language, the Roku OS will by default select the Portuguese audio track the next time they watch content (if available). If the selected audio track is in Portuguese (Brazil), the user's preferred country is set to Brazil, and the Portuguese (Brazil) audio track is selected by default the next time the user watches content.

> It is recommend that apps use the audio track selection logic provided by the Roku OS instead of implementing their own.

Overall, the Roku OS uses the following criteria (listed in order of priority) to determine which audio track to play:

1.  Preferred audio track settings:
    
    a. The track explicitly selected by the user.
    
    b. The track with the user's preferred language, country code and descriptive setting.
    
    c. The track with the preferred language and the country code.
    
    d. The track with the preferred language that is marked as the default audio track.
    
    e. The track with the preferred language.
    
    f. The first track.
    
2.  Highest quality audio track (based on bitrate/format)
    

> Any language not included in the provided list of common languages is added to the list as the last entry. The common languages list may only have a single unlisted language. For example, if the user selects Korean as the audio track for a movie, the last entry in the common languages list is Korean, which is used as the preferred language from thereon. If the user then selects a Chinese audio track, Chinese overwrites Korean as the last entry in the common language list and is used as the preferred language.

### CDN fields

Developers can receive event-based notifications when the CDN is switched during content playback.

AttributeTypeValuesDescriptioncdnSwitchroArray of roAssociativeArrays

| Key | Required/ Optional | Type | Description |
| --- | --- | --- | --- |
| URLFilter | Required | String | A substring that identifies the (base)URL to which these CDN settings apply.  <br>  <br>The Roku media player matches this string against all (base)URLs listed in the manifest and applies the setting to all (base)URLs that contain this substring. |
| ContentFilter | Optional | String | For DASH streams, a substring that filters the period or asset ID to which these CDN settings apply.  <br>  <br>The Roku player only applies these CDN setting to periods with a period ID or asset ID that contains this substring.  <br>  <br>This match is used in addition to the URL filter. |
| Priority | Required | Integer | For configuring failovers, sets the priority for this (base)URL from 1 to x (a priority of 0 or less is invalid).  <br>  <br>A lower value indicates a higher priority. For example, a (base)URL with a priority of 1 is higher than another with a priority of 10.  <br>  <br>If the highest priority server fails, traffic is routed to the server with the next highest priority. If all servers are configured with the same priority, and one fails, no failover will happen. |
| Weight | Required | Integer | For configuring load balancing, sets the relative weight for all (base)URLs with the same priority. This must be a value of 1 or greater (a weight of 0 disables a CDN).  <br>  <br>The weight of a given BaseURL is its weight value divided by the sum of all weight values. This means that to spread the load equally across multiple CDNs with the same priority, set the weight for each to the same value. To configure the weights for two servers to 80% and a third server to 20%, for example, set servers one and two to 8 and server three to 4. |
| ServiceLocation | Optional | String | A blacklist of failed BaseURL locations. |

Indicates that a CDN switching event has occurred.  
  
Apps can monitor this field in the background. When the Video player detects a CDN change, it automatically updates this field.

### Miscellaneous fields

FieldTypeDefaultAccess PermissionDescriptionMaxVideoDecodeResolutionvector2d (width, height)\[0,0\]READ\_WRITESets the max resolution required by your video.  
  
Video decode memory is a shared resource with OpenGL texture memory. The Brightscript 2D APIs are implemented using OpenGL texture memory on Roku models that support the Open GL APIs (see [Hardware specifications](/docs/specs/hardware.md) for a list of these models).  
  
On models that do not support Open GL APIs, this field exists for API compatibility but has no effect on actual memory allocations.  
  
Video decode memory allocation is based on a resolution of 1920x1080 or 1280x720 as the maximum supported resolution for a particular Roku model (see [Hardware specifications](/docs/specs/hardware.md) for a list of these models).  
  
This field enables applications that want to use both the 2D APIs and video playback with a lower resolution than 1080p. Without this field, these applications are likely to not have enough memory for either video playback or UI rendering.  
  
If width is 0 (the default), it is unlimited. If height is 0 (the default), it is unlimited.cgmsinteger0READ\_WRITESets the CGMS (Copy Guard Management System) on analog outputs to the desired level. The valid values are:  
  

| Value | Effect |
| --- | --- |
| 0   | No copy restriction |
| 1   | Copy no more |
| 2   | Copy once allowed |
| 3   | No copying permitted |

enableScreenSaverWhilePlayingBooleanfalseREAD\_WRITESet this to true to allow the screensaver to activate even if video is playing, as long as that video does not cover 50% or more of the screen. Set to false to block the screensaver activating if any video is playing. Note that this field has no effect when the video node plays audio only streams. For screensaver control with audio only streams, use the disableScreenSaver field.disableScreenSaverBooleanfalseREAD\_WRITESet this to true to suppress the screensaver. This is typically used to suppress the screensaver when playing audio-only streams.contentBlockedBooleanfalseREAD\_ONLY_Available since Roku OS 8._  
  
Determines whether the current content is blocked.

Data bindings
-------------

See [Content Meta-Data](/docs/developer-program/getting-started/architecture/content-metadata.md) for the required and optional play parameters, and descriptive information for video playback. Set these parameters in a [ContentNode](/docs/references/scenegraph/control-nodes/contentnode.md) node, and assign the ContentNode to the content field of the Video node to apply the parameters to a particular video content item.

For HTTPS access, note the following Content Meta-Data attributes:

*   `HttpCertificatesFile`
*   `HttpCookies`
*   `HttpHeaders`
*   `HttpSendClientCertificates`

These attributes must be set to handle secure HTTP transfers of video files. Note that this is a different HTTPS mechanism than used for other SceneGraph nodes as described in [roHttpAgent](/docs/references/brightscript/components/rohttpagent.md).

> Prior to Roku OS 7.2, each Audio and Video node created and configured an `HttpAgent` only when the first content was played in a given Audio or Video node instance. This sometimes meant that additional content would fail to play in the same node because headers, cookies, and certificates were not updated or correctly replaced from the new content record. Apps that are dependent upon this behavior will need to be updated to set the required data into the Content Meta-Data for each piece of content, or to programmatically set those values into the `HttpAgent` before playing each piece of content.

Example
-------

To play video in an application, you first need to create a Video node, either in BrightScript using the roSGNode [ifSGNodeChildren](/docs/references/brightscript/interfaces/ifsgnodechildren.md) interface, or in XML markup. For example, in XML markup:

    <Video
      id="musicvideos"
      width="1280"
      height="720"
      translation="[0,0]"
    />
    

The Video node is then scripted to specify the URL of the video stream, streaming format, video title, and any other [Content Meta-Data](/docs/developer-program/getting-started/architecture/content-metadata.md) attributes needed for the particular playback. Once the video properties are specified, the video can be played by setting the Video node `control` field value to `play`.

    <script type="text/brightscript" >
    <![CDATA[
    
    sub init()
      m.top.setFocus(true)
      setVideo()
    end sub
    
    function setVideo() as void
      videoContent = createObject("RoSGNode", "ContentNode")
      videoContent.url = "https://roku.s.cpl.delvenetworks.com/media/59021fabe3b645968e382ac726cd6c7b/60b4a471ffb74809beb2f7d5a15b3193/roku_ep_111_segment_1_final-cc_mix_033015-a7ec8a288c4bcec001c118181c668de321108861.m3u8"
      videoContent.title = "Test Video"
      videoContent.streamformat = "hls"
    
      m.video = m.top.findNode("musicvideos")
      m.video.content = videoContent
      m.video.control = "play"
    end function
    
    ]]>
    </script>
    

#{source-enum-list}

*   "emsg"
*   "id3"
*   "hls"
*   "unk"

Sample app
----------

[VideoExample](https://github.com/rokudev/samples/tree/master/media/VideoExample) is a sample app demonstrating Video in action.

ifByteArray
===========

Implemented by
--------------

| Name | Description |
| --- | --- |
| [roByteArray](/docs/references/brightscript/components/robytearray.md "roByteArray") | The byte array component is used to contain and manipulate an arbitrary array of bytes |

Supported methods
-----------------

### WriteFile(path as String) As Boolean

#### Description

Writes the bytes contained in the Byte Array to the specified file.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| path | String | The path to the file to which the bytes are to be written. |

#### Return Value

A flag indicating whether the bytes were successfully written to the file.

### WriteFile(path as String, start\_index as Integer, length as Integer) As Boolean

#### Description

Writes a subset of the bytes contained in the Byte Array to the specified file.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| path | String | The path to the file to which the bytes are to be written. |
| start\_index | Integer | The index of the calling ByteArray from which to start writing bytes. |
| length | Integer | The length of the bytes to be written to the file, starting from the specified index. |

#### Return Value

A flag indicating whether the bytes were successfully written to the file.

### ReadFile(path as String) As Boolean

#### Description

Reads the specified file into the Byte Array. Any data currently in the Byte Array is discarded.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| path | String | The path to the file to be read. |

#### Return Value

A flag indicating whether the bytes were successfully read into the Byte Array.

### ReadFile(path as String, start\_pos as Integer, length as Integer) As Boolean

#### Description

Reads the specified file into the Byte Array. Any data currently in the Byte Array is discarded.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| path | String | The path to the file to be read. |
| start\_pos | Integer | The index of the file from which to start reading bytes. |
| length | Integer | The length of the bytes to be read from the file, starting from the specified starting position. |

#### Return Value

A flag indicating whether the bytes were successfully read into the Byte Array.

Slice(\[start\_pos as Integer\[, end\_pos as Integer\]\]) As Object
-------------------------------------------------------------------

#### Description

Returns a new array object with a shallow copy of the specified portion of the array.

The **start\_pos** and **end\_pos** fields specify the 0-based indices of items in the array, where the **end\_pos** field represents the position **past** the last element to be copied.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| start\_pos | Integer | The 0-based index of first element to copy. A negative index specifies an offset from the end of the array. The default value is 0. |
| end\_pos | Integer | The 0-based index past last element to copy. A negative index indicates an offset from the end of the array. The default value is the array length. |

#### Example

    '          0   1   2   3   4   5
    byteArr = [99, 26, 26, 36, 42]
    
    ' get the 3rd (index 2) and subsequent elements
    byteArr2 = byteArr.Slice(2)
    ? FormatJSON(byteArr2)
    ' => [26,36,42]
    
    ' get the 2nd (index 1) through 3rd (index 2) elements
    byteArr2 = byteArr.Slice(1, 3)
    ? FormatJSON(byteArr2)
    ' => [26,26]
    
    ' get the last 2 elements
    byteArr2 = byteArr.Slice(-2)
    ? FormatJSON(byteArr2)
    ' => [36,42]
    
    ' empty range
    byteArr2 = byteArr.Slice(1, 1)
    ? FormatJSON(byteArr2)
    ' => []
    

### AppendFile(path as String) As Boolean

#### Description

Appends the contents of the Byte Array to the specified file.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| path | String | The path to the file to be appended to the ByteArray. |

#### Return Value

A flag indicating whether the file was successfully appended to the calling ByteArray.

### AppendFile(path as String, start\_pos as Integer, length as Integer) As Boolean

#### Description

Appends the contents of the Byte Array to the specified file.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| path | String | The path to the file to be appended to the Byte Array. |
| start\_pos | Integer | The position in the file from which to start appending bytes. |
| length | Integer | The length of the bytes to be appended to the Byte Array, starting from the specified starting position. |

#### Return Value

A flag indicating whether the file was successfully appended to the calling ByteArray.

### SetResize(min\_size as Integer, auto\_resize as Boolean) As Void

#### Description

If the size of the Byte Array is less than min\_size, expands the Byte Array to min\_size. Also sets the auto-resize attribute of the Byte Array to the specified value.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| min\_size | Integer | The minimum size to which the calling Byte Array is to be expanded. |
| auto\_resize | Boolean | A flag specifying whether auto resize is enabled on the calling Byte Array. |

### ToHexString() As String

#### Description

Returns a hexadecimal string representing the contents of the Byte Array, two digits per byte.

#### Return Value

A hexadecimal string.

### FromHexString(hexstring as String) As Void

#### Description

Sets the contents of the Byte Array to the specified value. Any data currently in the Byte Array is discarded.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| hexstring | String | An even number of hexadecimal digits. The string must contain valid hexadecimal digits, or the result is undefined |

### ToBase64String() As String

#### Description

Returns a base-64 string representing the contents of the Byte Array.

#### Return Value

A base-64 string representing the contents of the Byte Array.

### FromBase64String(s as String) As Void

#### Description

Sets the contents of the Byte Array to the specified value. Any data currently in the Byte Array is discarded.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| s   | String | A valid base-64 encoding |

### ToAsciiString() As String

#### Description

Returns the contents of the Byte Array as a string. The contents must be valid UTF-8 (or ASCII subset), or the result is undefined

#### Return Value

A String containing the contents of the ByteArray.

### FromAsciiString(s as String)

#### Description

Sets the contents of the Byte Array to the specified string using UTF-8 encoding. Any data currently in the Byte Array is discarded.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| s   | String | The string to which the ByteArray is to be set. |

### GetSignedByte(index as Integer) As Integer

#### Description

Returns the signed byte at the specified zero-based index in the Byte ArrayUse the [ifArrayGet.GetEntry()](/docs/references/brightscript/interfaces/ifarrayget.md#getentryindex-as-integer-as-dynamic) method or the \[ \] array operator to read an unsigned byte in the Byte Array.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| index | Integer | The index of the signed byte to be returned. |

#### Return Value

The signed byte at the specified zero-based index in the Byte Array.

### GetSignedLong(index as Integer) As Integer

#### Description

Returns the signed long (four bytes) starting at the specified zero-based index in the Byte Array.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| index | Integer | The index of the ByteArray from which to start retrieving the signed long. |

#### Return Value

A signed long.

### GetCRC32() as Integer

#### Description

Calculates a CRC-32 of the contents of the Byte Array.

#### Return Value

The calculated CRC-32 checksum.

#### Example

        ba = CreateObject("roByteArray") 
        ba.FromAsciiString("Hello world!")
        n = ba.GetCrc32()
        print n, "0x" ; StrI(n, 16)
        REM 461707669 0x1b851995
    

### GetCRC32(start as Integer, length as Integer) As Integer

#### Description

Calculates a CRC-32 of a subset of bytes within the Byte Array.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| start | Integer | The starting index of the subset of bytes to be used in the CRC-32 calculation. |
| length | Integer | The length of the bytes to be included. |

#### Return Value

The calculated CRC-32 checksum.

### IsLittleEndianCPU() As Boolean

#### Description

Returns true if the CPU architecture is little-endian.

#### Return Value

A flag indicating whether the CPU architecture is little-endian.

ifAudioMetadata
===============

Implemented by
--------------

| Name | Description |
| --- | --- |
| [roAudioMetadata](/docs/references/brightscript/components/roaudiometadata.md "roAudioMetadata") | This component provides developers access to audio file metadata included in many audio files |

Supported methods
-----------------

### SetUrl(url as String) as Void

#### Description

Sets the URL to the audio file. Only file URLs are initially supported

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| url | String | The URL of the audio file. |

### GetTags() as Object

#### Description

Returns an associative array that contains a simple set of tags that are common to most audio formats.

#### Return Value

An associative array that may be set to one of the following values:

| Name | Type | Notes |
| --- | --- | --- |
| title | String |     |
| artist | String | Returns the first artist found even though many titles have multiple artists |
| album | String |     |
| composer | String | Returns the first composer found even though many titles have multiple composers |
| comment | String |     |
| genre | String |     |
| year | Integer |     |
| track | Integer |     |

### GetAudioProperties() as Object

#### Description

Returns an associative array with a simple set of audio properties.

#### Return Value

An associative array that may be set to one of the following values (these are values that may involve reading a larger portion of the file and thus may take longer to retrieve than tags):

| Name | Type | Description |
| --- | --- | --- |
| length | Integer | Duration in seconds |
| bitrate | Integer | In kilobytes per second |
| samplerate | Integer | Samples per second. For example: 44100 for CD sample rate |
| channels | Integer | Number of channels. For example: 2 for stereo |

### GetCoverArt() as Object

#### Description

Returns the cover art, if available.

#### Return Value

An associative array with two entries: "bytes" and "type".

ifScreen
========

| Name | Description |
| --- | --- |
| [roScreen](/docs/references/brightscript/components/roscreen.md "roScreen") | The roScreen component provides a full screen drawing surface that can be stacked and that you can receive input events from |

Supported methods
-----------------

### SwapBuffers() as Void

#### Description

This function first operates the same as a call to [ifDraw2D](/docs/references/brightscript/interfaces/ifdraw2d.md "ifDraw2D"), completing all queued drawing operations on the back buffer (draw surface).

The new back buffer should be assumed to be in a garbage state after this call is complete, which means you will need to re-render the entire frame before a subsequent call to SwapBuffers. This call will not return until the back buffer is ready to be drawn on to. Depending on the implementation, it may take up to a single video frame period for the new front buffer to become visible.

This operation is extremely fast (that is, it never copies a bitmap from one location to another), and is guaranteed not to "tear" the visible image.

If the screen is single buffered, this method returns immediately after this operation. If the screen is double buffered, this method swaps the back buffer with the front buffer, so the back buffer is now visible.

Prioritizing authenticated apps
===============================

SVOD and TVE apps must communicate the authentication status of customers when they launch your app. Authenticated apps are listed above non-authenticated ones in content discovery features such as the Roku Search; therefore, providing the authentication status prioritizes your app, which helps drive users to your app.

> Apps that require authentication (SVOD, TVE, and other subscription services) must communicate authentication status to pass certification. AVOD apps are exempt from this requirement because they do not benefit from this integration.

Overview
--------

When customers search for a movie, TV series, actor/actress, and so on, Roku Search displays content matching the query. When customers select which content to watch, the content providers screen in Roku Search lists containing the requested content. The matching apps are ordered by active subscriptions, or in other words, which ones enable the content to be watched without requiring a transaction or viewing ads. This helps customers identify on which app the content is “free” for them.

For example, if a movie is available on an SVOD app that the customer has authenticated into, an AVOD app, and an unauthenticated SVOD app, the authenticated SVOD app is listed higher in the search results than the other apps. This is because the content on the authenticated SVOD app is the most "free" for the customer. On the other apps, the content resides behind an additional paywall or requires viewing ads.

The overall priority of apps in the Roku Search content providers list is based on Roku algorithms that consider a number of factors, including the priority of customer's entitlement to the selected content based on app type (for example, authenticated SVOD, TVE, free AVOD, and so on).

![roku815px - SVOD channels listed in Roku Search](https://image.roku.com/ZHZscHItMTc2/red-authentication-svod.jpg "SVOD channels in Roku Search content provider list")

Sending authentication events
-----------------------------

Each time an authenticated customer launches your app, send an authentication event to Roku. This can be done using either the Roku Event Dispatcher (RED) library or the **fireRokuMarketingPixel()** method in the Roku Advertising Framework (RAF) library. Using the RED library is the recommended approach; however, if you are already integrating RAF and want to avoid incorporating multiple libraries in the app, you can use the **fireRokuMarketingPixel()** method.

The Roku Search algorithm uses a 30-day lookback window for authentication events sent from Roku devices; therefore, sending authentication events each time ensures your app is prioritized appropriately in the content providers list.

### Integrating the Roku Event Dispatcher in the authentication workflow

To use the Roku Event Dispatcher in your app's authentication workflow to send authentication events, follow these steps:

1.  Enable the RED library in your app by adding the following line to the [manifest](/docs/developer-program/getting-started/architecture/channel-manifest.md) file:

       sg_component_libs_required=roku_analytics
    

2.  Use the [Roku Analytics Component](/docs/developer-program/libraries/roku-analytics-component.md) to send authentication events from your app following these steps:
    
    a. When `roSGScreen` is active, create a "Roku\_Analytics:AnalyticsNode" node and persist it by storing in the global node.
    

b. To add the RED library as a provider, include `RED: {}` when assigning to its `.init` field.

c. To dispatch an event for authentication, assign `{RED: {eventName: "Roku_Authenticated"}} to the .trackEvent` field.

The following example demonstrates how to send authentication events:

       sub Notify_Roku_UserIsLoggedIn(rsgScreen = invalid as Object)
        ' get the global node
        if type(m.top) = "roSGNode"  ' was called from a component script
            globalNode = m.global
        else ' must pass roSGScreen when calling from main() thread
            globalNode = rsgScreen.getGlobalNode()
        end if
    
        ' get the Roku Analytics Component Library used for RED
        RAC = globalNode.roku_event_dispatcher
        if RAC = invalid then
            RAC = createObject("roSGNode", "Roku_Analytics:AnalyticsNode")
            RAC.debug = true ' for verbose output to BrightScript console, optional
            RAC.init = {RED: {}} ' activate RED as a provider
            globalNode.addFields({roku_event_dispatcher: RAC})
        end if
    
        ' dispatch an event to Roku
        RAC.trackEvent = {RED: {eventName: "Roku_Authenticated"}}
    end sub
    

3.  Use the [debug console](/docs/developer-program/debugging/debugging-channels.md) to verify that your app is sending authentication events.

![roku815px - Search results for an authenticated channel that isn't using the Roku Event Dispatcher](https://image.roku.com/ZHZscHItMTc2/red-3.jpg "red-3")

### Integrating the RAF fireRokuMarketingPixel() method in the authentication workflow

To use the RAF **fireRokuMarketingPixel()** method to send authentication events to Roku, follow these steps:

1.  Enable the RAF library in your app by adding the following line to the [manifest](/docs/developer-program/getting-started/architecture/channel-manifest.md) file:

       bs_libs_required=roku_ads_lib
    

2.  Instantiate the RAF library in the app:

       adIface = Roku_Ads()
    

3.  When an authenticated customer launches your app, call the **fireRokuMarketingPixel()** method using the following syntax:

       adIface.fireRokuMarketingPixel("Roku_Authenticated")

roEVPDigest
===========

The EVP Digest component provides an interface to the OpenSSL EVP library of message digest algorithms. The EVP library provides a high-level interface to cryptographic hash functions.

roEVPDigest processes an arbitrary amount of data and generates a hash of the data, using a selected algorithm.

> For additional information on the OpenSSL library of message digest algorithms see: [http://www.openssl.org/docs/apps/dgst.html](http://www.openssl.org/docs/apps/dgst.html)

**List of Supported Digest Algorithms**

*   md5 - MD5 message digest algorithm (default)
*   sha1 - SHA-1 message digest algorithm
*   sha224 - SHA-2, 224 bit variant
*   sha256 - SHA-2, 256 bit variant
*   sha384 - SHA-2, 384 bit variant
*   sha512 - SHA-2, 512 bit variant

**Example: SHA1 Message Digest with roEVPDigest**

    ba = CreateObject("roByteArray")
    ' ...populate bytearray...
    digest = CreateObject("roEVPDigest")
    digest.Setup("sha1")
    result = digest.Process(ba)
    print result
    

**Example: MD5 Message Digest with roEVPDigest**

    ba1 = CreateOjbect("roByteArray")
    ' ...populate ba1...
    ba2 = CreateObject("roByteArray")
    ba2.FromAsciiString(somestring)
    digest = CreateObject("roEVPDigest")
    digest.Setup("md5")
    digest.Update(ba1)
    digest.Update(ba2)
    result = digest.Final()
    print result
    

Supported interfaces
--------------------

*   [ifEVPDigest](/docs/references/brightscript/interfaces/ifevpdigest.md "ifEVPDigest")

ifList
======

Implemented by
--------------

| Name | Description |
| --- | --- |
| [roList](/docs/references/brightscript/components/rolist.md "roList") | The list object implements the interfaces: ifList, ifArray, ifEnum and therefore can behave like an array that can dynamically add members |
| [roXMLList](/docs/references/brightscript/components/roxmllist.md "roXMLList") | Contains a list of roXML objects |

Supported methods
-----------------

### ResetIndex() As Boolean

#### Description

Resets the current index or position in list to the head element.

#### Return Value

A flag indicating whether the index has been reset.

### AddTail(tval As Dynamic) As Void

#### Description

Adds an element to the tail of the list.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| AddTail | Dynamic | The element to be added to the tail of the list. |

### AddHead(tval As Dynamic) As Void

#### Description

Adds an element to the head of the list.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| AddHead | Dynamic | The element to be added to the head of the list. |

### RemoveIndex() As Dynamic

#### Description

Removes the entry at the current index or position from the list and increments the index or position in the list.

#### Return Value

The entry removed from the list. This method returns invalid if the end of the list is reached.

### GetIndex() As Dynamic

#### Description

Gets the entry at current index or position from the list and increments the index or position in the list.

#### Return Value

The entry retrieved from the list. This method returns invalid if the end of the list is reached.

### RemoveTail() As Dynamic

#### Description

Removes the entry at the tail of the list.

#### Return Value

The entry removed from the tail of the list.

### RemoveHead() As Dynamic

#### Description

Removes the entry at the head of the list.

#### Return Value

The entry removed from the head of the list.

### GetTail() As Dynamic

#### Description

Retrieves the entry at the tail of the list.

#### Return Value

The entry retrieved from the tail of the list.

### GetHead() As Dynamic

#### Description

Retrieves the entry at the head of the list.

#### Return Value

The entry retrieved from the head of the list.

### Count() As Integer

#### Description

Returns the number of elements in the list.

#### Return Value

The number of elements in the list.

### Clear() As Void

Removes all elements from the list

roAssociativeArray
==================

An associative array (also known as a map, dictionary or hash table) allows objects to be associated with string keys. Associative arrays are built into the language. They can be accessed implicitly by using the dot or bracket operators, or by calling functions from the [ifAssociativeArray](/docs/references/brightscript/interfaces/ifassociativearray.md "ifAssociativeArray") interface. For example, the last three lines in this example are equivalent:

    aa = { one : 1, two : 2, three : 3 }
    x = aa["two"]
    x = aa.two
    x = aa.Lookup("two")
    

This object is created with no parameters:

    CreateObject("roAssociativeArray")
    

It can also be created implicitly by using an Associative Array literal.

Starting from Roku OS 8, the quoted keys in Associative Array literals are now case-preserving. This change improves the readability of your code and is compatible with JSON usage.

**Example**

    ' Creation of associative arrays
    
    aa1 = CreateObject("roAssociativeArray")   ' Explicitly 
    aa2 = {}                                   ' Implicitly
    aa3 = {                                    ' With some initial values
       foo : 12,
       bar : 13
    }
    
    ' Assigning values
    
    aa1.AddReplace("Bright", "Script")  ' With explicit function calls
    aa1.AddReplace("TMOL", 42)
    aa1.boo = 112                       ' With dot operator
    aa1["baz"] = "abcdefg"              ' With bracket operator
    
    ' Accessing values
    
    print aa1.Bright           ' With dot operator (will print 'Script')
    print aa1.Lookup("TMOL")   ' With function call (will print 42)
    print aa1["boo"]           ' With bracket operator (will print 112)
    
    ' Using ifEnum interface to walk through keys in an associative array
    for each key in aa1
    
        print "  " key "=" aa1[key]
    
    end for
    

Supported interfaces
--------------------

*   [ifAssociativeArray](/docs/references/brightscript/interfaces/ifassociativearray.md)
*   [ifEnum](/docs/references/brightscript/interfaces/ifenum.md)

SequentialAnimation
===================

Extends [**AnimationBase**](/docs/references/scenegraph/abstract-nodes/animationbase.md)

The SequentialAnimation node class allows you to specify that a set of animations should occur sequentially. The children of the SequentialAnimation node specify the set of animations to be executed. Note that the use of the delay field in the child animations allows a delay between any two animations to be specified, if desired.

The state field is set to running when any of the child animations is in progress. Once all the animations have run to completion, the state field is set to stopped.

### Example

The following example animates a group of rectangles to expand and change opacity sequentially from left to right.

#### SequentialAnimation Node Class Example

    <?xml version="1.0" encoding="utf-8" ?>
    
    <!--********** Copyright 2015 Roku Corp.  All Rights Reserved. **********-->
    
    <component name="animationsequentialtest" extends="Group" >
        <script type="text/brightscript" >
            <![CDATA[
                function init()
                  m.testsequentialanimation = m.top.FindNode("testSequentialAnimation")
                  m.testsequentialanimation.repeat = "true"
                  m.testsequentialanimation.control = "start"
                  m.top.setFocus(true)
                end function
             ]]>
        </script>
    
    <children>
    
        <LayoutGroup   id = "dancingbars"  translation = "[640,360]"  itemSpacings = "[10]"  layoutDirection = "horizontal"  horizAlignment = "center"  vertAlignment = "center" >
            <Rectangle      id="R1"      color="0x00FF00FF"      opacity = ".2"     width = "50"      height = "100"      scaleRotateCenter = "[25, 50]"     translation = "[0, 0]"/>
            <Rectangle      id="R2"      color="0x00FF00FF"      opacity = ".2"     width = "50"      height = "100"      scaleRotateCenter = "[25, 50]"     translation = "[60, 0]"/>
            <Rectangle      id="R3"      color="0x00FF00FF"      opacity = ".2"     width = "50"      height = "100"      scaleRotateCenter = "[25, 50]"     translation = "[120, 0]"/>
            <Rectangle      id="R4"      color="0x00FF00FF"      opacity = ".2"     width = "50"      height = "100"      scaleRotateCenter = "[25, 50]"     translation = "[180, 0]"/>
            <Rectangle      id="R5"      color="0x00FF00FF"      opacity = ".2"     width = "50"      height = "100"      scaleRotateCenter = "[25, 50]"     translation = "[240, 0]"/>
        </LayoutGroup>
        <Label   text = "Bars Should Be Dancing"  width = "1280"  translation = "[0,500]"  horizAlign = "center"  vertAlign = "center"  />
        <SequentialAnimation   id = "testSequentialAnimation" >
        <Animation        id = "R1Animation"       duration = "2"       easeFunction = "linear" >
            <Vector2DFieldInterpolator    key= "[0, 0.5, 1]"    keyValue= "[ [1, 1], [1, 2], [1, 1] ]"    fieldToInterp="R1.scale" />        
            <FloatFieldInterpolator    key= "[0, 0.5, 1]"    keyValue= "[ 0.2, 1, 0.2 ]"    fieldToInterp="R1.opacity" />
        </Animation>
        <Animation        id = "R2Animation"       duration = "2"       easeFunction = "linear" >
             <Vector2DFieldInterpolator    key= "[0, 0.5, 1]"    keyValue= "[ [1, 1], [1, 2], [1, 1] ]"    fieldToInterp="R2.scale" />
             <FloatFieldInterpolator    key= "[0, 0.5, 1]"    keyValue= "[ 0.2, 1, 0.2 ]"    fieldToInterp="R2.opacity" />
        </Animation>
        <Animation        id = "R3Animation"       duration = "2"       easeFunction = "linear" >
            <Vector2DFieldInterpolator    key= "[0, 0.5, 1]"    keyValue= "[ [1, 1], [1, 2], [1, 1] ]"    fieldToInterp="R3.scale" />
            <FloatFieldInterpolator    key= "[0, 0.5, 1]"    keyValue= "[ 0.2, 1, 0.2 ]"    fieldToInterp="R3.opacity" />
        </Animation>
        <Animation        id = "R4Animation"       duration = "2"       easeFunction = "linear" >
            <Vector2DFieldInterpolator    key= "[0, 0.5, 1]"    keyValue= "[ [1, 1], [1, 2], [1, 1] ]"    fieldToInterp="R4.scale" />
            <FloatFieldInterpolator    key= "[0, 0.5, 1]"    keyValue= "[ 0.2, 1, 0.2 ]"    fieldToInterp="R4.opacity" />
        </Animation>
        <Animation       id = "R5Animation"      duration = "2"      easeFunction = "linear" >
            <Vector2DFieldInterpolator   key= "[0, 0.5, 1]"   keyValue= "[ [1, 1], [1, 2], [1, 1] ]"   fieldToInterp="R5.scale" />
            <FloatFieldInterpolator   key= "[0, 0.5, 1]"   keyValue= "[ 0.2, 1, 0.2 ]"   fieldToInterp="R5.opacity" />
        </Animation>
        </SequentialAnimation>
    
    </children>
    
    </component>
    

Sample app
----------

[AnimationSequentialExample](https://github.com/rokudev/samples/tree/master/ux%20components/animation/AnimationSequentialExample) is a sample app demonstrating SequentialAnimation in action.

Creating custom components
==========================

A SceneGraph application consists of one or more custom SceneGraph components defined in XML files. These component XML files define the appearance and behavior of the component as needed for the application design. Defining these custom components consists of selecting node classes and previously-defined custom components that have the appearance and behavior of the application design sub-elements that will make up the component, and then defining custom attributes and scripting for the component.

You can select the node classes for your component from the built-in node classes (as described in **[SceneGraph API Reference](SceneGraph-API-Reference_1607602.html)**), and also from custom components that you have created yourself by defining the custom component in an XML file. In both cases, you must identify the node class or component to be defined for your component, either in BrightScript using the `createObject()` or `createChild()` or similar functions, or as child nodes of the **<children>** element in the XML file. In both cases, you begin the new XML file definition of the component by identifying either the basic abstract node class the component will be extended from, either a **Scene** node class or the **Group** node class, or a built-in node class, or another custom component defined in an XML file.

For example, you may want to use the built-in node classes **Rectangle** and **Label** for a simple custom component that displays some text in an on-screen box. You can define the box and the text as follows:

**Defining Custom Components in XML Markup**

    <children>
    
      <Rectangle
        id = "infoRectangle"
        translation = "[0,40]"
        height = "460"
        width = "520"
        color = "0x00000099" >
    
        <Label
          id = "infoLabel"
          translation = "[15,15]"
          height = "430"
          width = "490"
          wrap = "true"
          font = "font:MediumBoldSystemFont" />
      </Rectangle>  
    
    </children>
    

To use this custom component directly in a **Scene** node, add this XML markup to an XML component file extended from one of the built-in abstract **Scene** node classes. To use it as a custom component in as many different custom components in your application where it would be useful, add the XML markup to an XML component file extended from the built-in abstract **Group** node class, with a descriptive name such as `textbox`. After that, you can use the component in any other XML component file by creating it using that name. For example, to use it by declaring it in the XML markup in the **<children>** element of an XML component file:

    <children>
    
        ...
    
        <textbox />
    
        ...
    
    </children>
    

Focus Handling in Custom Components
-----------------------------------

There has been some confusion about how to set focus to a specific RSG element in custom components / views.

**Best Practices:**

Best practice is setting focus to view and allowing view to handle the proper child focus.

Focus should be handled by observing **focusedchild** and then checking if the required node does not have focus.

**MainScene.brs file**

    function init() as void
        customView = CreateObject("roSGNode", "CustomView")
        m.top.appendChild(customView)
        customView.setFocus(true)
    end function
    

**What to Avoid:**

A common mistake is setting focus to an element in the custom component's init() function.

A Node should never set focus to any of it’s children if not asked. Creating additional objects of your node will create problems.

Extending Custom Components
---------------------------

After you have created a custom component that contains one or more of the built-in node classes, you can also extend that component into one or more new custom components. There are some special considerations concerning custom components extended from other custom components.

### Custom Component Initialization Order

The process by which custom components are initialized is similar to how C++ object constructors work. First, the component being extended is completely constructed, then the component or components extended from it are constructed.

As each component being extended is constructed, the following sequence of events occurs:

1.  The **<children>** nodes defined in the component being extended are created, and their fields are set to their initial values, either to a default value, or to the value specified in the XML markup.
2.  The **<interface>** fields in the component being extended are created, and their initial values are set, either to a default value, or to the value specified by the `value` attribute.
3.  The **<script>** element `init()` function of the component being extended is called, and all initializations contained in the function are performed.

At this point, the component being extended is completely initialized, and the component or components to be extended from it are constructed, following the same three steps as above. Note these are the same steps described in [**Component initialization order**](/docs/developer-program/core-concepts/xml-components/component-initialization-order.md), and note the implications of the initialization order described there.

### Characteristics of Components Extended from Custom Components

The following describes the characteristics of components extended from custom components:

*   Calling a function in an extended component with the same name as in the custom component from which it is extended will call the function in the _extended component_. This allows you to _override_ (or _overload_) a function name to perform differently depending on the component from which it is called.
*   **<interface>** fields accumulate: the extended component includes all of the interface fields of the component from which it is extended in addition to its own. In the case where an extended component field name is the same as the component from which it is extended, the definition of the extended component field is used, similar to functions.
*   Any component object declared with the `m` object reference (see [**SceneGraph Data Scoping**](/docs/developer-program/core-concepts/data-scoping.md) can be accessed in either the component that is extended or any components extended from it.
*   All functions defined in a component that is extended can be called directly from any components extended from it.

#### Example

For an example of extending custom components, download the sample app [ExtendingCustomComponents](https://github.com/rokudev/samples/tree/master/ux%20components). This sample defines a custom component called CenteredRectangle. This component creates a rectangle centered on the screen. It also defines a subroutine called **SetColor**, which sets the color property of the rectangle. The sample also defines a component that extends **CenteredRectangle**, called **RedCenteredRectangle**. This new component overrides the **SetColor** subroutine to make the rectangle red.

ParallelAnimation
=================

Extends [**AnimationBase**](/docs/references/scenegraph/abstract-nodes/animationbase.md)

The ParallelAnimation node class allows you to specify that a set of animations should occur simultaneously. The children of a ParallelAnimation node specify the set of animations to be executed. Note that the use of the delay field in the child animations allows the start of the child animations to be offset from one another, if desired.

The state field is set to running when any of the child animations is in progress. Once all the animations have run to completion, the state field is set to stopped.

### Example

The following example animates a group of rectangles to expand and change opacity at the same time.

#### ParallelAnimation Node Class Example

    <?xml version="1.0" encoding="utf-8" ?>
    
    <!--********** Copyright 2015 Roku Corp.  All Rights Reserved. **********-->
    
    <component name="animationparalleltest" extends="Group" >
        <script type="text/brightscript" >
            <![CDATA[
                function init()
                  m.testparallelanimation = m.top.FindNode("testParallelAnimation")
                  m.testparallelanimation.repeat = "true"
                  m.testparallelanimation.control = "start"
                  m.top.setFocus(true)
                end function
            ]]>
        </script>
    
    <children>
    
        <LayoutGroup   id = "dancingbars"  translation = "[640,360]"  itemSpacings = "[10]"  layoutDirection = "horizontal"  horizAlignment = "center"  vertAlignment = "center" >
          <Rectangle      id="R1"      color="0x00FF00FF"      opacity = ".2"     width = "50"      height = "100"      scaleRotateCenter = "[25, 50]"     translation = "[0, 0]"/>
          <Rectangle      id="R2"      color="0x00FF00FF"      opacity = ".2"     width = "50"      height = "100"      scaleRotateCenter = "[25, 50]"     translation = "[60, 0]"/>
          <Rectangle      id="R3"      color="0x00FF00FF"      opacity = ".2"     width = "50"      height = "100"      scaleRotateCenter = "[25, 50]"     translation = "[120, 0]"/>
          <Rectangle      id="R4"      color="0x00FF00FF"      opacity = ".2"     width = "50"      height = "100"      scaleRotateCenter = "[25, 50]"     translation = "[180, 0]"/>
          <Rectangle      id="R5"      color="0x00FF00FF"      opacity = ".2"     width = "50"      height = "100"      scaleRotateCenter = "[25, 50]"     translation = "[240, 0]"/>
        </LayoutGroup>
        <Label   text = "Bars Should Be Dancing"  width = "1280"  translation = "[0,500]"  horizAlign = "center"  vertAlign = "center"  />
        <ParallelAnimation   id = "testParallelAnimation" > <!--** ParallelAnimation   id = "testParallelAnimation"   repeat = "true" **-->
        <Animation id = "R1Animation" duration = "2" easeFunction = "linear" >
            <Vector2DFieldInterpolator    key= "[0, 0.5, 1]"    keyValue= "[ [1, 1], [1, 2], [1, 1] ]"    fieldToInterp="R1.scale" /> 
            <FloatFieldInterpolator    key= "[0, 0.5, 1]"    keyValue= "[ 0.2, 1, 0.2 ]"    fieldToInterp="R1.opacity" />
        </Animation>
         <Animation        id = "R2Animation"       duration = "2"       easeFunction = "linear" > 
             <Vector2DFieldInterpolator    key= "[0, 0.5, 1]"    keyValue= "[ [1, 1], [1, 2], [1, 1] ]"    fieldToInterp="R2.scale" />
                 <FloatFieldInterpolator    key= "[0, 0.5, 1]"    keyValue= "[ 0.2, 1, 0.2 ]"    fieldToInterp="R2.opacity" />
         </Animation>
         <Animation        id = "R3Animation"       duration = "2"       easeFunction = "linear" > 
             <Vector2DFieldInterpolator    key= "[0, 0.5, 1]"    keyValue= "[ [1, 1], [1, 2], [1, 1] ]"    fieldToInterp="R3.scale" />
                 <FloatFieldInterpolator    key= "[0, 0.5, 1]"    keyValue= "[ 0.2, 1, 0.2 ]"    fieldToInterp="R3.opacity" />
         </Animation>
         <Animation        id = "R4Animation"       duration = "2"       easeFunction = "linear" >
             <Vector2DFieldInterpolator    key= "[0, 0.5, 1]"    keyValue= "[ [1, 1], [1, 2], [1, 1] ]"    fieldToInterp="R4.scale" />
                 <FloatFieldInterpolator    key= "[0, 0.5, 1]"    keyValue= "[ 0.2, 1, 0.2 ]"    fieldToInterp="R4.opacity" />
         </Animation>
         <Animation       id = "R5Animation"      duration = "2"      easeFunction = "linear" >
             <Vector2DFieldInterpolator   key= "[0, 0.5, 1]"   keyValue= "[ [1, 1], [1, 2], [1, 1] ]"   fieldToInterp="R5.scale" />
             <FloatFieldInterpolator   key= "[0, 0.5, 1]"   keyValue= "[ 0.2, 1, 0.2 ]"   fieldToInterp="R5.opacity" />
         </Animation>
        </ParallelAnimation>
    
    </children>
    
    </component>
    

Sample app
----------

[AnimationParallelExample](https://github.com/rokudev/samples/tree/master/ux%20components/animation/AnimationParallelExample) is a sample app demonstrating ParallelAnimation in action.

ifArrayJoin
===========

Implemented by
--------------

| Name | Description |
| --- | --- |
| [roArray](/docs/references/brightscript/components/roarray.md "roArray") | Returns information about the application |

Supported methods
-----------------

### Join(separator as String) as String

#### Description

Creates a string by joining all array elements together separated by the specified separator. All elements must be of type string; otherwise, an empty string is returned

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| separator | String | The string used to separate elements in an array. |

#### Return Value

A String containing the array elements.

#### Examples

        a = ["ant","bat","cat"] 
        s = a.Join(",")
        print """" + s + """"
        REM "ant,bat,cat"
    
        a = "abc".Split("")
        s = a.Join("--")
        print """" + s + """"
        REM "a--b--c"

Keyboard
========

Extends [**Group**](/docs/references/scenegraph/layout-group-nodes/group.md "**Group**")

The Keyboard node class allows a user to enter a string of alphanumeric characters. The string entered is displayed in a [TextEditBox](/docs/references/scenegraph/widget-nodes/texteditbox.md "TextEditBox") node that is part of the Keyboard node.

The Keyboard node must have the key focus in order to work properly. By default, a Keyboard node toggles between uppercase and lowercase letters when the Options remote key is pressed, to speed the entry of mixed-case strings by the user. It is important not to override this behavior, particularly if a Keyboard node is used as an internal node for a [KeyboardDialog](/docs/references/scenegraph/dialog-nodes/keyboarddialog.md "KeyboardDialog") node.

The default appearance of a Keyboard node is very transparent, allowing the keyboard to pick up most of its color from what is rendered underneath it. The appearance can be customized by changing the keyboardBitmapUri and other fields.

Fields
------

| Field | Type | Default | Access Permission | Description |
| --- | --- | --- | --- | --- |
| text | string | ""  | READ\_WRITE | Contains the string of characters that has been entered |
| keyColor | color | 0xffffffff | READ\_WRITE | Specifies the color of the key labels and icons when the Keyboard node does not have the focus |
| focusedKeyColor | color | 0xffffffff | READ\_WRITE | Specifies the color of the key labels and icons when the Keyboard node has the focus |
| keyboardBitmapUri | string | ""  | READ\_WRITE | Specifies the URI of an image file to be loaded to replace the default keyboard image drawn underneath the key label and icons.  <br>This image must be carefully designed so that the key positions match the default image. Template images for SD, HD and FHD resolutions are provided below. |
| focusBitmapUri | string | ""  | READ\_WRITE | Specifies the URI of an image file to be loaded to replace the keyboard focus indicator. This should be a 9-patch image so that it can be stretched to the appropriate size for the double width keys |
| textEditBox | TextEditBox node | system default | READ\_ONLY | This provides access to the Keyboard node internal TextEditBox node so that its appearance can be modified. You should not set this field, but you can set the fields of the TextEditBox node (such as, myKeyboard.textEditBox.textColor = "0xFF0000FF") |
| showTextEditBox | boolean | true | READ\_WRITE | Specifies whether or not the Keyboard node internal TextEditBox node is displayed. In most cases, it is desirable to display the TextEditBox node so that the user can see the string as it is entered. In some cases though, you might want to show only the keyboard part of the Keyboard node. In those cases, the text field of the node will still contain the string entered by the user, so it can displayed in some different manner |

#### Keyboard Bitmap Templates

You can use the following bitmap templates to design your own keyboard background artwork. These templates have opaque white lines that show the key outlines with the rest of the images fully transparent. Looking at the files in some image viewers that do not support transparency will result in the images looking all white.

When creating your own keyboard background artwork, you must maintain the size of the image and the position of the keys in order for it to align properly with the rendered key labels and icons.

*   [SD Keyboard Template](https://image.roku.com/ZHZscHItMTc2/SDKeyboardTemplate.png "SD Keyboard Template")
*   [HD Keyboard Template](https://image.roku.com/ZHZscHItMTc2/HDKeyboardTemplate.png "HD Keyboard Template")
*   [FHD Keyboard Template](https://image.roku.com/ZHZscHItMTc2/FHDKeyboardTemplate.png "FHD Keyboard Template")

Sample app
----------

[KeyboardExample](https://github.com/rokudev/samples/tree/master/ux%20components/widgets/KeyboardExample) is a sample app demonstrating Keyboard in action.

Screensavers
============

> Only standalone screensaver apps are permitted. Non-screensaver apps, including but not limited to video/audio streaming apps, games, and utilities, are prohibited from including screensavers.

Overview
--------

A screensaver is automatically invoked when either a video, game, utility, or application has been idle. The screensaver starts according to a user specified period of time. The main operational difference between a screensaver and a streaming app is that screensavers do not accept any user input (e.g., remote button push, etc). When a screensaver is running, any user input terminates the screensaver and returns the user to the streaming app.

Screensavers **cannot** include:

*   [DynamicComponent libraries](/docs/references/scenegraph/control-nodes/componentlibrary.md)
*   Ad insertion
*   In-app purchases
*   Deep links
*   Any type of user-initiated, interactive functionality

Screensaver context
-------------------

When a screensaver is run, a new Brightscript context is created for screensaver execution. The screensaver does not share Brightscript data objects with the streaming app.

The screensaver's [BrightScript Debugger](/docs/developer-program/debugging/debugging-channels.md) uses port 8087.

Discovery
---------

All screensavers in the Roku environment use the **`RunScreenSaver()`** function. Note that **`RunUserInterface()`** or **`Main()`** are prohibited for screensavers.

You can access the list of available screensavers in the screensaver store or menu that is discoverable on your device (in the Roku UI) by going to **Settings > Theme > Screensavers**. This is where you can go to get, set, or remove screensavers. Note that once a screensaver is purchased and added the screensaver is not displayed on the Roku Home screen.

![roku815px - screensavers menu](https://image.roku.com/ZHZscHItMTc2/screensavers-menu.png "screensavers_menu")

Settings
--------

The **`RunScreenSaverSettings()`** function stores screensaver data in the device's registry. If a screensaver implements the **`RunScreenSaverSettings()`** function a new context menu, called **Change screensaver settings** is available under the given screensaver detail menu.

![roku815px - change screensaver settings](https://image.roku.com/ZHZscHItMTc2/change-screensaver-settings.png "change_screensaver_settings")

After clicking **Change screensaver settings** the **`RunScreenSaverSettings()`** entry point is invoked allowing you to change developer specified screensaver options.

Manifest entries
----------------

A screensaver must have an entry in its [manifest file](/docs/developer-program/getting-started/architecture/channel-manifest.md) named **`screensaver_title`** whose value is the title of the screensaver (usually the same as the title of the app).

> The **`screensaver_title`** manifest entry may only be used for screensaver applications. Other apps may not use this manifest entry; app publishing will be blocked if it is provided.

Usable components
-----------------

Normally a screensaver uses roScreen or roImageCanvas to display images on the screen. Components which accept user input are not supported in a screensaver. This is a list of components which **cannot** be used in a screensaver.

*   **`roAudioPlayer`**
*   **`roChannelStore`**
*   **`roVideoPlayer`**

SceneGraph screensavers
-----------------------

You can also create screensavers in Roku SceneGraph. You should **not** create SceneGraph screensavers that require any type of user input (such as a keyboard), or have video playback.

### Screensaver examples

See the [screensaver sample channels](https://github.com/rokudev/samples/tree/master/screen%20savers) for examples.

TargetSet
=========

Extends [**Node**](/docs/references/scenegraph/node.md)

The TargetSet node class is used to specify a set of target regions where items in a [TargetGroup](/docs/references/scenegraph/layout-group-nodes/targetgroup.md) node are rendered. This information includes an array of rectangles that is used to define the location and size of a region that will be occupied by an item in the TargetGroup as well as an optional index that identifies one rectangle in the array to be treated as the region where the item with focus is located.

Fields
------

| Field | Type | Default | Access Permission | Description |
| --- | --- | --- | --- | --- |
| targetRects | array of rectangles | \[ \] | READ\_WRITE | Specifies an array of rectangles that define the target regions used by a TargetGroup node. To specify a rectangle, you can either specify a associative array with x, y, width and height elements or an array of 4 numeric values. For example, you could specify an array of two rectangles like this:  <br>  <br>\[ \[ x:10, y:5, width: 200, height:150 \], \[ x:10, y:160, width: 200, height:150 \] \]  <br>  <br>Alternately, you could specify the same array like this:  <br>  <br>\[ \[ 10, 5, 200, 150 \], \[ 10, 160, 200, 150 \] \] |
| focusIndex | integer | \-1 | READ\_WRITE | Identifies the index of an element of the targetRects array that will be treated as the region occupied by the focus item. The default of of -1 indicates that the TargetGroup's current focus index will not be changed when the TargetGroup is set to use the TargetSet to define its target regions. |
| color | Color | 0xFFFFFF80 | READ\_WRITE | If the TargetGroup using this TargetSet has its showTargetRects field set to true, the target rectangles of the current TargetSet will be drawn using the specified color. Drawing the TargetSet's target rectangles is generally only done when debugging an application. |

Sample app
----------

[TwoRowFixedFocus](https://github.com/rokudev/samples/tree/master/ux%20components/screen%20elements/target_group/TwoRowFixedFocus) is a sample app demonstrating TargetSet in action.

ifInput
=======

Implemented by
--------------

| Name | Description |
| --- | --- |
| [roInput](/docs/references/brightscript/components/roinput.md "roInput") | An roInput object can be used to receive events sent from a network client using the External Control Protocol (ECP), as described in External Control API |

Supported methods
-----------------

### GetMessagePort() as Object

#### Description

Returns the message port (if any) currently associated with the object.

#### Return Value

The message port value.

### SetMessagePort(port as Object) as Void

#### Description

Sets the roMessagePort to be used to receive events.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| port | Object | The port to be used to receive events. |

### EnableTransportEvents() as Boolean

#### Description

Registers an app to receive `roInput transport` events, which are voice commands sent via the Roku remote control, Roku mobile app, or a virtual assistant such as Amazon Alexa or Google Assistant.

Voice commands include the following: "fast forward", "next, "play", "pause", "replay", "rewind", "seek", and "startover". Once you register your app to receive transport events, your app must call the `EventResponse()` method to handle them.

See [Implementing Voice Controls](/docs/developer-program/media-playback/voice-controls/transport-controls.md) for more information.

#### Return Value

A flag indicating whether transport event notifications were successfully registered.

### EventResponse(roAssociativeArray aa) as Boolean

#### Description

Marks a transport command as handled, unhandled, or handled with an error.

If your app has registered for handling transport events (by calling the `EnableTransportEvents()`function on an `roInput` object), it must call this method within 5 seconds of receiving a transport event. This is because the Roku OS needs to know whether a transport command has been handled, unhandled, or handled with an error. If a transport event is marked as unhandled, the Roku OS can provide the default behavior. If a transport event is marked as handled with an error, the Roku OS can provide on-screen feedback.

If your app has registered for transport events, but does not call this method within 5 seconds of receiving a transport event, the event is considered unhandled.

#### Parameters

This method takes an AssociativeArray with two fields: **id** and **status**. The **id** field specifies the transport ID event; the **status** specifies whether the event was handled, handled with an error, or unhandled.

| Parameter | Type | Description |
| --- | --- | --- |
| Id  | String | The unique ID of the transport event. |
| status | String | Indicates whether the event was handled successfully, handled with an error, or unhandled. This may be one of the following values:  <br>  <br><br>*   "error.generic". No active media is available to fulfill the voice command. Passing this status displays "That is not available" in the Roku Voice heads-up display. This can be used in cases, for example, when an app receives a "forward" or "next" command, but there is no content to fast forward or play next, respectively.<br>*   "unhandled". The app is not handling the event. The default behavior is executed by the Roku OS, if defined.<br>*   "error". The app failed to handle the event in that instance.<br>*   "error.ad". The transport command failed because an ad is playing.<br>*   "error.channel". The app does not support this command in any context.<br>*   "error.live". The transport command failed because the content is live.<br>*   "error.no-media". There is no media active.<br>*   "error.redundant". The transport command does not change the current state ("pause" command sent when the content is already paused)<br>*   "success". The app handled the event successfully.<br>*   "success.seek-start". A seek command was handled successfully, but the seek duration was before the beginning.<br>*   "success.seek-end". A seek command was handled successfully but the seek location was past the end. |

#### Return Value

A flag indicating whether the event response operation was successful.

roAudioGuide
============

> This component is only available on the following devices: Roku Streaming Stick (3600X), Roku Express (3700X) and Express+ (3710X), Roku Premiere (4620X) and Premiere+ (4630X), Roku Ultra (4640X), and any Roku TV running Roku OS version 7.5 and later.

The roAudioGuide component provides screen reader support for applications that require custom speech beyond what is provided by the automatic screen reader in SDK and Scene Graph components.

Though some of the roAudioGuide API is similar to [roTextToSpeech](/docs/references/brightscript/components/rotexttospeech.md "roTextToSpeech"), roAudioGuide provides support specific to screen reader, including:

*   Speaks when the screen reader is enabled, and doesn't speak if it isn't.
*   Automatically splits up text to reduce lag.
*   Uses the correct voice, language, volume, and speech rate for the screen reader.
*   Tries to be "smart" by pre-processing the text for correct pronunciation of things like currency, email addresses, acronyms, media-related names and titles, etc.

Usually, roAudioGuide would be used on its own, but it can be used in conjunction with [roTextToSpeech](/docs/references/brightscript/components/rotexttospeech.md "roTextToSpeech").

Supported interfaces
--------------------

*   [ifAudioGuide](/docs/references/brightscript/interfaces/ifaudioguide.md "ifAudioGuide")

ifAppManager
============

Implemented by
--------------

| Name | Description |
| --- | --- |
| [roAppManager](/docs/references/brightscript/components/roappmanager.md "roAppManager") | Returns information about the application |

Supported methods
-----------------

### GetUptime() as Object

#### Description

Returns an [roTimespan](/docs/references/brightscript/components/rotimespan.md "roTimespan") object, which is "marked" when the user clicked on the application button on the home screen.Calling the TotalMilliseconds() method on the returned roTimespan object returns the total number of milliseconds since the application started.

#### Return Value

An [roTimespan](/docs/references/brightscript/components/rotimespan.md "roTimespan") object.

### GetScreensaverTimeout() as Integer

#### Description

Returns the user's screensaver wait time setting in number of minutes, or zero if the screensaver is disabled.

#### Return Value

The number of minutes set for the screensaver wait time.

### SetUserSignedIn(signedIn as Boolean) as Void

#### Description

This method allows an app to tell Roku when the user is signed in or signed out of the appIf the app is removed, the Roku OS will call SetUserSignedIn(false) on the app's behalf.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| signedIn | Boolean | Set to true to indicate that the user is signed in; set to false to indicate the user is signed out. |

### SetAutomaticAudioGuideEnabled(enabled as Boolean) as Void

#### Description

Enables or disables the automatic screen reader and override any manifest setting.This is useful for apps that want to temporarily turn off the automatic screen reader for specific screens.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| enabled | Boolean | A flag indicating whether to enable or disable the automatic screen reader. |

### IsAppInstalled(channelID as String, version As String) as Boolean

#### Description

This method returns true if an app with the specified channelID and the minimum version required is installed.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| channelID | String | The unique id of the app. |
| version | String | The minimum version number of the app to be used for the query. |

#### Return Value

A boolean indicating whether the specified BrightScript app is installed.

### SetNowPlayingContentMetaData(contentMetaData as Object) as Void

#### Description

Updates video or audio [content metadata](/docs/developer-program/getting-started/architecture/content-metadata.md) during playback. This method takes a subset of content metadata parameters to be updated. These values override any previously ones sent to the Roku Media Player, and they are used until this function is called again or until the [**roAppManager**](/docs/references/brightscript/components/roappmanager.md) instance is deleted.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| contentMetaData | roAssociativeArray | The video or audio [content metadata](/docs/developer-program/getting-started/architecture/content-metadata.md) parameters to be updated (for example, the title and contentType) |

#### Example

    appmgr = CreateObject("roAppManager")
    appmgr.SetNowPlayingContentMetaData({
     title: "The Gambler",
     contentType: "movie"
    })
    

To revert an update, pass `invalid` in this method:

    appmgr.SetNowPlayingContentMetaData(invalid)
    

### StartVoiceActionSelectionRequest() as Void

#### Description

Triggers a voice request for the viewer to select a user profile if the device is paired with a hands-free Roku Voice remote control. This function should be called by apps that support voice commands and display a user profile selection screen upon launch, which is when this method should be called.

For example, when the user launches an app and the profile selection screen is displayed, calling this function will trigger Roku Voice to say and display "Which of these would you like" or "Who's watching?" (if a hands-free Roku Voice remote control is paired with the device).

Apps can check the launch parameters to determine whether the app was launched via a voice command before calling this method. Additionally, apps can call the [roDeviceInfo.HasFeature("handsfree\_voice")](/docs/references/brightscript/interfaces/ifdeviceinfo.md#hasfeaturefeature-as-string-as-boolean) function to check whether a hands-free Roku Voice remote control is paired with the device. If a hands-free remote is not paired with the device or is not active, calling this function has no effect.

### SetVoiceActionStrings(actions as Object) as Void

#### Description

Specifies a list of text strings, such as user profile names, that can be matched to voice requests.

When there is a match (the name uttered by the user matches the registered text string), it is provided to the app via an roInput voice command handler. Specifically, the **command** key in the associative array returned by the [**roInputEvent.GetInfo()**](/docs/references/brightscript/events/roinputevent.md#getinfo-as-object) method is set to "action", and the **text** key is set to the matched name or other text string.

**Parameters**

| Name | Type | Description |
| --- | --- | --- |
| actions | array of associative arrays | The list of text strings to be regsitered. Once a text string is registered, it can be matched to voice requests received by the app. Each text string is defined with the following attributes:<br><br>*   a **text** key for storing the name or word to be matched.<br>*   an optional **link** key for storing a deep link. |

#### Example

    appMgr = CreateObject("roAppManager")
    
    profile1 = { text: "kids", link: "d46ge-i8Y5-192"}
    profile2 = { text: "Jane", link: "2a2Nu-u1D4-555"}
    profile3 = { text: "John", link: "6Nu70-N37x-901"}
    
    actions = [profile1, profile2, profile3]
    
    appMgr.SetVoiceActionStrings(actions)
    

### GetLastExitInfo() as Object

_Available since Roku OS 13.0_

**Description**

Returns a roAssociativeArray that includes an exit code indicating why an app was terminated, a timestamp, the state of the app and Roku media player at the time the app was exited, and the memory limit exceeded (if applicable). This helps developers monitor and debug memory issues with their apps.

**Return Values**

An roAssociativeArray the following information about the most recent app exits. Invalid is returned if no app exits are recorded.

| Name | Type | Description |
| --- | --- | --- |
| timestamp | String | An ISO 8601 date string that specifies the time of the app exit. |
| exit\_code | String | The exit code, which denotes the cause of the app termination. See [lastExitOrTerminationReason](/docs/developer-program/getting-started/architecture/dev-environment.md#lastexitorterminationreason-parameter) for the list of possible exit codes. For memory-related app exits, this value will be one of the following:<br><br>*   **EXIT\_CHANNEL\_MEM\_LIMIT\_FG**: The app exceeded the per-app memory limit while running in the foreground.<br>*   **EXIT\_CHANNEL\_MEM\_LIMIT\_BG**: The app exceeded the per-app memory limit while running in the background.<br>*   **EXIT\_OUT\_OF\_MEMORY**: The device was running under low-memory conditions.<br>*   **EXIT\_AM\_LOWRESOURCE**: System resources were low.<br>*   **EXIT\_SYSTEM\_KILL**: The app was preemptively closed by the Roku OS.<br>*   **EXIT\_UNKNOWN:** The device was rebooted because of low memory, or 10 or more apps had run before the launch of your app. |
| mem\_limit | Integer | The applicable per-app memory limit that was exceeded (in Mb). This attribute is only included If the **exitCode** is EXIT\_CHANNEL\_MEM\_LIMIT\_FG or EXIT\_CHANNEL\_MEM\_LIMIT\_BG. |
| app\_state | String | The state of the app when it was terminated:<br><br>*   **foreground**: The application was running in the foreground.<br>*   **background**: The application was running in the background. |
| console\_log | String | The last 20 lines of text written to the BrightScript console before termination. The console output includes BrightScript print statements, BrightScript errors and warnings, and any system messages. The availability of this attribute depends on the platform and app configuration. |
| media\_player\_state | String | The state of the media player before the app was terminated. This attribute is included for all **exitCode** values except EXIT\_CHANNEL\_MEM\_LIMIT\_FG and EXIT\_CHANNEL\_MEM\_LIMIT\_BG:<br><br>*   **playing**: The media player was playing.<br>*   **stopped**: The media player was stopped. |

##### Example

The following sample demonstrates how to use the **GetLastExitInfo()** function.

    appManager = CreateObject("roAppManager")
    closureDump = appManager.GetLastExitInfo()
    
    if closureDump <> invalid then
        print "Timestamp: ", closureDump.timestamp
        print "exitCode: ", closureDump.exit_code
        print "limit: ", closureDump.mem_limit
        print "mediaPlayerState: ", closureDump.media_player_state
        print "------------------------------ " + "Console Log" + " ------------------------------"
        print closureDump.console_log
        print "------------------------------ " + "BrightScript Memory" + " ------------------------------"
    else
        print "No recorded closure for active plugin"
    end if

Instant Resume
==============

Instant Resume enables apps to save their current state upon exit and then continue playback upon relaunch. This improves the user experience by letting viewers quickly get back to the content they were watching without having to find it first. Consider how Instant Resume can help speed up playback upon the relaunch of live and VOD content:

*   **Live**. A user is watching a live linear stream and then exits the app by pressing the Home or Back key on their Roku remote control. When they re-launch the app later, it can resume directly into playback of the live video in approximately 1 second.

*   **VOD**. A user is watching a movie and then exits the app (by saying "Home" on their Roku Voice remote). When they re-launch the app later, it can display a Details Screen in just a few seconds The Details Screen gives the user the choice to either resume the video or play it from the beginning.

The following video demonstrates how Instant Resume works for live linear and VOD apps:

 <img src='https://image.roku.com/ZHZscHItMTc2/instant-resume-demo-v2.jpg' alt='Instant Resume Demo'

Pre-requisites
--------------

To integrate Instant Resume, you must have a Roku test device that meets the following prerequisites:

*   **Multi-core ARM processor**. Instant Resume is supported only on Roku devices with multi-core, ARM processors. Although Instant Resume will be enabled on other devices, its effectiveness will vary by platform memory profile. See the [Hardware specifications](/docs/specs/hardware.md#updatable-roku-models) for processor and memory capabilities of all Roku devices.

*   **Roku OS 10.0 (or higher)**. Instant Resume is supported only on devices that can run Roku OS 10.0 or higher. See the [Hardware specifications](/docs/specs/hardware.md#updatable-roku-models) for the list of current and updatable Roku devices.

> Developers of public apps that use Instant Resume must notify Roku before submitting an app for publication. Instant Resume can be integrated into beta and sideloaded apps without any notification.
> 
> Implementing Instant Resume in an app does not guarantee that the Roku OS can relaunch it in its suspended state. The Roku OS stores as many suspended apps as possible in memory; however, it removes suspended apps when additional memory is needed by the active app. If a suspended app is removed from memory, re-launching the app is done without Instant Resume.

Implementation
--------------

Instant Resume entails suspending the app state in the device RAM and then resuming the app upon relaunch. The app continues exactly where it was left off, without needing to execute tasks that would normally be required for a fresh launch.

To implement Instant Resume in an app, do the following:

1.  [Update the manifest with required attributes](#updating-the-channel-manifest).

2.  [Implement the required suspend and resume handlers](#implementing-suspend-and-resume-handlers).

3.  [(Optional) Execute background tasks](#background-tasks).

4.  [Add signal beacons to measure suspend and resume times](#adding-signal-beacons).

### Updating the manifest

The [manifest](/docs/developer-program/getting-started/architecture/channel-manifest.md) must include the **sdk\_instant\_resume=1** attribute to leverage Instant Resume. This attribute indicates the app's request to participate in Instant Resume. It acknowledges that the app has implemented all the requirements and protocols described in this document.

### Implementing suspend and resume handlers

Implementing Instant Resume involves programming two handlers: **customSuspend** and **customResume**. These handlers must be attached to any scene that may be active during app operation. They enable the app scene code to prepare for suspension and recover after resumption. In both handlers, code should solely focus on just the specific tasks needed to prepare the app for suspension and then update its state upon resumption.

When the Home key or labeled app key on the Roku remote control is pressed, the "Home" voice command is spoken, the app is exited by the press of the Back key or the "Back" voice command being spoken, or the Roku system screensaver is activated, an "interruption event" is generated. When this occurs, the Roku OS invokes the **customSuspend** handler for the active (in-focus) scene. In the **customSuspend** handler, apps free as many resources as possible to minimize the app's memory footprint and therefore maximize the chances that Instant Resume can be used upon relaunch.

When the user later returns to the app, the Roku OS invokes the matching **customResume** handler. In the **customResume** handler, apps implement logic to determine the playback experience upon re-launch. Using VOD content for example, the **customResume** handler can check whether a Video node is on the screen stack and remove it if it is in order to display the content's Details screen.

> As of Roku OS 12.0, pressing the "Back" key to exit an app generates an interruption. This means that apps without an Exit Confirmation dialog can support Instant Resume.
> 
> * * *
> 
> Apps should minimize memory usage to increase the probability of their app being re-launched with Instant Resume. Apps can use the [BrightScript Profiler](/docs/developer-program/dev-tools/brightscript-profiler.md) or the [**chanperf** command in the debug console](/docs/developer-program/debugging/debugging-channels.md#scenegraph-debug-server-port-8080-commands) to monitor memory consumption.

#### Example

##### SceneGraph

In the SceneGraph XML file of the app's Scene node, insert `customization suspendhandler` and `customization resumehandler` tags and set them to `customSuspend` and `customResume`, respectively:

    <customization suspendhandler="customSuspend" />
    <customization resumehandler="customResume" />
    

##### BrightScript

The following BrightScript code demonstrates how to execute the `customSuspend` and `customResume` handlers in the Scene. The **customResume** handler includes logic for managing the playback experience, which includes handling any deep link requests sent to the app upon relaunch. Details for each of these handlers, including the tasks to be performed within them, are provided after.

    function customSuspend(arg as dynamic)
         for each key in arg
           print " " key "=" arg[key]
         end for
    end function
    
    function customResume(arg as dynamic)
      for each key in arg
        print " " key "=" arg[key]
      end for
    
      if arg.launchParams <> invalid
        launchParams = arg.launchParams
         if(launchParams.mediaType <> invalid) and (launchParams.contentId <> invalid)
          print "Deep Link parameters: Media Type "; launchParams.mediaType " Content Id "; launchParams.contentId
        end if
      end if
    end function
    

#### customSuspend(arg as dynamic) as Void

##### Tasks

When this handler is called, the app loses access to the video decoder, and it then has 5 seconds to complete all necessary [background tasks](#background-tasks) before being suspended. When the 5-second timeout elapses (or at the return from the **customSuspend()** method, whichever is first), the app loses access to the graphics context. Execution context is preserved during suspension.

To maximize the app's chances of remaining in memory while suspended, free as many resources as possible at suspension time to minimize the app's memory footprint (for example, graphics assets, content nodes and associated meta data, and anything else that is not visible). This reduces the chances that the app is removed from memory when the active app needs additional memory.

##### Parameters

The **arg** parameter is an associative array that provides the source of the interruption. It has a **lastSuspendOrResumeReason** field that may be set to one of the following values:

*   **screensaver**. The Roku system screensaver was activated.

*   **home**. The Home key or a labeled app key on the Roku remote control is pressed (or any other source).

#### customResume (arg as dynamic) as Void

##### Tasks

When this handler is called, the app needs to update its own internal data with respect to any relevant environmental changes that may have occurred since suspension. At this point, the app once again has access to graphics and the video decoder. Pre-suspension execution context is also restored.

##### Parameters

The **arg** parameter is an associative array that includes the following fields:

*   **lastSuspendOrResumeReason**. The location from which the app is resumed: "screensaver" or "home".

*   **launchParams**. [Deep linking](/docs/developer-program/discovery/implementing-deep-linking.md) fields "contentId" and "mediaType", which specify the selected content and required app behavior when receiving a deep link request upon relaunch.

> [roInputEvents](/docs/references/brightscript/events/roinputevent.md) are not passed to the **customResume** handler upon relaunch to avoid sending the deep linking parameters twice. The **launchParams** field provides access to the deep linking parameters.

### Background tasks

Once an Instant Resume app is suspended, it should return the user to the Roku home page within 1 to 2 seconds of a Home keypress. The app, however, may still need to execute specific network tasks after it has been suspended. In this case, the app can execute such tasks in the background. During background tasks, the render thread is still active for another 5 seconds after the app has been suspended, and tasks that require a rendezvous with the render thread can be executed during this 5-second period.

> Apps should only use background tasks for lightweight tasks that do not consume too many CPU resources (for example, network IO tasks or logging); otherwise, the app may be removed from memory.

#### Enabling background tasks

To enable an Instant Resume app to execute background tasks, set the **allowBackgroundTask** field of the **Scene** node. The following BrightScript code demonstrates how to do this:

    scene = screen.CreateScene("BackgroundTaskTestScene")
    scene.allowBackgroundTask = true
    

Optionally, once the background tasks have been completed, the app can set the **Scene.allowBackgroundTask** field to false in order to block the render thread and dependent background tasks. To enable background tasks to be executed after the next suspension, the app must toggle this field back to true once it has been resumed.

Background tasks are automatically **blocked after 5 seconds** of app suspension (or if the app sets the **Scene.allowBackgroundTask** field to false, whichever happens first).

#### Screensaver interrupts

Background tasks are not executed when an app is interrupted by a screensaver.

#### Debugging

The BrightScript debug console (port 8085) cannot be used by the app once it has been suspended. As a result, any logging statements execute during background tasks are not be visible to the app on 8085 port, and also the app cannot debug background tasks using STOP statements.

### Adding signal beacons

Apps must use signal beacons to measure and record how long it takes to be suspended and resumed.

#### AppSuspend beacons

The Roku OS automatically fires **AppSuspendInitiate**/**AppSuspendComplete** beacons to measure the time it takes for an app to be suspended after being interrupted. No additional implementation is therefore required for apps to measure suspend times.

#### AppResume beacons

The **AppResume** beacons are similar to the [**AppLaunch** signal beacons](/docs/developer-program/performance-guide/measuring-channel-performance.md#applaunch-signal-beacons), which are used to measure app launch times (normal launches done without Instant Resume). Beacons are fired when a user presses OK to select an app from the Roku home screen (marking the start point) and when the selected app is fully rendered (the stop point). The elapsed time between the start and stop points is recorded and can be viewed using the [BrightScript console](/docs/developer-program/debugging/debugging-channels.md). You can then use the feedback from the console to update your application.

For Instant Resume, the Roku OS fires the **AppResumeInitiate** beacon when the app is re-launched. Apps, however, must implement the corresponding **AppResumeComplete** beacon. The **AppResumeComplete** beacon must be fired when the suspended scene is fully rendered during the resume process. This beacon must also be fired when video playback starts after handling a [deep link](/docs/developer-program/discovery/implementing-deep-linking.md), once the app can respond to commands sent via the Roku remote control.

> The **AppResumeComplete** beacon may only be fired at resume time; never fire it during a normal app launch.

To fire the **AppResumeComplete** beacon from the app, call the **signalBeacon()** function on any node as demonstrated in the following example:

`myScene.signalBeacon(“AppResumeComplete”)`

#### Instant Resume performance metrics

You can use the BrightScript console (port 8085) to view a log with your app's Instant Resume performance metrics. When a beacon is fired, the console immediately outputs statistics related to the initiate or complete beacon. When you exit your app, the console displays a report summarizing the statistics for the just-concluded session.

The following table lists how the resume and suspend beacons are measured and when their initiate and complete beacons are fired.

| Metric | Start Point | Stop Point | Initiate Beacon | Complete Beacon |
| --- | --- | --- | --- | --- |
| **Suspend** | An app interruption (for example, the user presses the Home button on the Roku remote control). If the user exits the app using the back key or an exit confirmation dialog, this beacon is not fired. | The app has been suspended to background and the home screen is fully rendered and operational. | AppSuspendInitiate (fired by Roku OS). The home key handler invokes app suspension. | AppSuspendComplete (fired by Roku OS). The first render pass completes after the complete beacon has been signaled (when the Roku OS completes application exit) and the Home screen is displayed. |
| **Resume** | The user presses the **OK** button to launch an app that had previously been suspended to background from the home screen. | The app is fully rendered and operational on its initial UI screen, or it reaches user-operable video playback. | AppResumeInitiate (fired by Roku OS). The last keypress before the beacon was signaled. If there was no prior keypress, the initiate beacon signal time. | **AppResumeComplete** (fired by app). The first render pass completes after the complete beacon has been signaled via the [**signalBeacon()** method](#appresume-beacons). |

App behavior guidelines
-----------------------

Instant Resume provides developers with the flexibility to customize their app's integration of this feature. Roku cannot anticipate proper app behavior in all circumstances, and can only provide guidelines and best practices for UX design and app behavior. Ultimately, the developer must determine how an app should handle Instant Resume to best complement the overall app UX and meet the needs of their viewers.

> For the app UX, Instant Resume suspend/resume events should be handled as normal app exits/re-launches. Instant Resume will automatically accelerate the app re-launch.

### Live video playback

It is recommended that apps resume playback at the current point in the live linear feed (or report that the feed has ended and proceed from there).

### VOD playback

It is recommended that apps use a basic implementation for the playback of VOD content. In this case, the video player screen is closed, which stops playback, and the content's Details Screen is displayed. The customer can then choose to either resume the video at its bookmarked position or play it from the beginning. This approach optimizes the user experience, while reducing the development time of more complex approaches that may be more susceptible to bugs and errors.

The following code snippet illustrates logic that could be used to resume an app when a video node has already been created and is on the screen stack. In this case, it closes the video node, removes it from the screen stack, and switches focus on the previous screen, which is typically the Details Screen.

    ' Callback function when the app is suspended from an app exit.
    ' In this example, we are only printing to the brightscript console
    ' that the app is being suspended.
    sub onMainSceneSuspend(arg as dynamic)  
      print "***** Suspending Channel ***** CALLED FROM"; arg.lastSuspendOrResumeReason
    end sub  
    
    ' Callback function when the app resumes after an app exit. The
    ' sample will check if a video node has been created. If it has, then we
    ' remove the video node from the screen stack and will focus on the previous
    ' screen. Otherwise, it will resume with the last screen the user was previously
    ' on before the app was suspended.
    sub onMainSceneResume(arg as dynamic) as boolean
      print "***** Resuming Channel ***** CALLED FROM"; arg.lastSuspendOrResumeReason  
      if m.videoPlayer <> invalid and lcase(m.videoPlayer.subtype()) = "video"
          print "***** Closing video screen... *****"
          CloseScreen(m.videoPlayer)  
      end if
    end sub
    

> Apps may attempt to resume playback at the suspension point; however, the user may not have launched the app for some time and therefore may lack context, which may not be an ideal user experience. In addition, this approach requires the handling of a number of complexities:
> 
> *   preserving ad breaks (if an interruption occurs during an ad break, the app must re-start the ad roll).
> *   maintaining authentication logic during signups (SVOD apps need to ensure their paywalls are not affected by users exiting the app when in the sign-up flow).
> *   bookmarking ( must start the video at last played position).
> *   managing any catalog changes that could affect how the app handles the content feed.

Sample app
----------

If your device is running Roku OS 10.0 (or later), you can download and install a [sample app](https://github.com/rokudev/instant-resume) that demonstrates how to implement Instant Resume in an app. You can customize the handling of suspend and resume events in the sample to meet your app's needs.

The `onMainSceneSuspend()` and `onMainSceneResume()` methods shown in the VOD playback code sample are taken from the **components/UILogic/VideoPlayerLogic.brs** file in the sample app. They are used as the controlling the `customSuspend()` and `customResume()` methods in the **components/MainScene.xml** file.

StandardProgressDialog
======================

Extends [StandardDialog](/docs/references/scenegraph/standard-dialog-framework-nodes/standard-dialog.md "**Standard Dialog**")

The StandardProgressDialog node displays a spinning progress indicator that includes a short progress message to the user. It is similar to the legacy [ProgressDialog](/docs/references/scenegraph/dialog-nodes/progressdialog.md) node.

![roku815px - progress-dialog-title](https://image.roku.com/ZHZscHItMTc2/progress-dialog-title-v2.jpg)

Structure
---------

The StandardProgressDialog is comprised of the following areas and building block nodes:

*   Zero or one StdDlgTitleArea.
*   StdDlgContentArea, which contains the following item:
    
    *   One StdDlgProgressItem

Fields
------

| Field | Type | Default | Access Permission | Description |
| --- | --- | --- | --- | --- |
| title | string | ""  | READ\_WRITE | The title to be displayed at the top of the dialog.If no title is specified, the progress dialog will be displayed without a title area and will use the minimum width needed to show the spinning progress indicator and message |
| message | string | ""  | READ\_WRITE | A string to be displayed next to the spinning progress indicator. It typically tells the user why they are waiting.  <br><br>> Minimize the message length. |

HLS and DASH
============

> Roku recommends that ad-supported apps employing [Server-Side Ad Insertion (SSAI)](/docs/developer-program/advertising/ssai-adapters.md) use _only_ HLS or DASH "standard" thumbnails, as an incompatibility in the BIF-support mechanism can cause thumbnails and video to fall out of synch during SSAI operation. Developers should convert existing apps that use BIF and SSAI to use "standard" thumbnails instead, at the earliest opportunity.

As an alternative to the Roku proprietary BIF file format, Roku SceneGraph supports (since OS version 9.3) the use of DASH and HLS thumbnail approaches for trick mode playback. For developers who have already prepared thumbnail tiles for their content (in order to offer trick mode functions on other streaming platforms, for instance), this feature can save significant time and effort, during content migration to the Roku platform.

> Developers who want to create standard-thumbnail files can find instructions for doing so [here](#standard-thumbnail-file-creation).

DASH considerations
-------------------

### DASH-standard thumbnail tiles

The DASH Industry Forum describes standard thumbnail tiles in ["Guidelines for Implementation: DASH-IF Interoperability Points" (Version 4.3: November, 2018](https://dashif.org/docs/DASH-IF-IOP-v4.3.pdf) – we refer to this publication as "DASH Interop Guidelines"). The tiles themselves (graphics files containing collections of thumbnail images arranged in an htiles x vtiles grid) are described in Section 6.2.6, and can be cited in MPD manifest files, in conjunction with `@contentType="image"` in Adaptation Sets.

> Roku's support for the DASH-IF is comprehensive, but not complete. For a list of known discrepancies between the full DASH standard and Roku's support for it, see [Roku OS support for DASH-IF](/docs/specs/media/dash-if.md).
> 
> As specified in Section 6.2.6 of the DASH Interop Guidelines, the maximum tile width or height pixel limit is 1080 for high-end devices and 720 for low-end devices. Developers are cautioned to use the _minimum_ dimensions necessary to retain the desired image quality. Roku will scale thumbnail images as necessary. Practical experience suggests that an original thumbnail image width at or near 308 pixels provides an optimal balance of performance vs. image quality in typical situations where scaling is employed.

### DASH manifest example

    <MPD mediaPresentationDuration="PT634.566S" minBufferTime="PT2.00S" profiles="urn:hbbtv:dash:profile:isoff-live:2012,urn:mpeg:dash:profile:isoff-live:2011" type="static" xmlns="urn:mpeg:dash:schema:mpd:2011" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:mpeg:DASH:schema:MPD:2011 DASH-MPD.xsd">
     <BaseURL>.</BaseURL>
     <Period>
      <AdaptationSet id="1" mimeType="video/mp4" contentType="video" subsegmentAlignment="true" subsegmentStartsWithSAP="1" par="16:9">
       <SegmentTemplate duration="120" timescale="30" media="$RepresentationID$/$RepresentationID$_$Number$.m4v" startNumber="1" initialization="$RepresentationID$/$RepresentationID$_0.m4v"/>
       <Representation id="bbb_30fps_1024x576_2500k" codecs="avc1.64001f" bandwidth="3134488" width="1024" height="576" frameRate="30" sar="1:1" scanType="progressive"/>
       <Representation id="bbb_30fps_640x360_800k" codecs="avc1.64001e" bandwidth="1013310" width="640" height="360" frameRate="30" sar="1:1" scanType="progressive"/>
      </AdaptationSet>
      <AdaptationSet id="2" mimeType="audio/mp4" contentType="audio" subsegmentAlignment="true" subsegmentStartsWithSAP="1">
       <Accessibility schemeIdUri="urn:tva:metadata:cs:AudioPurposeCS:2007" value="6"/>
       <Role schemeIdUri="urn:mpeg:dash:role:2011" value="main"/>
       <SegmentTemplate duration="192512" timescale="48000" media="$RepresentationID$/$RepresentationID$_$Number$.m4a" startNumber="1" initialization="$RepresentationID$/$RepresentationID$_0.m4a"/>
       <Representation id="bbb_a64k" codecs="mp4a.40.5" bandwidth="67071" audioSamplingRate="48000">
        <AudioChannelConfiguration schemeIdUri="urn:mpeg:dash:23003:3:audio_channel_configuration:2011" value="2"/>
       </Representation>
      </AdaptationSet>
    
      <AdaptationSet id="3" mimeType="image/jpeg" contentType="image">
        <SegmentTemplate media="$RepresentationID$/tile_$Number$.jpg" duration="100" startNumber="1"/>
          <Representation bandwidth="24000" id="thumbnails_256x144" width="2048" height="1024">
            <EssentialProperty schemeIdUri="http://dashif.org/guidelines/thumbnail_tile" value="5x2"/>
          </Representation>
      </AdaptationSet>
    
     </Period>
     </MPD>
    

HLS considerations
------------------

### Image media playlists for HLS

In HTTP Live Streaming (HLS), the traditional I-Frame playlist provides a sparse track of video frames for a client to use during trick-play and seek operations. The format currently specified by HLS is a coded video I-frame. This approach is efficient because it references frame data directly from the video stream and has the added benefit of supporting digital rights management. However, additional video decoding resources are required to process these I-frames for display, which can be problematic in some cases. To make these images more accessible on a wider range of client devices, Roku supports a second playlist format, which it developed in collaboration with Disney and WarnerMedia. This alternative format uses image files that have been compressed (usually via commonly-employed encoding schemes, e.g., JPEG). It extends the standard RFC 8216-bis – HTTP Live Streaming 2nd Edition, draft-pantos-hlsrfc8216bis- 04 ([https://tools.ietf.org/html/draft-pantos-hls-rfc8216bis-04](https://tools.ietf.org/html/draft-pantos-hls-rfc8216bis-04)). Many questions about the meaning and usage of the format elements can be answered by consulting the standard.

The alternative format adds the following tags to master playlists and image media playlists, respectively:

### Tag for master playlist

#### EXT-X-IMAGE-STREAM-INF

The EXT-X-IMAGE-STREAM-INF tag identifies an Image Media Playlist file containing Images in a compressed graphic image format. It stands alone, in that it does not apply to a particular URI in the Master Playlist.

##### Format:

#EXT-X-IMAGE-STREAM-INF:

##### Attributes:

> All attributes defined for the EXT-X-I-FRAME-STREAM-INF tag are also defined for the EXT-XIMAGE-STREAM-INF tag, except for HDCP-LEVEL and VIDEO-RANGE, which are not applicable.

| Name | Required? | Description/Notes | Example |
| --- | --- | --- | --- |
| URI | REQUIRED | The URI attribute value of EXT-X-IMAGE-STREAM-INF is a quoted-string containing a resource URI that identifies the Image Media Playlist file. That Playlist file MUST contain an EXT-XIMAGES-ONLY tag. | `"hd-tn.m3u8"``"640x360_5x4/640x360_5x4.m3u8"` |
| BANDWIDTH | REQUIRED | The value is a decimal-integer of bits per second. It represents the peak segment bit rate of the Variant Stream. If all the Media Segments in a Variant Stream have already been created, the BANDWIDTH value MUST be the largest sum of peak segment bit rates that is produced by any playable combination of Renditions. (For a Variant Stream with a single Media Playlist, this is just the peak segment bit rate of that Media Playlist.) An inaccurate value can cause playback stalls or prevent clients from playing the variant. If the Master Playlist is to be made available before all Media Segments in the presentation have been encoded, the BANDWIDTH value SHOULD be the BANDWIDTH value of a representative period of similar content, encoded using the same settings. | `BANDWIDTH=29729` |
| CODECS | REQUIRED | A quoted-string containing a comma-separated list of compressed graphic image formats present in the Image Media Playlist. Clients MUST ignore EXT-X-IMAGE-STREAM-INF tags that include unsupported CODECS attribute values. | `"jpeg``"`(if the Media Playlist file references JPEG images)`"ac-3,mp4a.40.2"`See [https://tools.ietf.org/html/rfc6381](https://tools.ietf.org/html/rfc6381) for a formal, detailed description of this attribute. |
| RESOLUTION | REQUIRED | declares a Target Resolution for the Image Media Playlist, to assist clients with Playlist selection. The resolution of Images referenced in an Image Media Playlist MUST NOT exceed the respective horizontal or vertical pixel dimension specified by RESOLUTION; otherwise, display errors can occur. When using the EXT-X-TILES tag in the Image Media Playlist, Target Resolution refers to the size of individual Image Tiles in the Grid. | `RESOLUTION=240×135` |
| VIDEO | OPTIONAL | The provisions in HLS Section 4.3.4.2.1 also apply to EXT-X-IMAGE-STREAM-INF tags with a VIDEO attribute. A Master Playlist that specifies alternative VIDEO Renditions and Image Media Playlists SHOULD include an alternative Image VIDEO Rendition for each regular VIDEO Rendition, with the same NAME and LANGUAGE attributes. |     |

### Tags for image media playlist

#### EXT-X-IMAGES-ONLY

The EXT-X-IMAGES-ONLY tag indicates that each resource URI in an Image Media Playlist is an Image Resource. By default, each Image Resource describes a single Image in a compressed graphic image format. If an Image Archive tag is present in the Playlist, the next Image Resource MAY contain multiple Images and require additional information for timing and display. Therefore, the client MUST use processing logic specific to the Image Archive type to ensure proper display.

The EXT-X-IMAGES-ONLY tag applies to the entire Image Media Playlist.

##### Format:

#EXT-X-IMAGES-ONLY

In a Playlist with the EXT-X-IMAGES-ONLY tag, the duration (EXTINF tag value) is the time between the presentation time of the Image Resource and the presentation time of the next Image Resource in the Playlist, or the end of the presentation if it is the last Image Resource in the Playlist. If the calculated duration of an Image Archive is greater than the EXTINF duration in the Playlist, the client MUST enforce the EXTINF Playlist duration and ignore Images that extend beyond the boundary.

When Image Media Playlists are present, all Media Playlists (audio, video, image, etc.) MUST contain synchronized EXT-X-DISCONTINUITY tags. In the case of a Live presentation, all Media Playlists MUST also contain synchronized EXT-X-PROGRAM-DATE-TIME and EXT-XDISCONTINUITY-SEQUENCE tags.

The requirement for declaring EXT-X-TARGETDURATION with a value greater-than or equal-to the largest EXTINF value in an Image Media Playlist MAY be ignored.

If an Image Resource is unavailable for the presentation, a placeholder Image Resource with an EXT-X-GAP tag and an EXTINF tag with appropriate duration SHOULD be used to signal the missing Image and preserve track alignment. The presence of an EXT-X-GAP tag on an Image Resource SHOULD NOT cause a client to look for another Variant Stream.

The File Signature (magic number) of an Image Resource, including Images referenced using EXT-X-BYTERANGE, MUST be a valid expected value for at least one entry in the CODECS attribute of the EXT-X-IMAGE-STREAM-INF tag referencing the Image Media Playlist. For example, the expected File Signature of a JPEG Image is 0xFFD8.

#### EXT-X-TILES

The EXT-X-TILES tag indicates the Image Resource is an Image Archive that contains one or more Images arranged in a Grid. A client processing the EXT-X-TILES tag MUST be capable of displaying individual Image Tiles using the Grid Sequence and Timing Model.

##### Format:

#EXT-X-TILES:

Attributes:

| Name | Required? | Description/Notes | Example |
| --- | --- | --- | --- |
| RESOLUTION | REQUIRED | The value is a decimal-resolution describing the pixel dimensions of a single Image in the Grid. | `RESOLUTION=320x180` |
| LAYOUT | REQUIRED | The value is a grid-item-dimension consisting of two positive decimal integers in the format: column-x-row (“4x3”). It describes the arrangement of Images in a Grid. The minimum valid LAYOUT is “1x1”. The maximum valid LAYOUT will depend on RESOLUTION and the maximum valid pixel dimensions allowed by the compressed graphic image format. | `LAYOUT=5x4` |
| DURATION | REQUIRED | The value is a decimal-floating-point or decimal-integer number of seconds indicating the display duration of a single Image Tile. | `DURATION=3.003` |

The Time Remaining for an Image Resource is the EXTINF duration minus the Total Elapsed Time of the Image Archive. Tiles are selected from the Grid in a specific Sequence starting top-left, moving left-to-right and top-to-bottom, following the Grid Layout. Each Tile from the Sequence is displayed for DURATION seconds or Time Remaining seconds, whichever is less. If Time Remaining is greater than zero when the Sequence completes, the last Image is displayed until Time Remaining is zero.

> Experimental results suggest that durations of around 10 seconds offer good performance vs. viewer convenience. As a general rule, the duration of each thumbnail should be be as long as the I-Frame, which it represents.

Standard-thumbnail file creation
--------------------------------

Roku has developed resources for producing standard-thumbnail tile files and playlists for HLS. This section describes those resources and their use.

### Mac prerequisites and installation

The following utility applications are needed:

*   ffmpeg: version 4.2.2
*   ImageMagick 7.0.10-7 Q16 x86\_64 2020-04-20, montage utility

### Linux (Centos 7) prerequisites and installation

The following utility applications are needed:

*   ffmpeg: version 2.8.15
*   ImageMagick 6.9.10-68 Q16 x86\_64 2020-04-01, montage utility

### Mac and Linux usage

Three Roku-provided scripts each do one task to build playlists.

1.  `gen_thumbs.sh`: uses ffmpeg to generate thumbnails from a stream `.mp4` or `.m3u8`, this script uses very simple ffmpeg options to generate thumbnails at fixed intervals.
2.  `gen_tiles.sh`: uses thumbnails generated in `gen_thumbs.sh`, and "assembles" them into a tile using the montage command from ImageMagick, e.g. 5x4 tiles.
3.  `gen_playlist.sh`: uses the tiles generated in `gen_tiles.sh` and outputs the thumbnail playlist, the output thumbnail playlist has to entered into the master playlist.

All three scripts must be run in sequence, which the `run_scripts_hls.sh` file does.

The following command generates 320x180 thumbnails and 5x4 tiles with 10 second intervals:

    $ ./run_scripts_hls.sh master.m3u8 thumb-tile 320x180 5 4 10
    

Here is a command that generates 640x360 thumbnails and 5x4 tiles with 10 seconds intervals:

    $ ./run_scripts_hls.sh master.m3u8 thumb-tile 640x360 5 4 10
    

Finally, the playlists generated by the two `run_scripts` commands should be entered into the master playlist, as so:

    #EXT-X-IMAGE-STREAM-INF:BANDWIDTH=16460,RESOLUTION=320x180,CODECS="jpeg",URI="5x4_320x180/320x180-5x4.m3u8"
    #EXT-X-IMAGE-STREAM-INF:BANDWIDTH=32920,RESOLUTION=640x360,CODECS="jpeg",URI="5x4_640x360/640x360-5x4.m3u8"
    

> All the materials mentioned in this article are available on GitHub, [here](https://github.com/rokudev/samples/tree/master/media/TrickPlayThumbnailsHLS).

Standard-thumbnail file creation for DASH
-----------------------------------------

Roku has also developed resources for producing standard-thumbnail tile files and playlists for DASH. This section describes those resources and their use.

### Mac prerequisites and installation

The following utility applications are needed:

*   [ffmpeg: version 4.3.1-skyzyx](https://github.com/homebrew-ffmpeg/homebrew-ffmpeg)

> This is a special version of ffmpeg that specifically supports DASH.

*   ImageMagick 7.0.10-7 Q16 x86\_64 2020-04-20, montage utility
    
*   python v3.8.5 (optional)
    

### Linux (Ubuntu 20.04) prerequisites and installation

The following utility applications are needed:

*   ffmpeg: version 4.2.4-1ubuntu0.1
*   ImageMagick 6.9.10-23 Q16 x86\_64 20190101, montage utility

### Mac and Linux usage

Three Roku-provided scripts each do one task to build playlists.

1.  `gen_thumbs.sh`: uses ffmpeg to generate thumbnails from a stream .mp4 or .mpd, this script uses very simple ffmpeg options to generate thumbnails at fixed intervals
2.  `gen_tiles.sh`: uses thumbnails generated in gen\_thumbs.sh, and "assembles" them into a tile using the montage command from ImageMagick, e.g. 5x2 tiles
3.  `gen_manifest.sh`: uses the tiles generated in gen\_tiles.sh and outputs an image/thumbnail manifest snippet to be entered into the master DASH manifest.

All three scripts must be run in sequence, a process that is automated by the `run_scripts_dash.sh` file.

The following command generates 256x144 thumbnails and 5x2 tiles with 10-second intervals.

    $ ./run_scripts_dash.sh master.mpd tile 256x144 5 2 10
    

After the thumbnails manifest snippet(s) are generated, they should be entered into the master manifest, as in the example below:

    <AdaptationSet id="3" mimeType="image/jpeg" contentType="image">
        <SegmentTemplate media="$RepresentationID$/tile_$Number$.jpg" duration="100" startNumber="1"/>
          <Representation bandwidth="24000" id="thumbnails_256x144" width="2048" height="1024">
            <EssentialProperty schemeIdUri="http://dashif.org/guidelines/thumbnail_tile" value="5x2"/>
          </Representation>
    </AdaptationSet>
    

> All the materials mentioned in this section are available on GitHub, [here](https://github.com/rokudev/samples/tree/master/media/TrickPlayThumbnailsDASH).

### Example Playlists

#### Master playlist sample 1

    #EXTM3U
    #EXT-X-VERSION:7
    #EXT-X-INDEPENDENT-SEGMENTS
    #EXT-X-MEDIA:TYPE=AUDIO,GROUP-ID="aac",NAME="English",LANGUAGE="en",AUTOSELECT=YES,\
    DEFAULT=YES,URI="layer8.m3u8"
    
    #EXT-X-STREAM-INF:BANDWIDTH=1499000,RESOLUTION=640x360,AUDIO="aac",\
    CODECS="avc1.4d401e,mp4a.40.2"
    layer1.m3u8
    #EXT-X-STREAM-INF:BANDWIDTH=2885000,RESOLUTION=960x540,AUDIO="aac",\
    CODECS="avc1.4d401f,mp4a.40.2"
    layer2.m3u8
    #EXT-X-STREAM-INF:BANDWIDTH=3964000,RESOLUTION=1280x720,AUDIO="aac",\
    CODECS="avc1.4d401f,mp4a.40.2"
    layer3.m3u8
    
    #EXT-X-I-FRAME-STREAM-INF:BANDWIDTH=129010,RESOLUTION=640x360,CODECS="avc1.4d401e",\
    URI="layer1-iframe.m3u8"
    #EXT-X-I-FRAME-STREAM-INF:BANDWIDTH=239655,RESOLUTION=960x540,CODECS="avc1.4d401f",\
    URI="layer2-iframe.m3u8"
    #EXT-X-I-FRAME-STREAM-INF:BANDWIDTH=352167,RESOLUTION=1280x720,CODECS="avc1.4d401f",\
    URI="layer3-iframe.m3u8"
    
    #EXT-X-IMAGE-STREAM-INF:BANDWIDTH=16460,RESOLUTION=240×135,CODECS="jpeg",\
    URI="sd-tn.m3u8"
    #EXT-X-IMAGE-STREAM-INF:BANDWIDTH=29729,RESOLUTION=640×360,CODECS="jpeg",\
    URI="hd-tn.m3u8"
    

#### Master playlist sample 2

    #EXTM3U
    #EXT-X-VERSION:5
    #EXT-X-INDEPENDENT-SEGMENTS
    
    #EXT-X-MEDIA:TYPE=AUDIO,GROUP-ID="aac",NAME="English",LANGUAGE="en",AUTOSELECT=YES,DEFAULT=YES,URI="layer8/layer8_cl_0.m3u8"
    
    #EXT-X-STREAM-INF:FRAME-RATE=29.970,BANDWIDTH=283000,AVERAGE-BANDWIDTH=267000,RESOLUTION=416x234,CLOSED-CAPTIONS="cc1",CODECS="avc1.4d400d,mp4a.40.2",AUDIO="aac"
    layer0/layer0_cl.m3u8
    #EXT-X-STREAM-INF:FRAME-RATE=29.970,BANDWIDTH=501000,AVERAGE-BANDWIDTH=465000,RESOLUTION=416x234,CLOSED-CAPTIONS="cc1",CODECS="avc1.4d400d,mp4a.40.2",AUDIO="aac"
    layer1/layer1_cl.m3u8
    #EXT-X-STREAM-INF:FRAME-RATE=29.970,BANDWIDTH=935000,AVERAGE-BANDWIDTH=859000,RESOLUTION=640x360,CLOSED-CAPTIONS="cc1",CODECS="avc1.4d401e,mp4a.40.2",AUDIO="aac"
    layer2/layer2_cl.m3u8
    #EXT-X-STREAM-INF:FRAME-RATE=29.970,BANDWIDTH=1500000,AVERAGE-BANDWIDTH=1352000,RESOLUTION=640x360,CLOSED-CAPTIONS="cc1",CODECS="avc1.4d401e,mp4a.40.2",AUDIO="aac"
    layer3/layer3_cl.m3u8
    #EXT-X-STREAM-INF:FRAME-RATE=29.970,BANDWIDTH=2047000,AVERAGE-BANDWIDTH=1842000,RESOLUTION=852x480,CLOSED-CAPTIONS="cc1",CODECS="avc1.4d401f,mp4a.40.2",AUDIO="aac"
    layer4/layer4_cl.m3u8
    #EXT-X-STREAM-INF:FRAME-RATE=29.970,BANDWIDTH=2891000,AVERAGE-BANDWIDTH=2597000,RESOLUTION=960x540,CLOSED-CAPTIONS="cc1",CODECS="avc1.4d401f,mp4a.40.2",AUDIO="aac"
    layer5/layer5_cl.m3u8
    #EXT-X-STREAM-INF:FRAME-RATE=29.970,BANDWIDTH=3971000,AVERAGE-BANDWIDTH=3577000,RESOLUTION=1280x720,CLOSED-CAPTIONS="cc1",CODECS="avc1.4d401f,mp4a.40.2",AUDIO="aac"
    layer6/layer6_cl.m3u8
    #EXT-X-STREAM-INF:FRAME-RATE=29.970,BANDWIDTH=5594000,AVERAGE-BANDWIDTH=5043000,RESOLUTION=1920x1080,CLOSED-CAPTIONS="cc1",CODECS="avc1.640028,mp4a.40.2",AUDIO="aac"
    layer7/layer7_cl.m3u8
    #EXT-X-STREAM-INF:BANDWIDTH=129000,AVERAGE-BANDWIDTH=129000,CLOSED-CAPTIONS="cc1",CODECS="mp4a.40.2",AUDIO="aac"
    layer8/layer8_cl_0.m3u8
    
    
    #EXT-X-IMAGE-STREAM-INF:BANDWIDTH=40000,RESOLUTION=320x180,CODECS="jpeg",URI="320x180_5x4/320x180_5x4.m3u8"
    #EXT-X-IMAGE-STREAM-INF:BANDWIDTH=80000,RESOLUTION=640x360,CODECS="jpeg",URI="640x360_5x4/640x360_5x4.m3u8"
    #EXT-X-IMAGE-STREAM-INF:BANDWIDTH=160000,RESOLUTION=960x540,CODECS="jpeg",URI="960x540_5x4/960x540_5x4.m3u8"
    
    #EXT-X-I-FRAME-STREAM-INF:BANDWIDTH=49759,AVERAGE-BANDWIDTH=17947,RESOLUTION=416x234,CLOSED-CAPTIONS="cc1",CODECS="avc1.4d400d",URI="layer1/layer1_cl-iframe.m3u8"
    #EXT-X-I-FRAME-STREAM-INF:BANDWIDTH=127115,AVERAGE-BANDWIDTH=46261,RESOLUTION=640x360,CLOSED-CAPTIONS="cc1",CODECS="avc1.4d401e",URI="layer3/layer3_cl-iframe.m3u8"
    #EXT-X-I-FRAME-STREAM-INF:BANDWIDTH=197846,AVERAGE-BANDWIDTH=67625,RESOLUTION=852x480,CLOSED-CAPTIONS="cc1",CODECS="avc1.4d401f",URI="layer4/layer4_cl-iframe.m3u8"
    #EXT-X-I-FRAME-STREAM-INF:BANDWIDTH=234179,AVERAGE-BANDWIDTH=83870,RESOLUTION=960x540,CLOSED-CAPTIONS="cc1",CODECS="avc1.4d401f",URI="layer5/layer5_cl-iframe.m3u8"
    #EXT-X-I-FRAME-STREAM-INF:BANDWIDTH=355410,AVERAGE-BANDWIDTH=122589,RESOLUTION=1280x720,CLOSED-CAPTIONS="cc1",CODECS="avc1.4d401f",URI="layer6/layer6_cl-iframe.m3u8"
    #EXT-X-I-FRAME-STREAM-INF:BANDWIDTH=506175,AVERAGE-BANDWIDTH=162353,RESOLUTION=1920x1080,CLOSED-CAPTIONS="cc1",CODECS="avc1.640028",URI="layer7/layer7_cl-iframe.m3u8"
    
    #EXT-X-MEDIA:TYPE=CLOSED-CAPTIONS,GROUP-ID="cc1",LANGUAGE="en",NAME="English",DEFAULT=YES,AUTOSELECT=YES,INSTREAM-ID="CC1"
    

#### VOD image media playlist sample 1a

    #EXTM3U
    #EXT-X-TARGETDURATION:6
    #EXT-X-VERSION:7
    #EXT-X-MEDIA-SEQUENCE:0
    #EXT-X-PLAYLIST-TYPE:VOD
    #EXT-X-IMAGES-ONLY
    
    #EXTINF:6.006,
    preroll-ad-1.jpg
    #EXTINF:6.006,
    preroll-ad-2.jpg
    #EXTINF:3.003,
    preroll-ad-3.jpg
    
    #EXT-X-DISCONTINUITY
    
    #EXTINF:60.060,
    #EXT-X-TILES:RESOLUTION=640x360,LAYOUT=5x2,DURATION=6.006
    content-0.jpg
    #EXTINF:60.060,
    #EXT-X-TILES:RESOLUTION=640x360,LAYOUT=5x2,DURATION=6.006
    content-1.jpg
    #EXTINF:60.060,
    #EXT-X-TILES:RESOLUTION=640x360,LAYOUT=5x2,DURATION=6.006
    content-2.jpg
    
    . . .
    
    #EXTINF:60.060,
    #EXT-X-TILES:RESOLUTION=640x360,LAYOUT=5x2,DURATION=6.006
    content-8.jpg
    #EXTINF:54.054,
    #EXT-X-TILES:RESOLUTION=640x360,LAYOUT=5x2,DURATION=6.006
    content-9.jpg
    
    #EXT-X-DISCONTINUITY
    
    #EXTINF:6.006,
    midroll-ad-1.jpg
    #EXTINF:6.006,
    midroll-ad-2.jpg
    #EXTINF:3.003,
    midroll-ad-3.jpg
    
    #EXT-X-DISCONTINUITY
    
    #EXTINF:60.060,
    #EXT-X-TILES:RESOLUTION=640x360,LAYOUT=5x2,DURATION=6.006
    content-10.jpg
    #EXTINF:60.060,
    #EXT-X-TILES:RESOLUTION=640x360,LAYOUT=5x2,DURATION=6.006
    content-11.jpg
    
    . . .
    
    #EXTINF:60.060,
    #EXT-X-TILES:RESOLUTION=640x360,LAYOUT=5x2,DURATION=6.006
    content-39.jpg
    
    #EXT-X-ENDLIST
    

#### VOD image media playlist sample 1b

    #EXTM3U
    #EXT-X-TARGETDURATION:6
    #EXT-X-VERSION:7
    #EXT-X-MEDIA-SEQUENCE:0
    #EXT-X-PLAYLIST-TYPE:VOD
    #EXT-X-IMAGES-ONLY
    
    # ~~ promo ~~
    
    #EXTINF:6.006,
    promo_1.jpg
    #EXTINF:6.006,
    promo_2.jpg
    #EXTINF:3.003,
    promo_3.jpg
    
    #EXT-X-DISCONTINUITY
    
    # ~~ movie ~~
    
    #EXTINF:24.024,
    #EXT-X-TILES:RESOLUTION=640x360,LAYOUT=4x3,DURATION=2.002
    movie_001.jpg
    #EXTINF:24.024,
    #EXT-X-TILES:RESOLUTION=640x360,LAYOUT=4x3,DURATION=2.002
    movie_002.jpg
    #EXTINF:24.024,
    #EXT-X-TILES:RESOLUTION=640x360,LAYOUT=4x3,DURATION=2.002
    movie_003.jpg
    
    . . .
    
    #EXTINF:24.024,
    #EXT-X-TILES:RESOLUTION=640x360,LAYOUT=4x3,DURATION=2.002
    movie_275.jpg
    
    #EXT-X-DISCONTINUITY
    
    # ~~ translation credits ~~
    
    #EXTINF:24.024,
    #EXT-X-TILES:RESOLUTION=640x360,LAYOUT=4x3,DURATION=2.002
    credits_2_0.jpg
    #EXTINF:6.006,
    #EXT-X-TILES:RESOLUTION=640x360,LAYOUT=4x3,DURATION=2.002
    credits_2_1.jpg
    
    #EXT-X-ENDLIST
    

#### VOD image media playlist sample 2a

    #EXTM3U
    #EXT-X-TARGETDURATION:60
    #EXT-X-VERSION:7
    #EXT-X-MEDIA-SEQUENCE:0
    #EXT-X-PLAYLIST-TYPE:VOD
    #EXT-X-IMAGES-ONLY
    #EXTINF:60.060,
    #EXT-X-TILES:RESOLUTION=320x180,LAYOUT=5x4,DURATION=3.003
    0.jpg
    #EXTINF:60.060,
    #EXT-X-TILES:RESOLUTION=320x180,LAYOUT=5x4,DURATION=3.003
    1.jpg
    #EXTINF:60.060,
    #EXT-X-TILES:RESOLUTION=320x180,LAYOUT=5x4,DURATION=3.003
    2.jpg
    #EXTINF:60.060,
    #EXT-X-TILES:RESOLUTION=320x180,LAYOUT=5x4,DURATION=3.003
    3.jpg
    #EXTINF:60.060,
    #EXT-X-TILES:RESOLUTION=320x180,LAYOUT=5x4,DURATION=3.003
    4.jpg
    #EXTINF:60.060,
    #EXT-X-TILES:RESOLUTION=320x180,LAYOUT=5x4,DURATION=3.003
    5.jpg
    #EXTINF:60.060,
    #EXT-X-TILES:RESOLUTION=320x180,LAYOUT=5x4,DURATION=3.003
    6.jpg
    #EXTINF:60.060,
    #EXT-X-TILES:RESOLUTION=320x180,LAYOUT=5x4,DURATION=3.003
    7.jpg
    #EXTINF:60.060,
    #EXT-X-TILES:RESOLUTION=320x180,LAYOUT=5x4,DURATION=3.003
    8.jpg
    #EXTINF:60.060,
    #EXT-X-TILES:RESOLUTION=320x180,LAYOUT=5x4,DURATION=3.003
    9.jpg
    #EXTINF:60.060,
    #EXT-X-TILES:RESOLUTION=320x180,LAYOUT=5x4,DURATION=3.003
    10.jpg
    #EXTINF:60.060,
    #EXT-X-TILES:RESOLUTION=320x180,LAYOUT=5x4,DURATION=3.003
    11.jpg
    #EXTINF:15.015,
    #EXT-X-TILES:RESOLUTION=320x180,LAYOUT=5x4,DURATION=3.003
    12.jpg
    #EXT-X-ENDLIST
    

#### VOD image media playlist sample 2b

    #EXTM3U
    #EXT-X-TARGETDURATION:60
    #EXT-X-VERSION:7
    #EXT-X-MEDIA-SEQUENCE:0
    #EXT-X-PLAYLIST-TYPE:VOD
    #EXT-X-IMAGES-ONLY
    #EXTINF:60.060,
    #EXT-X-TILES:RESOLUTION=640x360,LAYOUT=5x4,DURATION=3.003
    0.jpg
    #EXTINF:60.060,
    #EXT-X-TILES:RESOLUTION=640x360,LAYOUT=5x4,DURATION=3.003
    1.jpg
    #EXTINF:60.060,
    #EXT-X-TILES:RESOLUTION=640x360,LAYOUT=5x4,DURATION=3.003
    2.jpg
    #EXTINF:60.060,
    #EXT-X-TILES:RESOLUTION=640x360,LAYOUT=5x4,DURATION=3.003
    3.jpg
    #EXTINF:60.060,
    #EXT-X-TILES:RESOLUTION=640x360,LAYOUT=5x4,DURATION=3.003
    4.jpg
    #EXTINF:60.060,
    #EXT-X-TILES:RESOLUTION=640x360,LAYOUT=5x4,DURATION=3.003
    5.jpg
    #EXTINF:60.060,
    #EXT-X-TILES:RESOLUTION=640x360,LAYOUT=5x4,DURATION=3.003
    6.jpg
    #EXTINF:60.060,
    #EXT-X-TILES:RESOLUTION=640x360,LAYOUT=5x4,DURATION=3.003
    7.jpg
    #EXTINF:60.060,
    #EXT-X-TILES:RESOLUTION=640x360,LAYOUT=5x4,DURATION=3.003
    8.jpg
    #EXTINF:60.060,
    #EXT-X-TILES:RESOLUTION=640x360,LAYOUT=5x4,DURATION=3.003
    9.jpg
    #EXTINF:60.060,
    #EXT-X-TILES:RESOLUTION=640x360,LAYOUT=5x4,DURATION=3.003
    10.jpg
    #EXTINF:60.060,
    #EXT-X-TILES:RESOLUTION=640x360,LAYOUT=5x4,DURATION=3.003
    11.jpg
    #EXTINF:15.015,
    #EXT-X-TILES:RESOLUTION=640x360,LAYOUT=5x4,DURATION=3.003
    12.jpg
    #EXT-X-ENDLIST
    

#### VOD image media playlist sample 2c

    #EXTM3U
    #EXT-X-TARGETDURATION:60
    #EXT-X-VERSION:7
    #EXT-X-MEDIA-SEQUENCE:0
    #EXT-X-PLAYLIST-TYPE:VOD
    #EXT-X-IMAGES-ONLY
    #EXTINF:60.060,
    #EXT-X-TILES:RESOLUTION=960x540,LAYOUT=5x4,DURATION=3.003
    0.jpg
    #EXTINF:60.060,
    #EXT-X-TILES:RESOLUTION=960x540,LAYOUT=5x4,DURATION=3.003
    1.jpg
    #EXTINF:60.060,
    #EXT-X-TILES:RESOLUTION=960x540,LAYOUT=5x4,DURATION=3.003
    2.jpg
    #EXTINF:60.060,
    #EXT-X-TILES:RESOLUTION=960x540,LAYOUT=5x4,DURATION=3.003
    3.jpg
    #EXTINF:60.060,
    #EXT-X-TILES:RESOLUTION=960x540,LAYOUT=5x4,DURATION=3.003
    4.jpg
    #EXTINF:60.060,
    #EXT-X-TILES:RESOLUTION=960x540,LAYOUT=5x4,DURATION=3.003
    5.jpg
    #EXTINF:60.060,
    #EXT-X-TILES:RESOLUTION=960x540,LAYOUT=5x4,DURATION=3.003
    6.jpg
    #EXTINF:60.060,
    #EXT-X-TILES:RESOLUTION=960x540,LAYOUT=5x4,DURATION=3.003
    7.jpg
    #EXTINF:60.060,
    #EXT-X-TILES:RESOLUTION=960x540,LAYOUT=5x4,DURATION=3.003
    8.jpg
    #EXTINF:60.060,
    #EXT-X-TILES:RESOLUTION=960x540,LAYOUT=5x4,DURATION=3.003
    9.jpg
    #EXTINF:60.060,
    #EXT-X-TILES:RESOLUTION=960x540,LAYOUT=5x4,DURATION=3.003
    10.jpg
    #EXTINF:60.060,
    #EXT-X-TILES:RESOLUTION=960x540,LAYOUT=5x4,DURATION=3.003
    11.jpg
    #EXTINF:15.015,
    #EXT-X-TILES:RESOLUTION=960x540,LAYOUT=5x4,DURATION=3.003
    12.jpg
    #EXT-X-ENDLIST
    

#### Live image media playlist sample 1

    #EXTM3U
    #EXT-X-TARGETDURATION:6
    #EXT-X-VERSION:7
    #EXT-X-MEDIA-SEQUENCE:127228
    #EXT-X-IMAGES-ONLY
    #EXT-X-DISCONTINUITY-SEQUENCE:5
    
    #EXT-X-PROGRAM-DATE-TIME:2019-04-17T19:28:12.046Z
    #EXTINF:6.006,
    content-123.jpg
    #EXTINF:6.006,
    content-124.jpg
    #EXTINF:6.006,
    content-125.jpg
    
    #EXT-X-DISCONTINUITY
    
    #EXT-X-PROGRAM-DATE-TIME:2019-04-17T19:28:30.064Z
    #EXT-X-GAP
    #EXTINF:6.006,
    missing-midroll.jpg
    #EXT-X-GAP
    #EXTINF:6.006,
    missing-midroll.jpg
    #EXT-X-GAP
    #EXTINF:3.003, missing-midroll.jpg
    
    #EXT-X-DISCONTINUITY
    
    #EXT-X-PROGRAM-DATE-TIME:2019-04-17T19:28:45.079Z
    #EXTINF:6.006,
    content-128.jpg
    #EXTINF:6.006,
    content-129.jpg
    #EXTINF:6.006,
    content-130.jpg
    #EXTINF:6.006,
    content-131.jpg
    

#### ASSOC-LANGUAGE audio rendition attribute

As of Roku OS 10.0, the HLS **ASSOC-LANGUAGE** audio rendition attribute is supported. This optional attribute is used, for example, to specify that a particular rendition's audio, provided in a given spoken language dialect, is represented in forced subtitles by a different but associated language.

In the following example manifest, Cantonese audio (language=yue) should use Traditional Chinese (LANGUAGE=zh\_HANT) forced subtitles. This is indicated by an ASSOC-LANGUAGE=zh\_HANT on the audio track.

    #EXTM3U
    #EXT-X-INDEPENDENT-SEGMENTS
    
    #EXT-X-MEDIA:TYPE=AUDIO,GROUP-ID="aac-96k",NAME="English",LANGUAGE="en",DEFAULT=YES,AUTOSELECT=YES,URI="aac_96k/vod.m3u8"
    #EXT-X-MEDIA:TYPE=AUDIO,GROUP-ID="aac-96k",NAME="Cantonese (粵語)",LANGUAGE="yue",ASSOC-LANGUAGE="zh-HANT",DEFAULT=NO,AUTOSELECT=YES,URI="aac_96k/vod.m3u8"
    
    #EXT-X-MEDIA:TYPE=SUBTITLES,GROUP-ID="subs",NAME="zh-ZANT--forced--",LANGUAGE="zh-HANT",DEFAULT=YES,FORCED=YES,URI="vtt-can/vod.m3u8"
    #EXT-X-MEDIA:TYPE=SUBTITLES,GROUP-ID="subs",NAME="繁體中文 [CC]",LANGUAGE="zh-HANT",DEFAULT=YES,FORCED=NO,CHARACTERISTICS="public.accessibility.transcribes-spoken-dialog,public.accessibility.describes-music-and-sound",URI="vtt-can/vod.m3u8"
    
    #EXT-X-STREAM-INF:BANDWIDTH=3520820,AVERAGE-BANDWIDTH=2515571,CODECS="mp4a.40.2,avc1.4d4020",RESOLUTION=960x408,AUDIO="aac-96k",SUBTITLES="subs"
    2500k/vod.m3u8
    
    #EXT-X-STREAM-INF:BANDWIDTH=4803229,AVERAGE-BANDWIDTH=3510860,CODECS="mp4a.40.2,avc1.640028",RESOLUTION=1280x544,AUDIO="aac-96k",SUBTITLES="subs"
    3500k/vod.m3u8
    
    #EXT-X-I-FRAME-STREAM-INF:BANDWIDTH=218215,CODECS="avc1.4d4020",RESOLUTION=960x408,URI="2500k/vod-iframe.m3u8"
    

Sample app
----------

You can [download and install a sample app](https://github.com/rokudev/samples) that demonstrates how to produce standard thumbnail tile files and playlists for [DASH](https://github.com/rokudev/samples/tree/master/media/TrickPlayThumbnailsDASH) and [HLS](https://github.com/rokudev/samples/tree/master/media/TrickPlayThumbnailsDASH).

File system
===========

Application storage
-------------------

Several means are available for an application to store data:

| Storage | Advantages | Disadvantages |
| --- | --- | --- |
| file in tmp: | Files are read/write | Contents are not retained when application exits.  <br>  <br>Unmanaged. Does not automatically delete data unless the application actively manages the directory. This increases app's memory usage, which could result in an app failures. |
| file in cachefs: | Files are read/write; an arbitrary amount of data can be written.  <br>  <br>cachefs use is per developer ID. Files in cachefs are stored in RAM; therefore, a reboot will evict them from cachefs.  <br>  <br>Does not count towards app’s total memory usage | Data is evicted when more space is required for another app |
| file in pkg: | Accesses any files included in app package | Files are read-only |
| file on USB device | Accesses files on removable USB media | Files are read-only; not all Roku models support USB |
| Registry | Data is read/write; data is retained when the application exits and when the system reboots | Data size is limited. Each app has access to only 32kb of registry space. |

### Cachefs

Developers can use the cachefs: file system to allow applications to cache data to volatile or persistent storage instead of tmp:. End-users can add an external SD card to their device which will preserve the data even after a system reboot and improve performance. Users without extended storage also benefit from the use of a shared in-memory cache that is automatically managed by the system to optimize for the most recently used assets.

Note that the OS can evict the data at any time, such as when another app decides to write so much data that space is required. Thus, a app should always check for the existence of the file they wrote to before relying on the data cache.

Depending on your application's requirements, you can choose one of these options. Interfaces to the registry are documented at [roRegistry](/docs/references/brightscript/components/roregistry.md). Interfaces to files are described below.

Pathnames
---------

A Roku Streaming Player Pathname identifies a file. Pathnames are used in [ifFileSystem](/docs/references/brightscript/interfaces/iffilesystem.md) methods, as well as in other components which use files. A Pathname is a string with the following format:

    device:/dir1/dir2/…/filename
    

The device field (sometimes called PHY) identifies the location of the file and can be one of:

*   **tmp** - Temporary file storage device for the application
*   **pkg** - The root of the application directory that provides read-only access to files provided in the pkg
*   **common** – A common read-only filesystem that all plugins have access to. Currently, it only contains a CA certificate bundle that contains CA certs trusted by Firefox ([common:/certs/ca-bundle.crt](http://common/certs/ca-bundle.crt)). You are encouraged to use this file in your apps, especially if you are aggregating many different feeds. Please see the twitterOAuth sample application for a usage example.
*   **ext1, ext2, …,ext9** – Storage devices recognized on the USB bus. Please see the USB player sample application for a usage example.

There is no concept of a current working directory or relative paths. All path names **must** use the absolute Roku Streaming Player Pathname format above.

The filename components in a pathname may not contain any of these characters:

      <  >  :  "  /  |  ?  *
    

nor any whitespace or non-printable character.

Example
-------

**Example of path names used from BrightScript**

    theme.OverhangSliceSD = "pkg:/images/Overhang_Slice_SD43.png"
    
    http.Http.GetToFile("tmp:/categorylist")
    
    DeleteFile("tmp:/categorylist")
    
    obj.SetCertificatesFile("common:/certs/ca-bundle.crt")

roDsa
=====

The DSA component provides support for the ECDSA and EdDSA (with Ed25519 form) digital signature algorithms. It is used to provide cryptographically signed evidence that an ad request originated from an actual Roku device.

Supported interfaces
--------------------

*   [ifDsa](/docs/references/brightscript/interfaces/ifdsa.md)

roXMLList
=========

Contains a list of roXML objects.

Normally roXMLList objects are not created via CreateObject(), but are returned from various ifXMLElement functions such as GetChildElements() and GetBod

Supported interfaces
--------------------

*   [ifList](/docs/references/brightscript/interfaces/iflist.md "ifList")
*   [ifXMLList](/docs/references/brightscript/interfaces/ifxmllist.md "ifXMLList")
*   [ifListToArray](/docs/references/brightscript/interfaces/iflisttoarray.md "ifListToArray")

StdDlgTextItem
==============

Extends [StdDlgItemBase](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-item-base.md "**StdDlgItemBase**")

The **StdDlgTextItem** node is used to display a block of text. It should only be used as a child of a [**StdDlgContentArea**](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-content-area.md) node.

![roku815px - StdDlgTextItem](https://image.roku.com/ZHZscHItMTc2/std-dlg-text-item.jpg)

> To separate lines of text, use multiple **StdDlgTextItem** nodes. Do not use newline characters.

Fields
------

FieldTypeDefaultAccess PermissionDescriptiontextstring""READ\_WRITESpecifies the text to be displayed. If the text width does not fit within the width of the content area, the text will wrap onto multiple lines.namedTextStylestring"normal"READ\_WRITESpecifies a named style to be used for the displayed text's color and font. The supported styles include:  

| Style Name | Palette Color | Font |
| --- | --- | --- |
| "normal" | DialogTextColor | SmallSystemFont |
| "secondary" | DialogSecondaryTextColor | SmallestSystemFont |
| "bold" | DialogTextColor | SmallBoldSystemFont |

audioGuideTextstring""READ\_WRITESpecifies the string to be spoken when the screen reader reads the text item. By default, the screen reader reads the string specified in the **text** field.

Sample app
----------

You can download and install a [sample app](https://github.com/rokudev/standard-dialog-framework) that demonstrates how to create a custom dialog that uses the text item.

Implementing voice controls
===========================

Voice controls enable your app to handle commands from the Roku voice remote and Roku mobile app. This makes it easy for your customers to control the playback of your content with the convenience of voice commands, which enhances the overall user experience of your app.

With voice controls, your app can respond to:

*   [Basic commands](#basic-voice-controls) such as "play", pause", "ok", fast forward", "rewind", "resume", and "replay".

*   [Enhanced commands](#enhanced-voice-controls) such as "rewind 30 seconds" and "forward 10 minutes" (referred to as "seek" commands), "start over", and "next" (for playing the next video clip in a playlist).

*   [Additional enhanced commands](#additional-enhanced-voice-controls) such as "what's playing" to display the title of the content currently in playback (referred to as "nowplaying"), "skip intro"/"skip recap" to skip the current section being played (referred to as "skip"), "shuffle" to randomly select content in a playlist, "loop" to repeat the content in a playlist, and "like"/"dislike" to rate content.

> Implementing the [basic](#basic-voice-controls), [enhanced](#enhanced-voice-controls), and [additional enhanced](#additional-enhanced-voice-controls) voice controls is required for apps that have streamed more than an average of 5 million hours per month over the last three months to pass [certification](/docs/developer-program/certification/certification.md#4-channel-operation) (it is also required for new apps expected to reach this threshold shortly after launch).

By default, the Roku OS handles supports for the basic commands. However, apps must still implement [error handling](#error-handling) for any unsupported basic commands.

In order for your app to support the enhanced voice controls, which include "seek", "start over", and "next", you must update the [manifest](/docs/developer-program/getting-started/architecture/channel-manifest.md) and implement the [roInput](/docs/references/brightscript/components/roinput.md) object to listen for and handle voice commands.

Updating the manifest
---------------------

To support the voice controls, add the following flags in the [manifest](/docs/developer-program/getting-started/architecture/channel-manifest.md):

| Feature | Manifest Entry |
| --- | --- |
| App supports voice controls. | supports\_voice\_roinput=1 |
| App handles the "seek" and "start over" voice commands. | supports\_etc\_seek=1 |
| App handles the "next" voice command. | supports\_etc\_next=1 |

If you do not enable the **supports\_etc\_seek** and **supports\_etc\_next** manifest flags, an error message will be displayed when users try to use the "seek", "start over", and "next" voice commands on your app.

Handling voice commands
-----------------------

To handle voice commands in your app, your application needs to use the [**roInput**](/docs/references/brightscript/components/roinput.md) object to listen for transport control events and process them. To do this, follow these steps:

1.  Create an **roInput** object, and set the [**roMessagePort**](/docs/references/brightscript/components/romessageport.md) for receiving events.
    
        input = CreateObject("roInput")
        port = CreateObject("roMessagePort")
        input.SetMessagePort(port)
        
    

2.  Register the **roInput** component for voice commands by calling its  [**EnableTransportEvents()**](docs/references/brightscript/interfaces/ifinput.md#enabletransportevents-as-boolean) function. This tells the Roku OS that your app can handle voice commands sent to the **roInput** object. Once this is set, your app will receive **roInput** events for every voice command on this **roInput** object.
    
        input.enableTransportEvents()
        
    

3.  Use a message loop to listen for the voice commands. In the message loop, do the following:
    
    a. Use the [**roInputEvent.GetInfo()**](/docs/references/brightscript/events/roinputevent.md#getinfo-as-object) method to check for voice control commands sent to your app. This method returns an AssociativeArray with the following fields: **type**, **id, command**.
    
    *   You can use the **type** key to verify that the event received is a voice command (transport event), and the **command** key to identify the specific command.
        
    *   For the "seek" command, the AssociativeArray will contain two additional fields: **direction** and **duration**. The **direction** field indicates whether the seek command is for skipping "forward" or "backward"; the **duration** field specifies how many seconds to skip forward or backward.
        
    *   Seek functionality can also be implemented via trickplay using the [**Video.seek**](/docs/references/scenegraph/media-playback-nodes/video.md#trickplay-fields) field. In this case, the app must implement the [Roku Advertising Framework](/docs/developer-program/advertising/roku-advertising-framework.md) (or not include ads). The seek voice control attribute must also be enabled in the [Roku manifest](/docs/developer-program/getting-started/architecture/channel-manifest.md) (**supports\_etc\_seek=1**).
        
    
    b. Call the [**roInput.EventResponse()**](/docs/references/brightscript/interfaces/ifinput.md#eventresponseroassociativearray-aa-as-boolean) method to indicate that you have handled the voice command.
    
    *   This method takes an AssociativeArray with two fields: **id** and **status**. The **id** field specifies the transport ID event; the **status** specifies whether the event was handled, handled with an error, or unhandled.
        
    *   This method should be called immediately after a voice command is received. If your application does not handle a transport event (or the command is unknown or not implemented in your app), mark it as "error.generic" or "unhandled". See [Error handling](#error-handling) for the complete list of error messages to which the **status** field can be set.
        
    
    c. Optionally, for better modularization, you can pass the captured voice command to a function for handing.
    
             while m.isPlaying
                 msg = wait(0, port)
                 if type(msg) = "roInputEvent" then
                     info = msg.GetInfo()
                     if info.type = "transport" then
                         eventRet = {status: "unhandled"}
                         player = m.top.getScene().findNode("myVideoPlayer")
                         if player <> invalid then
                             eventRet = player.callFunc("handleTransport", info)
                         end if
                         eventRet.id = info.id
                         input.EventResponse(eventRet)
                     end if
                     'else if ...
                     ' ... handling of other events
                end if
             end while
        
    

4.  Add business logic for handling each voice command. In this example, a function is used to receive the voice command and implement the required behavior. As a best practice, set the **ret.status** field to "unhandled" by default, and then update it to "success" if your app handles the command, or "error.generic" if the app cannot fulfill it. Setting the status to "error.generic" displays "That is not available" in the Roku Voice heads-up display. The default "unhandled" status results in the Roku OS executing the default behavior.
    
        function handleTransport(evt)
            cmd = evt.command
            ret = {status: "unhandled"}
        
            if cmd = "play"
                'handle "play" command
                ret.status = "success"
        
            else if cmd = "pause"
                'handle "pause" command
                ret.status = "success"
        
            else if cmd = "stop"
                'handle "stop" command
                ret.status = "success"
        
            else if cmd = "forward"
                'handle "forward" command
                ret.status = "success"
        
            else if cmd = "rewind"
                'handle "rewind" command
                ret.status = "success"
        
            else if cmd = "replay"
                'handle "replay" command
                ret.status = "success"
        
            else if cmd = "seek"
                duration = evt.duration.toInt()
                if evt.direction = "backward" then
                    duration = -duration
                    seekPosition = m.videoplayer.position + duration
                    if seekPosition > m.videoplayer.duration then
                        ret.status = "success.seek-end"
                        seekPosition = m.videoplayer.duration - 30
                    else if seekPosition < 0
                        then ret.status = "success.seek-start"
                        seekPosition = 0
                    end if
                m.seekPosition = seekPosition playVideoFrom()
                ret.status = "success"
        
            else if cmd = "next"
                'skip to next content item in playlist'
                ret.status = "success"
            end if
        
            else if cmd = "nowplaying"
                'handle nowplaying command
                appmgr = CreateObject("roAppManager")
                appmgr.SetNowPlayingContentMetaData({
                    title: "<title>",
                    contentType: "<contentType>"
                })
                ret.status = "success"
            end if
        
            else if cmd = "loop"
                'handle "loop" command
                 ret.status = "success"
            end if
        
            else if cmd = "shuffle"
                'handle "shuffle" command
                ret.status = "success"
            end if
        
            else if cmd = "skip"
                'handle "skip intro" command OR handle same as "next" if channel have no into/recap to skip
                ret.status = "success"
            end if
        
            else if cmd = "like"
                'handle "like" command
                'optionally display a song's artist, genre, or track, or playlist title in the Roku heads-up display
                ret.music_track = "Messages"
                ret.status = "success"
            end if
        
            return ret
        end function
        
    

Error handling
--------------

As described in [Handling voice commands](#handling-voice-commands), apps must immediately call the [**roInput.EventResponse()**](/docs/references/brightscript/interfaces/ifinput.md#eventresponseroassociativearray-aa-as-boolean) method upon receiving a voice command to indicate that the voice command has been handled. If your application does not handle a transport event (or the command is unknown or not implemented in your app), mark it as "error.generic" or "unhandled".

For convenience, the list of possible values for the **status** field of the associative array taken by the [**roInput.EventResponse()**](/docs/references/brightscript/interfaces/ifinput.md#eventresponseroassociativearray-aa-as-boolean) method is as follows:

*   "error.generic" (_Available since Roku OS 10.0_). No active media is available to fulfill the voice command. Passing this status displays "That is not available" in the Roku Voice heads-up display. This can be used in cases, for example, when an app receives a "forward" or "next" command, but there is no content to fast forward or play next, respectively.
    
*   "unhandled". The app is not handling the event. The default behavior is executed by the Roku OS, if defined.
    

*   "error". The app failed to handle the event in that instance.

*   "error.ad". The transport command failed because an ad is playing.

*   "error.channel". The app does not support this command in any context.

*   "error.live". The transport command failed because the content is live.

*   "error.no-media". There is no media active.

*   "error.redundant". The transport command does not change the current state ("pause" command sent when the content is already paused)

*   "success". The app handled the event successfully.

*   "success.seek-start". A seek command was handled successfully, but the seek duration was before the beginning.

*   "success.seek-end". A seek command was handled successfully but the seek location was past the end.

Ad breaks
---------

During ad breaks, apps may only handle “pause” and “play” voice commands. Apps must acknowledge all other voice commands received during ad breaks as "error.ad" or "error.generic".

Custom trick mode and SSAI
--------------------------

If your app is using a custom trick mode or it is using a server-side ad insertion (SSAI) implementation of the Roku Advertising Framework (RAF), it must explicitly [handle enhanced voice commands](#handling-voice-commands) in order for customers to use "seek", "start over", and "next" commands when watching content.

If your app has content organized in a playlist, and it is using standard trick mode and a client-side RAF implementation, it only must handle the "next" command to play the next clip in the list.

The following table summarizes which apps need to implement handling for enhanced voice commands:

| App implementation | Handling "seek" and "start over" commands required? | Handling "next" command required (content is in a playlist)? |
| --- | --- | --- |
| Standard trick mode | no  | yes |
| Custom trick mode | yes | yes |
| Client-side RAF integration | no  | yes |
| SSAI RAF integration | yes | Yes |

Using ECP commands for testing voice controls
---------------------------------------------

You can test voice controls in an app by sending [External Control Protocol (ECP)](/docs/developer-program/dev-tools/external-control-api.md) commands via cURL to your Roku device. Specifically, send an HTTP POST request to port 8060 on your Roku device using the following syntax:

    curl -d '' 'http://<roku-device-ip-address>:8060/input/<channelId>?id=<longInteger>&type=transport&command=<commandValue>'
    

| Parameter | Description | Example |
| --- | --- | --- |
| input | Use the **input** command for passing transport events. |     |
| channelId | Enter one of the following:<br><br>*   **dev**. Sideloaded app.<br>*   <**id**\>. Public or [beta](/docs/developer-program/publishing/channel-publishing-guide.md#beta-channel-guidelines) apps. To find your app ID, use the preview page on the [Developer Dashboard](https://developer.roku.com/developer). | dev |
| id  | Assign a unique ID (as a LongInteger) to the transport event. | 5   |
| type | Enter "transport" to specify that you are sending a transport event. | "transport" |
| command | Enter the type of transport event.  <br>  <br>If you are sending a "seek" command, you must pass two additional fields: **direction** and **duration**. | "seek" |
| direction | For the "seek" command only. Enter "forward" or "backward". | "backward" |
| duration | For the "seek" command only. Enter how many seconds to skip forward or backward. | "10" |

The following examples show how to send ECP commands via cURL HTTP POST requests. The examples are based on a sideloaded app handling forward and seek commands.

    curl -d '' 'http://192.168.1.114:8060/input/dev?id=5&type=transport&command=forward'
    

    curl -d '' 'http://192.168.1.114:8060/input/dev?id=8&type=transport&command=seek&direction=backward&duration=10'
    

Sample app
----------

You can download and install a [sample app](https://github.com/rokudev/transport-control) that demonstrates how to implement voice controls. It demonstrates how to handle voice commands in your app, and it shows you how to use the [**roInputEvent**](/docs/references/brightscript/events/roinputevent.md) to listen for transport events and then process them. This sample includes standard and custom video player apps, a live app, and an app implementing server-side ad insertion [SSAI](/docs/developer-program/advertising/ssai-adapters.md) via the [Roku Advertising Framework (RAF)](/docs/developer-program/advertising/roku-advertising-framework.md):

*   The standard UI app shows how the native Roku Media Player handles voice controls. You can run this app and use the [debug console](/docs/developer-program/debugging/debugging-channels.md) to view output related to transport events.
*   The custom UI, live, and SSAI apps shows how your application can receive and process voice controls. This is especially important if your app uses custom [trick mode](/docs/developer-program/media-playback/trick-mode.md) or it is using a RAF SSAI implementation because your app must explicitly handle "seek" and "start over" transport commands in these cases.

Video demo
----------

For a video demonstration of voice controls, see the [Voice overview guide](/docs/features/voice/overview.md).

Voice control required behavior
-------------------------------

The following table summarizes the different voice controls, how they may be invoked, and their required behavior: 

> If your app does not handle one of the listed voice controls (or it is unknown or not implemented in your app), [mark it as "error.generic" or "unhandled"](#errror-handling).

### Basic voice controls

| Voice control | Voice command examples | Required behavior (in menu) | Required behavior (VOD/Music) | Required behavior (live linear) |
| --- | --- | --- | --- | --- |
| play | "play"  <br>"resume" (if paused) | *   Content in focus: start playback.<br>*   Unable to start playback: show details screen. | *   Video paused: resume media.<br>*   Video fast forwarding or rewinding: resume media.<br>*   Video playing: acknowledge command as handled; the Roku OS will display "Playing". | *   App supports command: display appropriate message.<br>*   App does not support command: acknowledge command as unhandled; the Roku OS will display “Command not available”. |
| ok  | "OK"  <br>"yes" | *   Content in focus: show details screen.<br>*   In profile section screen: select profile. | Take one of the following actions:  <br><br>*   show title<br>*   pause playback<br>*   display timeline (a second “ok” command typically pauses content while the timeline is shown)<br>*   ignore command | *   App supports command: display appropriate message.<br>*   App does not support command: acknowledge command as unhandled; the Roku OS will display “Command not available”. |
| pause | "pause"  <br>"stop" | Acknowledge command as unhandled; the Roku OS will display “Command not available”. | *   Video playing: pause media.<br>*   Video fast forwarding or rewinding: pause media.<br>*   Video paused: acknowledge command as unhandled; the Roku OS will display “Command not available”. | *   App supports command: display appropriate message.<br>*   App does not support command: acknowledge command as unhandled; the Roku OS will display “Command not available”. |
| replay | "replay"  <br>"instant replay" | Acknowledge command as unhandled; the Roku OS will display “Command not available”. | Rewind media 10 to 25 seconds (actual rewind time depends on your application's implementation of Roku instant replay feature). | *   App supports command: display appropriate message.<br>*   App does not support command: acknowledge command as unhandled; the Roku OS will display “Command not available”. |
| rewind | "rewind"  <br>"start rewinding"  <br>"can you rewind?" | Acknowledge command as unhandled; the Roku OS will display “Command not available”. | Rewind media until another command is received and processed. Alternatively, app can revert playback position by a fixed number of seconds. | *   App supports command: display appropriate message (for example, display "cannot rewind" if at end of buffer).<br>*   App does not support command: acknowledge command as unhandled; the Roku OS will display “Command not available”. |
| forward | "fast forward"  <br>"forward"  <br>"start forwarding"  <br>"can you forward?"  <br>"can you fast forward?" | Acknowledge command as unhandled; the Roku OS will display “Command not available”. | *   Fast forward media until another command is received and processed. Alternatively, app can advance playback a fixed number of seconds.<br>*   If media is already fast forwarding, speed up the fast forwarding or acknowledge command as unhandled (the Roku OS will display “Fast forwarding...)”. | *   App supports command: display appropriate message (for example, display "cannot fast forward any further").<br>*   App does not support command: acknowledge command as unhandled; the Roku OS will display “Command not available”. |

### Enhanced voice controls

| Voice control | Voice command examples | Required behavior (in menu) | Required behavior (VOD/Music) | Required behavior (live linear) |
| --- | --- | --- | --- | --- |
| start over | "start over"  <br>"go to beginning" | Acknowledge command as unhandled; the Roku OS will display “Command not available”. | Play media from the beginning. | Unless supported, acknowledge command as unhandled; the Roku OS will display “Command not available”. |
| seek | **Forwards**  <br>"Forward 10 minutes"  <br>"Fast forward half an hour"  <br>"Skip 30 seconds"  <br>"Go forward 1 minute"  <br>  <br>**Backwards**  <br>"Rewind 10 minutes"  <br>"Go back 30 minutes"  <br>"Go backward 15 seconds" | Acknowledge command as unhandled; the Roku OS will display “Command not available”. | Skip media forwards or backwards by the specified time. | Unless supported, acknowledge command as unhandled; the Roku OS will display “Command not available”. |
| next | "next" | If in profile selection screen, advance focus to next profile. Otherwise, acknowledge command as unhandled; the Roku OS will display “Command not available”. | *   Video: If in an episode of a series, play the next video clip or acknowledge as unhandled (the Roku OS will display message “Command not available).<br>*   Music: If in a playlist, play the next song. | Unless unsupported, acknowledge command as unhandled; the Roku OS will display “Command not available”. |

### Additional enhanced voice controls

| Voice control | Voice command examples | Required behavior (in menu) | Required behavior (VOD/Music) | Required behavior (live linear) |
| --- | --- | --- | --- | --- |
| nowplaying | "what's playing?"  <br>"what am I watching?" | Acknowledge command as success; the Roku OS will display app name as playing. | *   Content playing is known to the app: Create an [**roAppManager**](/docs/references/brightscript/components/roappmanager.md) node, and then pass the item's title and contentType into a call to the [**roAppManager.SetNowPlayingContentMetaData()**](/docs/references/brightscript/interfaces/ifappmanager.md#setnowplayingcontentmetadatacontentmetadata-as-object-as-void) method. Mark the event as successfully handled.<br>*   No content playing or content playing is unknown to the app: Pass `invalid` into a call to the [**roAppManager.SetNowPlayingContentMetaData()**](/docs/references/brightscript/interfaces/ifappmanager.md#setnowplayingcontentmetadatacontentmetadata-as-object-as-void) method, and mark the event as "error.generic" or "unhandled". | Use content metadata to display title of content. |
| skip | "skip intro"  <br>"skip recap" | Acknowledge command as unhandled; the Roku OS will display “Command not available”. | If the content has an introduction or recap, handle the "skip" command; otherwise, handle it like a "next" command. | Unless supported, acknowledge command as unhandled; the Roku OS will display “Command not available”. |
| shuffle | "shuffle" | Acknowledge command as unhandled; the Roku OS will display “Command not available”. | Shuffle the content in a playlist. | Unless supported, acknowledge command as unhandled; the Roku OS will display “Command not available”. |
| loop | "loop this video" | Acknowledge command as unhandled; the Roku OS will display “Command not available”. | Repeat playback. Start playback over when finished (for example, loop song, album, playlist). | Unless supported, acknowledge command as unhandled; the Roku OS will display “Command not available”. |
| like | "I like this song"  <br>"I like this video" | Acknowledge command as unhandled; the Roku OS will display “Command not available”. | Execute app-specific action.  <br>  <br>When handling the "like" and "unlike" commands, you can optionally set one of the following variables to display a song's artist, genre, or track, or playlist title in the Roku heads-up display:<br><br>*   "music\_artist"<br>*   "music\_genre"<br>*   "music\_track"<br>*   "playlist\_title" | Unless supported, acknowledge command as unhandled; the Roku OS will display “Command not available”. |
| dislike | "I hate this"  <br>"never play this again" | Acknowledge command as unhandled; the Roku OS will display “Command not available”. | Execute app-specific action. | Unless supported, acknowledge command as unhandled; the Roku OS will display “Command not available”. |

ifDeviceCrypto
==============

Implemented By
--------------

| Name | Description |
| --- | --- |
| [roDeviceCrypto](/docs/references/brightscript/components/rodevicecrypto.md) | Encrypts and decrypts data on a device using a key that is unique per app, device, or model. |

Supported Methods
-----------------

### Encrypt (input as roByteArray, String as encType) as roByteArray

#### Description

Encrypts data on a device that is unique per device, app, or model.

#### Parameters

NameTypeDescriptioninputroByteArrayThe data to be encrypted.encTypeStringThe encryption key type, which is a string that may be set to "channel", "device", or "model":

| encType | Description |
| --- | --- |
| device | Encrypt data with a device unique key. This can be used to implement a secure storage-like algorithm. |
| channel | Encrypt data with an app unique key This enables you to provision credentials, API tokens, or other data from the cloud to devices securely. Apps signed with same signing key will share the encryption key. |
| model | Encrypt app with a model unique key This is similar to the "channel" encryption type, but with the scope limited to a specific model. |

#### Return Value

An roByteArray containing the encrypted data.

### Decrypt (EncryptedData as roByteArray, String as encType) as roByteArray

#### Description

Decrypts data stored on a device that was previously encoded with the [**Encrypt()**](#encrypt-input-as-robytearray-string-as-enctype-as-robytearray) method.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| EncryptedData | roByteArray | The previously encoded data to be decrypted. |
| encType | String | The encryption key type, which is a string that may be set to "channel", "device", or "model": ${encTypeValues-2} |

${encTypeValues-2}

| encType | Description |
| --- | --- |
| device | Encrypt data with a device unique key. This can be used to implement a secure storage-like algorithm. |
| channel | Encrypt data with an app unique key This enables you to provision credentials, API tokens, or other data from the cloud to devices securely. Apps signed with same signing key will share the encryption key. |
| model | Encrypt app with a model unique key This is similar to the "channel" encryption type, but with the scope limited to a specific model. |

#### Return Value

An roByteArray containing the decrypted data.

#### Example

You can use the `Encrypt()` and `Decrypt()` methods to encrypt plaintext on a Roku device and then decode it, as demonstrated in the following example:

      ' store plaintext to be encrypted in an roByteArray
      ba = CreateObject("roByteArray")
      ba.FromAsciiString("plain text1")  
    
      ' create roDeviceCrypto object and specify a device key
      dc = CreateObject("roDeviceCrypto") encType = "device"
    
      ' encrypt plaintext using the device key and store the encoded data in an roByteArray
      encrypted = dc.Encrypt(ba, encType)
    
      ' decode the encrypted data and store the decrypted data in an roByteArray
      if encrypted <> invalid then
        decrypted = dc.Decrypt(encrypted,encType)
      end if

Global math functions
=====================

The following math functions are part of global. Trig functions use or return radians, not degrees.

* * *

Abs(x as Float) as Float
------------------------

Returns the absolute value of the argument.

Atn(x as Float) as Float
------------------------

Returns the arctangent (in radians) of the argument; that is, ATN(X) returns "the angle whose tangent is X". To get arctangent in degrees, multiply ATN(X) by 57.29578.

Cdbl(x as Integer) as Float
---------------------------

Also returns a single precision float representation of the argument. Someday may return double.

Cint(x as Float) as Integer
---------------------------

Returns an integer representation of the argument, rounding up from midpoints. CINT(2.1) returns 2; CINT(2.5) returns 3; CINT(-2.2) returns -2; CINT(-2.5) returns -2; CINT(-2.6) returns -3.

Cos(x as Float) as Float
------------------------

Returns the cosine of the argument (argument must be in radians). To obtain the cosine of X when X is in degrees, use CGS(X\*.01745329).

Csng(x as Integer) as Float
---------------------------

Returns a single-precision float representation of the argument.

Exp(x as Float) as Float
------------------------

Returns the "natural exponential" of X, that is, _ex._ This is the inverse of the LOG function, so X=EXP(LOG(X)).

Fix(x as Float) as Integer
--------------------------

Returns a truncated representation of the argument. All digits to the right of the decimal point are simply chopped off, so the resultant value is an integer. For non-negative X, FIX(X)=lNT(X). For negative values of X, FIX(X)=INT(X)+1. For example, FIX(2.2) returns 2, and FIX(-2.2) returns -2.

Int(x as Float) as Integer
--------------------------

Returns an integer representation of the argument, using the largest whole number that is not greater than the argument.. INT(2.5) returns 2; INT(-2.5) returns -3; and INT(1000101.23) returns 10000101.

Log(x as Float) as Float
------------------------

Returns the natural logarithm of the argument, that is, **loge(x)** or **ln(x).** This is the inverse of the EXP function, so LOG(EXP(X)) = X. To find the logarithm of a number to another base b, use the formula logb(X) = loge(X) / loge(b). For example, LOG(32767) / LOG(2) returns the logarithm to base 2 of 32767.

Rnd(range as Integer) as Integer
--------------------------------

Rnd(0) as Float
---------------

Generates a pseudo-random number using the current pseudo-random "seed number" (generated internally and not accessible to user). RND may be used to produce random numbers between 0 and 1, or random integers greater than 0, depending on the argument.  
RND(0) returns a float value between 0 and 1.  
RND(integer) returns an integer between 1 and _integer_ inclusive . For example, RND(55) returns a pseudo-random integer greater than zero and less than 56.

Sgn(x as Float) as Integer
--------------------------

Sgn(x as Integer) as Integer
----------------------------

The "sign" function: returns -1 for X negative, 0 for X zero, and +1 for X positive.

Sin(x as Float) as Float
------------------------

Returns the sine of the argument (argument must be in radians). To obtain the sine of X when X is in degrees, use SIN(X\*.01745329).

Sqr(x as Float) as Float
------------------------

Returns the square root of the argument. SQR(X) is the same as X ^ (1/2), only faster.

Tan(x as Float) as Float
------------------------

Returns the tangent of the argument (argument must be in radians). To obtain the tangent of X when X is in degrees, use TAN(X\*.01745329).

roAppMemoryMonitor
==================

The **roAppMemoryMonitor** component is used to subscribe apps to low-memory notifications. When an app is subscribed, it receives a [roAppMemoryNotificationEvent](/docs/references/brightscript/events/roappmemorynotificationevent.md) when it reaches a specific percentage of the per-app memory limit (80%).

> The roAppMemoryMonitor functions are supported on all [current and updatable device models](/docs/specs/hardware.md), except for Liberty, Austin, Mustang and Littlefield.

Supported interfaces
--------------------

*   [ifAppMemoryMonitor](/docs/references/brightscript/interfaces/ifappmemorymonitor.md)

Supported events
----------------

*   [roAppMemoryNotificationEvent](/docs/references/brightscript/events/roappmemorynotificationevent.md)
*   [ifSetMessagePort](/docs/references/brightscript/interfaces/ifsetmessageport.md "ifSetMessagePort")
*   [ifGetMessagePort](/docs/references/brightscript/interfaces/ifgetmessageport.md "ifGetMessagePort")

FloatFieldInterpolator
======================

Extends [**Node**](/docs/references/scenegraph/node.md)

The FloatFieldInterpolator node class specifies a keyframe animation sequence to be applied to a floating point field of a node (such as, an opacity, width or height value.)

All field interpolators include a set of key/keyValue pairs that define a keyframe of the animation. Field interpolators are generally used as children of an Animation node. As the animation progresses, it sets the fraction field of its field interpolators to a value between 0 and 1, indicating the percentage of the Animation's progress. The keyframes of the interpolator include a "key", the percentage where the keyframe should occur, and a "keyValue", the value that the field should have at that percentage.

For example, if a FloatFieldInterpolator had three keyframes, (0.0, 10.0), (0.4, 200.0) and (1.0, 87.0), then when the interpolator's fraction field was 0.0 (i.e. 0%), the field would be set to 10.0. When fraction was 0.4 (i.e. 40%), the field would be set to 200.0. When fraction was 1.0 (i.e. 100%), the field would be set to 87.0.

For values of fraction between 0.0 and 0.4 (e.g. 0.2 or 20%), the field value is determined by linearly interpolating the keyValues for the first two keyframes. In this case, since the key of 0.2 is halfway between the key at 0.0 and the key at 0.4, the field would be set to 10.0 + 0.5 \* (10.0 + 200.0) = 105.0. Similarly, when fraction is between the second and third keys (i.e. between 0.4 and 1.0), the field value is determined by linearly interpolating the keyValues of the second and third keyframes.

If the first keyframe has a key percentage greater than zero, then the field value will be equal to the keyValue of the first keyframe until fraction reaches the first keyframe's key percentage. Similarly, if the last keyframe has a key percentage less than one, the field value will be set to the keyValue of the last keyframe from when fraction equals the the last keyframe's key percentage and will not change as fraction increases from that value to 1.0.

> While linearly interpolation is used to compute the keyValue's for fraction values between successive keys, non-linear easing functions may be applied to the fraction values computed by the Animation node, so the overall animation may vary in speed.

### Example

The following changes the opacity of a graphical image, gradually making it invisible, then back to visible, in 10 seconds, repeatedly.

#### FloatFieldInterpolator Node Class Example

    <?xml version="1.0" encoding="utf-8" ?>
    
    <!--********** Copyright 2015 Roku Corp.  All Rights Reserved. **********-->
    
        <component name="animationfloattest" extends="Group" >
    
            <script type="text/brightscript" >
                <![CDATA[
                    function init()
                        m.top.setFocus(true)
                    end function
                ]]>
            </script>
    
    <children>
    
        <Poster  id="testPoster"  uri="pkg:/images/rokuowds.png"  width="0.0"  height="0.0"  translation="[160,8]"  opacity="0.0" />
        <Animation   id="testAnimation"  duration="10"  repeat="true"  control="start"  easeFunction="linear" >
            <FloatFieldInterpolator    id = "testFloat"   key="[0.0, 0.5, 1.0]"    keyValue="[ 1.0, 0.0, 1.0 ]"       fieldToInterp="testPoster.opacity"   />
        </Animation>
    
    </children>
    
    </component>
    

Fields
------

| Field | Type | Default | Access Permission | Description |
| --- | --- | --- | --- | --- |
| fieldToInterp | string | ""  | READ\_WRITE | Specifies the field to interpolate. The string should contain the ID of a node in the scene and the name of a field of that node, separated by a dot ".". For example, "title.width" would indicate that the interpolator should be applied to the width field of a node whose id field was "title". The specified field must be of type float |
| key | array of floats | \[ \] | READ\_WRITE | Specifies the key percentages for the interpolator's keyframes. Each key percentage should be a unique value from 0 to 1 indicating the percentage of the animation where the keyValue should occur. Behavior is undefined if the number of values in the key field does not match the number of values in the keyValue field |
| keyValue | array of floats | \[ \] | READ\_WRITE | Specifies the key values or the interpolator's keyframes. Each value in the keyValue array corresponds to a value in the key field's array. The interpolator's behavior is undefined if the number of values in the key field does not match the number of values in the keyValue field |
| fraction | float | 0.0 | READ\_WRITE | Specifies the percentage to be used to compute a value for the field |
| reverse | boolean | false | READ\_WRITE | Enables animation to be played in reverse. |

Sample app
----------

[AnimationFloatExample](https://github.com/rokudev/samples/tree/master/ux%20components/animation/AnimationFloatExample) is a sample app demonstrating FloatFieldInterpolator in action.

roFontRegistry
==============

The roFontRegistry object allows you to create roFont objects, either using the default font or using fonts in TrueType or OpenType files packaged with your application.

This object is created with no parameters:

`CreateObject("roFontRegistry")`

**Example**

    reg = CreateObject("roFontRegistry")
    font = reg.GetDefaultFont(30, false, false)
    screen = CreateObject("roScreen")
    screen.DrawText("hello world", 100, 100, &hFFFFFFFF, font)
    

**Example using a font file**

    reg.Register("pkg:/fonts/myfont.ttf")
    font = reg.GetFont("MyFont", 30, false, false)
    screen = CreateObject("roScreen")
    screen.DrawText("hello world", 100, 100, &hFFFFFFFF, font)
    

Font files can quickly get very large, so be conscious of the size of the font files you include with your application. You should be able to find very good font files that are 50k or less. Anything larger is probably too big.

Supported interfaces
--------------------

*   [ifFontRegistry](/docs/references/brightscript/interfaces/iffontregistry.md "ifFontRegistry")

Instant Signup
==============

Apps using Roku Pay can participate in Roku's Instant Signup program to offer subscription services to customers when they activate their Roku devices. With Instant Signup, customers can subscribe to apps off-device with just a few clicks and then directly access content on the app without any additional steps.

Offers may include free trials, promotional pricing, and standard pricing (the user experience is tailored for each offer type; see [Appendix A](#appendix-a-instant-signup-user-experience) for examples):

*   Free trials and promotions are automatically converted to full paid subscriptions by Roku Pay.
*   Standard pricing may only be offered if the app does not offer free trials or promotional pricing on-device or across other comparable platforms.

> SVOD apps that have streamed more than an average of 10 million hours per month over the last three months (and new SVOD apps expected to meet the threshold shortly after launch) must participate in Roku’s Instant Signup program to pass [certification](/docs/developer-program/certification/certification.md#2-purchases).
> 
> Effective October 1, 2024, apps' Instant Signup integration must include offers for lapsed and canceled subscribers.
> 
> Apps offering Premium Subscriptions on The Roku Channel are exempt from these requirements.
> 
> * * *
> 
> Instant Signup is currently available for apps in the United States Streaming Store only.

Overview
--------

When a customer activates their Roku device on my.roku.com, they add their method of payment and then answer survey questions. These questions include which subscriptions they already have and which types of content they are interested in watching.

Roku checks for which offers the customer is eligible (customers that already have a subscription for a specific service are ineligible for free trial offers for that service). Apps leverage a [SHA-512 hashed email address](#using-email-hashes-to-determine-offer-eligibility) included in [API](#implementing-products-api) calls to the app's product endpoint to determine whether customers are eligible for their offers. Roku then retrieves the app's content images and trial products from the publishers' app images and products endpoints, respectively.

Based on the answers to the survey questions, the customer's eligibility, and other signals, a list of offers from different apps is displayed to customers. For example, if a customer selects music as one of their interests, their offers will likely include a music streaming service (the inclusion of an app in the list, however, cannot be guaranteed; the recommended apps are derived solely from the survey responses). The customer can then select which apps they subscribe to and then select specific offers.

![roku400px - isu-sample-streambox](https://image.roku.com/ZHZscHItMTc2/streambox-free-trial.jpg)

> Once an offer is presented to a customer and they select it and confirm the transaction, apps must honor the terms of the offer, regardless if the customer is actually eligible for the offer. To determine customers' offer eligibility, you must use the [SHA-512 email hash](#using-email-hashes-to-determine-offer-eligibility) passed in the [products API](#implementing-products-api) calls.

Once the customer confirms the transaction, the publisher's account endpoint receives the customer's information via a [push notification](/docs/developer-program/roku-pay/implementation/push-notifications.md#sale) from the Roku Pay web services. This enables the publisher to create a user account in their backend system for the customer automatically.

After the transaction is completed, the app is automatically added to the home screen of the customer's Roku devices. When the customer launches the app, they can directly access content without any additional steps—if the publisher has created a user account for them. If the publisher has not created a user account for the customer upon app launch, the app must use the alternative account creation method of calling the [ChannelStore](/docs/references/scenegraph/control-nodes/channelstore.md) APIs to validate the customer's subscription, get their information, and store access tokens in the device registry and in the Roku cloud.

![instant-signup-workflow](https://image.roku.com/ZHZscHItMTc2/instant-signup-workflow-v7a.jpg)

Prerequisites
-------------

Apps must have completed the following integrations to participate in Roku Instant Signup:

*   **[Roku Pay](/docs/developer-program/roku-pay/implementation/overview.md)**. Enable Roku to create trial subscriptions and handle billing for auto-renewals on app.

*   [**Roku Pay Web Service API push notifications**](/docs/developer-program/roku-pay/implementation/push-notifications.md). Receive personal information granted by customers to create user accounts on their behalf automatically.

*   **[On-device authentication](/docs/developer-program/authentication/on-device-authentication.md)**. Validate subscriptions activated through Roku Pay before granting customers access to content.

*   **[Automatic Account Link](/docs/developer-program/authentication/universal-authentication-protocol-for-single-sign-on.md)**. Automatically sign customers in when they activate additional Roku devices linked to their same Roku account.

Getting started
---------------

To get started with the Instant Signup integration, follow these steps:

1.  Verify that your app meets the listed [prerequisites](#prerequisities).

2.  Contact the [Roku Partner Success team](https://developer.roku.com/contact "https://developer.roku.com/contact"). They will determine whether your app is eligible for Instant Signup.

3.  Build the required metadata and products APIs. See [Integrating Instant Signup](#integrating-instant-signup) for more information on the requirements for these APIs.

4.  If you plan on using the SHA-512 email hashes included in the products API calls to determine customers' offer eligibility, verify that your user account lookup tables include the SHA-512 email hashes and implement logic to return offers based on the products (if any) already associated with the hash. See [Using email hashes to determine offer eligibility](#using-email-hashes-to-determine-offer-eligibility) for more information.

5.  Provide Roku with the following:
    
    *   The production image and product API endpoints (these production URLs are final and may not be changed once provided).
    *   The app ID for the beta version of the app.
    *   The app's [Roku Pay API Key](https://developer.roku.com/api/settings), which is used to sign and verify API calls.
    *   The title, company name, privacy URL, and terms URL to be included in the legal disclaimer text that is displayed directly before the customer signs up for an offer.

6.  Whitelist a set of Roku IP addresses used to support the Instant Signup integration. Roku Partner Success will provide you with the IP addresses to be whitelisted upon request.

Integrating Instant Signup
--------------------------

Apps must complete the following steps (in addition to completing the [prerequisites](#prerequisites)) to integrate into Roku Instant Signup:

*   **Implement images and metadata API**: Apps must provide an **images** endpoint that Roku can call to get the app image and any other metadata related to the content on the app.

*   **Implement personalized product display API**: Apps must provide a **products** endpoint that Roku can call to get the offer to be displayed to the customer.

*   **Create user accounts**: User accounts must be created before customers can access content; therefore, apps must implement additional account creation logic. User accounts can be created automatically after the customer activates a subscription and upon the user launching the app.

> It is recommended that both the **images** and **products** APIs use the same domain (for example, [https://mychannel.com/api/offers/rsb/images](https://mychannel.com/api/offers/rsb/images) and [https://mychannel.com/api/offers/rsb/products](https://mychannel.com/api/offers/rsb/products)).

### Implementing images API

Apps must implement an API that retrieves the images and description of the app to be displayed to customers. The following table lists the requirements for implementing the Images API:

ItemDescription**Endpoint**/api/offers/rsb/images**Method**GET**Header**The HTTP header of the GET requests includes a JSON Web Token (JWT) for verifying that the API call is from Roku and the customer's locale for determining which offer image to display to the customer.  

| Field | Type | Description |
| --- | --- | --- |
| Authorization: Bearer | String | A JWT token that enables apps to verify that API calls are from Roku. The JWT is signed with the partner's [Roku Pay API Key](https://developer.roku.com/api/settings) using the [HS512 (HMAC using SHA-512)](https://tools.ietf.org/html/rfc7518#section-3.2) algorithm. To generate the JWT, use the following algorithm, payload, and secret key:  <br>  <br>\- **Algorithm**: HS512.  <br>  <br>\- **Payload**:<br><br>    "iss": "roku_instant_signup",<br>    "sub": "instant_signup_metadata",<br>    "exp": 1616010343 (1 hour from the current time, in epoch unix timestamp format)<br>    "aud": "roku_developers" (the app name)<br>    "iat": 1616006743 (the current time, in epoch unix timestamp format)<br>    <br><br>  <br>\- **Secret key**: [Roku Pay API Key](https://developer.roku.com/api/settings) (see the following [document](/docs/developer-program/roku-pay/quickstart/setting-up-web-services.md#roku-pay-api-key) for more information).  <br>  <br>Apps can use [JWT debugger](https://jwt.io/) or other online tool to verify generated JWTs. |
| locale | String | The location of the customer in language-country format (en-us or es-mx, for example). |

**Response**The API returns the following:  
  
\- An **images** array. This array contains between 5 to 15 image URLs specifying the app content posters to be displayed. The first image returned must be the app logo (a 160X120 JPG with 72ppi minimum resolution). Other images must be 213X120 JPG with 72ppi minimum resolution, per the [Image specifications](#channel-image-specifications).  
  
\- A **description** string. This is a maximum 200-character string summarizing the app. The description may not include any pricing information.  
  
**Syntax**:

      {
        "images": "Array.<String>",
        "description": "string"
      }
    

  
**Example**:

      {
        "images": [ "https://myChannelImage/item1.jpg",  
                    "https://myChannelContentPosterImages/item2.jpg",
                    "https://myChannelContentPosterImages/item3.jpg"],
        "description": "Your favorite movies from your favorite decade"            
      }
    

**Error**

*   200: OK
*   400: Bad request
*   500: Error

#### Image specifications

The images used for the app must meet the requirements for width, height, minimum resolution, and format.

| Specification | Requirement |
| --- | --- |
| Width | 213px |
| Height | 120px |
| Minimum resolution | 72ppi |
| File format | JPG |

#### Poster/artwork specifications

The posters/artwork with the content or networks featured in the app are used to highlight the app's offerings. The posters/artwork must meet the following requirements:

| Specification | Requirements |
| --- | --- |
| File format | JPG |
| Aspect ratio | 4:3<br><br>*   **Content-oriented apps** (apps that promote movies, TV shows, music, and other content): A minimum of 10 posters must be included with an offer.<br>*   **vMVPD apps** (apps that promote multiple networks/channels): A minimum of 5 artwork images must be included with an offer. |
| Licensing | Posters/artwork must be licensed for usage. Dates that posters may be used must be specified |

> The displaying of up-to-date content images in the device activation workflow may be delayed because of Roku's caching and approval policy.

### Implementing products API

Apps must implement an API that retrieves the product offers to be displayed to the customer when they click an app image. Apps may return offers for up to three unique products (for example, for example, an ad-supported plan, monthly limited-ads plan, and monthly premium ad-free plan). Apps may not return different offers for the same product (for example, returning 7-day and 30-day free trials for the same product is not allowed).

Each product will include its associated name and description, which were entered in the **Product Name** field on the [**Manage In-app Products** page](/docs/developer-program/roku-pay/quickstart/in-channel-products.md) within the Developer Dashboard.

> To change the product offers that are displayed to customers, apps must contact the [Roku Partner Success team](https://developer.roku.com/contact "https://developer.roku.com/contact") before making any updates.
> 
> * * *
> 
> Apps can use the [ChannelStore.GetCatalog](/docs/references/scenegraph/control-nodes/channelstore.md#getcatalog) command to get a list of products associated with the app, including whether a free trial period or introductory pricing is offered.

The following table lists the requirements for implementing the personalized product display API:

ItemDescription**Endpoint**/api/offers/rsb/products**Method**GET**Headers**The HTTP header of the GET requests includes a JWT token for verifying that the API call is from Roku, and the customer's email hash, locale, and activation date for determining which offers the customer is eligible for:

| Field | Type | Description |
| --- | --- | --- |
| Authorization: Bearer | String | A JWT token that enables apps to verify that API calls are from Roku. The JWT is signed with the partner's [Roku Pay API Key](https://developer.roku.com/api/settings) using the [HS512 (HMAC using SHA-512)](https://tools.ietf.org/html/rfc7518#section-3.2) algorithm. To generate the JWT, use the following algorithm, payload, and secret key:  <br>  <br>\- **Algorithm**: HS512.  <br>  <br>\- **Payload**:<br><br>    "iss": "roku_instant_signup",<br>    "sub": "instant_signup_elegibility",<br>    "exp": 1616010343 (1 hour from the current time, in epoch unix timestamp format)<br>    "aud": "roku_developers" (the app name)<br>    "iat": 1616006743 (the current time, in epoch unix timestamp format)<br>    <br><br>  <br>\- **Secret key**: [Roku Pay API Key](https://developer.roku.com/api/settings) (see the following [document](/docs/developer-program/roku-pay/quickstart/setting-up-web-services.md#roku-pay-api-key) for more information).  <br>  <br>Apps can use [JWT debugger](https://jwt.io/) or other online tool to verify generated JWTs. |
| roku-reserved-email-hash | String | The unsalted SHA-512 hash of the customer's email address. This can be used to determine which offers customers are eligible. See [Using email hashes to determine offer eligibility](#using-email-hashes-to-determine-offer-eligibility) for more information. |
| locale | String | The location of the customer in language-country format (en-us or es-mx, for example). |
| activation-date | String | A timestamp in UTC format indicating when the device was originally activated (for example, 2021-07-01T17:04:33Z). |

**Response**The API returns a **Products** array, which contains a list of product objects. The following information is included for each product in the array:  

| Field | Type | Description |
| --- | --- | --- |
| Id  | String | Identifies the product to be purchased, as entered in the **Product Identifier** field on the [In-Channel Product page in the Developer Dashboard](https://developer.roku.com/products) when the product was created. The name of the in-app product must include the app name. |
| desc | String | A brief (maximum 100 character) description of the product.  <br>  <br>Do not include any billing information such as pricing and billing cycle in the description. Roku automatically populates this information from the [in-app products you've created in the Developer Dashboard](/docs/developer-program/roku-pay/quickstart/in-channel-products.md). |
| details | String | Optional. App lineup images in markdown format (for example, `"![img](https://www.roku.com/images/roku-developers.svg)"`) |
| name | String | Optional. The name of the offer (for example, "Roku Developers annual subscription") |
| images | Array of Strings | Optional. An array of images that may be shown in the offer card once an offer is selected. |

  
  
**Syntax**:

      {
        "products": "Array.<Product>"
      }
    
      Product = {
        "id": "string",
        "desc": "string",
        "details": "string",
        "name" "string",
        "images": "Array.<String>"
      }
    

  
**Example**:

      {
          "products": [
              {
                  "id": "roku_developers_monthly",
                  "desc": "Unlimited streaming access to all Roku Developers content"
              },
              {
                  "id": "roku_developers_annual",
                  "desc": "Unlimited streaming access to all Roku Developers content."
              }
          ]
      }
    

  
If the customer is not eligible for any offers, return an empty array.**Error**

*   200: OK
*   400: Bad request
*   500: Error

#### Using email hashes to determine offer eligibility

Apps should leverage the email hash included in the Products API GET requests to verify whether a customer is eligible for a specific offer during activation before returning an offer to Roku (the email hash is based on the email address provided and verified by the customer prior to entering the offers flow).

*   If the user is not in your system or they already are in your system but not a current subscriber, they are eligible for a free trial, discount offer, or, direct-to-paid product. In this case, send the eligible products to Roku in the Products API response.
*   If the user is already in your system and a current subscriber, they are not eligible for an offer. In this case, send `<null>` in the Products API response.

The customer's SHA-512 hashed email address (unsalted) is included in a **roku-reserved-email-hash** field within the HTTP request header (the email address is lowercased before being hashed).

The SHA-512 hashing algorithm is an industry-standard one-way function for hashing customers' contact information so that it can be passed anonymously between platforms. Because the hash functions as an anonymous ID, no consent is required order for it to be passed.

> Roku does not send any personally identifiable information (PII) in the calls to your products endpoint (for example, raw email addresses may not be sent). Only SHA-512 email hashes are included.

The length of the input used in this algorithm may vary, but the output is always a fixed length. This means that an infinite number of input strings can be used to generate a hash, which makes it impossible to reverse the hash and get the PII from which it was created. Consider the modulo operation as an example. The result of 5%4 is 1; however, another party would have no way to determine the numbers used to get the result of 1.

The following diagram illustrates how the SHA-512 email hash is used to determine offer eligibility:

![SHA-512-email-hash-offer-eligibility](https://image.roku.com/ZHZscHItMTc2/email-hash-offer-eligibility-v9a.jpg)

### Creating user accounts

Apps must use Roku Pay Web Service API [push notifications](/docs/developer-program/roku-pay/implementation/push-notifications.md) to automatically create new user accounts in their backend system when customers sign up for a subscription. To integrate push notifications, go to the [Developer Dashboard](https://developer.roku.com/api/settings) and then click **Roku Pay Web Services**. Under **Push Notification URL**, enter a secure URL for receiving push notifications and keep the **Stop sending billing notifications** check box cleared.

Additionally, apps can use the [ChannelStore APIs](/docs/references/scenegraph/control-nodes/channelstore.md) to create new customer accounts when customers launch their app but do not have a user account.

> It is recommended that apps requiring user accounts support both account creation scenarios. Automatically creating user account upon activation of the trial subscription enables the customer to directly and seamlessly access content upon launching the app without any additional input. In the event that the app's web server listener is not responding to the push notifications or there is some other push notification failure, account creation can still be completed upon app launch as a backup.

#### Creating user accounts upon activation

Apps can provide an **account** endpoint that accepts POST requests. This enables apps to receive the customer's information that is collected during device activation and use it to create new user accounts in their backend system automatically.

When a customer selects a subscription, they are prompted to grant Roku permission to share their information with the app. If the customer consents, the [sale notification](/docs/developer-program/roku-pay/implementation/push-notifications.md#sale) will additionally include the customer's name, email address, billing zip code, and app-specific unique id. The following sample purchase notification demonstrates this:

     {
        "customerId": "168c2bda168854bb805f24ab296390a3",
        "transactionType": "Sale",
        "transactionId": "bf9af441015311ed810f0a58a9feac11",
        "channelId": "1143791",
        "channelName": "1p6d9g0o7k7w9a1m",
        "productCode": "UQcEYh2fVuKqS6cTuR3X_MonthlySub",
        "productName": "UQcEYh2fVuKqS6cTuR3X_MonthlySub_name",
        "price": 0.99,
        "total": 0.99,
        "tax": 0.0,
        "currency": "usd",
        "originalTransactionId": "bf9af441-0153-11ed-810f-0a58a9feac11",
        "eventDate": "2022-07-11T19:58:00Z",
        "expirationDate": "2022-08-11T19:57:58Z",
        "comments": "New order processed.",
        "responseKey": "bf9af441015311ed810f0a58a9feac11",
        "email": "aavella551+1657569447@gmail.com",
        "zip": "95032",
        "gender": "F",
        "firstName": "channelstore",
        "lastName": "qa",
        "birthMonth": 3,
        "birthYear": 1990,
        "purchaseChannel": "WEB",
        "purchaseContext": "ISU",
        "federationToken": "763edc77-4b19-547b-8c48-23a7a0234327",
        "pucId": "763edc77-4b19-547b-8c48-23a7a0234327",
        "isFreeTrial": false
    }
    

> If the user subscribes to your app via an Instant Signup on-device offer, the **purchaseChannel** and **purchaseContext** fields are set to "DEVICE" and "ISU", respectively.
> 
>     ...
>     "purchaseChannel": "DEVICE",
>     "purchaseContext": "ISU",
>     ...

Use the information in the push notification to create a new account for the customer. Store the transaction ID, and the customer's email address, name, and user ID in your system. As part of the [on-device authentication](/docs/developer-program/authentication/on-device-authentication.md) flow, the transaction ID is used to validate access to content upon subsequent app launches.

In addition, you should generate a secure temporary password and store it in the customer's account, and then send the customer a "Welcome" email with information on how to reset the temporary password.

Alternatively, you can ask the user to create a password upon launching the app and then complete the creation of the user account—in as few steps as possible. However, this approach is not recommended as the additional password step increases friction and therefore may increase churn.

Upon launch, apps may only display a single dialog for entering a password. The dialog may not serve any purpose other than password creation, and multiple dialogs are not allowed.

#### Creating user accounts upon app launch

Apps can leverage the [ChannelStore](/docs/references/scenegraph/control-nodes/channelstore.md) APIs and [Roku Pay web services](/docs/developer-program/roku-pay/implementation/roku-web-service.md#validate-transaction) to create user accounts when customers launch their app. This ensures that user accounts have been created before customers can access content. Creating user accounts with these APIs entails getting the purchase data, validating the subscription, and storing access tokens in the device registry and in the Roku cloud. The following steps describe how to do this:

1.  Call the [**ChannelStore.getPurchases**](/docs/references/scenegraph/control-nodes/channelstore.md#getpurchases) command. This causes the **purchases** field to be set to a **ContentNode** containing the results of the command. The **purchases** contentNode contains a child content node for each purchase.
    
          myChannelStore.command = "getPurchases"
        
    

2.  Get the transaction ID from the **purchaseId** field of the child content node. Find the subscription to be validated using the **code** or **productType** fields of the child content node.
    
          if (myChannelStore.purchases <> invalid)
              count = myChannelStore.purchases.GetChildCount()
              for x = 0 to count - 1
                  if (myChannelStore.purchases.getChild(x).code = "monthlySubscription")
                      transactionId = myChannelStore.purchases.getChild(x).purchaseId
                  end if
              end for
          endif
        
    

3.  Pass the transaction ID into a [**validate-transaction**](/docs/developer-program/roku-pay/implementation/roku-web-service.md#validate-transaction) Roku Pay Web Service API call.
    
          transactionId = myChannelStore.purchases.getChild(x).purchaseId
        
    

4.  Check the **isEntitled** field in the response to verify that the user is entitled to the content.
    
          <result>
              <transactionId>aa3f3a2479ea4e0c88d9a2d500f33e74</transactionId>
              ...
              <isEntitled>true</isEntitled>
              ...
              <rokuCustomerId>ac4d2fd61f624451a61aa2cf00a766a1</rokuCustomerId>
              <expirationDate>2020-08-22T14:59:50</expirationDate>
          </result>
        
    

5.  Check the access token in your entitlement server to verify whether it is still valid. If the access token is valid, generate a refresh token in your system and store it in the device registry and in the Roku cloud, and then grant the customer access to the content. In this case, no additional steps are required and authentication is complete.
    
    *   Call the [**roRegistrySection.write()**](/docs/references/brightscript/interfaces/ifregistrysection.md#writekey-as-string-value-as-string-as-boolean) and [**roRegistrySection.flush()**](/docs/references/brightscript/interfaces/ifregistrysection.md#deletekey-as-string-value-as-string-as-boolean) methods to permanently store the refresh token on the device:
        
             reg_sec.write("access_token_key_name", "access_token_value")
             reg_sec.flush()
            
        
    *   Call the [**ChannelStore.storeChannelCredData**](/docs/references/scenegraph/control-nodes/channelstore.md#storechannelcreddata) command to store the access token in the Roku cloud. You can use the **status** and **response** fields of the **storeChannelCredDataStatus** content node to verify that the command was successful and that the access token stored in the Roku cloud has the specified value.
        
              myChannelStore.channelCredData = "your access token"
              myChannelStore.command = "storeChannelCredData "
            
              'check if command was successful
              status = myChannelStore.storeChannelCredDataStatus.status
              if status = 0
                  ...
              end if
            
              'check if access token stored in Roku cloud has specifed value
              response = myChannelStore.storeChannelCredDataStatus.response
              if response.json.channel_data = myChannelStore.channelCredData
                  ...
              end if
            
        

Offer card construction
-----------------------

The following graphic demonstrates how an app's offer card is constructed from the data returned by its images and products APIs. Apps provide Roku with the name to be used for the title card (for example, "Streambox Plus"). Roku obtains the price and duration of the offer via calls to the ChannelStore API (based on the **id** included in the products API response).

> The headers and subscription terms displayed in the offer card are fixed and cannot be modified.

![ISU-offer-api-construction](https://image.roku.com/ZHZscHItMTc2/ISU-offer-api-construction-v3.png)

Testing
-------

The following process is used to test and verify the app's Instant Signup integration before making offers available to customers in Roku's production environment:

1.  Roku tests the publisher's final production images and products endpoints in a beta environment to ensure responses are received and adhere to the specifications listed in this document.
2.  Roku verifies that the app's offer card is displayed correctly.
3.  Roku tests and deploys the latest build in a beta environment.
4.  App uses the beta environment to verify and approve their offer card.
5.  Roku tests and verifies that customers can claim the offer.

Measuring Instant Signup
------------------------

Apps can identify whether Roku Pay subscription purchase originated from Instant Signup (a customer signing up for a free trial offer is considered a purchase). This may be useful, for example, for publishers to compare the number of subscription purchases made via Instant Signup versus on-device.

The ChannelStore node [**getPurchases**](/docs/references/scenegraph/control-nodes/channelstore.md#getpurchases) and [**getAllPurchases**](/docs/references/scenegraph/control-nodes/channelstore.md#getallpurchases) commands, [**roChannelStore.getPurchases**](/docs/references/brightscript/interfaces/ifchannelstore.md#getpurchases-as-void) function, [Roku Pay **validate-transaction** web service](/docs/developer-program/roku-pay/implementation/roku-web-service.md#validate-transaction), and [Roku Pay **Sale** push notification](/docs/developer-program/roku-pay/implementation/push-notifications.md#sale) include **purchaseChannel** and **purchaseContext** fields that indicate the source of the purchase.

| Source | purchaseChannel | purchaseContext |
| --- | --- | --- |
| Instant Signup Web (my.roku.com) | "ISU" | "WEB" |
| Instant Signup (on-device) | "ISU" | "DEVICE" |
| In-app purchase | "IAP" | "DEVICE" |

In addition, the [Roku Pay Transaction Report](/docs/features/analytics/transaction-report.md) includes a **purchase\_context** column indicating the origin of the sign-up ('isu" or "iap").

Appendix A: Instant Signup user experience
------------------------------------------

The Instant Signup user experience slightly varies based on whether a free trial, promotional pricing, or standard pricing is offered and whether the offer includes a single plan or multiple plans. The following images illustrate the workflows for each of these scenarios:

#### Free trial offer - single plan

| Offer | Confirm selection | Success |
| --- | --- | --- |
| ![img - roku400px](https://image.roku.com/ZHZscHItMTc2/Free-trial.png) | ![img roku400px](https://image.roku.com/ZHZscHItMTc2/Free-trial---confirmation-dialog.png) | ![img roku400px](https://image.roku.com/ZHZscHItMTc2/Free-trial---post-acceptance.png?version=1&modificationDate=1613586217000&api=v2) |

#### Free trial offer - multiple plans

| Offer | Plan selection | Confirm selection | Success |
| --- | --- | --- | --- |
| ![img - roku400px](https://image.roku.com/ZHZscHItMTc2/Multiple-trials.png) | ![img roku400px](https://image.roku.com/ZHZscHItMTc2/Multiple-trials---expanded.png) | ![img roku400px](https://image.roku.com/ZHZscHItMTc2/Multiple-trials---confirmation-dialog.png) | ![img roku400px](https://image.roku.com/ZHZscHItMTc2/Multiple-trials---post-acceptance.png) |

#### Promotional pricing

| Offer | Confirm selection | Success |
| --- | --- | --- |
| ![img roku400px](https://image.roku.com/ZHZscHItMTc2/Promo-pricing.png?) | ![img roku400px](https://image.roku.com/ZHZscHItMTc2/Promo-pricing---confirmation-dialog.png) | ![img roku400px](https://image.roku.com/ZHZscHItMTc2/Promo-pricing---post-acceptance.png) |

#### Standard pricing - single plan

| Offer | Confirm selection | Success |
| --- | --- | --- |
| ![img roku400px](https://image.roku.com/ZHZscHItMTc2/Direct-to-pay.png) | ![img roku400px](https://image.roku.com/ZHZscHItMTc2/Direct-to-pay---confirmation-dialog.png) | ![img roku400px](https://image.roku.com/ZHZscHItMTc2/Direct-to-pay---post-acceptance.png) |

#### Standard pricing - multiple plans

| Offer | Plan selection | Confirm selection | Success |
| --- | --- | --- | --- |
| ![img roku400px](https://image.roku.com/ZHZscHItMTc2/Direct-to-pay---multiple-plans-annual.png) | ![img roku400px](https://image.roku.com/ZHZscHItMTc2/Direct-to-pay---multiple-plans-annual---expanded.jpg) | ![img roku400px](https://image.roku.com/ZHZscHItMTc2/Direct-to-pay---multiple-plans-annual---confirmation-dialog.png) | ![img roku400px](https://image.roku.com/ZHZscHItMTc2/Direct-to-pay---multiple-plans-annual---post-acceptance.png) |

Appendix B: Subscription terms
------------------------------

The subscription terms presented in the subscription confirmation dialog, which are fixed and cannot be modified, differ based on whether the offer is a free trial, promotional price, or standard price. This appendix provides the text displayed for each of these scenarios.

#### Free trial subscription terms

You must cancel before your “<product-name>“<trial duration in days>-day trial ends to avoid being charged. After the trial, your account will be charged <product-price> each month to your payment method on file until you cancel.

By selecting “Start your free trial” you agree that we may share your Roku account information with <publisher name>, which may include your name, email address, zip code, age and gender, to create your account with “<publisher name>.” Visit “<product privacy policy URL>” to learn how <publisher name> uses your information. Access and use of “<product-name>“ is subject to the <publisher terms of service URL>, which may require you to create an account.

Recurring subscriptions are pre-paid and will automatically renew until you cancel. No refunds are given for partial term cancellations. You must cancel before your free trial ends to avoid being billed. You can manage your subscription at [my.roku.com](http://my.roku.com/). Valid payment method required. A temporary authorization hold may appear on your payment method. Certain promotional offers are available for new subscribers only. Certain promotional offers are subject to change or may be canceled at any time without notice. Void where prohibited.

#### Promotional pricing subscription terms

“<product-name>“ is a recurring, pre-paid subscription that will begin immediately after you select “Start your subscription”. Your “<product-name>“ subscription includes promotional pricing of <product-price> per month for the first <x> months. After the promotional period, your account will be charged <product-price> each month to your payment method on file until you cancel. You must cancel before your <x>-month promotional period ends to avoid being charged the non-promotional rate thereafter.

By selecting “Start your subscription” you agree that we may share your Roku account information with <publisher name>, which may include your name, email address, zip code, age and gender, to create your account with “<publisher name>.” Visit “<product privacy policy URL>” to learn how <publisher name> uses your information. Access and use of “<product-name>“ is subject to the publisher terms of service URL>, which may require you to create an account.

Recurring subscriptions are pre-paid and will automatically renew until you cancel. You must cancel before your subscription renews to avoid being billed for the next term. You can manage your subscription at [my.roku.com](http://my.roku.com/). No refunds are given for partial term cancellations. Valid payment method required. Certain promotional offers are available for new subscribers only. Promotional offers are subject to change or may be canceled at any time without notice. Void where prohibited.

#### Standard pricing subscription terms - single plan

“<product-name>“ is a recurring, pre-paid subscription that will begin immediately after you select “Start your subscription” at the cost of <product-price> per <month|year>. By selecting “Start your subscription” you agree that we may share your Roku account information with <publisher name>, which may include your name, email address, zip code, age and gender, to create your account with “<publisher name>”. Visit “<product privacy policy URL>” to learn how <publisher name> uses your information. Access and use of “<product-name>“is subject to the publisher terms of service URL>, which may require you to create an account.

The subscription will automatically renew for per <month|year> until you cancel. You must cancel before your subscription renews to avoid being billed for the next term. You can manage your subscription at [my.roku.com](http://my.roku.com/). No refunds are given for partial term cancellations. Void where prohibited.

#### Standard pricing subscription terms - multiple plans

After selecting “Start your subscription” you will be charged the <product-price> <monthly|annual> price for this subscription now.

“<product-name>“ is a recurring, pre-paid subscription that will begin immediately after you select “Start your subscription” at the cost of <product-price> per <month|year>. By selecting “Start your subscription” you agree that we may share your Roku account information with <publisher name>, which may include your name, email address, zip code, age and gender. Visit “<product privacy policy URL>” to learn how <publisher name> uses your information. Access and use of “<product-name>“ is subject to the publisher terms of service URL>, which may require you to create an account.

The subscription will automatically renew for <product-price> per <month|year> until you cancel. You must cancel before your subscription renews to avoid being billed for the next term. You can manage your subscription at [my.roku.com](http://my.roku.com/). No refunds are given for partial term cancellations. Void where prohibited.

Data management
===============

Thread ownership of Nodes
-------------------------

*   Each node is owned by the thread which created it, which might or might not be the Render thread. However, if a node interacts with the Render thread, the Render thread will automatically take ownership of that node.
    
*   In particular, renderable node instances ([Group](/docs/references/scenegraph/layout-group-nodes/group.md) and every component extended from it) are owned by the render thread, no matter which thread calls `createObject()`. The Global node is owned by the Render thread. When a node is set as a child or field of another node owned by the Render thread, the referenced node becomes owned by the Render thread. Any variable or node in the Task thread which interacts with the Render thread will automatically be owned by the Render thread. In such a case, the nodes are permanently owned by the Render thread.
    
*   The only instance of Non-Render thread ownership is that of a plain [Node](/docs/references/scenegraph/node.md) or [ContentNode](/docs/references/scenegraph/control-nodes/contentnode.md) or a component extending one of those that are created by a Task thread. A node instance in those circumstances will be owned by the Task thread as long as it is not added as a field or a child of a node owned by the Render thread.
    
*   This transfer of ownership is recursively performed on all nodes and field referenced by a transferred node, and it is even performed on nodes referenced in AA or array fields.
    
*   The key to optimizing performance is to allow the owning thread to access the node directly without a rendezvous.
    
*   Node creation, especially of inherited components, can be expensive. It is suggested that "AddFields" be used instead of "Extends" for such components.
    

Use of `m.global`
-----------------

*   Since the global node (`m.global` in a Component) is owned by the SceneGraph render thread, any operations on `m.global` from a Task thread are accomplished via rendezvous.
    
*   If a Task thread creates a node and adds it to `m.global` via a field or as a child (or grandchild, etc.), it is best to have the Task thread perform operations on the node before it is added so that it may do so without rendezvous.
    

### Referencing subsections of `m.global`

Given the rendezvous penalties, don't repeatedly reference the same fields in `m.global` to get data subsections. Use temporaries to hold references to successive parts of the tree. For example, assume that you have a large set of app configuration data stored in `m.global.config`. This data is a large web with elements (AAs or node trees) for settings, analytics, etc.:

    m.global
    {
            config
            {
                settings
                {
                    }
                analytics
                {
                    }
            }
    }
    

Getting some or all of this data into a Task node can be done as follows:

    <component name="DataTask" extends="Task">
    <interface>
        <field id="settings" ... />
        <field id="analytics" ... />
    </interface>
    ...
    
    function init() as void
        m.config = m.global.config
        m.settings = m.config.settings
        m.analytics= m.config.analytics
    end function
    
    ...
    
    </component>
    

The Task makes a local copy of the config global data which it then references via that local variable, avoiding a rendezvous and a copy for subsequent references. Generally speaking a Task should locally copy only what it needs from `m.global`, so there is a design trade-off in grouping data in subtrees versus spreading it all out at the top level.

Task to render thread rendezvous
--------------------------------

*   When a Task thread operates on nodes it owns, it does so directly, and it does not trigger a rendezvous.
    
*   When a Task thread operates on a Render-thread-owned node, it triggers a rendezvous. Depending on the structure of the Task, other Tasks might be able to access its nodes, triggering a rendezvous. Nodes are passed by reference whereas Associative Arrays are passed by value.
    
*   Under the covers, the Task thread queues a requested operation on the Render thread's queue and blocks, waiting for completion of the operation. The Render thread eventually pulls the requested operation off of its queue, executes it, and returns the results into references from where the Task thread may access them. The Task thread sees the results of the operation as soon as it unblocks from the rendezvous. Thus, it appears as a synchronous call to the Task thread. From the Task thread's point of view, both the syntax and the semantics of the call are the same as if the Task thread owned the node itself.
    
*   While rendezvous are designed to be invisible to syntax and semantics, **a rendezvous is at least an order of magnitude more expensive than a direct access.** For this reason, rendezvous should be used somewhat sparingly.
    
*   A distinct rendezvous is used on each separate operation invoked by a Task thread on a Render-thread-owned node. In particular, consider an expression like x.y.z, where x is a node and y and z, are fields on that node. This is evaluated as a succession of getField() calls. If x is owned by the Render thread and this expression is evaluated in a Task thread, each dot represents a distinct rendezvous. Simply counting dots in naively organized Task thread scripts can indicate the number of rendezvous and the performance penalties incurred. In well designed Task thread scripts, most dots avoid as many rendezvous as it can.
    

> Use the [**logrendezvous** command](/docs/developer-program/debugging/debugging-channels.md#scenegraph-debug-server-port-8080-commands) in the SceneGraph debug console to identify performance issues in the Task thread caused by a rendezvous. This command indicates whether a rendezvous is occurring and the length of it is taking (in milliseconds).

### Utilizing the UriFetcher data model

Use the [UriFetcher sample app](https://github.com/rokudev/samples/blob/master/utilities/uri-fetcher-master) to handle URL requests. UriFetcher provides a simple, non-blocking implementation of a basic download manager which is capable of multiple asynchronous URL requests implemented through a long-lived data task and is the preferred data model to fetch multiple URLs, even simultaneously. Since this data model acts as a long-lived task, it allows for more consistent memory usage by implementing a queuing mechanism for the tasks.

Data modeling
-------------

*   Generally, data passed to and from fields is passed by copy. This is necessary to support a multi-threaded model that avoids explicit locking.
    
*   In particular, containers like associative arrays and plain arrays get passed to and from fields by deep copy. This is a complete recursive copy of all of the data in the container, including copies of all the containers in the container.
    
*   Unlike traditional BrightScript, passing large webs of AAs or arrays through SceneGraph node fields is not efficient and should be avoided.
    
*   On the other hand, using AAs to model small data structures is a reasonable way to consolidate related fields that are usually set or read as a whole. If the AA is being passed between the Render thread and a Task thread, this will incur a single rendezvous. This way, it is not required to trigger multiple rendezvous for each field access if separate data elements are modeled as separate fields.
    
*   Each instance of a SceneGraph node is an exception to the copy rule through fields. **SceneGraph nodes get passed to and from fields by reference.** Using a node tree to model complex content means that a single field or child can accept a large change in the data model with one reference change.
    
*   The result of the above considerations is that the data that needs to be accessible via nodes and fields fall into two categories:
    
    *   The first category represents small, shallow data structures where each structure instance is usually treated as a single cohesive item. These are reasonable and efficient to model as **AA fields**.
    *   The second represents large, deep data webs where copying would be prohibitive. It is reasonable to model these as **node trees**.
*   Prune unneeded data in ContentNode AAs. Keep the data limited to what might be utilized when the node is called. As an example, when in a TimeGrid view, users won't see the show descriptions. Hence, when populating the Grid, parse what data is displayed before it gets to the ContentNode. This will prevent slow loading because of significant amounts of Meta-Data.
    

Marshalling data
----------------

*   Loading large amounts of server data should be done in the background using a Task node. The Task thread should try to keep ownership of the node while updating its fields, and should only pass the node into a field or as a child of a node owned by the Render thread after performing all the operations on the node that it must.
    
*   Rendering the content on the screen in the app on the Render thread is done by setting the ContentNode of the appropriate SceneGraph UI component. By the above guidance, this ContentNode should only be set into the UI node's content field once all of the data models are loaded by the Task thread into the ContentNode. Since each dot operation on a node requires a rendezvous, once the node is owned by the Render thread, a Task thread should use one dot reference at the end to set the entire ContentNode and its subtree rather than transferring the node and then operating on it with many subsequent dot operations.
    
*   As a best practice, small amounts of data that form input or status for Task threads can be grouped in AA fields, and large data webs should be returned from the Task thread to the Render thread as node trees.
    
*   To get data structures (more than one scalar value for example) into a Task node at a time, it is best to create a single interface field on the Task node with type assocarray. The Render thread can then set that interface field with the data it wants to pass. Only one rendezvous is required for the whole copy, versus multiple if there are individual interface fields for each value.
    

Threading and observer callbacks
--------------------------------

*   The observer callback function for setting a particular field is executed in the thread that owns the node in which the field was set initially.
    
*   Any callbacks set up on the Task node's fields will be executed by the Render thread if the node is owned by the Render Thread. For a Task thread to respond to the setting of such a node's fields, use the port form of the [`observeField()`](/docs/references/brightscript/interfaces/ifsgnodefield.md) call and wait for an [roSGNodeEvent](/docs/references/brightscript/events/rosgnodeevent.md) on that port. For nodes owned by the Task thread itself, the callback functions are set to call back directly to the Task thread.
    

Task initialization
-------------------

1.  The initialization of a Task does a bit more work and has more nuances than for other node types. The differences are designed to be mostly invisible, much like a rendezvous operation versus a normal operation.
    
2.  During the creation of the Task node, `init()` is executed by the Render thread (because the Task thread is in the process of being created).
    
3.  The Component `m` that is created before and modified during `init()` belongs to the Render thread at this point. Function callbacks of Task node fields setup during `init()` executes in the Render thread and then access this `m`.
    
4.  When the Task's control field is set to RUN, the Render thread's m is cloned (deep copied), the Render thread gets the clone, and the Task thread gets the original m. This ensures that a port created in init() is available to the Task thread, as it is the thread that needs to access the port
    
5.  In `init()`, the newly created port can be immediately used to observe fields; these fields guarantee to generate events that will be received by the Task thread once it is started. Waiting to create a port and observe fields in the Task thread itself can create a race condition where settings of the field from the Render thread may occur before the Task thread has had a chance to set up observation.
    
6.  If the same instance of a Task node stops and is started again, the Render thread's m is cloned; the Render thread gets this clone, and the Task thread gets the "original" (now a 1st generation clone created in 4). If there is setup that must be done for m (like creating a new port), it must be done in a field callback of the Task node (executed by the render thread during task initialization), that can modify the appropriate m and set the Task node's control to `RUN`.
    

Garbage Collector
-----------------

*   **SceneGraph Nodes** Nodes are reference counted. When the reference count goes to zero, the Roku OS automatically handles the clean up of SceneGraph nodes.
    
*   **Brightscript Objects** Brightscript objects can be cleaned up using the built-in Garbage Collector if no other elements are referencing the Brightscript object. Generally, this is done once right before video playback.
    

> **Note**: There is no advantage to calling the Garbage Collector frequently. For more information refer to [RunGarbageCollector](/docs/references/brightscript/language/global-utility-functions.md#rungarbagecollector-as-object).

Circular Dependencies in SceneGraph
-----------------------------------

A **circular reference** is a series of references where the last object references the first, resulting in a closed loop. Since all the nodes are reference counted, as soon as the reference count for the node is zero, the Roku OS automatically clears out that node. Although, the Roku OS won't be able to clean out circular dependent nodes, as they will always have a reference to one another. This, in turn, consumes memory indefinitely.

Using getScene()
----------------

getScene() is a useful function to avoid having to store parent pointers. It gets the Node's root Scene, and from there you can search down for the Nodes you want to access without storing any pointers. More for information about getScene(), refer to [getScene() as roSGNode](/docs/references/brightscript/interfaces/ifsgnodechildren.md#getscene-as-rosgnode).

Image Sizing
------------

*   Using properly sized images for various resolutions ensures that the quality of the UI is maintained. Smaller images can be added to the script using different URLs for different images. Moreover, [uri\_resolution\_autosub](/docs/developer-program/getting-started/architecture/channel-manifest.md#graphics-scaling-attributes) can be used to substitute the resolution type for a particular image URL, and the function regresses the URL automatically.
    
*   If the developer cannot provide the images using the server, they can use the Poster node fields: LoadWidth, LoadHeight, and LoadDisplayMode, at minimum values to provide low-resolution images. For more information about these fields, refer to [Posters](/docs/references/scenegraph/renderable-nodes/poster.md#autoscaling).

MaskGroup
=========

Extends [**Group**](/docs/references/scenegraph/layout-group-nodes/group.md "**Group**")

The MaskGroup node class allows an alpha mask bitmap to be applied to the rendering of its children. This allows effects such as having a list fade out at the bottom to be easily created.

> MaskGroup nodes do not work on all Roku players (specifically, MaskGroup nodes only work on players that support OpenGL). On players whose graphics do not support OpenGL, a MaskGroup node just renders its children without applying the extra alpha mask. For this reason, you should avoid using the MaskGroup node for anything other than decorative purposes, such as creating a fading effect at the bottom of the screen, where the user interface information value of the screen element is not affected by the lack of the MaskNode node rendering.

Unlike other bitmaps, the MaskGroup node class does not work with 9-patch images. If the bitmap size does not match the group bounding rectangle, the edge rows of the mask are repeated as needed.

For example, suppose the MaskGroup node bounding rectangle has an origin at (0, 0), a width of 150 and a height of 80. If the mask bitmap were also 150 by 80, and the maskOffset and maskSize field values were left at their default values of \[ 0, 0 \], then each pixel of the mask bitmap would be applied to the corresponding pixel of the MaskGroup node bounding rectangle. The figure below illustrates that case. On the right is a MaskGroup node that contains a Poster node. In the center is an alpha bitmap with the same size as the Poster node. On the right is the result of rendering the MaskGroup node with the image in the center used as a mask.

![roku815px - maskExample1](https://image.roku.com/ZHZscHItMTc2/maskExample1.png "maskExample1")

The maskSize and maskOffset field values can be used to scale and offset the mask bitmap relative to the group coordinate system, as shown in the figure below. The mask is the same bitmap as in the figure above. In the below figure, the maskOffset field value has been set to (50, 30), offsetting the origin of the mask bitmap coordinate system relative to the origin of the MaskGroup node coordinate system 50 pixels to the left and 30 pixels down.The maskSize field value has been set to (100, 50), This causes the width of the mask bitmap to be scaled from 150 to 100, and the height of the mask bitmap to be scaled from 80 to 50, so that the mask right edge aligns with the right edge of the MaskGroup node bounding rectangle, and the mask bottom edge aligns with the bottom edge of the MaskGroup node bounding rectangle. The center of the figure shows the mask with the maskOffset and maskSize field values applied overlaid on top of the MaskGroup node. The right side of the figure shows the result of applying the mask to the MaskGroup node. Notice that the left column of pixels in the mask is used as the mask for all columns of the MaskGroup node that lie to the left of the mask, causing those columns to be rendered with full opacity. Similarly, and the top row of the mask is used as the mask for all rows of the MaskGroup node that lie above the mask, causing each of the rows to fade out on the right.

![roku815px - maskExample2](https://image.roku.com/ZHZscHItMTc2/maskExample2.png "maskExample2")

As shown in above, the transformed mask may not overlay all the rendered pixels of the MaskGroup node. In that case, the leftmost (rightmost) columns of the mask bitmap are used as the mask for any MaskGroup node pixels that are to the left (right) of the transformed mask. The top (bottom) row of the mask bitmap is used as the mask for MaskGroup node pixels that are above (below) the transformed mask.

### Example

[MaskGroup](https://github.com/rokudev/samples/tree/master/ux%20components/control) shows how to use a MaskGroup node to conceal and reveal a poster.

Fields
------

| Field | Type | Default | Access Permission | Description |
| --- | --- | --- | --- | --- |
| maskUri | URI string | ""  | READ\_WRITE | Specifies the bitmap to use for the group alpha mask. The alpha value of each pixel rendered in the group is multiplied by the value of a pixel in the alpha mask. The mapping from pixel coordinates in the group to mask pixel coordinates is controlled by the maskSize and maskOffset field values. Those fields define a coordinate system for the mask bitmap relative to the group coordinate system. This mask coordinate system is used to map mask pixels to their corresponding pixels in the MaskGroup node |
| maskSize | vector2d | \[ 0, 0 \] | READ\_WRITE | Specifies a scaling factor of the alpha mask coordinate system relative to the group coordinate system. If either element of the maskSize field value does not match the corresponding size of the mask bitmap, the mask bitmap is scaled to the specified size in the dimension. Setting either element of the maskSize field vector to 0 causes the mask bitmap to be used at its actual size in that dimension |
| maskOffset | vector2d | \[0, 0 \] | READ\_WRITE | Specifies an offset of the mask coordinate system relative to the group coordinate system. For example, if the maskOffset field value is set to \[ 100, 0 \], then mask pixel \[0, 0\] is used as the alpha value for pixels rendered for the MaskGroup node coordinate \[100, 0\] |
| maskBitmapWidth | float | 0   | READ\_ONLY | Contains the actual width of the mask bitmap. The mask bitmap can be stretched horizontally by setting the x-dimension of the maskSize field value to a different value than the maskBitmapWidth field value |
| maskBitmapHeight | float | 0   | READ\_ONLY | Contains the actual height of the mask bitmap. The mask bitmap can be stretched vertically by setting the y-dimension of the maskSize field value to a different value than the maskBitmapHeight field value |

Sample app
----------

[MaskGroupExample](https://github.com/rokudev/samples/tree/master/ux%20components/control/MaskGroupExample) is a sample app demonstrating MaskGroup in action.

ifSocketConnectionStatus
========================

Implemented by
--------------

| Name | Description |
| --- | --- |
| [roStreamSocket](/docs/references/brightscript/components/rostreamsocket.md "roStreamSocket") | The roStreamSocket component enables BrightScript apps to accept and connect to TCP streams as well as send and receive data with them |

Supported methods
-----------------

### eConnAborted() as Boolean

#### Description

Checks whether a connection aborted error (ECONNABORTED) has occurred.

#### Return Value

A flag indicating whether an ECONNABORTED error has occurred.

### eConnRefused() as Boolean

#### Description

Checks whether a connection refused (ECONNREFUSED) has occurred.

#### Return Value

A flag indicating whether an ECONNREFUSED error has occurred.

### eConnReset() as Boolean

#### Description

Checks whether a connection reset error (ECONNRESET) has occurred.

#### Return Value

A flag indicating whether an ECONNRESET error has occurred.

### eIsConn() as Boolean

#### Description

Checks whether an is connected error (EISCONN) has occurred.

#### Return Value

A flag indicating whether an EISCONN error has occurred.

### eNotConn() as Boolean

#### Description

Checks whether a not connected error (ENOTCONN) has occurred.

#### Return Value

A flag indicating whether an ENOTCONN error has occurred.

Measuring app performance
=========================

The Roku OS records key app performance metrics such as app launch time, app change time, app exit time, and video start time via signal beacons. Signal beacons are markers for the start and stop points of user-initiated actions.

To measure app launch time, for example, beacons are fired when a user presses OK to select an app from the Roku home screen (marking the start point) and when the selected app is fully rendered (the stop point). The elapsed time between the start and stop points is recorded and can be viewed using the [BrightScript console](/developer-program/debugging/debugging-channels.md). You can then use the feedback from the console to update your application, if needed, to meet the certification requirements. 

> App launch and video start times must meet the specified [certification performance requirements](/docs/developer-program/certification/certification.md#3performance).

Measuring app launch times
--------------------------

For most app performance metrics, the Roku OS automatically fires the beacons for the start and stop points (referred to as "initiate" and "complete" beacons, respectively). Using video start time for example, the Roku OS automatically fires the video start beacons (**VODStartInitiate** and **VODStartComplete**). No additional implementation is therefore required for apps to measure video launch times.

For measuring app launch times, however, apps must implement the **AppLaunchComplete** signal beacon. In addition, apps must implement AppDialog signal beacons if the app UI displays a login or user selection dialog before the home page.

### AppLaunch signal beacons

Apps must fire an **AppLaunchComplete** beacon when the app home page is fully rendered. This beacon must also be fired when video playback starts after handling a [deep link](/docs/developer-program/discovery/implementing-deep-linking.md), and the app can respond to commands sent via the remote control.

To fire the **AppLaunchComplete** beacon from the app, call the **signalBeacon()** function on any node as demonstrated in the following example:

    myScene.signalBeacon(“AppLaunchComplete”)
    

> For your app to pass certification, your application must fire the **AppLaunchComplete** beacon to measure app launch time.

### AppDialog signal beacons

If the app UI displays a login, user selection, or end-user license agreement (EULA) dialog before the home page, the app must fire **AppDialogInitiate** and **AppDialogComplete** beacons when the dialog loads and exits, respectively.

These beacons, which were introduced in Roku OS 9.3, enable more accurate measurements of app launch times as the time spent on any dialogs requiring user input prior to rendering the home page are subtracted from the overall app launch time. If the app displays more that one dialog before the home page, multiple pairs of **AppDialogInitiate**/**AppDialogComplete** beacons may be fired. Do not fire AppDialog beacons on message dialogs that do not involve any user interaction (for example, a "please wait" or "loading" dialog).

To fire the **AppDialogInitiate**/**AppDialogComplete** beacons from the app, call the **signalBeacon()** function on any node as demonstrated in the following example:

    myScene.signalBeacon(“AppDialogInitiate”)
    myScene.signalBeacon(“AppDialogComplete”)
    

> For your app to pass certification, your application must fire the **AppDialogInitiate** and **AppDialogComplete** beacons if the app UI displays a login, user selection, EULA, or any other dialog before the home page.

Measuring EPG launch times
--------------------------

If your app contains an EPG, the application must also fire beacons when the user initiates a keypress to display the EPG (**EPGLaunchInitiate**) and when the EPG is fully rendered and navigable (**EPGLaunchComplete**). The following example demonstrates how to do this:

    myEPGComponent.signalBeacon(“EPGLaunchInitiate”)
    m.top.signalBeacon(“EPGLaunchComplete”)
    

Only the first sequence of EPG launch beacons is recorded. If a user launches the EPG more than once while the app is running, a warning message is output to the debug console. This warning message, which acknowledges the receipt of the beacon while notifying that subsequent ones will not be recorded, may be ignored.

Only EPG launch sequences that start within 5 seconds of the `AppLaunchComplete` event being fired qualify as a valid measurements for certification. EPG launch sequences fired after the 5-second window are still recorded so that app performance can be compared against requirements.

Viewing app performance metrics
-------------------------------

You can use the BrightScript console (port 8085) to view a log with your app's performance metrics. When a beacon is fired, the console immediately outputs statistics related to the initiate or complete beacon. When you exit your app, the console displays a report summarizing the statistics for the just-concluded session, which are described as follows:

| **Statistic** | **Beacon Type** | **Description** |
| --- | --- | --- |
| TimeBase | Initiate | A timestamp for the beacon based on milliseconds elapsed since the initiate beacon for the app launch was recorded. |
| Duration | Complete | Milliseconds between the initiate and complete beacons. |
| Memory Points (MiP, KiP, or p) | Complete | Memory points provide a relative measurement for your app's memory performance that can be used for trend analysis. You can monitor the amount of memory points reported for any complete beacon to see if it goes up or down across builds of your application.  <br>  <br>Memory points are measured in mebipoints (MiP), kibipoints (KiP), or points (p). This is similar to how units of information are expressed as mebibytes (MiB), kibibytes (Kib), and bytes. |

![roku815px - signalBeaconReport](https://image.roku.com/ZHZscHItMTc2/signalBeaconReport-v2.jpg "signalBeaconReport")

Performance metrics reference
-----------------------------

The Roku OS can measure and record eight app performance metrics: app launch, app compile, dialog launch, Electronic Program Guide (EPG) launch, video start, live start, change, and channel exit. For each app performance metric, the following table lists how they are measured and when their initiate and complete beacons are fired.

| **Metric** | **Start Point** | **Stop Point** | **Initiate Beacon** | **Complete Beacon** |
| --- | --- | --- | --- | --- |
| App launch | The user presses the OK button to launch an app from the home screen. | The app is fully rendered and operational on its initial UI screen, or it reaches user-operable video playback. | AppLaunchInitiate  <br>  <br>The last keypress before the beacon was signaled. If there was no prior keypress, the Initiate beacon signal time. | AppLaunchComplete  <br>  <br>The first render pass completes after the Complete beacon has been signaled via the signalBeacon() method.  <br>  <br>**Your application must fire this beacon to pass certification.** |
| App compile | The app compilation starts. | The app compilation finishes. | AppCompileInitate  <br>  <br>The app compilation starts after the app is launched. | AppCompileComplete  <br>  <br>The app compilation finishes. |
| Dialog launch | A dialog (for example, a login, user selection, or network error screen that the user must dismiss) is loaded. | The dialog exits. | AppDialogInitiate  <br>  <br>The app enters a dialog before rendering the home screen where the app waits for user input.  <br>  <br>**Your application must fire this beacon if your app includes any dialogs requiring user input before rendering the home page.** | AppDialogComplete  <br>  <br>The user dismisses the dialog.  <br>  <br>**Your application must fire this beacon if your app includes any dialogs requiring user input before rendering the home page.** |
| EPG launch | The user initiates a keypress to bring up the EPG. | The EPG is fully rendered and navigable. | EPGLaunchInitiate  <br>  <br>The last keypress before the initiate beacon was signaled. If there was no prior keypress, the Initiate beacon signal time.  <br>  <br>**Your application should fire this beacon if your app includes an EPG.** | EPGLaunchComplete.  <br>  <br>The first render pass completes after the Complete beacon has been signaled via the signalBeacon() method.  <br>  <br>**Your application should fire this beacon if your app includes an EPG.** |
| Video start | The user initiates a keypress to play a video. | Video playback has started and is visible to the user. | VODStartInitiate  <br>  <br>The last keypress that occurred between play events. If there was no prior keypress, the Initiate beacon signal time. | VODStartComplete  <br>  <br>The first render pass completes after the Complete beacon has been signaled (when the video node receives the "firstFramePresented" event from the Media Player). |
| Live start | After bringing up the EPG, the user initiates a keypress to play a video. | Video playback has started and is visible to the user. | LiveStartInitiate  <br>  <br>The last keypress that occurred between play events. If there was no prior keypress, the Initiate beacon signal time. | LiveStartComplete  <br>  <br>The first render pass completes after the Complete beacon has been signaled (when the video node receives the "firstFramePresented" event from the Media Player). |
| Channel change | The user initiates a keypress to change the app. | The new video playback has started and is visible to the user. | LiveChannelChangeInitiate  <br>  <br>The time of the last keypress that occurred between play events, which must both be live streams as reported by the media player session object when the firstFramePresented event is received. In addition, the previous keypress must have happened before the video player was destroyed for a live channel change event to have occurred. | LiveChannelChangeComplete  <br>  <br>The first render pass completes after the Complete beacon has been signaled (when the video node receives the "firstFramePresented" event from the Media Player upon a live channel change occurring). |
| Channel exit | The user presses the Home button to exit an app. | The app has exited and the home screen is fully rendered and operational. | AppExitInitiated  <br>  <br>The home key handler engages app shutdown. | AppExitComplete  <br>  <br>The first render pass completes after the Complete beacon has been signaled (when the Roku OS completes application exit) and the Home screen is displayed. |

roFileSystemEvent
=================

The roFileSystem component sends the roFileSystemEvent with the following predicates that indicate its valid event types:

Supported methods
-----------------

### isStorageDeviceAdded() as Boolean

Checks if a storage device was inserted in the USB port. This method returns true if a storage device was inserted; otherwise, it returns false.

#### GetMessage() as String

Returns the volume name of the device inserted into the USB port.

### isStorageDeviceRemoved() as Boolean

Checks if a storage device was removed from the USB port. This method returns true if a storage device was removed; otherwise, it returns false.

#### GetMessage() as String

Returns the volume name of the device removed from the USB port.

AnimationBase
=============

Extends [**Node**](/docs/references/scenegraph/node.md "**Node**")

AnimationBase is an abstract node class that contains the fields common to the [Animation](/docs/references/scenegraph/animation-nodes/animation.md "Animation"), [SequentialAnimation](/docs/references/scenegraph/animation-nodes/sequentialanimation.md "SequentialAnimation"), and [ParallelAnimation](/docs/references/scenegraph/animation-nodes/parallelanimation.md "ParallelAnimation") nodes. The purpose of the AnimationBase node class is to provide the basic functionality needed to animate screen elements, such as moving them across the display screen, fading them in and out of view, or changing their color. All node classes extended from AnimationBase require the use of the interpolator node classes [FloatFieldInterpolator](/docs/references/scenegraph/animation-nodes/floatfieldinterpolator.md "FloatFieldInterpolator"), [Vector2DFieldInterpolator](/docs/references/scenegraph/animation-nodes/vector2dfieldinterpolator.md "Vector2DFieldInterpolator"), and [ColorFieldInterpolator](/docs/references/scenegraph/animation-nodes/colorfieldinterpolator.md "ColorFieldInterpolator") as child nodes to achieve a specific animation effect.

> AnimationBase is not meant to be instantiated directly by app code

Fields
------

FieldTypeDefaultAccess PermissionDescriptioncontroloption stringnoneREAD\_WRITEControls the animation. Supported options include:

| Option | Effect |
| --- | --- |
| none | Initial state with no associated action |
| start | Always plays the animation from the beginning |
| stop | Stops the animation in its current state |
| pause | Pauses the animation in its current state |
| resume | If paused, resumes the animation from its current state. If the animation is not paused, plays the animation from the beginning. |
| finish | Jumps to the end of the animation, then stops. All animated fields will be immediately set to their final values as if the animation had completed. |

statevalue stringstoppedREAD\_ONLYIndicates the state of the animation. Values include:

| Value | Meaning |
| --- | --- |
| running | Indicates that the animation is in progress |
| paused | Indicates that the animation has been paused |
| stopped | Indicates that the animation has either run to completion or has been explicitly stopped |

repeatBooleanfalseREAD\_WRITEControls whether the animation stops when it finishes (false) or repeats from the beginning (true)delaytime0READ\_WRITEDelays the start of the animation by the specified number of seconds

roTextureManager
================

The Texture Manager provides a set of API's for managing an roBitmap cache.

**Example: Requesting an roBitmap from the roTextureManager**

    Sub Main()
        mgr = CreateObject("roTextureManager")
        msgport = CreateObject("roMessagePort")
        mgr.SetMessagePort(msgport)
    
        request = CreateObject("roTextureRequest","pkg:/assets/comet.jpg")
        mgr.RequestTexture(request)
    
        msg=wait(0, msgport)
        if type(msg)="roTextureRequestEvent" then
            print "request id";msg.GetId()
            print "request state:";msg.GetState()
            print "request URI:";msg.GetURI()
            state = msg.GetState()
            if state = 3 then
                bitmap = msg.GetBitmap()
                if type(bitmap)<>"roBitmap" then
                    print "Unable to create robitmap"
                    stop   ' stop exits to the debugger
                end if
            end if
       end if
    End Sub
    

Supported interfaces
--------------------

*   [ifTextureManager](/docs/references/brightscript/interfaces/iftexturemanager.md "ifTextureManager")
*   [ifSetMessagePort](/docs/references/brightscript/interfaces/ifsetmessageport.md "ifSetMessagePort")
*   [ifGetMessagePort](/docs/references/brightscript/interfaces/ifgetmessageport.md "ifGetMessagePort")
*   [ifHttpAgent](/docs/references/brightscript/interfaces/ifhttpagent.md "ifHttpAgent")

Supported events
----------------

*   [roTextureRequestEvent](/docs/references/brightscript/events/rotexturerequestevent.md "roVideoPlayerEvent")

ifArraySort
===========

Implemented by
--------------

| Name | Description |
| --- | --- |
| [roArray](/docs/references/brightscript/components/roarray.md "roArray") | An array stores an indexed collection of BrightScript objects. Each entry of an array can be a different type, or they may all of the same type. |

Supported methods
-----------------

### Sort(flags as String = "") as Void

#### Description

Performs a stable sort on an array.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| flags | Dynamic | Items are arbitrarily grouped by comparable type of number or string, and are sorted within the group with a logical comparison.  <br>  <br>If "r" is included in flags, a reverse sort is performed. If "i" is included in flags, a case-insensitive sort is performed. If invalid flags are specified, the sort is not performed. |

#### Examples

        a=[3, 1, 2] 
        a.Sort()
        print a  
        REM sets the array to [1, 2, 3]
    
        a=[3, 1, 2.5] 
        a.Sort("r")  REM reverse order sort
        print a
        REM sets the array to [3, 2.5, 1]
    
        a=["cat", "DOG", "bee"] 
        a.Sort()  REM case-sensitive sort by default
        print a
        REM sets the array to ["DOG", "bee", "cat"]
    
        a=["cat", "DOG", "bee"]  
        a.Sort("i")  REM case-insensitive sort
        print a
        REM sets the array to ["bee", "cat", "DOG"]
    
        a=["cat", "DOG", "bee"]  
        a.Sort("ir")  REM case-insensitive, reverse order sort
        print a
        REM sets the array to ["DOG", "cat", "bee"]
    

### SortBy(fieldName as String, flags as String = "") as Void

#### Description

Performs a stable sort of an array of associative arrays by value of a common field.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| fieldName | String | The field to be used for sorting. |
| flags | Dynamic | Items are arbitrarily grouped by comparable type of number or string, and are sorted within the group with a logical comparison.  <br>  <br>If "r" is included in flags, a reverse sort is performed. If "i" is included in flags, a case-insensitive sort is performed. If invalid flags are specified, the sort is not performed. |

#### Examples

        a=[ {id:3, name:"Betty"}, {id:1, name:"Carol"}, {id:2, name:"Anne"} ]
        a.SortBy("name") 
        REM sets the array to [ {id:2, name:"Anne"}, {id:3, name:"Betty"}, {id:1, name:"Carol"} ]
        a.SortBy("id") 
        REM sets the array to [ {id:1, name:"Carol"}, {id:2, name:"Anne"}, {id:3, name:"Betty"} ]
        a.SortBy("name", "r")  REM reverse order sort
        REM sets the array to [ {id:1, name:"Carol"}, {id:3, name:"Betty"}, {id:2, name:"Anne"} ]
    

### Reverse() as Void

#### Description

Reverses the order of elements in an array.

#### Example

        a=[1, "one", 2, "two"] 
        a.Reverse() 
        REM sets the array to ["two", 2, "one", 1]

Roku advertising requirements
=============================

This document lists the requirements for displaying video and interactive ads in a channel. These requirements are applicable for both client-side and server-side ad requests. Channels must adhere to these requirements to pass certification, including those related to the Roku Advertising Framework (RAF).

Roku advertising framework (RAF) requirements
---------------------------------------------

### RAF 1 Integration requirements

Channels must integrate the following RAF-related requirements to pass certification:

| Requirement | Description | Documentation |     |
| --- | --- | --- | --- |
| RAF 1.1 | RAF integration | Channels must integrate RAF for all ads without modifying, obstructing, or disabling RAF functionality in any way. Replays of live broadcast streams are exempt from this requirement, unless dynamic ad insertion is used to insert new ads. | [RAF integration guide](/docs/developer-program/advertising/roku-advertising-framework.md) |
| RAF 1.2 | Measurement beacons | Channels must fire all measurement beacons client-side via RAF. This requirement is applicable for both client-side and server-side ad insertion. | [Roku Advertising Watermark integration guide](/docs/developer-program/advertising/ad-watermark.md) |
| RAF 1.3 | Audience measurement | Channels in the U.S. Channel Store only that are not child-directed must support Roku ad tracking by calling the [enableAdMeasurements()](/docs/developer-program/advertising/raf-api.md#enableadmeasurementsenabled) method and passing the required content metadata within the following methods: [setContentGenre()](/docs/developer-program/advertising/raf-api.md#setcontentgenregenres-as-string-kidscontent-as-boolean), [setContentId()](/docs/developer-program/advertising/raf-api.md#setcontentgenregenres-as-string-kidscontent-as-boolean), and [setContentLength()](/docs/developer-program/advertising/raf-api.md#setcontentlengthlength-as-integer). Optionally, apps may use the [setNielsenGenre API](/docs/developer-program/advertising/raf-api.md#setnielsengenregenre-as-string) to pass specific Nielsen Genre granularity and the [setNielsenAppId API](/docs/developer-program/advertising/raf-api.md#setnielsenappidid-as-string) for those who specify a custom Nielsen App ID. The [enableAdMeasurements](/docs/developer-program/advertising/raf-api.md#enableadmeasurementsenabled) method deprecates the [enableNielsenDAR](/docs/developer-program/advertising/raf-api.md#nielsen-dar) API; therefore, do not use the [enableNielsenDAR](/docs/developer-program/advertising/raf-api.md#nielsen-dar) API. | [General Audience Measurement](/docs/developer-program/advertising/raf-api.md#general-audience-measurement) |
| RAF 1.4 | Ad break - numbering | For ads inserted client-side, apps must display the number of ads during ad breaks using the standard Roku-branded label applied by RAF. | [RAF integration guide](/docs/developer-program/advertising/integrating-roku-advertising-framework.md) |

General advertising requirements
--------------------------------

### ADS 1 General integration requirements

| Requirement | Name | Description | Documentation |
| --- | --- | --- | --- |
| ADS 1.1 | SDKs and libraries | Partners must disclose integration/use of all non-Roku SDKs, libraries, or other software systems and external advertising partners (for example, DSPs) that enable video, audio, or banner ad insertion, and Roku has the right to approve or deny such non-Roku SDKs, libraries, or other software systems. | [Roku Advertising Framework overview](/docs/developer-program/advertising/roku-advertising-framework.md) |
| ADS 1.2 | Ad terms | Channels that have an inventory relationship with Roku must meet the advertising terms specified in all applicable agreements. | [Video Advertising](/docs/features/monetization/video-advertisements.md) |
| ADS 1.3 | Ad experience | Channels selling ads exclusively and/or with Roku must comply with ad load, ad frequency, and acceptable ad requirements. | [Roku Advertising Guidelines](http://www.roku.com/adguidelines) |
| ADS 1.4 | Demand API | Channels in the U.S. Channel Store that have both streamed more than an average of 100,000 hours per month and averaged more than 10,000 new installs per month over the last three months may be required to implement the Demand API as part of their integration (this requirement may also be applicable to new apps projected to reach the specified thresholds shortly after launch).  <br>  <br>Channels outside the U.S. Channel Store that have streamed more than an average of 200,000 hours per month over the last three months, and new apps outside the U.S. Channel Store that are projected to reach this threshold, may also be required to implement the Demand API. | [Implementing the Demand API](/docs/developer-program/advertising/demand-api.md) |
| ADS 1.5 | RFI screen for authenticated ad-monetized apps | Authenticated ad-monetized apps must use the [getUserData](/docs/references/scenegraph/control-nodes/channelstore.md#getuserdata) command to display a Request For Information (RFI) screen during the sign-up and sign-in workflows to enable customers to share their Roku account information with the channel. Only if the user declines the request may apps require the customer to manually enter their information. | [Signup requirements and best practices](/docs/developer-program/roku-pay/signup-best-practices.md)  <br>  <br>[Sign-in requirements and best practices](/docs/developer-program/roku-pay/signin-best-practices.md) |

### ADS 2 Privacy requirements

| Requirement | Name | Description | Documentation |
| --- | --- | --- | --- |
| ADS 2.1 | Roku ID for Advertisers (RIDA) identifier Limit Ad Tracking (LAT) flag | Channels must pass Roku's ID for Advertisers (RIDA) and "limit ad tracking" (LAT) value on ad server requests. If the user has opted out, apps must still pass the temporary ID returned by the [rodeviceInfo.GetRida()](/docs/references/brightscript/interfaces/ifdeviceinfo.md#getrida-as-string) function to support frequency capping (this temporary ID is different than the UUID returned if the user has not opted out; it expires after 30 days). | [GetRida()](/docs/references/brightscript/interfaces/ifdeviceinfo.md#getrida-as-string)  <br>  <br>[IsRIDADisabled()asBoolean](/docs/references/brightscript/interfaces/ifdeviceinfo.md#isridadisabled-as-boolean)  <br>  <br>[URL parameter macros](/docs/developer-program/advertising/integrating-roku-advertising-framework.md#url-parameter-macros) |
| ADS 2.2 | Child-directed content | Channels with child-directed content must make ad requests that indicate that content is child-directed when serving ads during child-directed content. | [kidsContent parameter in the setContentGenre() method](/docs/developer-program/advertising/raf-api.md#setcontentgenregenres-as-string-kidscontent-as-boolean)  <br>  <br>[ROKU\_ADS\_KIDS\_CONTENT URL parameter macro](/docs/developer-program/advertising/integrating-roku-advertising-framework.md#url-parameter-macros) |

### ADS 3 Ad request requirements

| Requirement | Name | Description | Documentation |
| --- | --- | --- | --- |
| ADS 3.1 | Channel ID | Channels must pass their Roku channel ID in ad server requests to Roku. | [roChannelInfo.getId() function](/docs/references/brightscript/interfaces/ifappinfo.md#getid-as-string)  <br>  <br>[ROKU\_ADS\_APP\_ID URL parameter macro populated by RAF](/docs/developer-program/advertising/integrating-roku-advertising-framework.md#url-parameter-macros) |
| ADS 3.2 | User agent | Channels must use the Roku-generated device user agent in all server-side ad requests. | [RAF integration guide](/docs/developer-program/advertising/integrating-roku-advertising-framework.md#3-user-agent-requirements) |

### ADS 4 Ad break playback requirements

| Requirement | Name | Description | Documentation |
| --- | --- | --- | --- |
| ADS 4.1 | Ad break - back button behavior | All apps (except those streaming live content or replaying live broadcast streams) must return to the previous screen when the back button is pressed during an ad break (if the channel can't return to the previous screen, the channel displays an exit confirmation dialog).  <br>  <br>Channel s must attempt to initiate an ad break to preserve the previously exited ad experience when playback resumes (with the same or different content). | [RAF integration guide](/docs/developer-program/advertising/integrating-roku-advertising-framework.md) |
| ADS 4.2 | Ad break - FF/REW commands | All apps (except those streaming live content or replaying live broadcast streams) must ignore FF/REW commands received during an ad break (via either key presses or voice commands). | [RAF integration guide](/docs/developer-program/advertising/integrating-roku-advertising-framework.md) |
| ADS 4.3 | Ad break - pause | All apps (except those streaming live content or replaying live broadcast streams) may only display static graphics that do not contain any video (for example, banner ads) when an ad is paused. Channels are prohibited from displaying video ads when an ad break is paused. | [RAF integration guide](/docs/developer-program/advertising/integrating-roku-advertising-framework.md) |

Specifying display resolution
=============================

SceneGraph applications allow you to specify an intended display screen resolution for your user interface application. But SceneGraph applications also automatically scale the screen elements for screen displays and Roku players that do not support the intended screen resolution. This gives you greater control of the appearance quality of your application than in previous Roku firmware, and allows you to design your application for full high-definition display resolution.

SceneGraph display resolution scaling support
---------------------------------------------

The following describes how SceneGraph applications support different display screen resolutions.

### Supported screen resolutions

Roku players support up to three screen resolutions for the application user interface, depending on the specific Roku player. Please note that SD-only apps are not supported on Roku.

| Resolution | Pixel Dimensions | Pixel Shape |
| --- | --- | --- |
| Full high-definition | 1920 x 1080 | square |
| High-definition | 1280 x 720 | square |
| Standard definition | 720 x 480 | non-square |

### Automatic screen element scaling

SceneGraph applications can automatically scale screen elements, such as fonts and rectangles, to any specified supported resolution. This scaling is controlled by specifying the screen resolutions the application is intended to support. If support is only specified for high-definition, and not full high-definition, then the screen elements are scaled from 720 resolution to 1080 resolution if needed for the display resolution. If support is only specified for full high-definition, and not high definition, then the screen elements are scaled from 1080 resolution to 720 resolution if needed for the display resolution.

#### Automatic selection of supported graphical image resolutions

SceneGraph applications can automatically select graphical images based on the supported resolution. The Roku OS can modify a special URI string with a variable that gets the correct graphical image for each supported and specified resolution. If this special URI string is not specified, the Roku OS will automatically scale graphical images to the display resolution from the specified intended resolution.

#### Recommended intended resolution

For SceneGraph applications, Roku recommends you design and develop for an intended 1080 screen resolution. But for performance reasons, for Roku players and display screens that do not support full high-definition resolution, you should supply both 1080 and 720 graphical images for your application. The SceneGraph application will scale the design elements and the graphical images for the actual supported resolution, but you can achieve the best appearance for all supported resolutions if you provide both resolutions of graphical images. If you can only provide one resolution of graphical images, provide 720 graphical images.

### Manifest file screen resolution specification

You specify the intended support for various screen display resolutions in special manifest file attributes for SceneGraph applications. The following describes the manifest file attributes to specify the supported screen resolutions for SceneGraph applications.

### Autoscaling guidelines

When creating layouts of visual components that take advantage of the Roku SceneGraph ability to autoscale layouts from one screen resolution to another (such as, from FHD/1080p to HD/720p), the best results will be obtained if you use the following simple rule.

When designing for FHD, positioning items on 3-pixel boundaries, and specifying width, height, and spacing values that are divisible by three will produce the best results. This allows each of those values to be autoscaled to integer values in HD, since the FHD to HD scaling factor is 2/3. This minimizes visual anomalies due to floating point rounding errors.

Similarly, when designing for HD, positioning items on 2-pixel boundaries, and specifying width, height, and spacing values that are divisible by two will produce the best results. This allows each those values to be autoscaled to integer values in FHD, since the HD to FHD scaling factor is 1.5.

Failing to follow these rules may result in some minor visual artifacts during animations when running at the autoscaled screen resolution. This is most noticeable when a user scrolls through grids by holding down a remote control direction pad key. The sizes and spacing between adjacent items may vary by one pixel as the grid items scroll across the screen.

In general, these visual anomalies are minimal, but following these simple guidelines will lead to better results. And of course, if you want precise control of the screen layouts in both resolutions, you can create separate layouts for HD and FHD, and set `ui_resolutions=HD,FHD` in the application `manifest` file.

Adding in-app products
======================

Apps implementing Roku Pay can offer monthly and annual subscriptions and one-time purchases (for example, movie rentals/purchases, sporting events, pay-per-views). The **In-channel products** page lets you create the subscription and one-time purchase products for subscription video on demand (SVOD) and transactional video on demand (TVOD) apps linked to your Roku developer account.

*   SVOD apps can create one or more monthly and annual subscription products, offer free-trials and discounts, and schedule limited-time offers. Monthly and annual subscriptions can further be organized into product groups to support on-device upgrades/downgrades and prevent customers from accidentally being double-billed for the same service. SVOD apps can also offer one-time purchase products such as pay-per-views, sporting events, premium movie releases, and so on. Continue reading this guide for creating in-app subscription and one-time purchase products for SVOD apps.

*   TVOD-exclusive apps (apps offering only transactional content) create one in-app product for each different price point in the app. See [Creating TVOD apps](/docs/developer-program/roku-pay/implementation/tvod-channel.md) for how to create one-time purchase products.

> To test in-app products on an app, the app must:
> 
> *   be configured with subscription and/or one-time purchase monetization methods.
> *   be enabled for billing testing.
> *   have test users associated with it (the test users' Roku accounts must be linked to the Roku devices being used for testing).

Adding in-app products
----------------------

Creating an in-app product entails the following steps:

1.  [Adding a new product](#adding-a-new-product).
2.  [Entering product basics](#product-basics). Specify offering the product, and enter the product category, name, language, and ID/code.
3.  [Entering product pricing](#product-pricing). Specify the product type (monthly subscription, annual subscription, or one-time purchase) and the price of the product.
4.  [Adding trials and offers](#trials-and-offers) (optional) . Configure any free-trials and discounts to be included with the product.
5.  [Scheduling offers](#scheduling-offers) (optional). Create limited-time free trial and discount offers.
6.  [Adding product groups](#adding-product-groups) for all sets of mutually exclusive subscription products.

### Adding a new product

To create a new product, follow these steps:

1.  In the [Developer Dashboard](https://developer.roku.com/developer), select **Product Catalog**. You can also select **Manage In-Channel Products** from the drop-down list on the left side of the pages within the Developer Dashboard.
    
    ![roku815px - manage-in-channel-product roku600px](https://image.roku.com/ZHZscHItMTc2/manage-in-channel-products-v3.jpg)
    

2.  In the **Manage In-Channel Products** index page, click **Add a new product**.
    
    ![roku815px - add-new-product](https://image.roku.com/ZHZscHItMTc2/add-new-product-v4.png)
    

### Product basics

To provide the basic information for an in-app product, follow these steps:

![roku600px - in-channel-products-basics](https://image.roku.com/ZHZscHItMTc2/in-channel-products-basics-v2.png)

1.  From the **Channels** list, select one or more apps where this product will be available for sale. All that belong to the logged-in administrator (root account) are listed.

2.  From the **Product category** list, select one of the following classifications for the app:
    
    *   **Video:** Primarily short- or long-form video content, including music videos.
        
    *   **Audio:** Primarily audio content without accompanying video, such as streaming audio services or audio-only podcasts.
        
    *   **Game:** Primarily functions as a game.
        
    *   **App/Utility:** An application or utility. Examples include screensavers, weather apps, lottery results, etc.
        
3.  In the **Product** **name** field, enter a 30-character maximum product name in English. The name can include letters, numbers, spaces, and punctuation marks (UTF-8 characters are not supported). The product name may be included in invoices emailed to your customers; therefore, enter a name that is logical and easy-to-read for customers. For example, you can include a distinctive phrase or brand that makes the name easy for customers to recognize.
    
    UTF-8 characters are not supported in this version of the product name. You can enter localized versions of the product name that may include these characters in the next step.
    

> The product name is displayed to customers in the app's on-device purchasing workflow and in subscription emails sent by Roku. Make it easy for customers to identify subscription and one-time purchase products.
> 
> * * *
> 
> **Certification requirement:** The in-app product names must clearly identify the service being offered by the app. The publisher must have full legal rights or consent for their in-app product names and the rights to all trademarks and copyright expressions associated with the names. The in-app product names may not include the name "Roku", text related to a trial or discount offer**,** or any profanity or derogatory or misleading language.
> 
> **Do not include billing information in the product name such as pricing, billing cycle (for example, "monthly" or "annual"), or offers. Do not include text related to a trial or discount offer in the product name.**
> 
> **Do not include "Roku" or any profanity/derogatory language in the product name.**
> 
> * * *
> 
> You can use the following recommended syntax: ""_appName_ **\-** _planName_"". Product names on the "Roku Developers" app using this syntax could be, for example:
> 
> *   "Roku Developers - Ad-supported"
>     
> *   "Roku Developers - Premium Ad Free"
>     
> 
> ![roku815px - rsg-channelstore-doorder-product-name-highlighted](https://image.roku.com/ZHZscHItMTc2/rsg-channelstore-doorder-product-name-highlighted.jpg)

4.  Optionally, you can provide a localized product name. To do this, click **Add product name in another language**, select a language from the list (French, Spanish, or German), and then enter the localized product name. The localized product name can be a maximum of 30 characters and may include UTF-8 characters. Repeat this step to provide another localized product name; you can provide one per language.
    
    ![roku815px - inCP-SpanishProductName](https://image.roku.com/ZHZscHItMTc2/inCP-SpanishProductName.jpg)
    

> You may want certain products to only be available in specific countries. In the app, you can call the [**getUserRegionData**](/docs/references/scenegraph/control-nodes/channelstore.md#getuserregiondata) command to determine the country associated with the user's Roku account. You can then implement business logic to filter the results of the ChannelStore [**getCatalog** command](/docs/references/scenegraph/control-nodes/channelstore.md#getcatalog) to only display products that should be available for that country.
> 
> If you want to offer a specific in-app product in multiple countries, currency conversion can be handled by Roku or the publisher:
> 
> *   **Roku handles currency conversion**: Create a single in-app product for all countries.
> *   **Publisher handles currency conversion**: Create in-app products for each country and filter out the product by the country in the app business logic.

5.  In the **Product identifier** field, enter the internal code for your app. This identifier is used as the `code` field for retrieving catalog items, creating orders, and getting previous purchases with the [SceneGraph ChannelStore node](/docs/references/scenegraph/control-nodes/channelstore.md).

### Product pricing

To enter the price of a product, follow these steps:

![roku600px - in-channel-products-pricing](https://image.roku.com/ZHZscHItMTc2/in-channel-products-pricing-v2.png)

1.  From the **Purchase type** list, select one of the following types for the product being added:
    
    *   **One-Time Purchase:** A movie rental/purchase, sporting event, pay-per-view, or other product that may only be purchased a single time from an SVOD app. The publisher controls entitlements (number of viewings and permitted viewing time) for one-time purchase products in their backend system.
        
    *   **One-Time Purchase, Consumable - Quantity:** A "packet" of identical items (such as game points, number of viewings permitted ). Enter the size of the packet in the **Quantity** field.
        
        If you are creating a [TVOD-exclusive app](/docs/developer-program/roku-pay/implementation/tvod-channel.md), select this option and select **1** for quantity. This is because you create a single generic in-app product per product type for a TVOD app (rather than a product per content item as in a SVOD app), and this setting allows that generic in-app product to be purchased multiple times. For example, if you plan on offering movie rentals, you only need to create a single one-time purchase consumable video product. See [Creating TVOD apps](/docs/developer-program/roku-pay/implementation/tvod-channel.md) for more information.
        
    *   **Monthly subscription:** A product requiring a monthly charge for continued access.
        
    *   **Yearly subscription:** A product requiring an annual charge for continued access.
        

2.  From the **Price tier** list, select one of the predefined prices for the product.
    
    *   Tiers are used to enforce 99 cent or 49 cent pricing on app products.
        
        *   One to three-digit tier numbers are used for 99 cent pricing. Subtract 1 cent from a tier to get the corresponding price. For example, Tier 1 is 99 cents, Tier 2 is $1.99, Tier 10 is $9.99, Tier 100 is $99.99 and so on. The highest tier is 400 ($399.99).
            
        *   Four-digit tier numbers are used for 49 cent pricing. Append 49 cents to the last digit or last two digits in the tier to get the corresponding price. For example, Tier 1000 is 49 cents, Tier 1001 is $1.49, Tier 1010 is $10.49, Tier 1020 is $20.49 and so on. The highest tier is 1030 ($30.49).
            
            If you are creating a [TVOD-exclusive app](/docs/developer-program/roku-pay/implementation/tvod-channel.md), select any price tier. The price passed in the [ChannelStore APIs](/docs/references/scenegraph/control-nodes/channelstore.md) overrides the price corresponding to the selected price tier.
            

> Certification requirement: SVOD apps must provide 30-days notice to existing customers before changing the price of their service.

*   A chart under the **Price tier** field displays the price, in appropriate local currency, for each Streaming Store where the product will be available.
    
    *   The **Purchase price** reflects the amount to be paid by the customer. The purchase price for EU Streaming Store countries include VAT. Proceeds are based on pre-tax (net) prices.
        
    *   The **Your proceeds** field displays the amount that you receive from Roku for the sale of the product. Based on exchange rate fluctuations, the proceeds in one Streaming Store may not equal the amount to be received in another.
        

### Trials and offers

Apps can offer free trial periods and discounted offers, and Roku Pay automatically handles the auto-renewals of the trial or discounted offers to paid full-price subscriptions. Separate products do not need to be created for free trial or discounted offers. A single product may include both a base offer (the standard base price) and a trial/discount offer.

The administrator (root account) can create free-trials offers, discount pricing, and limited-time offers for a monthly or annual subscription following these steps:

1.  Under **Base offer**, select one of the following offers (by default, **None** is selected, meaning the subscription product does not include an offer):
    
    *   **Discounted Price**. Include a discount with the product. In the **Discounted Price Tier** box, select the pricing tier corresponding to the discounted price to be offered, and then enter the number of months the discount is included.
        
        Discounts cannot be specified using percentages or absolute currency units (for example, USD). Discounts may only be specified using the appropriate price tier. For example, the absolute discount from tier 9 to tier 6 is $3.00 ($8.99-5.99); the percentage discount is 33.4% ($(1-(5.99/8.99))x100)
        

*   **Free Trial**. Include a free trial period with the product. In the **Trial duration** box, enter the number of days or months in the trial offer and then select the unit of time (**Days** or **Months**).
    
    ![roku815px - inCP-TrialsAndOffers2](https://image.roku.com/ZHZscHItMTc2/inCP-TrialsAndOffers2.jpg)
    

2.  If the product is ready to be made available to customers for purchase, select the **Cleared for Sale** check box. This makes the product visible to the ChanelStore node (specifically, the node's [**getCatalog** field](/docs/references/scenegraph/control-nodes/channelstore.md#getcatalog) will return this product). Selecting this check box also enables you to schedule limited-time free trial and discount offers for the product.
    
    If the product is still being tested, keep the check box cleared (it is cleared by default). In this case, the **ChannelStore** node's [**getCatalog** field](/docs/references/scenegraph/control-nodes/channelstore.md#getcatalog) will not return this product.
    

3.  Click **Save** to add the in-app product to the **Manage In-Channel Products** index page.
    
    ![roku815px - in-channel-products-home](https://image.roku.com/ZHZscHItMTc2/in-channel-products-home-v2.png)
    

4.  This page lists the name, identifier/code, type, and purchase price (in USD) for each product and whether the product was **Cleared for Sale** (yes or no). The initial **Status** is based on whether the product was cleared for sale. If yes, the status is "Approved"; if no, it is marked with a "Submit for Review" link. Clicking the "Submit for Review" link approves the product. To make it available for purchase, however, you still need to edit the product and select the **Cleared for sale** check box.

### Scheduling offers

You can schedule time-limited free trial and discount offers on monthly and annual subscription products that have been cleared for sale. When a new customer subscribes to a product during an active time-limited offer, the customer receives that offer (a time-limited offer takes precedence over the base offer). If no time-limited offer is active, the customer receives the base offer. Customers may only ever receive a single free trial or discount offer for a subscription product, and they may only receive an offer that was made and accepted.

* * *

**Example**

Consider a monthly subscription product with the following time-limited and base offers:

*   **Time-limited offer**: Two-month free trial.
*   **Base**: Three-month 50% discount.

A customer accepts a two-month free trial. When the trial period ends, the customer is billed at the full monthly subscription rate for the next month (they do not receive the 50% discount included in the base offer because a customer may only ever receive a single free trial or discount offer).

If no time-limited offer was scheduled when the customer initially purchased their subscription, the customer would be billed for the first three months at 50%, and would then pay the full subscription rate starting with the fourth month.

* * *

To schedule a time-limited offer for a monthly or annual subscription product, follow these steps:

1.  In the **Manage In-Channel Products** index page, click the product name link to edit the product.

2.  At the bottom of the **Manage In-Channel Products** page, verify that the **Cleared for Sale** check box is selected. If the check box is cleared, select it, click **Save**, and then click the **Product name** link from the index page again.
    
    ![roku600px - schedule-offer-start](https://image.roku.com/ZHZscHItMTc2/schedule-offer-start.jpg)
    

3.  Click **Schedule offer**.
    
    ![roku600px - schedule-offer-button](https://image.roku.com/ZHZscHItMTc2/schedule-offer-button-v2.jpg)
    

4.  In the **Product Offers** page, create an offer following these steps:
    
    a. Click **Create new offer**.
    
    ![roku600px - create-new-offer](https://image.roku.com/ZHZscHItMTc2/create-new-offer-v2.png)
    
    b. Select the type of time-limited offer to be created: **Free trial** or **discounted price**. If you select **Free trial**, enter the number of days or months in the trial offer and then select the unit of time (**Days** or **Months**). If you select **Discounted price,** select the pricing tier corresponding to the discounted price to be offered, and then enter the number of months the discount is included. The discounted offer price must be lower than the regular product price.
    
    ![roku815px - SchedOffSchedProdOff](https://image.roku.com/ZHZscHItMTc2/SchedOffSchedProdOff-v2.png)
    
    c. In the **Start Date** and **End Date** boxes, select when the time-limited offers begins and ends in Pacific Time Zone (PT). The **End date** is inclusive. For example, if the state date is Nov 11, 2021 and the end date is Dec 26, 2021, the offer begins on November 11th at 12:00AM PST (08:00 AM UTC), and it ends December 26th at 11:59PM PST (December 27th, 07:59 AM UTC). The **End date** may not be in the past. Scheduled offers may not overlap—only one scheduled offer may be active on any given date.
    
    ![roku600px - SchedOffSchedProdOffDiscPr](https://image.roku.com/ZHZscHItMTc2/SchedOffSchedProdOffDiscPr-v2.png)
    
    d. Click **Save** and then click **Confirm** in the **Confirm new time-limited offer** dialog.
    
    ![roku600px - confirm-offer](https://image.roku.com/ZHZscHItMTc2/confirm-offer-v2.png)
    
    e. The new offer is listed in the **Product offers** index page.
    
5.  The **Product offers** index page lists all the active and future scheduled time-limited offers.
    
    ![roku815px - time-limited-offers-index](https://image.roku.com/ZHZscHItMTc2/time-limited-offers-index-v2.png)
    
    *   To edit a scheduled offer, click its **Offer name** link. Active and expired offers cannot be edited.
        
    *   To delete a scheduled offer, click the check box to the left of the offer name and then click **Delete**. Active and expired offers cannot be deleted.
        
    *   To view a list of historical offers, click **Expired** **offers**.
        

### Editing in-app products

You can edit a product listed in the **Manage In-Channel Products** index page by clicking its **Product name** link. Editing a product is necessary for changing its **Cleared for Sale** status and scheduling trial and discount offers.

### Deleting in-app products

> Deleted products cannot be recovered. If the subscription product could be made available for purchase again in the future, just edit the product and set its **Cleared for Sale** status to "No". This cancels all existing subscriptions of the product.

Deleting a product without first changing its **Cleared for Sale** status to "No" keeps the current subscriptions of the product active, but it prevents additional purchases of the product.

You can delete a product listed in the **Manage In-Channel Products** index page following these steps:

1.  Verify that the product is "not cleared for sale". If it is, edit it and clear the **Cleared for Sale** check box. All existing product subscriptions will no longer be renewed on their expiration dates.
    
2.  Select the checkbox to the left of the product name, and then click the **Delete** button that appears at the top of the column. You can delete multiple products at the same time. The selected products are permanently removed from all apps to which they are linked.
    

Adding product groups
---------------------

Subscription services must add any set of _mutually exclusive_ subscription products to a product group (mutually exclusive means subscription products that customers cannot be subscribed to simultaneously). This enables customers to upgrade or downgrade those subscription products on-device, and avoid being double-billed for access to the same content or service.

*   **Upgrade/downgrade**. If an app offers monthly and annual subscriptions, a product group that includes both plans must be created. Similarly, if an app offers ad-supported and ad-free plans, or HD and 4K plans, those sets of products must be added to a product group.

*   **Double billing**. If an app has two in-app products for the same monthly subscription but with different free trial durations, these two products must be added to the same product group to prevent the customer from paying for two separate monthly subscriptions.

From the customer perspective, if they try to purchase a subscription product when they already have one in the same product group, Roku Pay displays a "You're already subscribed to this app" dialog.

> For more on how product groups are used to enable customers to easily switch between different service tiers, see the [On-device upgrade and downgrade](/docs/developer-program/roku-pay/implementation/on-device-upgrade-downgrade.md) implementation guide.

![roku815px - already-subscribed](https://image.roku.com/ZHZscHItMTc2/already-subscribed.jpg)

> **Certification requirement**: Subscription services must create product groups for all sets of subscription products that customers cannot be subscribed to simultaneously in order to pass [certification](/docs/developer-program/certification/certification.md#2-purchases).

To create a product group, follow these steps:

1.  Click the **Product Groups** tab, and then click **Add a New Group**.
    
    ![roku815px - add-new-product-group](https://image.roku.com/ZHZscHItMTc2/add-new-product-group-v2.png)
    

2.  In the **Group Name** box, enter a descriptive name for the group that makes it easy to identify. For example, if you are creating a product group containing monthly and annual plans, it could be named "Subscription Plans".

3.  From the **Channel List**, select the app that uses the product group.

4.  Under **Add to group** on the right-hand side of the page, select the checkbox for each mutually exclusive in-app product to be included in the product group, and then click the **Add to group** icon (+). To remove a product from a group, select its check box under **Remove from group** on the left-hand side of the page and then click the minus (-) icon.
    
    ![roku815px - product-group-selected-products](https://image.roku.com/ZHZscHItMTc2/product-group-selected-products-v2c.png)
    

5.  Click **Save**.

6.  The **Product group** index page lists the new product group. You can edit a product group by clicking its **Group name** link. You can delete a product group by selecting its check box and clicking **Delete**.
    
    ![roku600px - product-group](https://image.roku.com/ZHZscHItMTc2/product-group-v2.png)

ZoomRowList
===========

The ZoomRowList node allows a row of the Row-Row Grid to smoothly zoom up to a larger size when that row has focus. Rows in this node are capable of gaining the focus while scrolling, and smoothly zooming up by the specified amount. The amount to zoom can be specified on a per row basis so that some rows can zoom up by a larger amount than others.

Anatomy of a ZoomRowList node
-----------------------------

ZoomRowList is a vertically scrolling list of ZoomRowItem's. ZoomRowItem refers to a horizontally scrolling row or items plus any annotations such as title or counter. In the diagram below, the light blue rectangle identifies what's included in a ZoomRowItem.

![roku815px - partsLabelled](https://image.roku.com/ZHZscHItMTc2/partsLabelled.jpg "partsLabelled")

#### ZoomRowItem's consist of four parts:

*   **Row Title** - This is a built-in Label used to display a title for the row. The string that is displayed comes from the \_title \_field of the Row's ContentNode. The Row Title supports turning its display on or off, changing its position relative to the ZoomRowItem's coordinate system and modifying its color and font. This is identified by the **green** box in the diagram above.
*   **Row Counter** - This is a built-in Label used to display a counter for the row (i.e. 3 of 14). The string that is displayed is automatically generating by the ZoomRowList. In addition to supporting the display attributes listed above for the Row Title, the Row Counter also supports the option of only displaying it when there are enough items in the row to fill up the entire width of the ZoomRowList. By default, the Row Counter is only displayed for the focused row. This is identified by the **orange** box in the diagram above.
*   **Row Decoration** - Row Decoration refers to an optional custom RSG component that is used to supplement or replace the Row Title and Row Counter displayed by each ZoomRowItem. The Row Decoration supports several fields that can be used to control its appearances, such as the current height of the ZoomRowItem and the current focus percentage of the row. Some examples where this could be useful include:
    
    *   Replacing the built-in Row Title with a more complex title that includes both text and icons
    *   Adding a Bob to the ZoomRowItem that becomes visible as the row enters the focus position and displays details about the currently focused item in the row.In the picture above, the ZoomRowItem does not include a custom Row Decoration.
*   **Row** - Row refers to the part of the ZoomRowItem that displays the horizontally scrolling set of Item nodes. Each Item uses a custom RSG component to render the associated data. The Row is identified by the **yellow** box in the diagram above. An Item is identified by the **magenta** box in the diagram above.

In some cases, Decoration is used to refer to all the parts of the ZoomRowItem other than the Row (i.e. the Row Title, Row Counter and Row Decoration).

ZoomRowList uses the same data model as RowList nodes. There is a single ContentNode, the root ContentNode, that is assigned to be the content of the entire ZoomRowList. The root ContentNode contains zero or more child ContentNode's that contain the data for each row of the ZoomRowList. These are referred to as row ContentNodes. Each of the row ContentNode's contain zero or more child ContentNode's that contain the data for each item in the row. These are referred to as item ContentNodes.

Layout and coordinate systems
-----------------------------

### Overall coordinate system and layout parameters

The illustration below shows the overall coordinate system used by the ZoomRowList (the green X-Y axis). The origin of the coordinate system defines the top/left point of the fixed focus location.

The heights of each ZoomRowItem is defined by the `rowZoomHeight` field if the row is focused and the `rowHeight` field if the row is not focused. As the row enters or leaves the focus position, the ZoomRowItem's height is smoothly interpolated between the two values. Each ZoomRowItem is separated from the next by the value specified in the `spacingAfterRow` field, shown in bright blue in the diagram.

The ZoomRowList's `itemClippingRect` field is used to specify the region where the items in each Row can appear. In this case, the itemClippingRect, shown in yellow in the diagram, is set so that no partial items to the left of ZoomRowList's origin are visible. Generally, setting the itemClippingRect to the smallest value that contains the item's that should be displayed provides optimal performance, so in this case, the width/height of the itemClippingRect is set to the distance between the origin of the ZoomRowList's coordinate system and the right/bottom edge of the screen. Note that the itemClippingRect does not clip the focus feedback indicator.

The `rowWidth` field specifies the maximum width of items in each Row before the item's wrap. If the total width of the items in the row is less than rowWidth, the focus will float left and right as the user navigates the row. If the total width of the items in the row exceeds rowWidth, the focus will stay fixed on the left and the items will animate left and right as the use navigates the row. In this case, the value of the rowWidth field has also been used to specify the position of the Row Counter.

![roku815px - overallCoordinateSystem](https://image.roku.com/ZHZscHItMTc2/overallCoordinateSystem.jpg "overallCoordinateSystem")

### Zoomed and unzoomed row layout parameters

The diagram below shows how the various `rowItem` fields are used to layout zoomed and not zoomed ZoomRowItem's. Each ZoomRowItem has its own coordinate system. The X coordinate of the origin the coordinate system is equal to the X coordinate of the overall ZoomRowList's coordinate system. The Y coordinate of the origin of the each ZoomRowItem's coordinate system is position at the top of each ZoomRowItem. The ZoomRowItem coordinate system is shown as green axes in the diagram.

The focused ZoomRowItem at the top uses the `rowItemZoomOffset` field to position its Row relative to the top of the ZoomRowItem's coordinate system. Similarly, the `rowItemZoomHeight` field is used to specify the height of the items in the Row. The width of the items in the Row is computed using the item's height and aspect ratio, which either comes from the `rowItemAspectRatio` field (if the `useDefaultAspectRatio` field is true) or from the `aspectRatio` field of each item's ContentNode if useDefaultAspectRatio is false.

Similarly, the unfocused ZoomRowItem occupying the second row uses the `rowItemOffset` field to position its Row relative to the top of the ZoomRowItem's coordinate system. Similarly, the `rowItemHeight` field is used to specify the height of the items in the Row. The aspect ratio is used to compute the width of each item the height as above. The `spacingAfterRowItem` field is used to specify the horizontal distance between items in the Row. This spacing is zoomed up by the same percentage as the rowHeight as the row gains focus.

In this illustration, there is no custom Row Decoration. The positions of Row Title and the Row Counter are specified relative to the origin of each ZoomRowItem by the `rowTitleOffset` and the `rowCounterOffset` fields, respectively. The Row Counter is right-aligned, so its right edge is located at the X coordinate of the rowCounterOffset.

![roku815px - rowLayout](https://image.roku.com/ZHZscHItMTc2/rowLayout.jpg "rowLayout")

### Custom row decoration

The illustration below is similar to the one above, but in this case, a custom Row Decoration component is used to display album details for the ZoomRowItem in the focused position. Observe in this case that the rowItemZoomYOffset for the zoomed row is much larger than the rowItemYOffset for the un-zoomed row. This causes the space between the top of the ZoomRowItem and it's horizontally scrolling Row of items to increase as the ZoomRowItem gains focus, allowing room for the album details to smoothly transition onscreen to fill that extra space.

Also, notice that the ratio of the focused/unfocused ZoomRowItem's overall height (rowZoom Height/row Height) is significantly larger than the ratio of the focus/unfocused heights of the ZoomRowItem's Row's (rowItemZoomHeight / rowItemHeight). To allow for the extra space occupied by the album details, the Row of items zooms up less than the overall ZoomRowItem does.

Also note that in this case, the itemClippingRect is set to reveal partial items to the left of the origin of the ZoomRowList. Since the first row contains enough items to wrap, the partial items are shown. In the second row, there are not enough items to wrap, so all the items are fully visible and no duplicate partial items are shown.

![roku815px - rowDecorationLayout](https://image.roku.com/ZHZscHItMTc2/rowDecorationLayout.jpg "rowDecorationLayout")

ZoomRowList fields
------------------

ZoomRowList extends Group so has all the fields of Group as well its parent class Node.

Many ZoomRowList fields have an array of values as their type. Unless otherwise noted, the values in these arrays specify a value for each row in the ZoomRowList's data model. If no values are specified, a default value is used. If there are fewer items in the array than rows in the ZoomRowList's data model, the last value in the array is repeated as needed for the unspecified rows. If there are more items in the array than rows in the ZoomRowList's data model, the extra values are ignored.

One common use case for these array fields is to specify a special value for the first row in the array (a Hero row) and a second value for all other rows. In that case, the field would be set to `[ <Hero Row Value>, <Regular Row Value> ]` so that the Hero Row Value is used for the first row and the Regular Row Value is used for the remaining rows.

This table documents all the fields in ZoomRowList:

| Field | Type | Default | Access Permission | Use |
| --- | --- | --- | --- | --- |
| content | ContentNode | invalid | READ\_WRITE | Specifies the content for the list. The content should be a single ContentNode that has one child ContentNode for each row. These child ContentNodes for each row should themselves contains child ContentNodes for each item in the row. See [ZoomRowList data model](/docs/references/scenegraph/list-and-grid-nodes/zoomrowlist.md#zoomrowlist-data-model) below for more details. |
| itemComponentName | string | ""  | READ\_WRITE | Specifies the name of an XML component for the items in each row. An instance of this component is created on demand for each visible item of each row. The XML component must define a specific interface as detailed [Item component fields](/docs/references/scenegraph/list-and-grid-nodes/zoomrowlist.md#item-component-fields) below. |
| rowWidth | float | 0.0 | READ\_WRITE | This specifies a "safe" width for the row. Currently, it's only used if the displayed width of the zoomed Item's exceeds this width. If that occurs, the items in the row will wrap horizontally.  <br>  <br>Once full floating focus functionality is added in a subsequent release, this will be used to specify the rightmost limit that the focus can reach as focus floats from left to right. |
| rowHeight | array of float | \[ \] | READ\_WRITE | Specifies the height of the ZoomRowItem when the row is not zoomed. Note that this includes the height of the Row and its Decorations. At least one value must be specified. |
| rowZoomHeight | array of float | \[ \] | READ\_WRITE | Specifies the height of the ZoomRowItem when the row is zoomed. As the row gains focus, the height of its ZoomRowItem will smoothly change from the row's itemHeight to the row's rowZoomHeight.  <br>  <br>If no values are specified, none of the rows zoom. |
| spacingAfterRow | float | 0.0 | READ\_WRITE | Specifies the spacing between rows of the ZoomRowList. Note that this spacing value is not scaled by the zoomPercent. |
| itemClippingRect | Rect2D | AA with x, y, width, height set to zero | READ\_WRITE | Specifies a clipping region for the ZoomRowItem's rendered. This provides control over which items are visible. For example, if the left value is set to a negative number, items to the left of the grid's item origin will be visible.  <br>  <br>For best performance, this should be set so that the itemClippingRect exactly matches what's visible onscreen.  <br>  <br>If this field is not set, heuristics are used to determine an acceptable clipping rectangle for the items in the ZoomRowList.This field will have the same value as rowFocusPercent unless the remainZoomedAboveFocus field is set to "never" or if the zoomed and un-zoomed height of a row are equal. |
| rowItemYOffset | array of float | \[ \] | READ\_WRITE | This specifies the vertical position of the Row relative to the top of its ZoomRowItem when the row is unfocused.  <br>  <br>Combined with rowZoomYOffset, this allows the vertical position of the ZoomRowItem's Row to smoothly change relative to the top of the ZoomRowItem as the ZoomRowItem gains or loses focus. |
| rowItemZoomYOffset | array of float | \[ \] | READ\_WRITE | This specifies the vertical position of the Row relative to the top of its ZoomRowItem when the row is focused (i.e. zoomed).  <br>  <br>Combined with rowYOffset, this allows the vertical position of the ZoomRowItem's Row to smoothly change relative to the top of the ZoomRowItem as the ZoomRowItem gains or loses focus. |
| rowItemHeight | array of float | \[ \] | READ\_WRITE | This specifies the height of each Item in a Row when the row is unfocused.  <br>  <br>Combined with rowZoomItemHeight, this allows the height of each Item in a Row to be scaled differently than the height of the Row's ZoomRowItem. As the ZoomRowItem gains or loses focus, the height of each Item in the Row smoothly interpolated between the rowItemHeight and rowZoomItemHeight for that row. |
| rowItemZoomHeight | array of float | \[ \] | READ\_WRITE | This specifies the height of each Item in a Row when the row is focused (i.e. zoomed).  <br>  <br>Combined with rowZoomItemHeight, this allows the height of each Item in a Row to be scaled differently than the height of the Row's ZoomRowItem. As the ZoomRowItem gains or loses focus, the height of each Item in the Row smoothly interpolated between the rowItemHeight and rowZoomItemHeight for that row. |
| rowItemAspectRatio | array of float | \[ \] | READ\_WRITE | This specifies the aspect ratio of the Items in a Row. This is used to compute the width of the Item's based on the interpolated row item height (see the rowItemHeight and rowZoomItemHeight fields above).  <br>  <br>If useDefaultAspectRatio is true for that row, then the rowItemAspectRatio value is used to compute the width of each Item in the Row. If false, then if the ContentNode for the Item includes an aspectRatio field, that value is used. This allows different items in a Row to have different aspect ratios.  <br>  <br>The rowItemAspectRatio values should be a floating point values that represent the ratio of the Item's width to height. For example, if the Item should have a 16 x 9 aspect ratio, this value specified would by 1.7777778 ( = 16 / 9). |
| spacingAfterRowItem | array of float | \[ \] | READ\_WRITE | This specifies the horizontal spacing between Items in a Row. When the row is unfocused, this spacing is set to this value. As the row gains focus, this value scales by the same percentage as the row item height increases as it's interpolated between the rowItemHeight and the rowItemZoomHeight for the row. |
| useDefaultAspectRatio | array of Boolean | \[ \] | READ\_WRITE | If set to false, rowItemAspectRatio is used to specify the aspect ratio for items in a Row. If set to true and if the ContentNode for an Item in the row includes an aspectRatio field, that value is used instead of the rowItemAspectRatio value. This allows different items in a Row to have different aspect ratios. |
| wrap | Boolean | true | READ\_WRITE | If true, the items wrap from bottom to top. If false, the items do not wrap. |
| drawFocusFeedbackOnTop | Boolean | true | READ\_WRITE | If true, the focus feedback indicator is drawn on top of (after) the items. If false, it is drawn below (before) the items. |
| drawFocusFeedback | Boolean | true | READ\_WRITE | If true, the focus feedback indicator is drawn. If false, it is not drawn. |
| fadeFocusFeedbackWhenLongPressScrolling | Boolean | true | READ\_WRITE | If true, when long press scrolling begins, the focus indicator will fade out and reappear when long press scrolling ends. If false, the focus indicator remains visible during long press scrolling. |
| focusBitmapUri | uri | ""  | READ\_WRITE | Specifies the bitmap file used for the focus feedback indicator when the ZoomRowList has focus. In most cases, this should be a 9-patch image that specifies both expandable regions as well as margins. Only set this field to specify a custom bitmap that differs in appearance from the default bitmap. |
| focusBitmapBlendColor | color | 0xFFFFFFFF | READ\_WRITE | Blend the graphic image specified by `focusBitmapUri` with the specified color. If set to the default, 0xFFFFFFFF, no color blending will occur. Set this field to show a focus indicator graphic image with a different color than the image specified by `focusBitmapUri`. |
| wrapDividerBitmapUri | uri | ""  | READ\_WRITE | Specifies the bitmap file to use as a visual separator between the last and first list items when the list wraps. In most case, this should be a 9-patch image that specifies both expandable regions. Only set this field to specify a custom bitmap that differs in appearance from the default bitmap. |
| wrapDividerBitmapBlendColor | color | 0xFFFFFFFF | READ\_WRITE | Blend the graphic image specified by wrapDivider `BitmapUri` with the specified color. If set to the default, 0xFFFFFFFF, no color blending will occur. Set this field to show a focus indicator graphic image with a different color than the image specified by wrapDivider`BitmapUri`. |
| wrapDividerHeight | float | 0   | READ\_WRITE | Specifies the height of the divider. The wrap divider bitmap will be scaled to this height. This height is also added to the row spacing after the last row to allow more space between the first and last rows when the divider is drawn. |
| wrapDividerWidth | float | 0   | READ\_WRITE | Specifies the width of the divider. The wrap divider bitmap will be scaled to this width. If not specified, the width is set to the value of the `rowWidth` field. |
| wrapDividerOffset | Vector2D | 0   | READ\_WRITE | By default, the wrap divider is drawn with its X-position set to 0 in the ZoomRowList's coordinate system and vertically centered in the space between the first and last rows (This space equals the spacing after the last row plus the row divider height). This field allows the position of the wrap divider to be adjusted relative to its default position. |
| showRowTitle | array of Boolean | \[ \] | READ\_WRITE | Specifies whether the row title displayed.  <br>  <br>**NOTE:** RowList has an identical field named "showRowLabel". The name was changed to "showRowTitle" for the ZoomRowList to indicate that the text for the label comes from the Row ContentNode's title field. |
| rowTitleOffset | array of Vector2D | \[ \] | READ\_WRITE | Specifies the offset of the Row Title for each row. The x-coordinate specifies the horizontal offset of the label from the left edge of the row. The y-coordinate specifies the vertical spacing of the top of the Row Title from the top of the row's coordinate system. If the array specified contains no values, a default offset value of `[0,0]` is used. |
| rowTitleFont | Font | invalid | READ\_WRITE | Specifies the font for the Row Title's text.  <br>  <br>**NOTE:** RowList has an identical field named "rowLabelFont" (see showRowTitle's description above for more details). |
| rowTitleColor | array of color | \[ \] | READ\_WRITE | Specifies the color of the Row Title's text.  <br>  <br>**NOTE:** RowList has an identical field named "rowLabelColor" (see showRowTitle's description above for more details). |
| showRowCounter | array of Boolean | \[ \] | READ\_WRITE | Specifies whether each row's Row Counter is displayed. Note that the Row Counter is displayed for the focused row even if the `showRowTitle` field value for that row is set to true. |
| rowCounterOffset | array of Vector2D | \[ \] | READ\_WRITE | Specifies the offset of the Row Counter for each row. The x-coordinate specifies the horizontal offset of the label from the left edge of the row. The y-coordinate specifies the vertical spacing of the top of the Row Counter from the top of the row's coordinate system. If the array contains fewer elements than the number of rows in the data model, the last value in the array is used as the offset for the labels of the extra rows. If the array specified contains no values, a default offset value of `[0,0]` is used.  <br>  <br>Note that the Row Counter is right-aligned, so the x-coordinate of its rowCounterOffset is used to position the right edge of the Row Counter's Label node. |
| rowCounterFont | Font | invalid | READ\_WRITE | Specifies the font for the Row Counter's text.  <br>  <br>**NOTE:** RowList did not allow a different font for the Row Counter to be used. It always used the same font as the Row Title. |
| rowCounterColor | array of color | \[ \] | READ\_WRITE | Specifies the font for the Row Counter's text.  <br>  <br>**NOTE:** RowList did not allow a different color for the Row Counter to be used. It always used the same color as the Row Title. |
| showRowCounterForShortRows | Boolean | true | READ\_WRITE | When set to true, the Row Counter is shown for all rows. When set to false, the Row Counter is not shown if the total zoomed width of the items in the room is less than the value of the `rowWidth` field. |
| rowDecorationComponentName | array of strings | \[\] | READ\_WRITE | Specifies the name of an XML component to decorate each row. An instance of this component is created on demand for each visible item of each row. The XML component must define a specific interface as detailed in the [Row decoration component fields](/docs/references/scenegraph/list-and-grid-nodes/zoomrowlist.md#row-decoration-component-fields) section below. |
| rowSelected | integer | \-1 | READ\_ONLY | When an item is selected, set to the index of the selected row.  <br>  <br>**NOTE:** RowList has an identical field named "itemSelected". This new name better reflects the field's purpose. |
| rowFocused | integer | \-1 | READ\_ONLY | When a row gains the key focus, set to the index of the focused row.  <br>  <br>**NOTE:** RowList has an identical field named "itemFocused". This new name better reflects the field's purpose. |
| rowUnfocused | integer | \-1 | READ\_ONLY | When a row loses the key focus, set to the index of the unfocused row.  <br>  <br>**NOTE:** RowList has an identical field named "itemUnfocused". This new name better reflects the field's purpose. |
| rowItemSelected | array of integer | \[ \] | READ\_ONLY | When an item is selected, set to a 2-element array, where element 0 contains the index of the row containing the selected item, and element 1 contains the index of the selected item in that row. |
| rowItemFocused | array of integer | \[ \] | READ\_ONLY | When an item gains the key focus, set to a 2-element array, where element 0 contains the index of the focused row, and element 1 contains the index of the focused item in that row. |
| scrollingStatus | Boolean | false | READ\_ONLY | Set to true whenever the ZoomRowList is scrolling the focus horizontally or vertically. |
| rowsRendered | array of integer | \[ \] | READ\_ONLY | Contains a pair of indices that indicate the first and last Row ContentNode's that were rendered during the previous render. It is set at the end of each render.  <br>  <br>For example, if rows 2, 3 and 4 were rendered, the field is set to `[2, 4]`  <br>  <br>Note if the rows have wrapped vertically, the first value will be less than the second. So if there are 7 Row ContentNode's and itemsRendered is set to \[ 6, 1\] that indicates that Row ContentNode's 6, 0 and 1 were rendered. |
| rowItemsRendered | array of integer | \[ \] | READ\_ONLY | Contains an array of values that indicate what Row ContentNode's and what Item ContentNode's were rendered during the previous render. It is set at the end of each render.  <br>  <br>The values in the arrays are triples of integers with each triple containing the index of the Row ContentNode, followed by the first and last index of the Item ContentNode's in that row that was rendered.  <br>  <br>For example if rowItemsRender is set to \[ 0, 4, 7, 1, 0, 2, 2, 0, 3 \] that indicates that Item ContentNode children 4 to 7 of Row ContentNode 0 were rendered, Item ContentNode children 0 to 2 of Row ContentNode 1 were rendered and Item ContentNode children 0 to 3 of Row ContentNode 2 were rendered.  <br>  <br>The triples will appear in the order in which the rows were rendered and will contain one triple of values for each rendered row.  <br>  <br>If the Item's in a row have wrapped horizontally, the first item index for that row will be greater than the second. For example, if row 3 has 8 Item ContentNode's and rowItemsRendered is set to \[ 3, 6, 2\], that indicates that Item ContentNode's 6, 7, 0, 1 and 2 of row 3 were rendered. |
| currFocusRow | float | \-1.0 | READ\_ONLY | Set to the index of the row that currently overlaps the ZoomRowList's fixed focus position (i.e. y=0 in the ZoomRowList's coordinate system). Let's refer to that position as yFocusTop. The value is a floating point value where the integer part represents the row that overlaps yFocusTOp and the fractional part represents the percentage of the item that overlaps the fixed focus position. For example, a value of 2.3 indicates that the focus is 30% of the way between row's 2 and 3.  <br>  <br>If currFocusRow is greater than the number of rows' in the content minus 1, that indicates that the focus is between the last row and the first row. For example, if the ZoomRowList's content has 8 rows, currFocusRow = 7.65 would indicate that the focus is 65% of the way between row 7 and row 0. |
| jumpToRow | integer | \-1 | WRITE\_ONLY | When set to a valid item index, causes the list to immediately update so that the specified row moves into the focus position.  <br>  <br>**NOTE:** RowList has an identical field named "jumpToItem". This new name better reflects the field's purpose. |
| jumpToRowItem | array of integer | \[ \] | WRITE\_ONLY | When set to a valid \[ row, col \] index pair, causes the list to immediately update so that the specified row, col item moves into the focus position. |
| animateToRow | integer | \-1 | WRITE\_ONLY | **Write-Only**   <br>When set to a valid item index, causes the list to quickly scroll so that the specified row moves into the focus position.  <br>  <br>**NOTE:** RowList has an identical field named "animateToItem". This new name better reflects the field's purpose. |
| remainZoomedAboveFocus | string | focusIsAtTop | READ\_WRITE | This field controls whether the rows that appear above the focus row are shown in their zoomed size or un-zoomed size as they move in/out of the focus position.  <br>  <br>If set to "focusIsAtTop" and the ZoomRowList's itemClippingRect's top is set 0.0, then rows will remain at their zoomed size as they enter/exit the focus region from above. The UX team has decided that this looks better as it minimizes the number of items simultaneously changing sizes as the user scrolls vertically.  <br>  <br>If set to "never", then rows will zoom up/down as they enter/exit the focus region from above.  <br>  <br>If set to "always", then rows will always remain at their zoomed size as they enter/exit the focus region from above regardless of the itemClippingRect's top value. |
| fadeOutAboveFocus | string | focusIsAtTop | READ\_WRITE | This field controls whether the rows that appear above the focus row fade in/out as they move in/out of the focus position.  <br>  <br>If set to "focusIsAtTop" and the ZoomRowList's itemClippingRect's top is set 0.0, then rows will fade in/out as they enter/exit the focus region from above.  <br>  <br>If set to "never", then rows will not fade in/out as they enter/exit the focus region from above.  <br>  <br>If set to "always", then rows will always fade in/out as they enter/exit the focus region from above regardless of the itemClippingRect's top value. |

ZoomRowList data model
----------------------

A ZoomRowList node should have a single ContentNode as the root node stored in its content field. One child ContentNode should be added to the root node for each row in the list (these nodes can be thought of as `row nodes`). Each row node should contain one child ContentNode for each item in the row (these nodes can be thought of as `item nodes`).

#### Row ContentNode data bindings

| Attribute | Type | Description |
| --- | --- | --- |
| title | string | This is used as the string display in the Row Title |

#### Item ContentNode data bindings

| Attribute | Type | Description |
| --- | --- | --- |
| aspectRatio | float | This specifies the aspectRatio for the item. It is used to compute the width from the interpolated row item height for row's where the useDefaultAspectRatio is set to false.  <br>  <br>The value should be a floating point value representing the ratio of the Item's width to height. For example, if the Item should have a 16 x 9 aspect ratio, this value specified would by 1.7777778 ( = 16/9). |

Item component fields
---------------------

Each Item in the ZoomRowList is rendered using a custom XML component specified by the `itemComponentName` field value. An instance of this component is created for each visible Item in each Row of the ZoomRowList.

If the XML component contains interface fields that match the names shown in the table below, those fields will be updated by the ZoomRoowList node. This allows the XML component to dynamically alter the item's appearance by observing changes to these interface fields.

Note that the fields are updated in the order presented in the table below. Most notably, when the itemContent field is set initially, the other fields will have valid values. This allows the script to be made more efficient by delaying computations until the itemContent field is set in some cases.

| Field Name | Field Type | Access Permission | Description |
| --- | --- | --- | --- |
| width | float | READ\_ONLY | Set to the width of the Item.  <br>  <br>Note this is computed from the interpolated row item height scaled by the item's aspect ratio. The aspect ratio comes from either the rowItemAspectRatio field (if useDefaultAspectRatio for the row if true) or from the Item's ContentNode (if useDefaultAspectRatio for the row is false). |
| height | float | READ\_ONLY | Set to the height of the Item.  <br>  <br>Note this is computed by interpolating the rowItemHeight and rowZoomItemHeight field values for the row. |
| index | integer | READ\_ONLY | Set to the index of the Item ContentNode in the row's Row ContentNode associated with this item. For example, if the index is set to 2, that indicates that this item is associated with child 2 of the Row's ContentNode. Note that the index of the RowContent node is available via the rowIndex field. |
| rowIndex | integer | READ\_ONLY | Set to the index of the Row ContentNode associated with this item. For example, if the index is set to 2, that indicates that this Item is part of row 2. |
| itemHasFocus | Boolean | READ\_ONLY | Indicates whether the Item is currently the RowList's focused item. When scrolling starts, the itemHasFocus field for the currently focused Item is set to false. When scrolling ends, the itemHasFocus field for the newly focused Item is set to true. During the scrolling animation, all itemHasFocus fields are set to false.  <br>  <br>Only one Item's of the ZoomRowList will ever have itemHasFocus set to true. If the ZoomRowList does not have focus, all itemHasFocus fields of all Item's will be set to false. |
| rowHasFocus | Boolean | READ\_ONLY | Set to true if the Row that contains this Item has focus, false otherwise. When scrolling starts, the rowHasFocus field for all Item's in the Row in the currently focused Row is set to false. When scrolling ends, the rowHasFocus field for all Item's the newly focused Row are set to true. During the scrolling animation, all rowHasFocus fields are set to false.  <br>  <br>Only the Item's in one Row of the ZoomRowList will ever have rowHasFocus set to true. If the ZoomRowList does not have focus, all rowHasFocus fields of all Item's will be set to false. |
| rowListHasFocus | Boolean | READ\_ONLY | Set to true if the ZoomRowList that contains this Item has focus, false otherwise. The rowListHasFocus field of all Item's of the ZoomRowList will always have the same value. |
| itemContent | ContentNode | READ\_ONLY | Contains the data to be displayed by the row list item. The relationship between data in the ContentNode node and the visual elements of the row list item is determined by the markup and scripts' of the item's XML component. Typically, an observer callback function of the itemContent field is used to update the row list item when the content changes. |
| focusPercent | float | READ\_ONLY | A fractional value that smoothly changes from 0.0 to 1.0 as the Item gains focus and from 1.0 to 0.0 as the item loses focus. This value is typically used in the item's XML component to smoothly change some aspect of the Item's appearance as it moves horizontally in and out of the focus position. |
| rowFocusPercent | float | READ\_ONLY | A fractional value that smoothly changes from 0.0 to 1.0 as the Item's Row gains focus and from 1.0 to 0.0 as the Item's Row loses focus. This value is typically used in the item's XML component to smoothly change some aspect of the Item's appearance as it's Row moves vertically in and out of the focus position. |
| rowHeightPercent | float | READ\_ONLY | A fractional value that smoothly changes from 0.0 to 1.0 as the height of item's in the row animate between their unfocused height (rowHeightPercent=0.0) and focused height (rowHeightPercent=1.0) while gaining/losing focus. This value is typically used in the item's XML component to smoothly change some aspect of the Item's appearance as it's Row moves vertically in and out of the focus position.  <br>  <br>This field will have the same value as rowFocusPercent unless the remainZoomedAboveFocus field is set to "never" or if the zoomed and un-zoomed height of a row are equal. |

Row decoration component fields
-------------------------------

If a `RowDecorationComponentName` is specified, an instance of this component is created as a child of each visible row's ZoomRowItem.

If the XML component contains interface fields that match the names shown in the table below, those fields will be updated by the ZoomRoowList node. This allows the XML component to dynamically alter the row decoration's appearance by observing changes to these interface fields.

Note that the fields are updated in the order presented in the table below. Most notably, when the itemContent field is set initially, the other fields will have valid values. This allows the script to be made more efficient by delaying computations until the itemContent field is set in some cases.

| Field Name | Field Type | Access Permisson | Description |
| --- | --- | --- | --- |
| width | float | READ\_ONLY | Set to the width of the row as specified in the ZoomRowList's rowWidth field. |
| height | float | READ\_ONLY | Set to the height of the ZoomRowItem. |
| rowFocused | integer | READ\_ONLY | Set to the index of the currently focused Item when the ZoomRowList's rowFocused field is set. |
| rowCounterText | string | READ\_ONLY | Set to the text that is displayed by the Row Counter. This would typically be used if the default Row Counter is not shown and the row decoration component displays that information in another way. |
| rowContent | ContentNode | READ\_ONLY | Contains the ContentNode associated with the Row. |
| rowFocusPercent | float | READ\_ONLY | A fractional value that smoothly changes from 0.0 to 1.0 as the Item's Row gains focus and from 1.0 to 0.0 as the Item's Row loses focus. This value is typically used in the item's XML component to smoothly change some aspect of the Item's appearance as it's Row moves vertically in and out of the focus position. |
| rowHeightPercent | float | READ\_ONLY | A fractional value that smoothly changes from 0.0 to 1.0 as the height of item's in the row animate between their unfocused height (rowHeightPercent=0.0) and focused height (rowHeightPercent=1.0) while gaining/losing focus. This value is typically used in the item's XML component to smoothly change some aspect of the Item's appearance as it's Row moves vertically in and out of the focus position.  <br>  <br>This field will have the same value as rowFocusPercent unless the remainZoomedAboveFocus field is set to "never" or if the zoomed and unzoomed height of a row are equal. |
| drawBeforeItems | Boolean | false | **Write-only**. Controls whether the row decoration component is drawn before (true) or after the items (false) in a row. This allows a background image to be drawn behind the tiles in a row. |

Sample app
----------

[zoomRowListDefaultLayoutTest](https://github.com/rokudev/samples/tree/master/ux%20components/lists%20and%20grids/zoomRowListDefaultLayoutTest) is a sample app demonstrating the ZoomRowList in action.

SceneGraph coordinate systems
=============================

Each renderable node has a local coordinate system associated with it with an origin at (0,0) with x increasing left-to-right and y increasing top-to-bottom. Each node can also have a 2D transformation specified that transform its local coordinate system into a transformed coordinate system. In the Roku SceneGraph implementation a node transformation matrix is specified by setting the values of four fields:

| Field | Description |
| --- | --- |
| translation | 2D vector that describes an \[x, y\] offset of the local coordinate system origin |
| scale | 2D vectors that describes an \[x, y\] scaling of the local coordinate system |
| rotation | Floating point value that describes a Z-axis rotation of the local coordinate system. The value is specified in radians with positive values representing a counter-clockwise rotation. |
| scaleRotateCenter | 2D vector that describes a point in the local coordinate system that serves as the center of scaling and rotation |

Each of these fields can be combined into an overall 2D transformation for the node by first applying these steps:

1.  Translate by the inverse of the scale/rotate center
2.  Multiplying by the scale amount
3.  Apply the Z-axis rotation
4.  Translate by the scale/rotate center
5.  Translate by the translation amount.

In matrix math, the overall matrix is:

       M = C(-1) S R C T
    

Where M is the total matrix, C is a 2D translation matrix that describes the location of the scale/rotation center in the node local coordinate system, C(-1) is the inverse of C, S is a 2D scaling matrix, R is a 2D rotation matrix, and T is a 2D translation matrix.

As the SceneGraph is traversed, 2D transformations are accumulated so that each child local coordinate system is transformed not only by its own 2D transformation matrix, but also the accumulated transformation matrix of all of its ancestors in the tree structure. This allows logical groupings of nodes to be positioned/animated by changing the transformation fields of nodes at various levels in the tree.

The transformation accumulation allows node classes to be developed without regard to their absolute pixel coordinates. Instead, each node can be have a layout relative to its local coordinate system, with its absolute on-screen position, size and orientation determined by the accumulated transformation matrix. For example, in a [PanelSet](/docs/references/scenegraph/sliding-panels-nodes/panelset.md) node screen, each [Panel](/docs/references/scenegraph/sliding-panels-nodes/panel.md) node has a local origin of (0,0) at the top/left corner of the panel. The PanelSet node is the parent of each Panel node in the tree hierarchy, and animates the translation field of the Panel nodes to cause them to slide on/off screen. Each Panel node has a subtree of nodes that draw its contents. Since these nodes inherit the Panel node translation, they all slide together as the Panel node translation field is modified.

Roku Pay best practices
=======================

Do
--

Review the following checklist to make sure your app is adhering to best practices for implementing Roku Pay. Following these tips will help optimize your user acquisition funnel, provide better feedback to customers, prevent customers from being billed twice for the same product, and improve the precision of entitlements.

### In-app products

| Tip | Explanation | Documentation |
| --- | --- | --- |
| Use the **getUserRegionData** command to implement country-specific or multicountry products | You may want certain products to only be available in specific countries. In the app, you can call the [**getUserRegionData**](/docs/references/scenegraph/control-nodes/channelstore.md#getuserregiondata) command to determine the country associated with the user's Roku account. You can then implement business logic to filter the results of the ChannelStore [**getCatalog** command](/docs/references/scenegraph/control-nodes/channelstore.md#getcatalog) to only display products that should be available for that country.  <br>  <br>If you want to offer a specific in-app product in multiple countries, currency conversion can be handled by Roku or the publisher:<br><br>*   **Roku handles currency conversion**: Create a single in-app product.<br>*   **Publisher handles currency conversion**: Create in-app products for each country and filter out the product by the country in the app using the [**ifDeviceInfo.GetCountryCode()**](/docs/references/brightscript/interfaces/ifdeviceinfo.md#getcountrycode-as-string) method. | [ChannelStore](/docs/references/scenegraph/control-nodes/channelstore.md#getuserregionaldata) |
| Add free trials and discount offers to subscription products instead of creating separate products | The [In-App Products page](/docs/developer-program/roku-pay/quickstart/in-channel-products.md) in the Developer Dashboard enables publishers to offer free trials and discount offers on in-app subscription products for a specific number of days or months.  <br>  <br>Roku Pay then automatically renews the subscription at the regular base price once the free trial or discount period ends. This makes it easy to provide customers with introductory pricing incentives.  <br>  <br>Separate products do not need to be created for free-trial or discounted subscription products. | [Adding in-app products](/docs/developer-program/roku-pay/quickstart/in-channel-products.md#trials-and-offers) |

### Sign-in and sign-ups

| Tip | Explanation | Documentation |
| --- | --- | --- |
| Only use a single ChannelStore node in the app | Only one ChannelStore node should ever be used in the purchase workflow.  <br>  <br>In the app, create a ChannelStore node, and then use its [**getCatalog** command](/docs/references/scenegraph/control-nodes/channelstore.md#getcatalog) to retrieve the subscription and one-time purchase products offered by the app.  <br>  <br>You can then create orders using the products returned by the `getCatalog` command. | [ChannelStore](/docs/references/scenegraph/control-nodes/channelstore.md#getcatalog) |

### On-device upgrades/downgrades

| Tip | Explanation | Documentation |
| --- | --- | --- |
| Block upgrade/downgrade flow if the subscription was created through the publisher's system and the customer's sign-in does not match the Roku account linked to their device | On-device upgrades/downgrades are automatically billed to the Roku account linked to the device, regardless of the authentication mechanism.  <br>  <br>Therefore, if the customer signs in to a subscription service using an account created through the publisher's services (and not through Roku Pay) and the email address they enter differs from the one used for the Roku account currently linked to their Roku device, the app should implement business logic to prevent the users from upgrading or downgrading their plan.  <br>  <br>This prevents the Roku Pay and the publisher services from becoming out of sync on the customer's current subscription plan. | [On-device upgrade and downgrade](/docs/developer-program/roku-pay/implementation/on-device-upgrade-downgrade.md) |
| Provide simple base package options | Apps that offer multiple base packages with varying content need to make it easy for customers to select the best one for them.  <br>  <br>To do this, adhere to the following best practices:<br><br>*   Minimize the number of choices to reduce friction.<br>*   Offer monthly and annual plans.<br>*   Organize packages so customers can easily compare and contrast them. For example:<br>    <br>    *   Highlight the “Best Deal” or “Most Popular”<br>    *   Highlight the "Best for Cord Cutters", "Best for Sports", "Best for Entertainment", and so on | [On-device upgrade and downgrade](/docs/developer-program/roku-pay/implementation/on-device-upgrade-downgrade.md) |
| Make package add-ons easy to upgrade/downgrade without friction | Apps that offer add-on packages such as premium movie apps, sports passes, and so on need to make it easy for customers to purchase them on-device—without generating friction in the initial signup flow.  <br>  <br>To do this, adhere to the following best practices:<br><br>*   Limit add-on selections in the initial signup flow to the most popular packages. The initial signup flow should enable customers to select just the base package and the top add-ons. Once the customer has purchased their subscription, you can funnel them into a complete add-on selection flow.<br>*   Place complete add-on selection flow in a separate section within the on-device account management page (add-ons can still be promoted from any place in the app).<br>*   Group add-ons into categories (for example, sports, movies, family, and so on).<br>*   Minimize the number of choices to maximize purchases (too many options may cause overload customers and cause funnel friction).<br>*   Provide links to the on-device account management page to ensure customers know they can upgrade/downgrade base packages and add-ons anytime. | [On-device upgrade and downgrade](/docs/developer-program/roku-pay/implementation/on-device-upgrade-downgrade.md) |
| Bill upgrades/downgrades correctly | When upgrading/downgrading subscriptions, apps must bill customer using the correct timing:<br><br>*   **Upgrades**. Bill customers immediately for the upgraded subscription. Correspondingly, make new apps available immediately.<br>*   **Downgrades**. Bill customers after the current period ends for the downgraded subscription. | [On-device upgrade and downgrade](/docs/developer-program/roku-pay/implementation/on-device-upgrade-downgrade.md) |
| Use the **rokuCustomerId** as the primary key for tracking upgrades/downgrades in backend | The **rokuCustomerId** is a persistent identifier that can be used to track a customer's transactions, including their original subscription purchase and any upgrades/downgrades, in the publisher's backend system.  <br>  <br>After the initial subscription purchase, get the **purchaseId** from the ChannelStore node's **[doOrder](/docs/references/scenegraph/control-nodes/channelstore.md#doorder)** command and pass it into a call to the **validate-transaction** API.  <br>  <br>Record the **rokuCustomerId** included in the response in the backend. Use the **rokuCustomerId** to identify the customer associated with any subsequent upgrades/downgrades. | [On-device upgrade and downgrade](/docs/developer-program/roku-pay/implementation/on-device-upgrade-downgrade.md) |

### Payment retry checks

| Tip | Explanation | Documentation |
| --- | --- | --- |
| Implement nightly payment retry checks | When Roku Pay cannot renew a subscription because the customer's method of payment on file cannot be charged, the subscription is placed in recovery.  <br>  <br>When this occurs, Roku Pay notifies the customer once a day for multiple consecutive days (typically three) to update their method of payment in order to renew the subscription, and it attempts to charge the customer's method of payment to ensure collection of payment and continuation of service.  <br>  <br>While Roku Pay attempts to collect payment, the publisher's entitlement service should sync with Roku Pay's [**validate-transaction** API](/docs/developer-program/roku-pay/implementation/roku-web-service.md#validate-transaction) nightly to manage subscriptions in the dunning state.  <br>  <br>This ensures that subscriptions without entitlements are canceled promptly, but subscriptions that are successfully renewed or are currently in the dunning state are still accessible on the app and across all platforms. | [Roku Pay web services reference](/docs/developer-program/roku-pay/implementation/roku-web-service.md#managing-subscription-recovery) |

Don't
-----

The following list provides examples of common mistakes publisher should avoid when implementing Roku Pay. This list is continuously updated as Roku identifies additional errors to be avoided:

| Tip | Explanation | Documentation |
| --- | --- | --- |
| Do not offer on-device cancellations | Apps can offer a downgrade on-device, or customers can cancel Roku Pay subscriptions online from their [Roku account](https://my.roku.com/account/subscriptions). | [On-device upgrade and downgrade](/docs/developer-program/roku-pay/implementation/on-device-upgrade-downgrade.md) |

Node
====

The abstract base class of all SceneGraph nodes and the equivalent of the BrightScript roSGNode component. See [roSGNode](/docs/references/brightscript/components/rosgnode.md "roSGNode") for supported interfaces.

**Node** class objects do not draw anything and are skipped in the render traversal of the SceneGraph node tree. The Node class provides the core parenting and key focus management functionality used by all nodes.

Fields
------

FieldTypeDefaultAccess PermissionDescriptionidstring""READ\_WRITEAdds a dictionary entry that allows the node to be retrieved with [ifSGNodeDict](/docs/references/brightscript/interfaces/ifsgnodedict.md "ifSGNodeDict") findNode() function.focusedChildN/AN/AREAD\_WRITEWhen a node or one of its children gains or loses the keyboard focus, the focusedChild field will be set and call its observer functions. In the observer function, typically, you use [ifSGNodeFocus](/docs/references/brightscript/interfaces/ifsgnodefocus.md "ifSGNodeFocus") functions to query whether this node or some other node has the key focus or is in the key focus chain. Accessing the value of the field will result in script errors.focusableBooleanfalseREAD\_WRITEProvides a hint as to whether or not this node can take the key focus.changeassociative array{ Index1: 0, Index2: 0, Operation: none }READ\_ONLYOperations affecting the set of children of a Node are recorded in this field if, and only if, this field has been observed. The field associative array indicates the operation and two indexes, index1 and index 2, involved in the change. The operation is denoted by these value strings:

| Value | Meaning |
| --- | --- |
| none | No operation on the children nodes since the change field was observed, indexes are irrelevant |
| insert | A child node was inserted at _index1_. If multiple child nodes were inserted (for example, via the [insertChildren() function](/docs/references/brightscript/interfaces/ifsgnodechildren.md#insertchildrenchild_nodes-as-object-index-as-integer-as-boolean)), the last inserted child node is stored at _index2_. |
| add | A child node was added to the end of the children node tree (at _index 1_). If multiple child nodes were added (for example, via the [appendChildren() function](/docs/references/brightscript/interfaces/ifsgnodechildren.md#appendchildrenchild_nodes-as-object-as-boolean)), the last added child node is stored at _index2_. |
| remove | A child node was removed from position _index1_, and if _index2_\>_index1_, all the children nodes between _index1_ and _index2_ inclusive were removed |
| set | The child node at position _index1_ was replaced with a new child node |
| clear | All the children nodes were removed |
| move | The child node at position _index1_ was moved to the new position _index2_ |
| setall | All the children nodes were replaced |
| modify | A pre-defined content meta-data field of a **ContentNode** node child at _index1_ was changed (_only_ set for **ContentNode** node children when a pre-defined content meta-data field changes) |

roAudioResource
===============

The roAudioResouce allows .wav files to be cached to memory and quickly played at any time. roAudioResource is intended to support short audio clips which need to be played with very little latency. The system caches the entire wav file in memory so that playback can begin very quickly.

On Roku "Classic" models, roAudioResource does not support mixing of sounds. So when you play a sound effect, any background music is paused while the sound effect plays and then resumes after the sound effect ends. On later models, sound effects are mixed with background music. See the [Hardware specifications document](/docs/specs/hardware.md#current-models) for a list of Current and Classic models.

This object is created with a filename parameter that is a path to the sound resource file:

`CreateObject("roAudioResource", filename)`

The filename must be the name of a local file and cannot be a URL. To use a URL, you may download the file to the application's "tmp:" file system using [roUrlTransfer](/docs/references/brightscript/components/rourltransfer.md) and pass a filename of the form "tmp:/file.wav" to CreateObject.

    sound = CreateObject("roAudioResource", "pkg:/sounds/beep1.wav")
    sound.Trigger(75)
    

An object can also be created using the name of a system sound effect:

*   "select" - the sound effect to be played when a selection is made, e.g. when OK is pressed.
*   "navsingle" - the sound effect to be played when navigating a list or grid, e.g. when left or right is pressed.
*   "navmulti" - the sound effect to be played when paging through a list or grid, e.g. when rewind or fast-forward is pressed.
*   "deadend" - the sound effect to be played when a button press could not be processed.

Note that system sound effects are played at the volume selected in the user's settings, or not played at all if the user has turned sound effects off, regardless of the volume value passed to Trigger.

    sound = CreateObject("roAudioResource", "select")
    sound.Trigger(50)
    

Mult iple sounds can be mixed and played at the same time:

    sound1 = CreateObject("roAudioResource", "pkg:/sounds/beep1.wav")
    sound2 = CreateObject("roAudioResource", "select")
    sound1.Trigger(50, 0)
    if sound2.maxSimulStreams() > 1
      sound2.Trigger(50, 1)
    end if
    

Supported Interfaces
--------------------

*   [ifAudioResource](/docs/references/brightscript/interfaces/ifaudioresource.md)

roFont
======

roFont represents a particular font, from a font-family (eg. Arial), with a particular pixel size (e.g 20), and a particular boldness or italicness.

It is used in conjunction with [roFontRegistry](/docs/references/brightscript/components/rofontregistry.md "roFontRegistry") to create and manage fonts. Font files are registered with roFontRegistry and then various methods in roFontRegistry can be used to create roFont objects. Applications should not create roFonts with CreateObject() but should always use roFontRegistry to create them. roFont objects in turn can be used with [ifDraw2D.DrawText](/docs/references/brightscript/interfaces/ifdraw2d.md#drawtextrgba-as-integer-x-as-integer-y-as-integer-text-as-string-font-as-object-as-boolean "ifDraw2D.DrawText") to draw text on the screen or into bitmaps.

**Example**

    screen = CreateObject("roScreen")
    white = &hFFFFFFFF
    blue = &h0000FFFF
    font_registry = CreateObject("roFontRegistry")
    font = font_registry.GetDefaultFont()
    
    ' Draw white text in a blue rectangle
    text = "Hello world"
    w = font.GetOneLineWidth(text, screen.GetWidth())
    h = font.GetOneLineHeight()
    x = 200
    y = 100
    border = 8
    screen.DrawRect(x, y, w + 2*border, h + 2*border, blue)
    screen.DrawText(text, x+border, y+border, white, font)
    

Supported interfaces
--------------------

*   [ifFont](/docs/references/brightscript/interfaces/iffont.md "ifFont")

UI philosophy
=============

Roku experience is designed for a mass market; it should be noted that television displays are communal and different from computers, phones, and tablets. For example, people lean back and relax while watching TV, which means they don't expect to use anything complicated requiring training or mental acrobatics (i.e., minimize cognitive load). This makes it important for a TV UI to be invisible.

Following these ten tips will help the viewer navigate through your app better and find the content they are looking for quickly and with minimal effort.

### 1\. Understand your audience

*   What are their goals and how do they want to access your content (E.g., By date/time, topic, person, rating, etc.)?
*   Create usage scenarios and design for them.
*   Review and test all of your TV UI designs with real users, on actual TV screens, viewed from 10 feet away in a moderately dark room.
*   Pay more attention to what users do rather than what they say.
*   Continually collect data and improve your design.

### 2\. Leverage conventions

*   Being unique is appealing for a brand, but it is better to differentiate with your content, features, and capabilities rather than with an unconventional and unfamiliar UI.
*   Consistency with Roku UI conventions means your users will learn how to use and navigate your UI faster and be able to pay more attention to what really matters.
*   Consistency with other Roku apps in UI controls, screen layouts, and general navigation will shift focus from how to use your UI to your unique features and content.
*   Play with many other Roku apps to see patterns, understand what works well, and what to leverage.

### 3\. Minimize screen types

*   Your entire UI, whether it has 10 or 100 individual screens, should be built from as few screen types or templates as possible.
*   Fewer screen templates ensures a reduced learning curve and greater comfort.
*   However, make sure that your home screen is unique and distinct from all your other screens (When the user backs out from deep within your app, they should easily recognize arriving on the app home screen).

### 4\. Make it remote friendly

*   Roku's remote is intentionally minimal, appropriately pushing system functions and choices onto the TV UI.
*   Count on Roku users having muscle-memory and eyes-free operation of the following remote buttons: 4-way directional pad (dPad), OK, Back, and Home.
*   Optimize all primary UI interactions for these buttons accordingly.
*   Users should be able perform all critical functions without ever discovering any hidden menus or special remote button presses.

### 5\. Make it performant

App should launch with a fully rendered homescreen within:

*   Recommended: 15 seconds on Roku Express (Litlefield)
*   Required: 20 seconds on Roku Express (Littlefield)

The app is responsive to user navigation, Roku Search, and the playback of content at a reasonable speed expected on all targeted Roku platforms; specifically as measured on Littlefied:

*   Tile-to-tile navigation within 250 ms
*   App response to remote button press within 250 ms
*   Video starts playing within 5 seconds of initiation
*   If animations are present, they must be at least 30 fps
*   Scene-to-scene transitions are within 3 seconds
*   App works with Fast Video Start to allow for pre-buffering of content and improve playback performance where applicable (E.g., On a springboard page)

Actions requiring background progress longer than 3 seconds should display the appropriate 'loading' or 'retrieving' screens.

Always test your app on the low end platforms (Roku Express = Littlefield) to ensure acceptable performance (It will then run great on a high end platform).

[SceneGraph performance guide](/docs/developer-program/performance-guide/development-tips.md) provides more in-depth technical advice on how to build a smooth, lag-free experience for users across all Roku devices.

### 6\. Properly advertise your app

*   Within Roku's Streaming Store, be sure to offer a great summary, description, clear pricing, and a variety of screenshots.
*   Screenshots should show all aspects of your app: home screen, content browsing, content details page, as well as the video playback with voice controls visible.
*   When creating an ad, follow [Roku's ad guidelines](https://docs.roku.com/doc/advertisingguidelines/en-us) to make big beautiful content images with minimal text and standard call-to-action.
*   Expose your app as much as possible by offering as many doorways from Roku's main UI to your app (E.g., Roku Search, My Feed, Ads, etc.).
*   When running on-device promotional ads, ensure that you use relevant targeting to show the right promotional ad to the right user.
*   Once the app is ready to be promoted, the app can purchase their own ad campaigns at [https://admanager.roku.com/](https://admanager.roku.com/).

### 7\. Try before you buy

*   For apps requiring payment or purchase, at minimum, let users browse your content in front of the paywall so that they can see or sample what they would be buying.
*   Ideally, the app can offer a free trial, UI and content browsing, or some free content. The best way to convince users into a free trial is to let them explore, learn about the app and watch the content.

### 8\. Make app sign-up easy

*   If installing your app also requires users to go through a sign up process, make it as short and easy as possible.
*   [Roku Pay](/docs/developer-program/roku-pay/implementation/overview.md) increases successful sign-ups by letting users sign-up by a single button click.
*   If you have to collect additional user information other than what is necessary for signing up, it is highly recommended to not ask that during the sign-up process. Collect additional information via a follow-up email.
*   Most additional sign-up screen that ask for date of birth, gender, any screen with an on-screen keyboard, etc., result in significant user drop-out and is not recommended.

### 9\. Properly monetize your app

*   If you are monetizing your app with video ads, be sure to integrate it with the Roku Advertising Framework (RAF). RAF is a certification requirement for ad-supported apps. You can refer to the [RAF documentation](/docs/developer-program/advertising/roku-advertising-framework.md) for more information.
*   RAF ensures that all ads across your app have a consistent experience and hence can drive higher user engagement.
*   RAF supports a privacy compliant Roku ID for advertisers that enables advanced targeting and frequency capping.
*   RAF also supports advanced and immersive ad formats that many advertisers prefer to use.

### 10\. Offer diverse ads

*   If your app shows advertisements intermixed with its content playback, ensure a healthy ad mix for a good user experience. Seeing the exact same ad repeatedly over the course of a long viewing session is not only incredibly frustrating for users, but the bad experience will drive them away from your app.

ifDsa
=====

Implemented by
--------------

| Name | Description |
| --- | --- |
| [roDsa](/docs/references/brightscript/components/rodsa.md) | The **roDSA** component provides support for the ECDSA and EdDSA (with Ed25519 form) digital signature algorithms. It is used to provide cryptographically signed evidence that an ad request originated from an actual Roku device. |

Supported methods
-----------------

### SetPrivateKey(keyFileName as String) as Integer

#### Description

Specifies the private key to be used for signing.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| keyFileName | String | Specifies the ECDSA or Ed25519 private key to be used for signing. Provide the key as a path, either in the package or a temporary path. |

#### Return Value

An integer indicating whether the operation was successful:

*   1 = The key is valid.
*   0 = The file does not contain a valid key.
*   \-1 = The file was not found.

### SetPrivateKeyFromByteArray(key as Object) as Integer

#### Description

Specifies the private key to be used for signing.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| key | roByteArray Object | Specifies the ECDSA or Ed25519 private key to be used for signing. |

#### Return Value

An integer indicating whether the operation was successful:

*   1 = The key is valid.
*   0 = The key is not valid.

### SetPublicKey(keyFileName as String) as Integer

#### Description

Specifies the public key to be used for verification.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| keyFileName | String | Specifies the ECDSA or Ed25519 public key to be used for signing. Provide the key as a path, either in the package or a temporary path. |

#### Return Value

An integer indicating whether the operation was successful:

*   1 = The key is valid.
*   0 = The file does not contain a valid key.
*   \-1 = The file was not found.

### SetDigestAlgorithm(algorithm as String) as Boolean

#### Description

Specifies the digest algorithm to be used for signing and verification.

| Name | Type | Description |
| --- | --- | --- |
| algorithim | String | An OpenSSL string with the algorithm to be used: "sha1""sha224""sha256" (default)"sha384""sha512". When using Ed25519 signing, the only supported digest algorithm is "sha512". |

#### Return Value

A flag indicating whether the operation was successful:

*   true = algorithm was successfully set
*   false = string was not recognized

### SetSignAlgorithm(algorithm as String) as Boolean

Specifies the signing algorithm to be used for signing and verification.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| algorithm | String | An OpenSSL string with the algorithm to be used:"ECDSA" (default)."Ed25519". |

#### Return Value

A flag indicating whether the operation was successful:

*   true = algorithm was successfully set.
*   false = string was not recognized.

### Sign(message as Object) as Object

#### Description

Generates a signature based on the specified message.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| message | roByteArray Object | The roByteArray to be signed. |

#### Return Value

An roByteArray containing the signature. If an error occurs, "invalid" is returned.

Errors are printed to the BrightScript Debug Console. Common errors include:

*   digest is empty
*   SetPrivateKey() was not yet called
*   out of memory
*   the digest could not be signed

### Verify(message as Object, signature as Object) as Integer

#### Description

Verifies the given message and signature. The message and the signature should both be roByteArrays.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| message | roByteArray Object | The message to be verified. |
| signature | roByteArray Object | The signature to be verified. |

#### Return Value

Indicates the result of the validation. This may be one of the following values:

*   1 = The signature matches.
*   \-1 = The SetPublicKey() method was not yet called.
*   \-2 = The digest is empty.
*   \-3 = Internal error.
*   \-4 = Incorrect digest/sign algorithms
*   0 = The signature does not match.

Examples
--------

### Using ECDSA signing with SHA256 digest

#### Signing

    msg_ba = CreateObject("roByteArray")
    
    ' ...populate bytearray with the message...
    
    dsa = CreateObject("roDSA")
    
    ' ... save private key to tmp:/privateKey.txt
    
    dsa.SetDigestAlgorithm("sha256")
    dsa.SetSignAlgorithm("ECDSA")
    dsa.SetPrivateKey("tmp:/privateKey.txt")
    
    signature = dsa.Sign(msg_ba)
    

#### Verification

    msg_ba = CreateObject("roByteArray")
    
    ' ...populate bytearray with the message...
    
    sig_ba = CreateObject("roByteArray")
    
    ' ...populate bytearray with the signature...
    
    dsa = CreateObject("roDSA")
    
    ' ... save public key to tmp:/publicKey.txt
    
    dsa.SetDigestAlgorithm("sha256")
    dsa.SetSignAlgorithm("ECDSA")
    dsa.SetPublicKey("tmp:/publicKey.txt")
    
    result = dsa.Verify(msg_ba, sig_ba)
    
    if (result = 1)
        print "Verified"
    else
        print "Not verified, result = " result
    end if
    

### Using Ed25519 signing with SHA512 digest

#### Signing

    msg_ba = CreateObject("roByteArray")
    
    ' ...populate bytearray with the message...
    
    dsa = CreateObject("roDSA")
    
    ' ... save private key to tmp:/privateKey.txt
    
    dsa.SetDigestAlgorithm("sha512")
    dsa.SetSignAlgorithm("Ed25519")
    dsa.SetPrivateKey("tmp:/privateKey.txt")
    
    signature = dsa.Sign(msg_ba)
    

#### Verification

    msg_ba = CreateObject("roByteArray")
    
    ' ...populate bytearray with the message...
    
    sig_ba = CreateObject("roByteArray")
    
    ' ...populate bytearray with the signature...
    
    dsa = CreateObject("roDSA")
    
    ' ... save public key to tmp:/publicKey.txt
    
    dsa.SetDigestAlgorithm("sha512")
    dsa.SetSignAlgorithm("Ed25519")
    dsa.SetPublicKey("tmp:/publicKey.txt")
    
    result = dsa.Verify(msg_ba, sig_ba)
    
    if (result = 1)
        print "Verified"
    else
        print "Not verified, result = " result
    end if

Global utility functions
========================

BrightScript has a set of standard, module scope, functions. These functions are stored in the global object. If the compiler sees a reference to one of the global functions, it directs the runtime to call the appropriate global object member.

* * *

Sleep(milliseconds as Integer) as Void
--------------------------------------

This function causes the script to pause for the specified time, without wasting CPU cycles. There are 1000 milliseconds in one second.

    sleep(1000) ' sleep for 1 second
    sleep(200) ' sleep 2/10 of a second
    sleep(3000) ' sleep three seconds
    

Wait(timeout as Integer, port as Object) as Object
--------------------------------------------------

This function waits on objects that are "waitable" (those that have a MessagePort interface). Wait() returns the event object that was posted to the message port. If timeout is zero, "wait" will wait for ever. Otherwise, Wait will return after timeout milliseconds if no messages are received. In this case, Wait returns a type "invalid".

**Example**

    p = CreateObject("roMessagePort")
    s = CreateObject("roScreen")
    s.SetPort(p)
    msg = Wait(0, p) 
    print Type(msg) ' e.g. roUniversalControlEvent
    print msg.GetInt() ' button number
    

GetInterface(object as Object, ifname as String) as Interface
-------------------------------------------------------------

Each BrightScript Component has one or more interfaces. This function returns a value of type "Interface". Note that generally BrightScript Components allow you to skip the interface specification. In which case, the appropriate interface within the object is used. This works as long as the function names within the interfaces are unique.

FindMemberFunction(object as Object, funName as String) As Interface
--------------------------------------------------------------------

Returns the interface from the object that provides the specified function, or invalid if not found.

For example:

    print FindMemberFunction({}, "Count") '= <Interface: ifAssociativeArray>
    

UpTime(dummy as Integer) as Float
---------------------------------

Returns the uptime of the system since the last reboot in seconds.

RebootSystem() as Void
----------------------

Requests the system to perform a soft reboot. The Roku platform has disabled this feature.

ListDir(path as String) as Object
---------------------------------

Returns a List object containing the contents of the directory path specified.

For example:

     BrightScript> l=ListDir("pkg:/movies")
     BrightScript> print l
     test_movie_3.vob
     test_movie_4.vob
     test_movie_1.vob
     test_movie_2.vob
    

ReadAsciiFile(filepath as String) as String
-------------------------------------------

This function reads the specified file and returns the data as a string.

The file can be encoded as either UTF-8 (which includes the 7-bit ASCII subset) or UTF-16.

An empty string is returned if the file can not be read.

For example:

    text=ReadAsciiFile("tmp:/config.txt")
    

WriteAsciiFile(filepath as String, text as String) as Boolean
-------------------------------------------------------------

This function writes the specified string data to a file at the specified location.

The string data is written as UTF-8 encoded (which includes the 7-bit ASCII subset).

The function returns true if the file was successfully written.

For example:

    WriteAsciiFile("tmp:/config.txt", "the text to write")
    

CopyFile(source as String, destination as String) as Boolean
------------------------------------------------------------

Make a copy of a file.

MoveFile(source as String, destination as String) as Boolean
------------------------------------------------------------

Rename a file.

MatchFiles(path as String, pattern\_in as String) as Object
-----------------------------------------------------------

Search a directory for filenames that match a certain pattern. _Pattern_ is a wildmat expression. Returns a List object.  
This function checks all the files in the directory specified against the pattern specified and places any matches in the returned roList.

The returned list contains only the part of the filename that is matched against the pattern not the full path.  
The pattern may contain certain special characters:

*   A '?' matches any single character.
*   A '\*' matches zero or more arbitrary characters.
*   The character class '\[...\]' matches any single character specified within the brackets. The closing bracket is treated as a member of the character class if it immediately follows the opening bracket. i.e. '\[\]\]' matches a single close bracket. Within the class '-' can be used to specify a range unless it is the first or last character. e.g. '\[A-Cf-h\]' is equivalent to '\[ABCfgh\]'.
*   A character class can be negated by specifying '' as the first character. To match a literal '' place it elsewhere within the class.
*   The characters '?', '\*' and '\[' lose their special meaning if preceded by a single '\\'. A single '\\' can be matched as '\\\\'.

For example:

    files = MatchFiles(".", "*.mpg")
    

DeleteFile(file as String) as Boolean
-------------------------------------

Delete the specified file.

DeleteDirectory(dir as String) as Boolean
-----------------------------------------

Deletes the specified directory. It is only possible to delete an empty directory.

CreateDirectory(dir as String) as Boolean
-----------------------------------------

Creates the specified Directory. Only one directory can be created at a time

FormatDrive(drive as String , fs\_type as String) as Boolean
------------------------------------------------------------

Formats a specified drive using the specified filesystem.

StrToI(str as String) as Dynamic
--------------------------------

Return the integer value of the string, or 0 if nothing is parsed.

RunGarbageCollector() as Object
-------------------------------

This function runs the garbage collector on the current thread. It returns and Associative array with some statistics regarding the garbage collection.  
See the [Garbage collection](/docs/references/brightscript/language/component-architecture.md#garbage-collection) section of this manual for more detail. You don't normally need to call this function.

For example:

    BrightScript Debugger> a=[]  
    BrightScript Debugger> a[0]=a  
    BrightScript Debugger> a=invalid  
    BrightScript Debugger> print RunGarbageCollector()  
    COUNT: 3  
    ORPHANED: 1  
    ROOT: 2
    

ParseJson(jsonString as String, flags = "" as String) as Object
---------------------------------------------------------------

This function will parse a string formatted according to RFC4627 and return an equivalent BrightScript object (consisting of booleans, integer and floating point numbers, strings, roArray, and roAssociativeArray objects). If the string is not syntactically correct, **Invalid** will be returned. A few other things to note:

*   By default, any roAssociativeArray objects in the returned objects will be **case sensitive**. As of Roku OS 9.4, to return a **case-insensitive** structure, set the `flags` parameter to `"i"`.

> If the `"i"` option is used, and the jsonString includes multiple keys that match case-insensitively, duplicates are overwritten and only the last matching values are preserved.

*   An error will be returned if arrays/associative arrays are nested more than 256 levels deep.

For example, lets say your service returns a JSON object that contains a list of photo URLs:

    {
          "photos" : [
               {  
                     "title" : "View from the hotel",
                     "url" : "http://example.com/images/00012.jpg" 
               },
               { 
                     "title" : "Relaxing at the beach",
                     "url" : "http://example.com/images/00222.jpg" 
               },
               { 
                     "title" : "Flat tire",
                     "url" : "http://example.com/images/00314.jpg" 
               }
          ]
    }
    

    searchRequest = CreateObject("roUrlTransfer")
    searchRequest.SetURL("http://api.example.com/services/rest/getPhotos")
    response = ParseJson(searchRequest.GetToString())
    For Each photo In response.photos
        GetImage(photo.title, photo.url)
    End For
    

FormatJson(json as Object, flags = 0 as Integer) as String
----------------------------------------------------------

Formats a supported data type as a JSON string.

Data types supported are booleans, integer and floating point numbers, strings, roArray, and roAssociativeArray objects.

Passing `invalid` into this function returns "null".

An error will be returned if arrays/associative arrays are nested more than 256 levels deep.

If an error occurs an empty string will be returned.

Normally non-ASCII characters are escaped in the output string as "\\uXXXX" where XXXX is the hexadecimal representation of the Unicode character value.

#### Output flags (optional)

| **Value** | **Description** |
| --- | --- |
| &h0000 | Default: Non-ASCII characters are escaped in the output string as "\\uHHHH" where HHHH is the hexadecimal representation of the Unicode character value. |
| &h0001 | DontEscape: Non-ASCII characters are **not** escaped. |

##### Example

    euroStr = Chr(&h20AC)
    
    '* By default, non-ASCII Unicode characters are escaped in JSON style
    ? FormatJSON(euroStr)
    ' => "\u20AC"
    
    '* If specified, non-ASCII Unicode characters are not escaped.
    ? FormatJSON(euroStr, &h0001)
    ' => "€"
    

#### Behavior flags (optional)

| **Flag** | **Description** |
| --- | --- |
| &h0000 | Default: If an unsupported value type is encounted, FormatJSON fails and returns an empty string. |
| &h0100 | Ignore: Unsupported value types are output as JSON null values. |
| &h0200 | Annotate: Unsupported value types are output as a descriptive string. |

##### Example

    list = CreateObject("roList")
    obj = {list:list, n:1}
    
    '* By default, attempting to format with any unsupported type fails and returns an empty string.
    ? FormatJSON(obj)
    ' => BRIGHTSCRIPT: BRIGHTSCRIPT: ERROR: FormatJSON: list: Value type not supported: roList
    
    '* If specified, unsupported values can be output as JSON 'null' values.
    '* (In this case, no error diagnostics are printed to the console).
    ? FormatJSON(obj, &h0100) 
    ' => {"list":null,"n":1}
    
    '* If specified, unsupported values can be output as diagnostic string values.
    '* The diagnostic string is the component type in angle brackets.
    '* (In this case, no error diagnostics are printed to the console).
    ? FormatJSON(obj, &h0200) 
    ' => {"list":"<roList>","n":1}
    

### FormatJson(json as Object, flags = "" as String) as String

The same as the previous [FormatJson method](#formatjsonjson-as-object-flags--0-as-integer-as-string), but accepts the **flags** parameter as a string.

Tr(source as String) as String
------------------------------

Translates the source string into the language of the current locale. The function looks for a translations.xml file in the XLIFF format in the pkg:/locale subdirectory named for the current locale (see [ifDeviceInfo.GetCurrentLocale](/docs/references/brightscript/interfaces/ifdeviceinfo.md#getcurrentlocale-as-string) for the list of currently-supported locales). If the translations.xml file exists for the current locale, and contains the source string with a translated string, the function returns the translated string. Otherwise, the function returns the original source string.

In some cases you may want to include a placeholder marker in a localizable string that gets dynamically substituted with a value at runtime.  
One way to accomplish that is to use the Replace method on the string value returned from the Tr() lookup.

For example:

    `text = Tr("Video will start in %1 seconds").Replace("%1",
    numSeconds.ToStr())`

ifSocketAddress
===============

Implemented by
--------------

| Name | Description |
| --- | --- |
| [roSocketAddress](/docs/references/brightscript/components/rosocketaddress.md "roSocketAddress") | The roSocketAddress is used by the roStreamSocket and roDataGramSocket components for TCP and UDP traffic respectively |

Supported methods
-----------------

### SetAddress(address as String) as Boolean

#### Description

Sets the IPV4 address.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| address | String | The string consists of a hostname, optionally followed by a colon and a decimal port number. The hostname may be either dotted quad (such as "192.168.1.120") or a DNS name (such as "roku.com"). If a name is given, a DNS lookup is performed to convert it to dotted quad. Use IsAddressValid() to determine the result of the DNS lookup. Example: "192.168.1.120:8888" or "roku.com". |

#### Return Value

A flag indicating whether the IPV4 address was successfully set.

### GetAddress() as String

Returns the IPV4 address in dotted quad format (for example, "192.168.1.120:8888").

#### Return Value

The IPV4 address.

### SetHostName(hostname as String) as Boolean

#### Description

Sets the hostname. The port number is unchanged.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| hostname | String | The hostname to be used. |

#### Return Value

A flag indicating whether the hostname was successfully set.

### GetHostName() as String

#### Description

Returns the hostname.

#### Return Value

The hostname.

### SetPort(port as Integer) as Boolean

> This function is deprecated and should not be used. Use the [setMessagePort()](/docs/references/brightscript/interfaces/ifsetmessageport.md#setmessageportport-as-object--as-void) function instead.

#### Description

Sets the port number. The hostname is unchanged.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| port | Integer | The port number to be used. |

#### Return Value

A flag indicating whether the port number was successfully set.

### GetPort() as Integer

#### Description

Returns the port number.

#### Return Value

The port number.

### IsAddressValid() as Boolean

#### Description

Checks whether the component contains a valid IP address.

#### Return Value

A flag indicating whether the component contains a valid IP address.

StdDlgItemBase
==============

Extends [Group](/docs/references/scenegraph/layout-group-nodes/group.md)

**StdDlgItemBase** is the base class for all the content area items. It provides the common functionality for all StdDlg\[_x_\]Item nodes (for example, [**StdDlgBulletTextItem**](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-bullet-text-item.md), [**StdDlgTextItem**](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-text-item.md), [**StdDlgKeyboardItem**](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-keyboard-item.md), [**StdDlgProgressItem**](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-progress-item.md), [**StdDlgGraphicItem**](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-graphic-item.md), and the other dialog building block nodes).

Fields
------

| Field | Type | Default | Access Permission | Description |
| --- | --- | --- | --- | --- |
| scrollable | boolean | false | READ\_WRITE | Indicates whether the item can be scrolled vertically by the user. The StandardDialog layout algorithm reduces the height of a scrollable item as needed if the overall height of the dialog is too large to fit on the display. |

roDeviceInfo
============

The Device Info provides an interface to obtain attributes about the device.

These attributes are not changeable by the script, but may be queried to obtain values for the player. It is common for scripts to need access to the serial number and model info for negotiating with backend services.

This object is created with no parameters:

`CreateObject("roDeviceInfo")`

**Example**

    di = CreateObject("roDeviceInfo")
    print di.GetModel()
    print di.GetVersion()
    print di.GetChannelClientId()
    

**Output**

The output from the above code would like the following:

     N1000
     999.99E99999X
     20E825000036
    

Supported interfaces
--------------------

*   [ifDeviceInfo](/docs/references/brightscript/interfaces/ifdeviceinfo.md "ifDeviceInfo ")
*   [ifSetMessagePort](/docs/references/brightscript/interfaces/ifsetmessageport.md "ifSetMessagePort")
*   [ifGetMessagePort](/docs/references/brightscript/interfaces/ifgetmessageport.md "ifGetMessagePort")

Supported events
----------------

*   [roDeviceInfoEvent](/docs/references/brightscript/events/rodeviceinfoevent.md "roDeviceInfoEvent")

StandardMessageDialog
=====================

Extends [StandardDialog](/docs/references/scenegraph/standard-dialog-framework-nodes/standard-dialog.md "**Standard Dialog**")

The **StandardMessageDialog** node is used to displays a message to the user. It is similar to the legacy [Dialog](/docs/references/scenegraph/dialog-nodes/dialog.md) node. It may contain the following items (from top to bottom):

*   One or more blocks of text at the top.
*   One bulleted / numbered list.
*   One or more blocks of text at the bottom.

![roku815px - standard-message-dialog](https://image.roku.com/ZHZscHItMTc2/standard-message-dialog.jpg)

Structure
---------

The StandardMessageDialog is comprised of the following areas and building block nodes:

*   StdDlgTitleArea.
*   StdDlgContentArea, which may contain the following items:
    
    *   Zero or more StdDlgTextItem nodes (the block(s) of text with the main message).
    *   Zero or more StdDlgBulletTextItem nodes (bulleted/numbered list).
    *   Zero or more StdDlgTextItem nodes (the block(s) of text with the bottom message).
*   StdDlgButtonArea, which may contain zero or more StdDlgButton nodes.

Fields
------

| Field | Type | Default | Access Permission | Description |
| --- | --- | --- | --- | --- |
| title | string | ""  | READ\_WRITE | The title to be displayed at the top of the dialog. |
| message | array of strings | \[ \] | READ\_WRITE | One or more blocks of informational text displayed at the top of the dialog's content area. Each string in the array is displayed as a separate block of text with the standard amount of space left between the blocks.  <br><br>> To separate lines of text, add each line as an element in the array. Do not use newline characters. |
| bulletText | array of strings | \[ \] | READ\_WRITE | An array of strings displayed as a bulleted or numbered list. The list is displayed in the content area below the message and above the bottom message. |
| bulletType | string | "bullet" | READ\_WRITE | If the **bulletText** field is set, specifies the type of list item delimiter, which may be one of the following:  <br><br>*   "bullet" (this is the default)<br>*   "numbered"<br>*   "lettered"<br><br>. |
| bottomMessage | array of strings | \[ \] | READ\_WRITE | One or more blocks of informational text displayed at the bottom of the dialog's content area. Each string in the array is displayed as a separate block of text with the standard amount of space left between the blocks.  <br><br>> To separate lines of text, add each line as an element in the array. Do not use newline characters. |
| buttons | array of strings | \[ \] | READ\_WRITE | List of buttons to be displayed in the button area at the bottom of the dialog. Each string in the buttons array adds a new button to the button area.  <br><br>> Minimize the number of buttons in the dialog to ensure they are all visible when the dialog is displayed. |

Sample app
----------

You can download and install a [sample app](https://github.com/rokudev/standard-dialog-framework) that demonstrates how to create a standard message dialog.

ifSGNodeField
=============

The ifSGNodeField interface allows querying, getting, setting, and performing other similar manipulation operations on Scene Graph node fields. This interface also allows you to set and unset event observers on a subject node field.

Implemented by
--------------

| Name | Description |
| --- | --- |
| [roSGNode](/docs/references/brightscript/components/rosgnode.md "roSGNode") | The roSGNode object is the BrightScript equivalent of SceneGraph XML file node creation |

Supported methods
-----------------

### setField(fieldName as String, value as Object) as Boolean

#### Description

Sets the value of a subject node field. This will fail and stop script execution if the value is not of the appropriate type.

You can also use the node.field syntax to get the same result as setField(). Specifically, rect.setField("opacity", 0.5) is equivalent to rect.opacity = 0.5.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| fieldName | String | The name of the field to be updated. |
| value | Object | The updated value for the field. |

#### Return Value

A flag indicating whether the field was successfully updated.

_Since Roku OS 9.3_, `observeField()` and `observeFieldScoped()` methods include an optional `infoFields` parameter, which is an array of field names. Generally, these should be relevant fields in the same object being observed, which are necessary to give context to the field that triggered the field change event. The triggered event object itself will provide a `getInfo()` method, which returns an AA that contains the names and instantaneous values of the requested "context" fields at the point when the observed field changed. For example, use of `videoNode.observeField("position", m.port, ["clipId", "programId"])` to set up an observer for `position` would later allow the call `extraInfo = msg.GetInfo()` to retrieve requested "context" information, given that `msg` is the relevant roSGNodeEvent indicating that `position` has changed. The contents of `extraInfo` would resemble `{"clipid": 1, "programid": 0}`.

### observeField(fieldName as String, functionName as String \[, infoFields as Object\]) as Boolean

#### Description

Calls a function when a field of the subject node changes. The function called must be in the scope of the current component.

Optionally, this form can pass an [roSGNodeEvent](/docs/references/brightscript/components/rosgnode.md "roSGNodeEvent") message to the callback function by specifying the message object as an argument to the callback function. The following sample demonstrates how to do this:

    sub callback_function(message as Object)
      ...
    end sub
    

From this message in the callback function, you can get the node ID, the field name, and the field value at the time it was set, using the same [roSGNodeEvent](/docs/references/brightscript/components/rosgnode.md "roSGNodeEvent") methods described in the overloaded form observeField(fieldName as String, port as Object). The [roSGNodeEvent](/docs/references/brightscript/components/rosgnode.md "roSGNodeEvent") message also includes a pointer to the node that can be accessed using getRoSGNode(), to associate nodes without an ID in the callback function. Additional information can be accessed in the callback function by storing the information in a custom field of the node.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| fieldName | String | The name of the field to be monitored. |
| functionName | String | The name of the method to be executed when the value of the field changes. |
| infoFields | Object (String array) | Optional. Names of "context" field values to be reported via getInfo() when the monitored field changes. |

#### Return Value

A flag indicating whether this operation was successful.

### observeField(fieldName as String, port as Object \[, infoFields as Object\]) as Boolean

#### Description

This overloaded form sends an [roSGNodeEvent](/docs/references/brightscript/components/rosgnode.md "roSGNodeEvent") message to the [roMessagePort](/docs/references/brightscript/components/romessageport.md "roMessagePort") identified by port when the subject node field identified by fieldName changes value.

*   Running GetNode() on the message retrieves the ID of the node that changed.
*   Running GetField() on the message gets the name of the field that changed.
*   Running GetData() on the message gets the new field value at the time of the change.

This allows other threads to react to field changes, and avoids missing a value when the field changes twice before the message handler is able to receive the [roSGNodeEvent](/docs/references/brightscript/components/rosgnode.md "roSGNodeEvent") messages.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| fieldName | String | The name of the field to be monitored. |
| port | Object | The [roMessagePort](/docs/references/brightscript/components/romessageport.md "roMessagePort") to receive a [roSGNodeEvent](/docs/references/brightscript/components/rosgnode.md "roSGNodeEvent") message when the value of the field changes. |
| infoFields | Object (String array) | Optional. Names of "context" field values to be reported via getInfo() when the monitored field changes. |

#### Return Value

A flag indicating whether this operation was successful.

### queueFields(queueNode as Boolean) as Boolean

#### Description

Makes subsequent operations on the node fields to queue on the node itself rather than on the [Scene](/docs/references/scenegraph/scene.md "Scene") node render thread. This prevents the operations from being executed immediately.

Subsequently setting this method to false will then cause all of the operations to be transferred to the [Scene](/docs/references/scenegraph/scene.md "Scene") node render thread queue to be immediately executed in a single render cycle. This can be helpful when multiple fields of a node that affect the appearance of the user interface need to be changed at one time from another thread.

This method should not be used on a node that is not owned by the render thread, as the render thread will not be able to execute the operations when they are released to it. You can use it when a node owned by a [Task](/docs/references/scenegraph/control-nodes/task.md "Task") node thread is transferred to the render thread, by setting it to a child or a node field of a node already owned by the render thread, where the queue is then released.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| queueNode | Boolean | A flag enabling queuing on the node. |

#### Return Value

A flag indicating the current state of **queueNode**.

### addFields(fields as Object) as Boolean

#### Description

Adds the field(s) and corresponding field value(s) defined as key-value pair(s) in the associative array fields to the subject node. The types of the added fields are determined by the values which correspond to the allowable types for an `<interface>` field.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| fields | Object | An roAssociativeArray containing key-value pairs for the fields to be added. |

#### Return Value

A flag indicating whether the fields have been successfully added.

### getField(fieldName as String) as Object

#### Description

Returns the appropriately-typed value from the specified field of the subject node.

You can also use the node.field syntax to get the same result as getField(). Specifically, `rectpos = rect.getField("translation")` is equivalent to `rectpos = rect.translation`. You can also use the syntax node\[fieldName\].

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| fieldName | String | The name of the field to be retrieved. |

#### Return Value

A typed value.

### addField(fieldName as String, type as String, alwayNotify as Boolean) as Boolean

#### Description

Adds a field with the specified name and type to the subject node. The added field is initialized to the default value for the type.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| fieldName | String | The name of the field to be added. |
| type | String | The type of the field to be added.  <br>  <br>Type declarations must be lowercase or the field will not be added to the node. For example, declaring "Boolean" as the type will prevent the field from being added. |
| alwayNotify | Boolean | Specifies whether observers of the field are triggered when the field value is updated to the same or new value (true), or only when the field changes to a new value (false). |

#### Return Value

A flag indicating whether the field have been successfully added.

### getFieldType(fieldName as String) as String

#### Description

Returns the type of a specific field of the subject node.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| fieldName | String | The name of the field to have its type retrieved. |

#### Return Value

The field type.

### setFields(fields as Object) as Boolean

#### Description

Sets the values for one or more fields.

> This function does not set the fields according to their index position within an associative array. Do not use it if setting fields in a specific order is critical to your app application.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| fields | Object | An roAssociativeArray containing key-value pairs for the fields to be updated. |

#### Return Value

A flag indicating whether the fields have been successfully updated.

### removeFields(fieldNames as Object) as Boolean

#### Description

Removes one or more fields from the subject node.

Fields defined as part of the built-in node class cannot be removed. Fields defined in [content metadata](/docs/developer-program/getting-started/architecture/content-metadata.md " Content Meta-Data") and the related SceneGraph node class metadata bindings can be removed, but will be dynamically re-added at any time they are explicitly accessed.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| fieldNames | Object | An roArray containing the names of the fields to be removed. |

#### Return Value

A flag indicating whether the fields have been successfully removed.

### unobserveFieldScoped(fieldName as String) as Boolean

#### Description

Removes the connection between the observing component and the observed node's field.

This is similar to the [unobserveField()](/docs/references/brightscript/interfaces/ifsgnodefield.md#unobservefieldfieldname-as-string-as-boolean "unobserveField(fieldName as String)") method, which undoes both forms of observeField() and thus undoes both forms of observeFieldScoped().

This method looks for and removes the implicit connection state stored in the observing object so that the calling component will no longer receive notification of changes in the specified node's field. Connections in other observing objects or even in the observed object are not affected

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| fieldName | String | The name of the field to no longer be monitored. |

#### Return Value

A flag indicating whether this operation was successful.

### removeField(fieldName as String) as Boolean

#### Description

Removes a field from the subject node. Fields defined in [content metadata](/docs/developer-program/getting-started/architecture/content-metadata.md " Content Meta-Data") and the related SceneGraph node class metadata bindings can be removed, but will be dynamically re-added at any time they are explicitly accessed.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| fieldName | String | The name of the field to be removed. |

#### Return Value

A flag indicating whether the field has been successfully removed.

### observeFieldScoped(fieldName as String, functionName as String\[, infoFields as Object\]) as Boolean

#### Description

Sets up a connection between the observed node's field and the current component from which this call is made. This method is similar to the [observeField()](/docs/references/brightscript/interfaces/ifsgnodefield.md#observefieldfieldname-as-string-functionname-as-string-as-boolean "observeField(fieldName as String, functionName as String)") method.

While the connection exists, any change in the called/observed node's field specified by **fieldName** results in calling the function specified by functionName in the observing component.

The callback will be on the thread that owns the observed node. This is usually the render thread except in some narrowly defined scenarios. See [SceneGraph Threads](/docs/developer-program/core-concepts/threads.md "SceneGraph Threads") for further details.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| fieldName | String | The name of the field to be monitored. |
| functionName | String | The name of the method to be executed when the value of the field changes. |
| infoFields | Object (String array) | Optional. Names of "context" field values to be reported via getInfo() when the monitored field changes. |

#### Return Value

A flag indicating whether this operation was successful.

### observeFieldScoped(fieldName as String, port as Object\[, infoFields as Object\]) as Boolean

> This function is deprecated. Use the [ObserveFieldScopedEx()](#observefieldscopedexfieldname-as-string-port-as-object-infofields-as-object-as-boolean) function for improved memory usage as it correctly monitors the observing component.

#### Description

Sets up a connection between the observed node's field and the current component from which this call is made. This method is similar to the [observeField()](/docs/references/brightscript/interfaces/ifsgnodefield.md#observefieldfieldname-as-string-functionname-as-string-as-boolean "observeField(fieldName as String, functionName as String)") method.

While the connection exists, any change in the called/observed node's field specified by fieldName results in a message being sent to the [roMessagePort](/docs/references/brightscript/components/romessageport.md "roMessagePort") specified by port.

The message will be received on the thread that owns the port. This is either a task thread or the main BrightScript thread. See [SceneGraph Threads](/docs/developer-program/core-concepts/threads.md "SceneGraph Threads") for further details.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| fieldName | String | The name of the field to be monitored. |
| port | Object | The [roMessagePort](/docs/references/brightscript/components/romessageport.md "roMessagePort") to receive a [roSGNodeEvent](/docs/references/brightscript/components/rosgnode.md "roSGNodeEvent") message when the value of the field changes. |
| infoFields | Object (String array) | Optional. Names of "context" field values to be reported via getInfo() when the monitored field changes. |

#### Return Value

A flag indicating whether this operation was successful.

### observeFieldScopedEx(fieldName as String, port as Object\[, infoFields as Object\]) as Boolean

#### Description

Sets up a connection between the observed node's field and the current component from which this call is made. This method is similar to the [observeField()](/docs/references/brightscript/interfaces/ifsgnodefield.md#observefieldfieldname-as-string-functionname-as-string-as-boolean "observeField(fieldName as String, functionName as String)") method.

While the connection exists, any change in the called/observed node's field specified by fieldName results in a message being sent to the [roMessagePort](/docs/references/brightscript/components/romessageport.md "roMessagePort") specified by port.

The message will be received on the thread that owns the port. This is either a task thread or the main BrightScript thread. See [SceneGraph Threads](/docs/developer-program/core-concepts/threads.md "SceneGraph Threads") for further details.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| fieldName | String | The name of the field to be monitored. |
| port | Object | The [roMessagePort](/docs/references/brightscript/components/romessageport.md "roMessagePort") to receive a [roSGNodeEvent](/docs/references/brightscript/components/rosgnode.md "roSGNodeEvent") message when the value of the field changes. |
| infoFields | Object (String array) | Optional. Names of "context" field values to be reported via getInfo() when the monitored field changes. |

#### Return Value

A flag indicating whether this operation was successful.

### unobserveField(fieldName as String) as Boolean

#### Description

Removes the previously established connections between the subject node field identified by fieldName and any callback functions or message ports.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| fieldName | String | The name of the field to no longer be monitored. |

#### Return Value

A flag indicating whether this operation was successful.

### getFields() as Object

#### Description

Returns the names and values of all the fields in the node.

#### Return Value

An roAssociativeArray containing key-value pairs with the element names and values.

### hasField(fieldName as String) as Boolean

#### Description

Checks whether a field exists in the node.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| fieldName | String | The name of the field to be checked for whether it exists in the node. |

#### Return Value

A flag indicating whether the subject node has a field whose name exactly matches fieldName, or whose fully lowercase analog is identical to that of fieldName.

### getFieldTypes() as Object

#### Description

Returns the names and types of all the fields in the node.

#### Return Value

An roAssociativeArray containing key-value pairs with the element names and types.

| Name | Return Type | Return Value | Description |
| --- | --- | --- | --- |
| getFieldTypes | Object | roAssociatve Array | Returns an roAssociativeArray for the subject node containing key-value pairs with the field names and field types, respectively. |

### threadinfo() as Object

#### Description

A runtime debugging method for helping minimize Rendezvous spread. This method can be called on any node from any thread.

The following example demonstrates the information returned by this method:

    {   node: { type: "XXComponent",          
        id: "XXID",          
        address: 0x123XXX,          
        willRendezvousFromCurrentThread: "Yes",          
        owningThread: { type: "Render", name: "newMainScene", id:"123456" }        
    },
        currentThread: { type: "Task",   name: "conviva",     id: "234567" },    
        renderThread: { type: "Render", name: "newMainScene", id: "123456" }
    }
    

> Do not call this method from within function main() or any function called by function main()

#### Return Value

An roAssociativeArray with the following information:

*   What is calling a thread function is being called from.
*   On which component's behalf (what m.top) the current function is executing.
*   The thread ownership of the node in question.
*   Whether or not access to the node from the current thread would cause a rendezvous.

### signalBeacon(beacon As String) As Integer

#### Description

Signals start and/or stop points for measuring app launch and Electronic Program Grid (EPG) launch times.

To pass certification, an app must finish launching within the time specified in the [certification performance requirements](/docs/developer-program/certification/certification.md#3performance). The Roku OS automatically fires an **AppLaunchInitiate** event to mark when the user presses the OK button to launch an app from the Roku home screen. The app, however, must fire the corresponding `AppLaunchComplete` to mark when the app home page is fully rendered or when video playback starts after handling a [deep link](/docs/references/brightscript/interfaces/ifsgnodefield.md) and the app can respond to commands sent via the remote control.

Starting in Roku OS 9.3, if the app UI displays a login or user selection dialog before the home page, the app can fire **AppDialogInitiate** and **AppDialogComplete** beacons when the dialog loads and exits, respectively. These new beacons enable more accurate measurements of app launch times as the time spent on any dialogs requiring user input prior to rendering the home page are subtracted from the overall app launch time. If the app displays more that one dialog before the home page, multiple pairs of **AppDialogInitiate**/**AppDialogComplete** beacons may be fired. Do not fire AppDialog beacons on message dialogs that do not involve any user interaction (for example, a "please wait" or "loading" dialog).

To fire signal beacons within your application, call the `signalBeacon()` function on any node as demonstrated in the following examples:

    myScene.signalBeacon(“AppLaunchComplete”)
    myEPGComponent.signalBeacon(“EPGLaunchInitiate”)
    m.top.signalBeacon(“EPGLaunchComplete”)`
    

> Only the first sequence of EPG launch beacons is recorded. If a user launches the EPG more than once while the app is running, a warning message is output to the debug console. This warning message, which acknowledges the receipt of the beacon while notifying that subsequent ones will not be recorded, may be ignored.
> 
> Only EPG launch sequences that start within 5 seconds of the `AppLaunchComplete` event being fired qualify as a valid measurements for certification. EPG launch sequences fired after the 5-second window are still recorded so that app performance can be compared against requirements.

The following table summarizes when to fire the `AppLaunchComplete`, `AppDialogInitiate/AppDialogComplete`, and `EPGLauchInitiate`/`EPGLauchComplete` beacons and when their timestamps are recorded:

| Launch Event | **Placement** | **Timestamping** |
| --- | --- | --- |
| AppLaunchComplete | When the app home page is fully rendered, or when video playback starts and the app can responds to commands sent via the remote control (if your app is launched to direct playback).The system automatically fires an AppLaunchInitiated beacon to marks when your app is initially launched. | The first render pass completes after the stop point has been signaled. |
| AppDialogInitiate | Before signaling AppLaunchComplete, when the app enters a login dialog, user selection screen, network error dialog or any other dialog/screen where the app waits for user input. | The dialog is fully displayed and ready for user interaction. |
| AppDialogComplete | The app exits the last dialog before the home screen is rendered. | The user dismisses the dialog or a timeout occurs that forces the dialog to exit. |
| EPGLaunchInitiate | Where your app initiates the display of the app guide. | The last keypress before the start beacon was signaled. If there was no prior keypress, the start beacon signal time. |
| EPGLaunchComplete | Where the app guide is fully rendered and operational. | The first render pass completes after the stop point has been signaled. |

#### Return Value

When you fire a launch event, the system will return an integer indicating the result of its signaling:

| **Return Code** | **Description** |     |
| --- | --- | --- |
| 0   | Success | The event was successfully signaled. |
| 1   | Not Ready | The event cannot be fired until after the AppLaunchComplete beacon has been completed. |
| 2   | Invalid | An invalid string was passed into the signalBeacon function. |
| 3   | Already Signaled | An event that can only be fired once (AppLaunchComplete) was signaled again. |
| 4   | Wrong Order | The completion event was fired before the corresponding initiate event (for example, EPGLaunchComplete was signaled before EPGLaunchInitiate). |

> In addition to the app launch, dialog launch, and EPG launch times, the Roku OS automatically measures five other certification performance metrics: app compile time, video start time, live start time, channel change time, and channel exit time. You can use the [BrightScript console](/docs/developer-program/debugging/debugging-channels.md) (port 8085) to view a report detailing your app's performance. See [Measuring app performance](/docs/developer-program/debugging/debugging-channels.md) for more information.

ifMicrophone
============

Implemented by
--------------

| Name | Description |
| --- | --- |
| [roMicrophone](/docs/references/brightscript/components/romicrophone.md "roMicrophone") | The roMicrophone API allows apps to receive audio data from the user’s microphone-supported remote control device or mobile phone |

Supported methods
-----------------

### CanRecord() as Boolean

#### Description

Indicates whether the platform and paired remote control can be requested to open the microphone.

#### Return Value

A flag indicating whether the microphone can be opened.

### SetPrompt(prompt as String) as Void

#### Description

Sets the text to be displayed in the system microphone UI.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| prompt | String | The text to be displayed in the system microphone UI. |

### RecordToFile(wavFilePath as String) as Boolean

#### Description

Opens the microphone and records to create a WAV file at the specified output file path. Only tmp:/ paths are supported.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| wavFilePath | String | The file path where the WAV file is to be stored. |

#### Return Value

A flag indicating whether the recording was performed and saved successfully.

### StartRecording() as Boolean

#### Description

Opens the microphone and begins streaming microphone events to the app. The app must have called the [SetMessagePort()](/docs/references/brightscript/interfaces/ifsetmessageport.md#setmessageportport-as-object--as-void) method previously.

While the microphone is open, [RecordingInfo](/docs/references/brightscript/events/romicrophoneevent.md#isrecordinginfo-as-boolean) events will be sent periodically with audio data. When the microphone is closed, a [RecordingDone](/docs/references/brightscript/events/romicrophoneevent.md#isrecordingdone-as-boolean) event will be sent. See [roMicrophoneEvent](/docs/references/brightscript/events/romicrophoneevent.md) for detailed information.

#### Return Value

A flag indicating whether the microphone was opened successfully.

### StopRecording() as Boolean

#### Description

Stops recording and closes the microphone. This method is useful if the microphone was previously opened via the [StartRecording()](#startrecording-as-boolean) method and the app needs to cancel the current recording prematurely, (for example, the duration limit was reached or an application error).

#### Return Value

A flag indicating whether the microphone was opened and closed successfully.

ScrollingLabel
==============

Extends [**Group**](/docs/references/scenegraph/layout-group-nodes/group.md "**Group**")

The ScrollingLabel node class provides an automatic way to make a string scroll horizontally if it does not fit within the specified width. If the string can be drawn within the specified maximum width it is just drawn. If it does not fit within the specified maximum width, it is drawn with an ellipsis (...) at the end, then it transitions to the full string, clipped to the maximum width that scrolls left to right until the end of the string is visible, then transition back to the partial string with the ellipsis at the end. By default, this repeats continuously unless the repeatCount field is set to limit the number of times the scrolling occurs.

### Alignment

The ScrollingLabel node class uses the horizAlign and vertAlign fields to allow you to position the rendered text relative to a specified bounding rectangle.

#### Horizontal Alignment

The horizAlign field allows you to position text horizontally relative to the maximum width of the label as specified by the maxWidth field.

There are three possible values for the horizAlign field:

*   left The left edge of the text is drawn at the 0 x-coordinate position of the ScrollingLabel node's local coordinate system.
    
*   center The horizontal center of each line of text is positioned at the x-coordinate corresponding to half the computed width of the ScrollingLabel node's local coordinate system.
    
*   right The right edge of each line of text is positioned at x-coordinate position corresponding to the computed width of the ScrollingLabel node's local coordinate system.
    

#### Vertical Alignment

The vertAlign field allows you to position text vertically relative to the computed height of the label. The computed height is determined in one of two ways:

If the height field is greater than zero, the computed height is the value of the height field.

If the height field is zero, the computed height is the height of the line of rendered text, in which case the vertAlign field is ignored.

There are three possible values for the vertAlign field:

*   top The top edge of the text is drawn at 0 y-coordinate position of the ScrollingLabel node's local coordinate system.
    
*   center The vertical center of the rendered text is positioned at y-coordinate position corresponding to half the computed height of the ScrollingLabel node's local coordinate system.
    
*   bottom The text is drawn so that bottom edge of the rendered text is positioned at the y-coordinate position corresponding to the computed height of the ScrollingLabel node's local coordinate system.
    

Fields
------

| Field | Type | Default | Access Permission | Description |
| --- | --- | --- | --- | --- |
| text | string | ""  | READ\_WRITE | Specifies the text to be displayed |
| color | color | 0xddddddff | READ\_WRITE | Specifies the text color |
| font | Font | system default | READ\_WRITE | Specifies the Font node to be used |
| maxWidth | float | 500 | READ\_WRITE | Specifies the maximum width of the rendered text. If the rendered text exceeds the maximum width, the scrolling behavior is automatically triggered |
| height | float | 0   | READ\_WRITE | Specifies the height of the label. If set to zero, the actual height is determined by the value of the numLines field if it is greater than zero. See [Vertical Alignment](/docs/references/scenegraph/typographic-nodes/scrollinglabel.md#alignment "Vertical Alignment") |
| scrollSpeed | float | 100 | READ\_WRITE | Specifies the horizontal scrolling speed in pixels per second |
| repeatCount | float | \-1 | READ\_WRITE | If set to the default value of -1, the text scrolling behavior repeats continuously. If set to zero, the text will remain ellipsized and never scroll. If set to a value greater than zero, the text will scroll the specified number of times, at the end of which the text is rendered with an ellipsis at the end |
| horizAlign | option string | left | READ\_WRITE | See [Horizontal Alignment](/docs/references/scenegraph/typographic-nodes/scrollinglabel.md#alignment "Horizontal Alignment") |
| vertAlign | option string | top | READ\_WRITE | See [Vertical Alignment](/docs/references/scenegraph/typographic-nodes/scrollinglabel.md#alignment "Vertical Alignment") |

Sample app
----------

[ScrollingLabelExample](https://github.com/rokudev/samples/tree/master/ux%20components/text/ScrollingLabelExample) is a sample app demonstrating ScrollingLabel in action.

Audio
=====

Extends [**Node**](/docs/references/scenegraph/node.md)

The Audio node class plays streaming audio.

The Audio node class has no built-in visual UI, but you can build your own UI for the node, including trick play, or showing an album cover or similar graphical image for each song selected by a user.

Fields
------

FieldTypeDefaultAccess PermissionDescriptioncontentContentNodeNULLREAD\_WRITEThe ContentNode with the [Content Meta-Data](/docs/developer-program/getting-started/architecture/content-metadata.md) for the audio or audio playlist (a sequence of audios) to be played. If a audio playlist is to be played, the ContentNode must include complete child ContentNodes for each audio in the playlist, with all attributes required to play that audio.contentIsPlaylistBooleanfalseREAD\_WRITEIf set to true, enables audio playlists (a sequence of audios to be played). To enable audio playlists, the ContentNode set in the `content` field must have children ContentNodes for each audio in the playlist. When audio playback is started, all of the audios in the playlist will be played in sequence.nextContentIndexinteger\-1READ\_WRITEIf the `contentIsPlaylist` field is set to true to enable audio playlists, sets the index of the next audio in the playlist to be played. Setting this field does not immediately change the audio being played, but takes effect when the current audio is completed or skipped. By default, this value is -1, which performs the default index increment operation. After the audio specified by the index in this field begins playing, the field is set to the default -1 again, so the next audio played will be set by the default index increment operation, unless the field is set again to a different index.loopBooleanfalseREAD\_WRITEIf set to true, the audio or audio playlist (if the `contentIsPlaylist` field is set to true to enable audio playlists) will be restarted from the beginning after the end is reached.bufferingStatusassociative arrayinvalidREAD\_ONLYContains information about stream buffering progress and status. This field is valid only while buffering is in progress, both at stream startup or when re-buffering is required. Observers will be notified when any element of the array changes, and also when buffering is complete and the field itself becomes invalid. The array contains the following name - value pairs.  
  

| Value | Meaning |
| --- | --- |
| percentage | Percent buffering complete as an integer. |
| isUnderrun | Boolean value indicating if a stream underrun occurred. |

controloption stringnoneREAD\_WRITESets the desired play state for the audio, such as starting or stopping the audio play. Getting the value of this field returns the most recent value set, or `none` if no value has been set. In order to dynamically monitor the actual state of the audio, see the `state` field.  
  

| Option | Effect |
| --- | --- |
| none | No play state set |
| play | Start audio play |
| start | Start audio play |
| stop | Stop audio play |
| pause | Pause audio play |
| resume | Resume audio play after a pause |
| replay | Replay audio |
| prebuffer | Starts buffering the audio stream before the Audio node actually begins playback. Only one audio stream can be buffering in the application at any time. Setting the `control` field to `prebuffer` for another audio stream after setting `prebuffer` for a previous audio stream stops the buffering of the previous audio stream. |
| skipcontent | Skip the currently-playing content, and begin playing the next content in the playlist. If the content is not a playlist, or if the current content is the end of the playlist, this will end playback. |

notificationIntervaltime0.5READ\_WRITEThe interval between notifications to observers of the position field, specified as the number of seconds. If the value is 0, no notifications are delivered. This value may be read or modified at any time.timedMetaDataSelectionKeysarray of strings\[ \]READ\_WRITEIf the audio stream contains timed meta data such as ID3 tags, any meta data with a key matching an entry in this array will be set into the timedMetaData field. If any entry in this array is "\*", then all timed meta data will be selected.seektimeinvalidWRITE\_ONLYSets the current position in the audio. The value is the number seconds from the beginning of the stream, specified as a double.contentIndexinteger\-1READ\_ONLYThe index of the audio in the audio playlist that is currently playing. Generally, you would only want to check this field if audio playlists are enabled (by setting the `contentIsPlaylist` field to true), but it is set to 0 when a single audio is playing and audio playlists are not enabled.timedMetaDataassociative array{ }READ\_ONLYThe most recent timed meta data that has been decoded from the audio stream. Only meta data with a key that matches an entry in timedMetaDataSelectionKeys will be set into this field. The value of this field is an associative array which contains arbitrary keys and values, as found in the audio stream.  
  
As of Roku OS 10.5, this field can be used to read ID3 tags embedded in an audio stream.statevalue stringnoneREAD\_ONLYDescribes the current audio play state, such as if the audio play has been paused.  
  

| Value | Meaning |
| --- | --- |
| none | No current play state |
| buffering | Audio stream is currently buffering |
| playing | Audio is currently playing |
| paused | Audio is currently paused |
| stopped | Audio is currently stopped |
| finished | Audio has completed play |
| error | An error has occurred in the audio play. The error code and error message can be found in the `errorCode` and `errorMsg` fields respectively. |

positiontimeinvalidREAD\_ONLYThe current position in the audio play, as the number of seconds.durationtime0READ\_ONLYThe duration of the audio being played, specified in seconds. This becomes valid when playback begins and may change if the audio is dynamic content, such as a live event.errorCodeinteger0READ\_ONLYThe error code associated with the audio play error set in the `state` fielderrorMsgstringREAD\_ONLYAn error message describing the audio play error set in the `state` field.audioFormatstringREAD\_ONLYContains the format of the currently playing audio.  
  

| Value | Meaning |
| --- | --- |
| ""  | No stream playing |
| aac | ISO/IEC 14496-3, Advanced Audio Coding |
| aac\_adif | ISO/IEC 14496-3, Advanced Audio Coding, ADIF container |
| aac\_adts | ISO/IEC 14496-3, Advanced Audio Coding, ADTS container |
| aac\_latm | ISO/IEC 14496-3, Advanced Audio Coding, LATM container |
| ac3 | Dolby Digital |
| alac | Apple Lossless |
| dts | DTS Coherent Acoustics |
| eac3 | Dolby Digital Plus |
| flac | Free Lossless Audio Codec |
| mp2 | ISO/IEC 11172-3, MPEG Audio Layer II |
| mp3 | ISO/IEC 11172-3, MPEG Audio Layer III |
| none | Stream contains no playable audio |
| pcm | linear PCM |
| unknown | Stream contains unknown audio |
| vorbis | Ogg Vorbis |
| wma  <br>_sunset as of Roku OS 12.5_ | Microsoft Windows Media Audio.  <br>  <br>As of Roku OS 10.5, the Roku platform no longer supports this audio format. As part of the Roku OS 12.5 release, this format was officially sunset. |
| wmapro  <br>_sunset as of Roku OS 12.5_ | Microsoft Windows Media Pro Audio.  <br>  <br>As of Roku OS 10.5, the Roku platform no longer supports this audio format. As part of the Roku OS 12.5 release, this format was officially sunset. |

streamingSegmentassociative array{ }READ\_ONLYInformation about the audio segment that is currently streaming. This is only meaningful for segmented audio transports, such as DASH and HLS. The associative array has the following entries:  
  

| Key | Type | Value |
| --- | --- | --- |
| segBitrateBps | integer | Bitrate of the segment in bits per second |
| segSequence | integer | The sequence number of the segment in the audio |
| segStart | time | The start time of the segment from the start of the audio, specified in seconds |
| segUrl | string | URL of the segment |

focusedChildN/AN/AREAD\_WRITEWhen a node or one of its children gains or loses the keyboard focus, the focusedChild field will be set and call its observer functions. In the observer function, typically, you use [ifSGNodeFocus](/docs/references/brightscript/interfaces/ifsgnodefocus.md) functions to query whether this node or some other node has the key focus or is in the key focus chain.  
  
Accessing the value of the field will result in script errors.autoplayAfterSeekbooleantrueREAD\_WRITEEnables audio content to automatically play after rebuffering. Setting this flag to false disables this default behavior.mutebooleanfalseREAD\_WRITESet to true to mute the audio currently playing in the Audio node. Set to false to restore audio.streamInfoassociative arrayinvalidREAD\_ONLYInformation about the audio stream that is currently playing or buffering.  
  

| Key | Type | Value |
| --- | --- | --- |
| isUnderrun | Boolean | If true, the stream was downloaded due to an underrun |
| isResumed | Boolean | If true, playback was resumed after trickplay |
| measuredBItrate | Integer | The measured bitrate (bps) of the network when the stream was selected |
| streamBitrate | Integer | The bitrate of the stream |
| streamUrl | URI | The URL of the stream |

timeToStartStreamingtime0READ\_ONLYThe time in seconds from playback being started until the audio actually began playing. The minimum valid value is 1 millisecond, and this is only valid if the current value of the `state` field is `playing`. When the state field value is not `playing`, the value will be 0. This field is updated prior to the `state` field changing, so `state` field observer callback functions can assume this field is valid after the `state` field value changes to `playing`.

Data bindings
-------------

See [Content Meta-Data](/docs/developer-program/getting-started/architecture/content-metadata.md) for the required and optional play parameters, and descriptive information for audio playback. Set these parameters in a [ContentNode](/docs/references/scenegraph/control-nodes/contentnode.md) node, and assign the ContentNode to the content field of the Audio node to apply the parameters to a particular audio content item.

For HTTPS access, note the following Content Meta-Data attributes:

*   `HttpCertificatesFile`
*   `HttpCookies`
*   `HttpHeaders`
*   `HttpSendClientCertificates`

These attributes must be set to handle secure HTTP transfers of audio files. Note that this is a different HTTPS mechanism than used for other SceneGraph nodes as described in [roHttpAgent](/docs/references/brightscript/components/rohttpagent.md).

> Prior to Roku OS 7.2, each Audio and Video node created and configured an `HttpAgent` only when the first content was played in a given Audio or Video node instance. This sometimes meant that additional content would fail to play in the same node because headers, cookies, and certificates were not updated or correctly replaced from the new content record. Apps that are dependent upon this behavior will need to be updated to set the required data into the Content Meta-Data for each piece of content, or to programmatically set those values into the `HttpAgent` before playing each piece of content.

Example
-------

**Example application:** [AudioExample](https://github.com/rokudev/samples/tree/master/media/AudioExample)

[AudioExample](https://github.com/rokudev/samples/tree/master/media/AudioExample) uses a [LabelList](/docs/references/scenegraph/list-and-grid-nodes/labellist.md) node to select from several spoken audio examples. The [Content Meta-Data](/docs/developer-program/getting-started/architecture/content-metadata.md) for the example is found in the `pkg:/server/audiocontent.xml` file, read into a [ContentNode](/docs/references/scenegraph/control-nodes/contentnode.md) node by the [Task](/docs/references/scenegraph/control-nodes/task.md) node `audiocontentreader.xml` component file.

Sample app
----------

[AudioExample](https://github.com/rokudev/samples/tree/master/media/AudioExample) is a sample app demonstrating Audio in action.

Integrating the Roku Advertising Framework
==========================================

Getting started
---------------

The RAF library is intended to allow developers to focus their effort on the core design of their applications, and provide them with the ability to quickly and easily integrate video advertising features with minimal impact to the rest of their application. This section provides an overview of the fundamental steps required to integrate with such applications. Other developers may wish to have more control over certain features within their applications, such as rendering the ads with a custom UI, or integrating the event tracking with a 3rd-party analytics API. The [API Reference](/docs/developer-program/advertising/raf-api.md) provides more detailed information on the video ad API, and the [Use Cases](/docs/developer-program/advertising/integrating-roku-advertising-framework.md#use-cases) section offers examples designed to cover a variety of different scenarios. The video ad features are provided as a common library deployed and managed as a hidden app.

> The RAF library may not be loaded through a component library.

The following line must be placed in the [manifest file](/docs/developer-program/getting-started/architecture/channel-manifest.md) for any applications using the Roku Advertising Framework library:

**Manifest entry**

    bs_libs_required=roku_ads_lib
    

Client applications do not include any additional BrightScript modules as part of their own package file. Instead, the “Library” keyword is used. The following line should be the first entry in your `main.brs` file:

    Library "Roku_Ads.brs"
    

The library interface is obtained by calling the constructor with no arguments:

    adIface = Roku_Ads()
    

Configure the ad URL before making the ad request call:

    adIface.setAdUrl(myAdUrl)
    

(You may wish to check [URL Parameter Macros](/docs/developer-program/advertising/integrating-roku-advertising-framework.md#url-parameter-macros) to see if any parameter values in the ad URL should be replaced with the provided macros.)

Aside from the [Configuration](/docs/developer-program/advertising/raf-api.md#configuration) interface, there are two main methods used to control ad parsing and rendering. The first, [getAds()](/docs/developer-program/advertising/raf-api.md#client-ad-insertion), makes the initial request to the ad server, parses the server response, and returns the structure of ads to be rendered prior to, or during playback, of the selected content:

    adPods = adIface.getAds()
    

Any preroll ads present in the returned set of ad pods can be immediately rendered by calling:

    shouldPlayContent = adIface.showAds(adPods, invalid, adHolder)
    

Checking and acting on the return value here allows the application to determine if the user exited out of the ad (for example, by pressing the “Back” button on the remote) and return to the content selection screen before playing the main content.

If the application is only showing preroll ads, the above five lines are sufficient. If the ad server URL was configured for additional midroll and/or postroll ads, the client application should periodically call [getAds()](/docs/developer-program/advertising/raf-api.md#client-ad-insertion) with the message from the content video playback loop to determine when to halt the content playback and render the ads:

**Calling getAds() in a while loop**

    while shouldPlayContent
      videoMsg = wait(0, contentVideoScreen.GetMessagePort())
      adPods = adIface.getAds(videoMsg)
      if adPods <> invalid and adPods.Count() > 0
        contentVideoScreen.Close() ' stop playback of content
        shouldPlayContent = adIface.showAds(adPods) ' render current ad pod
        if shouldPlayContent
          ' *** Insert client app’s resume-playback code here
        end if
      end if
      ' *** Insert client app’s video event handler code here
    end while
    

**Please note** that the system overlay behavior has been modified in Roku OS 8. Every time RAF is rendered, the Video node will not be in focus. For the Roku system overlay to slide out when the \* button is clicked, the Video node should be set to be in focus. Otherwise, the app retains control over the \* button and will need to handle button presses on their own. To set the Video node in focus again, use the following code snippet:

    sub init()
    m.top.setFocus(true)
    setVideo()
    sub
    

Use cases
---------

The video ad library is intended to support a variety of use cases, depending on the requirements of the application. The sample code presented here is provided for illustrative purposes of each of these cases and is not intended to represent required or optimal usage in client applications. For clarity and concision, error and object validity checking are omitted in these examples.

In all cases, the library must first be included and its interface constructed as described in [Getting Started](/docs/developer-program/advertising/integrating-roku-advertising-framework.md#getting-started). Additionally, unless the client application is using Roku’s default ad URL (which currently provides only a single ad), the ad URL must be configured before requesting an ad pod:

    Library "Roku_Ads.brs"
    
    adIface = Roku_Ads()
    adIface.setAdUrl(myAdUrl)
    adPods = adIface.getAds()
    

You may wish to check [URL parameter macros](#url-parameter-macros) to see if any parameter values in the ad URL should be replaced with the provided macros.

At this point, the ad server response has been fully parsed and is available in the adPods [Ad Structure](/docs/developer-program/advertising/integrating-roku-advertising-framework.md#ad-structure).

### Client side ad insertion

If the client application has no need for custom UI or user interaction during ad rendering, it is recommended to use the default rendering method [showAds()](/docs/developer-program/advertising/raf-api.md#client-ad-insertion). This method handles rendering and control of interactive and video ads, as well as displaying basic messaging UI (e.g., “Your program will continue after these messages”) and feedback UI (“Ad 1 of 3”). Calling [showAds()](/docs/developer-program/advertising/raf-api.md#client-ad-insertion) with an array of ad pods (such as the structure returned from the initial call to [getAds()](/docs/developer-program/advertising/raf-api.md#client-ad-insertion)) will render the first pod scheduled as a preroll. Calling it with a single ad pod will render that pod, regardless of its `renderSequence` attribute.

#### Single preroll ad pod

Just call [showAds()](/docs/developer-program/advertising/raf-api.md#client-ad-insertion) with the adPods value that the application obtained above:

    shouldPlayContent = adIface.showAds(adPods)
    

Note that the return value should still be checked to see if the user exited the ad, and therefore should also exit out of content playback back to a selection screen.

#### Sequential rendering

Typically, if the ad service URL is configured to return a slate of ad pods to be presented throughout the presentation of the content, it is sufficient to use [getAds()](/docs/developer-program/advertising/raf-api.md#client-ad-insertion) as an event listener in the content video event loop, as described in [Getting Started](/docs/developer-program/advertising/integrating-roku-advertising-framework.md#getting-started), to determine when the scheduled ad breaks should occur:

**Sequential ad pod rendering example**

    shouldPlayContent = adIface.showAds(adPods)
    while shouldPlayContent
      videoMsg = wait(0, contentVideoScreen.GetMessagePort())
      adPods = adIface.getAds(videoMsg)
      if adPods <> invalid and adPods.Count() > 0
        contentVideoScreen.Close() ' stop playback of content
        shouldPlayContent = adIface.showAds(adPods) ' render current ad pod
        if shouldPlayContent
          ' *** Insert client app’s resume-playback code here
        end if
      end if
      ' *** Insert client app’s video event handler code here
    end while
    

This usage of [getAds()](/docs/developer-program/advertising/raf-api.md#client-ad-insertion) also automatically implements the default policy that determines whether to re-render ads that have already been viewed. This policy permits the user to rewind content up to 5 minutes before a scheduled ad break before displaying that ad pod again.

#### Custom scheduling

Alternatively, there may be instances where the application must have greater control over when ad breaks occur. As an example, if the ad service is configured to return a VAST 2.0 response without temporal ad breaks, the application could re-interpret this unstructured response and schedule rendering of those ads as necessary:

**Custom ad scheduling example**

    adBreakSchedule = [adBreakTime1, adBreakTime2, adBreakTime3]
    scheduledPods = []
    adBreakIndex = 0
    for each ad in adPods[0].ad
      ' schedule one ad per ad break
      scheduledPods.Push({viewed : false,
                          renderSequence : "midroll",
                          duration : ad.duration,
                          renderTime : adBreakSchedule[adBreakIndex],
                          ads : [ad]
                          })
      adBreakIndex = adBreakIndex + 1
    end for
    

Default sequential rendering could then be used by first importing this new `scheduledPods` ad structure, as described in [Custom Ad Parsing and Rendering](/docs/developer-program/advertising/integrating-roku-advertising-framework.md#custom-ad-parsing-and-rendering).

Or, if the library’s ad rendering features are desired without the default ad scheduling mechanism, the application may completely control which ads are scheduled for rendering:

**Complete ad rendering control example**

    shouldPlayContent = true
    adBreakIndex = 0
    while shouldPlayContent
      videoMsg = wait(0, contentVideoScreen.GetMessagePort())
      if videoMsg.isPlaybackPosition()
        curPos = videoMsg.GetIndex()
        nextPod = scheduledPods[adBreakIndex]
        if curPos > nextPod.renderTime and not nextPod.viewed
          contentVideoScreen.Close() ' stop playback of content
          shouldPlayContent = adIface.showAds(nextPod) ' render next ad pod
          adBreakIndex = adBreakIndex + 1
          if shouldPlayContent
            ' *** Insert client app’s resume-playback code here
          end if
        end if
      end if
      ' *** Insert client app’s video event handler code here
    end while
    

This type of custom ad scheduling may also be necessary if the client application relies on multiple ad services to fill its ad slots. For this case, separate calls are made to [setAdUrl()](/docs/developer-program/advertising/raf-api.md#setadurlurl-as-string), followed by [getAds()](/docs/developer-program/advertising/raf-api.md#getadsmsg-as-string-as-object), to get the ads from each service. Then scheduling and rendering can be done using one of the methods described above.

#### Example

For examples, see the [Roku Advertising sample apps](https://github.com/rokudev/samples/tree/master/advertising)

### Just in Time (JIT) midroll ad retrieval

Apps using VMAP or SmartXML ad responses to structure midroll ad pods can enable the Just In Time (JIT) feature to speed up ad playback start times. With JIT, individual midroll ad pods are retrieved before ad breaks instead of all them being fetched prior to content playback. This can reduce multiple seconds from the playback start time depending on the number of midroll ads being inserted.

> Apps that want to use the JIT feature, but use an ad response structure other than SmartXML or VMAP for inserting midroll ad breaks, can contact [adsupport@roku.com![roku815px - img](https://jira.portal.roku.com:8443/images/icons/mail_small.gif)](mailto:adsupport@roku.com) for solutions to speed up content playback.

To enable the JIT feature, call RAF’s **enableJITPods()** method:

`adIface.enableJITPods(true)`

See the [RAF API reference guide](/docs/developer-program/advertising/raf-api.md#enablejitpodsenabled-as-boolean) for more information on this method.

### Enabling audience measurement

The impression tags fired when video ads are displayed on your app must include your content's metadata (genre, ID, and length) for measurement purposes. This enables you to measure and report audience delivery with third-party audience measurement solutions such as Nielsen's Digital Ad Ratings (DAR), ComScore Campaign Ratings (CCR), and ComScore Validated Campaign Essentials (VCE).

To enable ad measurement, call the [enableAdMeasurements()](/docs/developer-program/advertising/raf-api.md#enableadmeasurementsenabled) method, and pass the required content metadata within the [setContentGenre()](/docs/developer-program/advertising/raf-api.md#setcontentgenregenres-as-string-kidscontent-as-boolean), [setContentId()](/docs/developer-program/advertising/raf-api.md#setcontentgenregenres-as-string-kidscontent-as-boolean), and [setContentLength()](/docs/developer-program/advertising/raf-api.md#setcontentlengthlength-as-integer) methods.

    adIface.enableAdMeasurements(true)
    adIface.setContentGenre(content.categories)
    adIface.setContentId(content.stream.contentid)
    adIface.setContentLength(content.length)
    

#### Setting the content genre

Each ad server may require different [Roku genre tags](#roku-genre-tags) tags that you need to pass. Check with your ad server for the [Roku genre tags](#roku-genre-tags) to be used.

##### Passing the kidsContent flag with the content genre

When specifying the content genre with the [setContentGenre()](/docs/developer-program/advertising/raf-api.md#setcontentgenregenres-as-string-kidscontent-as-boolean) method, pass the **kidsContent** flag to specify whether the content being played is targeted towards children (true) or not (false).

### Frequency capping and targeting using RIDA

The RIDA is similar to advertising identifiers used on other platforms. It is designed to allow ad personalization and frequency capping on the Roku platform via a device identifier that can be reset by the end user.

Apps can use the [GetRIDA()](/docs/references/brightscript/interfaces/ifdeviceinfo.md#getrida-as-string) API to get the RIDA of a device and then pass it in ad server requests. If the customer has not opted out of ad targeting, the RIDA is set to a unique user ID (UUID). If the customer has opted-out (by enabling the "Limit ad tracking" flag from the **Settings** menu), the RIDA is set to a temporary ID that is different than the UUID and expires after 30 days. Apps must still pass this temporary ID in ad server requests to support frequency capping.

**Retrieving RIDA example**

    Function getAdID() as String
        adId = ""
        dev_info = createObject("roDeviceInfo")
        if dev_info <> invalid then
          adId = dev_info.GetRIDA()
        end if
        return adId
    End Function
    

#### RIDA specific parameters

Many leading ad servers such as FreeWheel and DFP have Roku specific parameters in their ad request that the app can pass the RIDA in.

For Freewheel, the parameters are:

    _fw_did=rida:<roku-device-id>
    _fw_vcid2=<roku-device-id>
    

**Example**

    url = http://my.ad.server.net/?my_first_param=MyFirstValue&other_param=SomeOtherValue&_fw_did=rida:<roku-device-id>
    

For DFP, the parameter is called `rdid`. Additional details available here: [https://support.google.com/dfp\_premium/answer/6238701?hl=en](https://support.google.com/dfp_premium/answer/6238701?hl=en)

**Example**

    url = http://pubads.g.doubleclick.net/gampad/request-type?my_first_param=MyFirstValue&other_param=SomeOtherValue&rdid=<roku-device-id>
    

> Replace <roku-device-id> with the RIDA for audience targeting.

### Custom buffering screens

RAF also supports multiple ways of customizing the buffering screen which appear before ad playback.

#### Default ad buffering screen

The default ad buffering screen displays a message and a progress bar. Both attributes can either be enabled or disabled using [enableAdBufferMessaging()](/docs/developer-program/advertising/raf-api.md#buffer-screen-customization).

![roku815px - integrateraf1](https://image.roku.com/ZHZscHItMTc2/integrateraf1.jpg "integrateraf1")

#### Custom buffering screen using content metadata (fixed positioning)

The buffering screen can also be customized by passing a content metadata object to [setAdBufferScreenContent()](/docs/developer-program/advertising/raf-api.md#buffer-screen-customization). This function does not support custom positioning. Instead, use SetAdBufferScreenLayer() as described in the next section.

The supported content meta-data attributes are:

| Attribute | Positioning | Example (below image) |
| --- | --- | --- |
| HDBackgroundImageUrl | Aligned to top-left corner | [https://upload.wikimedia.org/wikipedia/commons/thumb/f/f8/Aspect-ratio-16x9.svg/1280px-Aspect-ratio-16x9.svg.png](https://upload.wikimedia.org/wikipedia/commons/thumb/f/f8/Aspect-ratio-16x9.svg/1280px-Aspect-ratio-16x9.svg.png) |
| SDBackgroundImageUrl | Aligned to top-left corner | n/a |
| HDPosterUrl | Aligned to top-center | [http://static.commentcamarche.net/ccm.net/faq/images/0-BX4VeV6H-resolution-comparison-s-.png](http://static.commentcamarche.net/ccm.net/faq/images/0-BX4VeV6H-resolution-comparison-s-.png) |
| SDPosterUrl | Aligned to top-center | n/a |
| Title | Center-aligned relative to and displayed below PosterUrl | "Title for custom buffering screen" |
| Description | Left-aligned relative to PosterUrl | "Description for custom buffering screen" |

    bufferScreenContent = {}
    bufferScreenContent.HDBackgroundImageUrl = "https://upload.wikimedia.org/wikipedia/commons/thumb/f/f8/Aspect-ratio-16x9.svg/1280px-Aspect-ratio-16x9.svg.png"
    bufferScreenContent.HDPosterUrl = "http://static.commentcamarche.net/ccm.net/faq/images/0-BX4VeV6H-resolution-comparison-s-.png"
    bufferScreenContent.Title = "Title for custom buffering screen"
    bufferScreenContent.Description = "Description for custom buffering screen"
    
    adIface.SetAdBufferScreenContent(bufferScreenContent)
    

![roku815px - integrateraf2](https://image.roku.com/ZHZscHItMTc2/integrateraf2.jpg "integrateraf2")

#### Custom buffering screen using content metadata (custom positioning)

For a complete custom buffering screen, [setAdBufferScreenLayer()](/docs/developer-program/advertising/raf-api.md#buffer-screen-customization) allows the same content meta-data attributes as [setAdBufferScreenContent()](/docs/developer-program/advertising/raf-api.md#buffer-screen-customization), but enables you to customize the positioning and other roImageCanvas attributes.

**Custom buffering screen using layers**

    layers = [
        {Url: BackgroundImageUrl}
        {Url: PosterUrl, TargetRect : {x : 405, y : 370, w : 467, h : 262}}
        {
            Text : "This is a custom build screen"
            TextAttrs : { Color : "#FF0000", HAlign : "Center", Font : "Large"}
            TargetRect : {y : 50, h : 30}
        }
    ]
    adIface.setAdBufferScreenLayer(2, layers)
    

![roku815px - integrateraf3](https://image.roku.com/ZHZscHItMTc2/integrateraf3.jpg "integrateraf3")

For an example on different custom buffering screen implementations, see [CustomBufferScreenSceneGraphSample](https://github.com/rokudev/samples/tree/master/advertising).

### Custom ad parsing and rendering

Custom ad parsing and rendering requires explicit approval from Roku to ensure proper ad delivery and quality. Please reach out to [adsupport@roku.com](mailto:adsupport@roku.com) for verifying your implementation prior to submitting your app for publication.

#### Custom ad parsing

Some applications may use an ad service that returns an unsupported response format, but can still take advantage of the library’s ad rendering features. In this case, the application is reponsible for requesting and parsing the ad response and structuring the ads into an array of pods according to the required [Ad Structure](/docs/developer-program/advertising/integrating-roku-advertising-framework.md#ad-structure). Scheduling and rendering can then proceed as described in [**Client Side Ad Insertion**](/docs/developer-program/advertising/integrating-roku-advertising-framework.md#client-side-ad-insertion) by first calling the [importAds()](/docs/developer-program/advertising/raf-api.md#importadsadpodarray-as-object) method with the ad structure constructed externally by the client:

    adIface.importAds(myAdPodArray)
    

#### Custom ad rendering

Client applications may elect to control the ad rendering within the application, either to provide custom UI while loading ads, or because the ads are rendered by a method unsupported by the video ad library (e.g., by server-side video stitching). It is sufficient to make a single call to [getAds()](/docs/developer-program/advertising/raf-api.md#client-ad-insertion) to get the entire [Ad Structure](/docs/developer-program/advertising/integrating-roku-advertising-framework.md#ad-structure). The client application is then responsible for using the `streams` data to render the ads, and also must trigger the [Tracking](/docs/developer-program/advertising/integrating-roku-advertising-framework.md#tracking-events) events when the requisite conditions are met.

The [fireTrackingEvents()](/docs/developer-program/advertising/raf-api.md#control) method is used to trigger event tracking, including client macro replacement and processing of ad measurement beacons. The `adStructure` parameter passed in to this method can be either an `adPod` or a single ad from [Ad Structure](/docs/developer-program/advertising/integrating-roku-advertising-framework.md#ad-structure), depending on whether the event is relevant for the entire pod (such as `PodStart` or `PodComplete`) or for a single ad (all other event types). The `ctx` parameter should contain either a `type` string from the [Tracking](/docs/developer-program/advertising/integrating-roku-advertising-framework.md#tracking-events) events or a `time` numerical value for firing time-dependent events such as quartile beacons. If both are specified, the `type` value takes precedence. Custom tracking event types can be added and fired as well, but client code should attempt to use conventional event types such as “Impression” where appropriate, as certain operations like Nielsen DAR parameter substitution rely on the “Impression” event type.

Note: The `type` values are case-sensitive, so will only fire events with names that match exactly the type specified.

Client code should fire all supported tracking events specified by [Tracking](/docs/developer-program/advertising/integrating-roku-advertising-framework.md#tracking-events) during ad rendering when the appropriate conditions are met. Some events need not be fired such as `Error`, which is specific to VAST parsing only. Events corresponding to operations unsupported during ad rendering also need not be fired, such as `Rewind`, `Mute`, or `AcceptInvitation` (which is specific to ads with interactive elements).

As an example, if `ad` contains the [Ad structure](/docs/developer-program/advertising/integrating-roku-advertising-framework.md#ad-structure) for a video ad that the client application has just begun rendering, the `Impression` beacons for that ad could be fired with a single call:

    adIface.fireTrackingEvents(ad, {type: "Impression"})
    

While the ad playback progresses, assuming the variable `adProgressTime` holds a value representing the number of seconds since the ad began rendering, the quartile beacons can be sent via:

    adIface.fireTrackingEvents(ad, {time: adProgressTime})
    

If the ad were paused by the user, then the client app would fire the `Pause` beacons:

    adIface.fireTrackingEvents(ad, {type: "Pause"})
    

Requirements for server side ad insertion
-----------------------------------------

#### 1\. Frequency capping and targeting requirements

For apps that serve ads via SSAI, the outbound ad call to the ad server is not made from the client. The app will have to assume the onus of passing the RIDA and device user agent from the client to the server side component of the SSAI vendor or the ad server.

**Note:** Please work with your SSAI vendor on how to pass the RIDA to the SSAI server side component. In some cases, the app may need to pass the RIDA as part of an ad call, in other cases there may be a web service that the app needs to call.

#### 2\. Ad measurement beacon requirements

For server side ad inserted applications, call [fireTrackingEvents()](/docs/developer-program/advertising/raf-api.md#control) in RAF and ensure that the ad measurement beacons are passed to RAF via that API. It is valid to pass all impression beacons to RAF via this API. For non-Nielsen DAR beacons, RAF will be just a pass-through.

> Per [Roku's certification requirements](/docs/developer-program/advertising/ad-requirements.md#ads-3-ad-tracking-requirements), all ad measurement beacons must be fired directly by RAF client-side (they may not be wrapped). This is required to apply the [Roku Advertising Watermark](/docs/developer-program/advertising/ad-watermark.md) to the beacons.

**Note:** All these data points are sent directly to audience measurement platforms via RAF. RAF does not keep or save any of these data elements on the device or any cloud storage.

#### 3\. User agent requirements

Apps must use the Roku-generated device user agent in all server-side ad requests to pass certification. To include the user agent in server-side ad requests, do the following:

1.  Obtain the user agent from a client-side call made to the ad stitcher or ad server.
2.  Pass the user agent into the User-Agent header in the server-side ad request, without any modifications.

#### 4\. Uniform ad experience requirements

To enhance user engagement and consistency of ads served on the Roku platform, RAF supports rendering of both video and interactive ads (from certain vendors such as Brightline and Innovid) in server-stitched streams. This allows Roku to display standard UI components and behavior (ad counter, ad timer, trickplay support, etc.) for server-stitched streams.

**Note:** Any interactive ad types that are not enabled in RAF when server-stitched would need to be rendered by the application. See [Custom Ad Rendering](/docs/developer-program/advertising/integrating-roku-advertising-framework.md#custom-ad-parsing-and-rendering) above.

#### Implementation details

There are two API methods required for these use cases. First, the application is responsible for requesting and parsing the ad response, and structuring the ads into an array of pods, according to the required [Ad Structure](/docs/developer-program/advertising/integrating-roku-advertising-framework.md#ad-structure). This ad metadata may, in some cases, come from a third party SDK provided by your stitching platform.

*   **For server stitched ads, the 'time' member of the 'tracking' data (in [Ad Structure](/docs/developer-program/advertising/integrating-roku-advertising-framework.md#ad-structure)) for each ad is required**. The value of this data member should correspond to the absolute time in the entire stream, not just relative to the current ad.
    
    *   Example: For a 30-second ad that starts at 15:00 in the stitched stream, the 'Impression' beacons for that ad should be set to 900 seconds and the 'Midpoint' beacons for that ad should be 915 seconds (i.e., @15:15). The 'time' member should still be omitted for beacons that do not depend on time (such as 'Pause' or 'AcceptInvitation').
*   The meaning of postroll stitched ads is slightly different than for client-inserted ads, since the ads are part of the stream. **Client code can still set the 'renderSequence' for the pod to 'postroll', but all time values should still refer to the absolute position within the stitched stream.**

Scheduling and rendering is then initialized by first calling the [`stitchedAdsInit()`](/docs/developer-program/advertising/raf-api.md#server-stitched-ads) method with the ad structure constructed by the client:

    adIface.stitchedAdsInit(myAdPodArray)
    

Playback of the stitched stream is then started via an roVideoPlayer object (or optionally, a wrapped interface that matches the specification described in [`stitchedAdHandledEvent()`](/docs/developer-program/advertising/raf-api.md#server-stitched-ads)). In the event loop for the video player, the app should then first check if an ad renderer handled the event, as well as checking for exit condition. If no ad renderer handled the event, control falls through to the application’s regular event-handling logic:

**Server side ad insertion example**

    playContent = true
    while playContent
      msg = Wait(0, videoPlayer.GetMessagePort())
      currentAd = adIface.stitchedAdHandledEvent(msg, videoPlayer)
    
      if currentAd <> Invalid and currentAd.evtHandled
        ' ad handled event, take no further action
        if currentAd.adExited
          ' user exited, return to content selection
          playContent = false
        end if
      else
        ' if no current ad or ad did not handle event, fall through to default event handling here
        ' ... Your application's usual event-handling code here ...
      end if
    end while
    

*   If currentAd = invalid, then no current ad is being rendered, and the app can handle the event normally.
*   If currentAd <> invalid and currentAd.evtHandled = true, then the ad renderer handled the event, and no further action should be taken on that event.
*   If currentAd.adExited = true, then the user exited the ad renderer and the app should exit playback and return to content selection.
*   Only if no current ad is being rendered or currentAd.evtHandled = false should the app handle the event in any way. Keep in mind that ad rendering can create new roImageCanvas objects with their own navigation, or roVideoPlayer objects with their own internal state and position. These will in general have nothing at all to do with any such object created by the content playback app, yet they will share the same message port so that the application event loop can forward all events to the ad renderer first.

Alternatively, an roAssociativeArray can wrap and mimic the interface of the roVideoPlayer parameter of [stitchedAdHandledEvent()](/docs/developer-program/advertising/raf-api.md#server-stitched-ads). See method description for the minimum required key-value pairs. This wrapped interface is useful if there are other actions to be taken on player control methods (such as analytics fired when the stream is paused, etc.).

Testing your RAF implementation
-------------------------------

To test your RAF implementation, you do not need to pass any URL argument to `setAdUrl()`. Use `setAdUrl()` as you would for the revenue split agreement and either omit the URL argument or the `setAdUrl()` call entirely. This allows you to check that ads are served correctly to users of the app, but no revenue will actually be generated.

URL parameter macros
--------------------

The video ad library allows parameter values to be substituted in ad request and tracking URLs. This allows for dynamic configuration of values that are either not directly exposed to the client application or are unnecessary for it to initialize and maintain. These values are typically used for ad targeting, interaction tracking, and development purposes, or to optimize the ad experience for the user’s device.

| URL Parameter | Description |
| --- | --- |
| ROKU\_ADS\_TRACKING\_ID | RIDA (Roku ID for Advertising) value used for device identification |
| ROKU\_ADS\_LIMIT\_TRACKING | Set to true or false, depending on whether user has limited ad tracking |
| ROKU\_ADS\_APP\_ID | Identifies the client application making the ad request |
| ROKU\_ADS\_APP\_VERSION | Used to obtain the application version string |
| ROKU\_ADS\_LIB\_VERSION | Used to obtain the RAF library version string |
| ROKU\_ADS\_CONTENT\_ID | Identifies the content to allow for ad targeting |
| ROKU\_ADS\_CONTENT\_GENRE | Identifies the content categorization to allow for ad targeting |
| ROKU\_ADS\_CONTENT\_LENGTH | Improves ad targeting by providing length of content (in number of seconds) |
| ROKU\_ADS\_USER\_AGENT | Device model and Roku OS version |
| ROKU\_ADS\_DEVICE\_MODEL | Device model |
| ROKU\_ADS\_EXTERNAL\_IP | External IP address of the device |
| ROKU\_ADS\_DISPLAY\_WIDTH | Width of device display |
| ROKU\_ADS\_DISPLAY\_HEIGHT | Height of device display |
| ROKU\_ADS\_TIMESTAMP | Current timestamp value (number of milliseconds elapsed since 00:00:00 1/1/1970 GMT) |
| ROKU\_ADS\_CACHE\_BUSTER | Makes the URL unique to avoid retrieving cached ad server responses, or to ensure proper counting of unique event tracking beacons |
| ROKU\_ADS\_KIDS\_CONTENT | Mark ad requests as appearing in a content title, channel, or area of a channel that is made for kids, or where you have actual knowledge that the end user is a child. This macro is designed to help flag ad requests that may be subject to child privacy and child protection laws such as the Children's Online Privacy Protection Act (COPPA). For more information about these laws, see [Channels or Content Made for Kids](https://docs.roku.com/published/madeforkids). |
| ROKU\_ADS\_LOCALE | Returns current locale in the same format as [roDeviceInfo.getCurrentLocale()](/docs/references/brightscript/interfaces/ifdeviceinfo.md#getcurrentlocale-as-string) (e.g., "en\_US", "es\_ES") |

#### Example

To make an ad request that requires the application ID, user agent, and timestamp values, call [setAdUrl()](/docs/developer-program/advertising/raf-api.md#setadurlurl-as-string) with those parameters set:

**setAdUrl example**

    rokuAds = Roku_Ads()
    url = "http://my.ad.server.net/?my_first_param=MyFirstValue&my_app_id=ROKU_ADS_APP_ID&my_user_agent=ROKU_ADS_USER_AGENT&my_timestamp=ROKU_ADS_TIMESTAMP&other_param=SomeOtherValue"
    rokuAds.setAdUrl(url)
    

Ad structure
------------

For a client application that must implement its own ad rendering, it is necessary to understand how the ad structure is represented in the BrightScript object returned from [getAds()](/docs/developer-program/advertising/raf-api.md#client-ad-insertion). The following is a description of the ad structure. Ad pods passed to [showAds()](/docs/developer-program/advertising/raf-api.md#client-ad-insertion) must conform to this structure.

Note: Square brackets ‘\[ \]’ indicate BrightScript arrays, curly brackets '{ }' indicate associative arrays, and prefix ‘+’ indicates a required data member.

**Ad structure**

    adPods : [{
             +viewed         : Boolean,
             +renderSequence : String ("preroll" | "midroll" | "postroll"),
             +duration       : Float (in s),
              renderTime     : Float (in s),
              slots          : Int,
              backfilled     : Boolean,
             +tracking: [{
                +event: String,
                +url: String,
                +triggered: Boolean,
                 valid: Boolean
              }],
             +ads : [{
                     +duration     : Float (in s),
                     +streamFormat : String,
                     +adServer     : String,
                      adId         : String,
                      adTitle      : String,
                      advertiser   : String,
                      creativeId   : String,
                      creativeAdId : String,
                      clickThrough : String (URL),
                     +streams : [{
                                 +url      : String (URL),
                                 +bitrate  : Int (in kbps),
                                 +width    : Int,
                                 +height   : Int,
                                 +mimeType : String,
                                  provider : String,
                                  id       : String
                      }],
                     +tracking : [{
                                  +event     : String,
                                  +url       : String (URL),
                                  +triggered : Boolean,
                                   valid     : Boolean,
                                   time      : Float (in s)
                      }],
                      companionAds: [{
                                     +url          : String (URL),
                                     +width        : Int,
                                     +height       : Int,
                                     +mimeType     : String,
                                      clickThrough : String (URL),
                                      provider     : String,
                                     +tracking : [{
                                                  +event     : String,
                                                  +url       : String (URL),
                                                  +triggered : Boolean,
                                                   valid     : Boolean,
                                                   time      : Float (in s)
                                      }]
                      }]
              }]
    }]
    

The object returned from a new call to [getAds()](/docs/developer-program/advertising/raf-api.md#client-ad-insertion) with no parameters is an array of adPods in this format.

Tracking
--------

Tracking events are triggered automatically during ad rendering by [showAds()](/docs/developer-program/advertising/raf-api.md#client-ad-insertion). For client applications that perform their own ad rendering, the valid event types that must be handled are represented in the `tracking` array of the [Ad Structure](/docs/developer-program/advertising/integrating-roku-advertising-framework.md#ad-structure) by:

| Event name | Trigger condition |
| --- | --- |
| Impression | Start of ad render (e.g., first frame of a video ad displayed) |
| PodStart | Beginning of ad pod render |
| PodComplete | Completed rendering ad pod |
| FirstQuartile | 25% of video ad rendered |
| Midpoint | 50% of video ad rendered |
| ThirdQuartile | 75% of video ad rendered |
| Complete | 100% of video ad rendered |
| Error | Error during ad parsing or rendering (VAST 3.0) |
| Close | User exited out of ad rendering before completion |
| Skip | User skipped ad (if skippable) |
| Pause | User paused ad |
| Resume | User resumed ad |
| Rewind | User rewound ad |
| Mute | User muted ad |
| Unmute | User un-muted ad |
| AcceptInvitation | User launched another portion of an ad (for interactive ads) |

Roku genre tags
---------------

Tagging content by genre via [setContentGenre()](/docs/developer-program/advertising/raf-api.md#setcontentgenregenres-as-string-kidscontent-as-boolean) is specific to the ad provider, and may not be uniformly implemented. For ads provided by the Roku ad service, there is currently a canonical set of genre tags that can be used to improve ad targeting:

*   Action
*   Adventure
*   Animals
*   Animated
*   Anime
*   Ballet
*   Biography
*   Children
*   Comedy
*   Comedy drama
*   Crime
*   Crime drama
*   Cuisine
*   Dark comedy
*   Docudrama
*   Documentary
*   Drama
*   Educational
*   Entertainment
*   Faith
*   Fantasy
*   Fashion
*   Food
*   Gaming
*   Health
*   Historical drama
*   History
*   Horror
*   Martial arts
*   Miniseries
*   Music
*   Musical
*   Musical comedy
*   Mystery
*   Nature
*   News
*   Performing arts
*   Reality
*   Romance
*   Romantic comedy
*   Science
*   Science fiction
*   Sitcom
*   Special
*   Sports
*   Suspense
*   Talk
*   Technology
*   Theater
*   Thriller
*   Travel
*   War
*   Western

Nielsen DAR genre tags
----------------------

Tagging content by genre via [setNielsenGenre()](/docs/developer-program/advertising/raf-api.md#nielsen-dar) requires a single primary genre code for the selected content from the following set of values. Publishers should provide the most specific category applicable to the content for which ads are to be shown.

| Description | Code |
| --- | --- |
| Adventure | A   |
| Audience Participation | AP  |
| Award Ceremonies & Pageants | AC  |
| Children’s Programming | CP  |
| Comedy Variety | CV  |
| Concert Music | CM  |
| Conversation, Colloquies | CC  |
| Daytime Drama | DD  |
| Devotional | D   |
| Documentary, General | DO  |
| Documentary, News | DN  |
| Evening Animation | EA  |
| Feature Film | FF  |
| General Drama | GD  |
| General Variety | GV  |
| Instructions, Advice | IA  |
| Musical Drama | MD  |
| News | N   |
| Official Police | OP  |
| Paid Political | P   |
| Participation Variety | PV  |
| Popular Music -Contemporary | PC  |
| Popular Music -Standard | PS  |
| Private Detective | PD  |
| Quiz -Give Away | QG  |
| Quiz -Panel | QP  |
| Science Fiction | SF  |
| Situation Comedy | CS  |
| Sports Anthology | SA  |
| Sports Commentary | SC  |
| Sports News | SN  |
| Sports Event | SE  |
| Suspense/Mystery | SM  |
| Western Drama | EW  |

Tracking signup abandonment
===========================

You can track customers' progress through your app's signup workflow to identify where users may be abandoning the process. For example, customers may successfully enter their login credentials to create an account, but exit the flow when prompted to enter their payment information. By firing events on each page, the generated feedback can be used to minimize friction in the sign-up workflow and thus reduce abandonment.

> Subscription apps that have streamed more than an average of 5 million hours per month over the last three months (and new subscription apps expected to reach the threshold shortly after launch) must fire events on each page in their signup workflow to pass [certification](/docs/developer-program/certification/certification.md#2-purchases).
> 
> Event names must use unique, sequential page numbering and clearly identify the type of page from which the event is being fired. See [Signup pages](#signup-pages) for more information.

Requirements
------------

A signup event must be sent upon loading each page within the signup flow and submission of the final page to help track where users are abandoning the process. If the app's sign up flow is contained within a form that covers one or more pages, a signup event must be fired when each element in the form is completed.

The name of a given signup event will differ depending on whether your signup flow consists of separate pages or a form.

### Signup pages

If your app's signup flow is contained within a series of pages, fire a signup event upon the loading of each page. Pages requiring signup events include, but are not limited to, the following: initial sign-up landing page, account creation/registration, device activation, subscription selection, payment, and cancellation. In addition, a signup event must be fired upon the submission of the final page within the flow.

The names of the signup events must include two elements:

*   **Page Number**. A unique page number that identifies the page's sequence within the sign-up flow.
*   **Page Type**. A label that clearly describes the page's functionality.

#### Syntax

When firing the signup event, pass in "Sign\_Up|" along with pipe-separated key-value pairs for the page number and page type.

The syntax is therefore as follows:

"Sign\_Up"|pageNumber={_int_}|pageType={_type_}.

You can use a hierarchal page numbering system to identify different pages in the signup flow at the same level. This is useful in case your signup flow forks based on different options. For example, you may have separate monthly and annual offer pages that you could number 3.1 and 3.2. If you use hierarchal numbering, the pages must still be uniquely numbered across the sign-up flow. The syntax in this case is therefore as follows:

"Sign\_Up"|pageNumber={_int_}.{_int_}|pageType={_type_}.

#### Examples

The following examples demonstrate how to name signup events:

*   "Sign\_Up|pageNumber=1|pageType=landing"
*   "Sign\_Up|pageNumber=2|pageType=offer\_selection"
*   "Sign\_Up|pageNumber=3.1|pageType=sign\_up\_offer\_monthly"
*   "Sign\_Up|pageNumber=3.2|pageType=sign\_up\_offer\_annual"

#### Including form elements

Optionally, you can add form element data in the signup event to generate more granular feedback on your app's signup flow. To do this, append a key-value pair with the name of the field. For example, you could fire the following event when a user enters their email address on the sign-in page:

"Sign\_Up|pageNumber=2|pageType=registration|field=emailAddress"

### Signup form

If your app's signup flow is contained within a form that covers one or more pages, fire a signup event after each field in the form has been completed. When firing the signup event, include **Sign\_Up|** and the name of the element as a key-value pair.

#### Syntax

"Sign\_Up"|field={_string_}.

#### Examples

"Sign\_Up"|field=emailAddress

"Sign\_Up"|field=creditCardNumber

> The indexes and types you use to number and classify the pages and fields are arbitrary. However, pages in the signup flow should be uniquely and sequentially numbered and types should clearly identify the corresponding page or field.

Sending signup events
---------------------

Signup events can be sent using the Roku Event Dispatcher (RED) library or the **fireRokuMarketingPixel()** method in the Roku Advertising Framework (RAF) library. Using the RED library is the recommended approach; however, if you are already integrating RAF and want to avoid incorporating multiple libraries in the app, you can use the **fireRokuMarketingPixel()** method.

### Integrating the Roku Event Dispatcher in the signup workflow

To use the Roku Event Dispatcher in your app's signup workflow to send events, follow these steps:

1.  Enable the RED library in your app by adding the following line to the [manifest](/docs/developer-program/getting-started/architecture/channel-manifest.md) file:
    
        sg_component_libs_required=roku_analytics
        
    

2.  Use the [Roku Analytics Component](/docs/developer-program/libraries/roku-analytics-component.md) to send signup events from your app following these steps:
    
    a. When `roSGScreen` is active, create a "Roku\_Analytics:AnalyticsNode" node and persist it by storing in the global node.
    
    b. To add the RED library as a provider, include `RED: {}` when assigning to its `.init` field.
    
    c. To dispatch a signup event, assign `{RED: {eventName: "Sign_Up|pageNumber=int|pageType=type"}` or `{RED: {eventName: "Sign_Up_Form"|field=string"}` to the `.trackEvent` field.
    
    The following example demonstrates how to send signup events:
    
         sub Notify_Roku_UserIsLoggedIn(rsgScreen = invalid as Object)
             ' get the global node
             if type(m.top) = "roSGNode"  ' was called from a component script
                 globalNode = m.global
             else ' must pass roSGScreen when calling from main() thread
                 globalNode = rsgScreen.getGlobalNode()
             end if
        
             ' get the Roku Analytics Component Library used for RED
             RAC = globalNode.roku_event_dispatcher
             if RAC = invalid then
                 RAC = createObject("roSGNode", "Roku_Analytics:AnalyticsNode")
                 RAC.debug = true ' for verbose output to BrightScript console, optional
                 RAC.init = {RED: {}} ' activate RED as a provider
                 globalNode.addFields({roku_event_dispatcher: RAC})
             end if
        
             ' dispatch an event to Roku
             RAC.trackEvent = {RED: {eventName: "Sign_Up|pageNumber=1|pageType=landing"}}
             end sub
        
    
3.  Use the [debug console](/docs/developer-program/debugging/debugging-channels.md) to verify that your app is sending signup events.
    

### Integrating the RAF fireRokuMarketingPixel() method in the signup workflow

To use the RAF **fireRokuMarketingPixel()** method to send authentication events to Roku, follow these steps:

1.  Enable the RAF library in your app by adding the following line to the [manifest](/docs/developer-program/getting-started/architecture/channel-manifest.md) file:
    
        bs_libs_required=roku_ads_lib
        
    

2.  Instantiate the RAF library in the app:
    
        adIface = Roku_Ads()
        
    

3.  When an authenticated customer launches your app, call the **fireRokuMarketingPixel()** method using the following syntax:
    
        adIface.fireRokuMarketingPixel("Sign_Up|pageNumber=1|pageType=landing")

Implementing Server-Side Ad Insertion Using Roku Adapters
=========================================================

Overview
--------

The Roku Ad Framework (RAF) is responsible for a consistent ad experience across the Roku platform. For apps that implement ads using server-side ad insertion (SSAI), this can prove challenging due to the various steps involved. To simplify this process, developers can leverage the Roku-approved approaches via the adapter samples provided by Roku [below](/docs/developer-program/advertising/ssai-adapters.md#rafx-ssai-adapter-samples).

> Before using the adapters, please refer to [Requirements for Server Side Ad Insertion](/docs/developer-program/advertising/integrating-roku-advertising-framework.md#requirements-for-server-side-ad-insertion).

Roku Ad Framework requirements
------------------------------

All apps including video advertisements are required to meet [Roku's certification requirements for RAF](/docs/developer-program/certification/certification.md). Notably, the app must always use client-side firing (all SSAI providers support client-side firing) through RAF.

The Roku adapters provide two options:

*   Firing off all metrics through the adapter and RAF
*   The app is responsible to fire metrics through RAF with the adapter callbacks (See examples for using callback below)

It is encouraged that the developer uses the first option, but with either option, the metrics must be fired using RAF APIs.

The APIs used are different depending on the approach, but audience measurement is always required to be dispatched client side at Roku. We recommend apps [adopt the comScore VCE-inclusive audience measurement API](/docs/developer-program/advertising/raf-api.md#general-audience-measurement).

RAFX SSAI Adapters
------------------

In general, the RAFX SSAI Adapters provide interfaces to both SSAI manifest servers (stitchers) and RAF, including:

*   Parsing of the masterURL response, and extraction of playURL, AdURL, and ad metadata
*   Transforming SSAI ad metadata into RAF-usable ad metadata and configuring RAF for playback
*   Observing stream events and timed metadata
*   Matching the stream events and ad metadata and firing event pixels on time
*   Pinging/Polling AdURL as required by the SSAI manifest server, parsing, and reconfiguring RAF

Server-Side Ad Insertion playback
---------------------------------

To playback an SSAI stream, the developer would typically follow these steps:

1.  Initialize a playback Task
2.  Make a request to the masterURL
3.  Enable the client-side ad tracking and get the playURL, AdURL and/or ad metadata
4.  Configure playback content and observe stream events
5.  Start playing stream and fire event pixels on time as responding to observed events and ping/poll ad metadata

How to playback SSAI content using the adapters
-----------------------------------------------

These are the high level instructions on how to playback server-side ads content using the adapters:

> For detailed working instructions, refer to the adapter samples [below](/docs/developer-program/advertising/ssai-adapters.md#rafx-ssai-adapter-samples).

### 1\. Loading the adapter

The following entry loads the adapter into your task:

> At the beginning of the playback Task, instantiate the adapter with proper parameters and then initialize it. The valid values of the parameter name are uplynk, adobe, onceux, yospace, awsemt, and ggldai.

    adapter = RAFX_SSAI({name:"uplynk"})  ' Supported: uplynk, adobeonceux, yospace, awsemt, ggldai
    adapter.init()
    

### 2\. Make an initial request to SSAI manifest server getting Ad metadata: Request Ad Metadata

    request = {
    
        type: adapter.SreamType.VOD  ' Required, VOD or LIVE
    
        url:  "http://admanifest.ssai.com/api?assetid=abcdefg"' Ad metadata URL, provided by SSAI
    
    }
    
    result = adapter.requestStream(request)
    The value of the parameter URL depends on which SSAI manifest servers to integrate and which type of stream it is. (The app may query the initial request to SSAI manifest server by itself rather than using the adapter.requestStream() call). Valid values of the parameter type are VOD or LIVE. VOD is when Ad metadata is fetched before the playback starts, LIVE is when Ad metadata is provided as ping/poll/in-stream (such as X-MARKER) content playback.
    

### 3\. Read stream info

The initial request to SSAI manifest servers returns content URL (like Adobe and Verizon Media Services). The following entry gets the content URL:

    streamInfo = adapter.getStreamInfo()
    url = streamInfo["playURL"]
    

### 4\. Enable ads

Once the content playback URL is known, the adapter is ready to track Ads. Pass the adapter player object and observe the position event on the video node. The value of params.player is given to RAF internally as the second parameter of RAF.stitchedAdHandledEvent(). adapter.enableAds() parses Ad metadata and/or configure additional settings such as observing timedMetadata2 of given video node. It then calls RAF.stitchedAdsInit() when valid Ad metadata was found in the initial response from the SSAI manifest servers.

    port = CreateObject("roMessagePort")
    params = {player: {sgnode:m.top.video, port:port}}
    adapter.enableAds(params)
    m.top.video.observeField("position", port)
    

The app can provide an optional parameter, params.useStitched = false. If the parameter is set to false, the app is required to:

*   Set the callback functions to proper AdEvents
*   Fire pixels by using RAF.fireTrackingEvents()
*   Run and manage Interactive Ads

By default, params.useStitched is set to true. In this case:

*   Setting callback functions is optional
*   Pixels are fired internally by the adapter and RAF
*   Interactive Ads are running and managed by the adapter and RAF

#### **a) Optional: enable ads without stitchedAdHandledEvent**

        params = {  
            player: {sgnode:m.top.video, port:port},
            useStitched: false
        }
    
        adapter.enableAds(params) ' adapter will not call RAF.stitchedAdHandledEvent() and RAF will not play Interactive Ad
    

#### **b) Optional: set callbacks**

A callback parameter is an object with keys, event, and position.

When using PODS, the object has an additional key, adPods, and the value of the parameter is an array of the adPod metadata.

When using POD\_START, the object has an additional key, adPod, and the value of the parameter is the current adPod metadata.

Supported callbacks are:

*   PODS
*   POD\_START
*   POD\_END
*   IMPRESSION
*   FIRST\_QUARTILE
*   MIDPOINT
*   THIRD\_QUARTILE
*   COMPLETE

Note: When params.useStiched = true or, not provided in the param (this is the default), setting callbacks is optional and for informational purposes only. The app MUST NOT call RAF.fireTrackingEvents() in such a case.

When params.useStitched = false, it is required to set callbacks and the app MUST call RAF.fireTrackingEvents().

**Setting the callback functions to the Adapter:**

    ' Set adapter callback functions
    
    adapter.addEventListener(adapter.AdEvent.POD_START, rafxCallback)
    
    adapter.addEventListener(adapter.AdEvent.POD_END, rafxCallback)
    
    adapter.addEventListener(adapter.AdEvent.IMPRESSION, rafxCallback)
    
    ...
    
    ...
    
    function rafxCallback(eventInfo as object) as void
    
        if adapter.AdEvent.POD_START = eventInfo.event
    
            m.top.adPlaying = true
    
        else if adapter.AdEvent.POD_COMPLETE = eventInfo.event
    
            m.top.adPlaying = false
    
        end if
    
        print "Callback at : ";eventInfo.position
    
    end function
    

### 5) Enable ad measurements

When you are ready to start playback, you need to configure RAF by enabling ad measurements:

Note: It is recommended to use [enableAdMeasurements](/docs/developer-program/advertising/raf-api.md#general-audience-measurement).

    adIface = Roku_Ads()
    
    adIface.enableAdMeasurements(true) ' Required
    
    adIface.setContentGenre(...) ' Set app/content genre info
    
    adIface.setContentLength(...) ' Set app/content length info
    
    adIface.setContentId(...) ' Set app/content specific info
    

### 6) Playback Loop

The developer can now start the playback and run the message loop:

    video.control = "play"  ' start playback
    
    while true
    
        msg = wait(1000, port)
    
        curAd = adapter.onMessage(msg)
    
        if invalid = curAd
    
            video.setFocus(true)  ' recommended
    
        end if
    
        '  exit while loop when condition met
    
        ...
    
    end while
    

adapter.onMessage() calls RAF.stitchedAdHandledEvent() and returns the object as it is. It is thus recommended to evaluate the returned value and call setFocus() on the video node in case the interactive ad changes focus while playing.

When not using RAF.stitchedAdHandledEvent(), the app must fire AdEvent pixels in the callback functions.

Once the playback is completed, discard the adapter. Do not reference the adapter outside of the Task or re-use the same adapter instance.

Roku Ad Framework APIs
----------------------

For apps playing SSAI streams, it is required to call RAF APIs using the guidelines below.

It is required for apps to call the following every time the content is played back in the Task:

Enable ad measurement: **enableAdMeasurements**(true) Set content/app info: [setContentGenre()](/docs/developer-program/advertising/raf-api.md#setcontentgenregenres-as-string-kidscontent-as-boolean), [setContentId()](/docs/developer-program/advertising/raf-api.md#setcontentgenregenres-as-string-kidscontent-as-boolean), and [setContentLength()](/docs/developer-program/advertising/raf-api.md#setcontentlengthlength-as-integer).

When the useStitched:true, the adapter itself will:

Generate RAF ad metadata from SSAI specific format and call **stitchedAdsInit()**, **stitchedAdHandledEvent()** to fire ad events and measurement pixels

When the useStitched:false, the developer should make sure that the app:

Sets callback functions to the adapter Fires event pixels via: **fireTrackingEvents()** when called back

RAFX SSAI Adapter samples
-------------------------

The following RAFX SSAI Adapter samples are built to provide client-side integration with SSAI, for both VOD and LIVE.

Note that VOD mode means ad metadata is fed from the SSAI server before content playback.

LIVE mode means ad metadata is given as a part of the content stream such as ID3 (HLS) and emsg (DASH), and/or periodic ping/poll request to SSAI server.

Before using the adapter samples, the developer must be familiar with the SSAI providers’ documentation:

*   [Verizon Media Services](https://docs.vdms.com/video/index.html)
*   [Adobe](https://help.adobe.com/en_US/primetime/ad_insertion/msapi/index.html#msapi_topics-Manifest_Server_API_for_Ad_Insertion)
*   [OTTera](https://www.ottera.tv/)
*   [Brightcove](https://support.brightcove.com/brightcove-once-ux-implementation-guide)
*   [Yospace](http://developer.yospace.com/)
*   [Amazon](https://docs.aws.amazon.com/mediatailor/latest/ug/ad-reporting-client-side.html)
*   [Google Ad Manager](https://developers.google.com/interactive-media-ads/docs/sdks/roku)
*   [Amagi](https://www.amagi.com/products/thunderstorm-dynamic-ad-insertion)

**Note:** The SSAI providers may have undocumented formats, parameters and API behaviors.

### Verizon Media Services Adapter

| **Verizon Media Services** | **File** |
| --- | --- |
| RAFX SSAI Adapter for Verizon Media Services Preplay and Ping mode, showing ad rendering via stitchedAdsInit()/stitchedAdHandledEvent().  <br>  <br>The Verizon Media Services Adapter provides the following services:  <br>  <br>When Live-Ping  <br>\- Request preplay and parse ads object  <br>\- Ping and parse JSON, track with timestamps  <br>\- Track ID3 tags and match ad objects  <br>\- Configure RAF stitchedAdsInit() as ID3 tags  <br>\- Track all ad events through stitchedAdHandledEvent()  <br>\- Halt or append ads to current adPods as ID3 tags indicate  <br>  <br>When VOD-Preplay  <br>\- Request preplay and parse ads object  <br>\- Configure RAF stitchedAdsInit()  <br>\- Track all ad events through stitchedAdHandledEvent() | [rsgupl](https://github.com/rokudev/samples/tree/master/advertising/rsgupl)  <br>  <br>See UplynkTask.brs to find out how to use the adapter. Copy rafxssai.brs to your project and integrate it with the content playback Task. |

### Adobe Adapter

| Adobe Adapter | File |
| --- | --- |
| RAFX SSAI Adapter for Adobe Manifest Server simple and x-marker mode, showing ad rendering via stitchedAdsInit()/stitchedAdHandledEvent().  <br>  <br>Adobe Adapter provides the following services:  <br>  <br>When Live-x-markerObserve  <br>\- Observe ID3 tag: #EXT-X-MARKER  <br>\- Parse ad metadata and configure RAF stitchedAdsInit()  <br>\- Track ad events through stitchedAdHandledEvent()  <br>  <br>When VOD-simple  <br>\- Request master URL and select stream  <br>\- Request ad metadata with pttrackingposition=1, pttrackingmode=simple  <br>\- Supported pttrackingversion=vmap and v2 JSON  <br>\- Parse ad metadata and configure RAF stitchedAdsInit()  <br>\- Track ad events through stitchedAdHandledEvent() | [rsgadb](https://github.com/rokudev/samples/tree/master/advertising/rsgadb/)  <br>  <br>See AdobeTask.brs to find out how to use the adapter. Copy rafxssai.brs to your project and integrate it with the content playback Task. |

### OTTera AdNet+ Adapter

| OTTera AdNet+ Adapter | File |
| --- | --- |
| \- RAFX SSAI Adapter for OTTera AdNet+ x-marker, showing ad rendering via stitchedAdsInit()/stitchedAdHandledEvent().  <br>  <br>OTTera AdNet+ Adapter provides the following services:  <br>\- Observe ID3 tag: #EXT-X-MARKER  <br>\- Parse ad metadata and configure RAF stitchedAdsInit()  <br>\- Track ad events through stitchedAdHandledEvent() | [rsgottera](https://github.com/rokudev/samples/tree/master/advertising/rsgottera)  <br>  <br>See OTTeraTask.brs to find out how to use the adapter. Copy rafxssai.brs to your project and integrate it with the content playback Task. |

### Brightcove/OnceUX Adapter

| Brightcove/OnceUX Adapter | File |
| --- | --- |
| RAFX SSAI Adapter for OnceUX VOD mode, showing ad rendering via stitchedAdInit()/stitchedAdHandledEvent().  <br>  <br>OnceUX Adapter provides the following services:  <br>  <br>When VOD  <br>\- Request ad metadata and parse XML  <br>\- Configure RAF stitchedAdsInit()  <br>\- Track ad events through RAF stitchedAdHandledEvent()  <br>  <br>When reading stream info, "playURL" field is not available because OnceUX provides a pair of video contentURL and metadata URL.  <br>  <br>**Read Stream Info:**  <br>  <br>  <br>  <br>...  <br>streamInfo = adapter.getStreamInfo()  <br>' url = streamInfo\["playURL"\] This field is NOT available when OnceUX adapter.  <br>...  <br>  <br>  <br>However, the returned value of getStreamInfo() includes a field called **tracking**. This returns a list of event info generated from XML element: <uo:contentImpressions><uo:Impression>. The app is responsible for sending those pixels when playback starts.  <br>  <br>For example:  <br>  <br>**Sending Content Start Beacon:**  <br>  <br>...  <br>m.top.video.control = "PLAY" ' Start video content  <br>...  <br>...  <br>adIface = Roku\_Ads()  <br>for each evt in streamInfo.tracking  <br>if "Impression" = evt.event  <br>adIface.util.getNoResponseFromUrl(evt.url) ' send beacon to OnceUX  <br>end if  <br>end for | [rsgoux](https://github.com/rokudev/samples/tree/master/advertising/rsgoux/)  <br>  <br>See OnceUXTask.brs to find how to use the adapter. Copy rafxssai.brs to your project and integrate it with the content playback Task. |

### Yospace Adapter

| Yospace Adapter | File |
| --- | --- |
| RAFX SSAI Adapter for Yospace server, showing ad rendering via stitchedAdInit()/stitchedAdHandledEvent().  <br>  <br>Yospace Adapter provides the following services:  <br>  <br>\- When VOD  <br>\- Request masterURL, parse XML(DASH) or manifest(HLS), extract playbackURL and analyticsURL  <br>\-Request ad metadata, parse XML and configure RAF stitchedAdsInit()  <br>\-Track ad events through RAF stitchedAdHandledEvent()  <br>  <br>  <br>\- When LIVE  <br>\- Request masterURL, parse XML(DASH) or manifest(HLS), extract playbackURL and analyticsURL  <br>\- Observe timed metadata  <br>\- As playback stream, ping Yospace server and parse XML  <br>\- Match timed metadata YMID and ad metadata, configure RAF stitchedAdsInit() and stitchedAdHandledEvent() | [rsgyspc](https://github.com/rokudev/samples/tree/master/advertising/rsgyspc/)  <br>  <br>See YospaceTask.brs to find how to use the adapter. Copy rafxssai.brs to your project and integrate it with the content playback Task. |

### AWS Adapter

| AWS Elemental MediaTailor Adapter | File |
| --- | --- |
| RAFX SSAI Adapter for AWS Elemental MediaTailor(AWSEMT), showing ad rendering via stitchedAdInit()/stitchedAdHandledEvent() .  <br>  <br>AWSEMT Adapter provides following services:  <br>  <br>\- Request masterURL, parse JSON, extract hls\_url and tracking\_url. For apps with known hls\_url, use setStreamInfo() instead of requestStream() and getStreamInfo()  <br>  <br>**Using setStreamInfo()**  <br>  <br>  <br>  <br>if makingIntialRequest  <br>result = adapter.requestStream(...)  <br>streamInfo = adapter.getStreamInfo()  <br>else  <br>streamInfo = {  <br>type: m.top.testConfig.type, 'Required  <br>tracking\_url: m.top.tracking\_url, 'Required. App must provide valid URL  <br>hls\_url: m.top.hls\_url 'Required. App must provide valid URL  <br>}  <br>adapter.setStreamInfo(streamInfo)  <br>end if  <br>  <br>  <br>  <br>\- Poll ad metadata, parse JSON and configure RAF stitchedAdsInit()  <br>\- Track ad events through RAF stitchedAdHandledEvent() masterURL may require GET or POST. When POST request is required, fill request.body with {"adParams":{}}  <br>\- See AEMTTask.brs, function loadStream(). | [rsgemt](https://github.com/rokudev/samples/tree/master/advertising/rsgemt/)  <br>  <br>See AEMTTask.brs to find how to use the adapter. Copy rafxssai.brs to your project and integrate it with the content playback Task. |

### Google Dynamic Ad Insertion (DAI)

You can use the Google's Interactive Media Ads (IMA) SDK for Roku to integrate multimedia ads into your app. This DAI solution combines ad and content video on the Ad Manager servers, and then returns a single video stream to your app for playback.

See the [IMA DAI SDK for Roku](https://developers.google.com/interactive-media-ads/docs/sdks/roku) guide for instructions on integrating Google DAI.

Trick mode
==========

Trick mode provides visual feedback during playback operations such as seek, forward, and rewind. This function lets a user visualize the timestamp of the content they are seeking. The Roku platform supports two types of trick mode. For apps generating and publishing image archives in the Roku BIF (Base Index Frame), HLS, or DASH standard file formats, a scene-based trick mode using index frames is supported. When the thumbnails necessary to support scene-based trick mode are not available at playback time, a time-based method of supporting trick modes is used instead.

> Apps must display thumbnails during trick play for VOD content longer than 15 minutes to pass [certification](/docs/developer-program/certification/certification.md#4-channel-operation).

Time-based trick mode
---------------------

For time-based trick mode, users are presented with a progress bar that displays their location in the content and allows them to seek to the desired timestamp using the standard trick play controls. Since scene information is not available, a user only has a visual timeline and numeric time information to locate the desired position in the content. Once the new location is selected, the system buffers a minimal amount of stream data and begins playback.

Scene-based trick mode
----------------------

A scene-based trick mode is based on the availability of scene information in the form of BIF-files or standard thumbnail files for HLS or DASH. If such data are published and accessible for a given title, the scene-based trick mode is used during playback. The content metadata indicates the availability of scene information data on a per title basis, by providing URLs for the HD and SD versions of these assets.

Consult [BIF file creation using the Roku BIF tool](/docs/developer-program/media-playback/trick-mode/bif-file-creation.md), to learn how to generate BIF-format thumbnail for trick mode purposes.

> As of Roku OS 9.4, Roku recommends that ad-supported apps employing [Server-Side Ad Insertion (SSAI)](/docs/developer-program/advertising/ssai-adapters.md) use _only_ HLS or DASH "standard" thumbnails, as an incompatibility in the BIF-support mechanism can cause thumbnails and video to fall out of synch during SSAI operation. Developers should convert existing apps that use BIF and SSAI to use "standard" thumbnails instead, at the earliest opportunity.

Consult [HLS and DASH](/docs/developer-program/media-playback/trick-mode/hls-and-dash.md), to learn how to use standard thumbnail files – including those that follow the DASH-IF Interoperability Points Guidelines document Version 4.3 – with HLS and DASH playlists.

> If both BIF-based scene information and information based on standard-thumbnails are provided for the same content, Roku will use the BIF-based information. Only if no scene information is provided at all, will Roku employ time-based trick mode.

Roku OS developer release notes
===============================

> [Join the Roku beta program](https://rokutestingportal.centercode.com/key/rdbp) to implement new features in the latest Roku OS before the general release.

Roku OS 14.5 beta
-----------------

Roku OS 14.5, which is being shared with developer beta partners under non-disclosure agreements (NDAs), includes major updates to the forthcoming Roku Resource Monitor and BrightScript Profiler releases. Here is the list of key developer-facing Roku OS 14.5 updates:

#### Roku Resource Monitor 4.0

Roku Resource Monitor 4.0 (RRM 4.0) introduces several UI enhancements, including the ability to disable specific metric panels for your channel. This feature stops monitoring and hides the selected metric, allowing for a more streamlined and customized monitoring experience. Additionally, RRM 4.0 automatically saves your view configuration, ensuring your preferred layout is retained the next time you launch the tool.

RRM 4.0 also consolidates the BrightScript Objects panels into one graph and adds an option for displaying the memory used by different objects, breaks out the SceneGraph metrics into the different node types (similar to the BrightScript Objects panel), and lets you drill down into the source code associated with a rendezvous event.

#### BrightScript Profiler

The BrightScript Profiler features improved performance and stability. The tool uses less CPU and memory resources; therefore, it stays performant as you use it for longer sessions or switch tabs during a session.

#### Media playback and content metadata

The **drmParams** parameter now includes a **ignoreInitDataPssh** control attribute that ignores the PSSH in the initialization segment. This enables support for Harmonic/DTV-GO DASH-IOP v5.0.0 streams with In-Band Key-Rotation Signaling without breaking legacy streams/apps that do not provide the `<ContentProtection>` element with PSSH info in the DASH manifest.

#### Roku SceneGraph (RSG) 1.1 apps sunset

Support for apps using SceneGraph 1.1 (RSG 1.1) has ended on Roku OS 14.5. Apps claiming "rsg\_version=1.1" in the manifest file will execute as if rsg\_version=1.2 was specified and therefore may stop functioning properly on Roku OS 14.5. Developers must migrate their RSG 1.1 apps to RSG 1.2 to ensure they run on Roku OS 14.5.

In the Roku OS 9.0 release, the **eval()** function was deprecated and developers were instructed to use RSG 1.2 by setting the **rsg\_version** flag in their manifest file to “rsg\_version=1.2” in order to optimize load time performance and memory usage. In the Roku OS 9.3 release, the **eval()** function was sunset and it was noted that developers had to either remove all usage of the **eval()** function or update the **rsg\_version** flag to “rsgversion=1.1”. With the release of Roku OS 14.5, the "rsg\_version=1.1" manifest value is no longer an option and will be ignored.

Roku OS 14.0
------------

**Initial rollout date**: September 24, 2024

Roku OS 14.0 includes new SceneGraph features for displaying monospaced text in your apps. Developers can use the new [**MonospaceLabel** node](/docs/references/scenegraph/label-nodes/monospace-label.md) to draw a single line of text with all characters spaced at a fixed distance from each other. This functions as an alternative to using a monospace font with the **Label** node. In addition, the [**LabelBase** node](/docs/references/scenegraph/label-nodes/label-base.md) includes a new [**monospacedDigits** field](/docs/references/scenegraph/label-nodes/label-base.md#fields) that enables the rendering of tabular digits in overhang time values and countdowns.

In addition, Roku OS 14.0 includes features that enhance the performance of media playback and Roku devices in general and expand platform support for industry standards covering content metadata.

Here is the list of key developer-facing Roku OS 14.0 updates:

*   [**MonospaceLabel**](/docs/references/scenegraph/label-nodes/monospace-label.md) — The [**MonospaceLabel** node](/docs/references/scenegraph/label-nodes/monospace-label.md) is used to draw a single line of text with all characters spaced at a fixed distance from each other. It transforms proportional fonts into monospaced fonts. It is a substitute for using a monospace font with the **Label** node.
*   [**LabelBase.monospacedDigits**](/docs/references/scenegraph/label-nodes/label-base.md#fields) — The LabelBase.monospacedDigits field is used to render monospaced digits.

Roku OS 13.0
------------

**Initial rollout date**: April 10, 2024

Roku OS 13.0 includes a new [**contentClassifier** content metadata attribute](/docs/developer-program/getting-started/architecture/content-metadata.md#content-classification-attributes) that lets developers optimize the sound and picture on Roku TVs based on different content genres. This helps developers increase app engagement by giving customers a simple, convenient way to optimize their playback experience. Other media enhancements include new **Video** node attributes that provide developers with accessibility information about audio and subtitle tracks.

New BrightScript APIs help developers monitor and debug memory issues. The [**roAppMemoryMontor** node](/docs/references/brightscript/interfaces/ifappmemorymonitor.md#getchannelmemorylimit-as-object) includes a new function that returns the maximum amount of background and foreground memory an app may use, and the [**roAppManager** node](/docs/references/brightscript/interfaces/ifappmanager.md#getlastexitinfo-as-object) includes a function that lists the reason an app was terminated. In addition, this release includes new APIs that let developers check whether autoplay is enabled on a device and whether the system clock is valid.

For tools, ECP includes new [**exit-app**](/docs/developer-program/dev-tools/external-control-api.md#exit-app-example) and [**query-channel-state**](/docs/developer-program/dev-tools/external-control-api.md#querychannel-state-example) commands that help developers automate the testing of apps that support Instant Resume and a new [**query/app-object-counts** command](/docs/developer-program/dev-tools/external-control-api.md#queryapp-object-counts-example) that helps developers associate memory and CPU usage with changes in BrightScript node object counts in their apps.

Here is the list of key developer-facing Roku OS 13.0 updates:

#### BrightScript APIs

*   [**Maximum available memory query**](/docs/references/brightscript/interfaces/ifappmemorymonitor.md#getchannelmemorylimit-as-object) — The **roAppMemoryMonitor** component includes a new [**GetChannelMemoryLimit** () function](/docs/references/brightscript/interfaces/ifappmemorymonitor.md#getchannelmemorylimit-as-object) that returns how much foreground and background memory the app may use and the maximum amount of memory that the RokuOS may allocate on behalf of the app (the memory that shows up in the app's heap memory statistics ). This helps developers debug memory issues and find out the maximum available memory for scenarios such as when their app has been suspended and is in the background, is playing a video, and so on.

*   [**App exit query**](/docs/references/brightscript/interfaces/ifappmanager.md#getlastexitinfo-as-object) — The **roAppManager** component includes a new [**GetLastExitInfo**() function](/docs/references/brightscript/interfaces/ifappmanager.md#getlastexitinfo-as-object) that returns an exit code indicating why an app was terminated. This helps developers monitor and debug memory issues with their apps. The last exit information is provided for only the 10 most recent exits across all apps, and exit information does not persist across device reboots.

*   [**Autoplay-enabled query**](/docs/references/brightscript/interfaces/ifdeviceinfo.md#isautoplayenabled-as-boolean) — The **roDeviceInfo** component includes a new [**IsAutoplayEnabled**() function](/docs/references/brightscript/interfaces/ifdeviceinfo.md#isautoplayenabled-as-boolean) that lets developers check whether autoplay is enabled on a device. This lets developers ensure that their apps respect this device setting when customers browse content in their app.

*   [**Hands-free voice remote check**](/docs/references/brightscript/interfaces/ifremoteinfo.md#hasfeaturefeature-as-string-remoteindex-as-integer-as-boolean) — The [**roRemoteInfo.hasFeature()** function](/docs/references/brightscript/interfaces/ifremoteinfo.md#hasfeaturefeature-as-string-remoteindex-as-integer-as-boolean) now takes a "hasMuteSwitch" parameter, which enables developers to check whether a Roku remote control includes a hands-free voice switch.

#### Media, DRM, and content metadata updates

*   [**Optimized sound and picture for Roku TVs based on content genre**](/docs/developer-program/getting-started/architecture/content-metadata.md#content-classification-attributes) — Developers can use the new [**contentClassifier** content metadata attribute](/docs/developer-program/getting-started/architecture/content-metadata.md#content-classification-attributes) to specify the genre of their content (for example, action, sports, or comedy), and the Roku OS will use this attribute to automatically adjust the sound and picture on Roku TVs (if auto mode is selected for the picture or sound settings).

*   [**Accessibility information for audio and subtitle tracks**](/docs/references/scenegraph/media-playback-nodes/video.md#closed-caption-fields) — The **Video** node's [**availableAudioTracks**](/docs/references/scenegraph/media-playback-nodes/video.md#closed-caption-fields) and [**availableSubtitleTracks**](/docs/references/scenegraph/media-playback-nodes/video.md#audio-fields) fields include new key-value pairs that provide accessibility information for audio and subtitle tracks. This helps developers identify whether a given track is an audio description.

*   [**Seamless audio track selection**](/docs/references/scenegraph/media-playback-nodes/video.md#audio-fields) — The **Video** node includes a new [**seamlessAudioTrackSelection** field](/docs/references/scenegraph/media-playback-nodes/video.md#audio-fields) that enables apps to continuously play video content when the audio track is switched (provided that the audio format remains the same). This gives developers the choice when the audio track is changed to either pause the video for approximately 1 second (current default behavior) or continue video playback. This feature currently supports HLS only.

#### Tools

**New ECP commands**

Developers can leverage the following ECP new commands in their tools and web services:

*   [**Suspend/terminate app command and app state query**](/docs/developer-program/dev-tools/external-control-api.md#general-ecp-commands) — A new [**exit-app** command](/docs/developer-program/dev-tools/external-control-api.md#exit-app-example) enables developers to suspend or terminate their running app, and a new [**query-channel-state** command](/docs/developer-program/dev-tools/external-control-api.md#querychannel-state-example) lets developers check whether their app is active, suspended (background), or inactive. These two commands help developers automate the testing of apps that support [Instant Resume](/docs/developer-program/media-playback/instant-resume.md).

*   [**BrightScript object counts query**](/docs/developer-program/dev-tools/external-control-api.md#general-ecp-commands) — ECP includes a new [**query/app-object-counts** command](/docs/developer-program/dev-tools/external-control-api.md#queryapp-object-counts-example) that helps developers determine counts of each type of object held by their BrightScript app.

#### Deprecated APIs

*   The [**roAppInfo.getSubtitle()** function has been deprecated](/docs/references/deprecated-apis.md#roappinfogetsubtitle).

Roku OS 12.5
------------

**Initial rollout date**: September 12, 2023

Roku OS 12.5 includes new APIs for monitoring the current amount of available memory for an app and getting the device user agent. This release also includes features that generally enhance the performance of media playback such as prebuffering for live content, improved closed captioning through ad breaks, and pre-playback audio and subtitle track selection.

Here is the list of key developer-facing Roku OS 12.5 updates:

#### BrightScript APIs

*   [**Available memory query**](/docs/references/brightscript/interfaces/ifurltransfer.md#getuseragent-as-string) — The [**roAppMemoryMonitor** node](/docs/references/brightscript/components/roappmemorymonitor.md) includes a new **GetChannelAvailableMemory()** function that provides developers with the estimated kilobytes (Kb) of memory available for their app. This helps developers identify when to release memory when their app receives low-memory warnings.

*   [**Device user agent**](/docs/references/brightscript/interfaces/ifurltransfer.md#getuseragent-as-string) — The [**roUrlTransfer** node](/docs/references/brightscript/components/rourltransfer.md) includes a new **GetUserAgent()** function that returns the device user agent. This provides developers with a direct method for getting the user agent in order to pass it into server-side ad requests.

#### Media, DRM, and content metadata updates

*   **Prebuffering for live content** — Roku's media player now includes support for prebuffering live content. For video-on-demand (VOD) content, the media player now requires less data to be prebuffered.

*   **Improved support for maintaining closed captioning through ad breaks** — If the start-time of a video ad occurs between the buffering and closed captioning start times, Roku's media player now maintains the closed captioning information. This helps recover any close caption sentences that may be missed after an ad break finishes. This is particularly useful for CEA 608/708 caption formatting because caption data is received from video content before ad breaks.

*   **Representation filtering based on HDCP level** — When a 4K-capable Roku device is connected to an HD display, the Roku media player now filters out 4K representations to prevent DRM-based decryption failures.

*   [**Pre-playback audio and closed captioning track selection**](/docs/references/scenegraph/media-playback-nodes/video.md#playback-fields) — The [**Video** node](/docs/references/scenegraph/media-playback-nodes/video.md) includes new fields for specifying the priority order of different audio track and subtitle track selections.

#### Deprecated APIs

*   [**run\_as\_process** manifest attribute](/docs/references/deprecated-apis.md#run_as_process-channel-manifest-attribute) has been deprecated — All apps now run in a separate process, regardless if the **run\_as\_process** attribute has been specified in the manifest.

*   [Support for the Windows Media Audio (wma) file format on the Roku platform has been sunset](/docs/references/deprecated-apis.md#audio-node-windows-media-audio). The WMA audio format was originally deprecated in the Roku OS 10.5 release.

Roku OS 12.0
------------

**Initial rollout date**: March 8, 2023

Roku OS 12.0 includes a new BrightScript API for getting localized times and Instant Resume support for apps that do not have exit confirmation dialogs. For tools, this release features new External Control Protocol (ECP) query commands, and it enables developers using the BrightScript Debug Protocol to add breakpoints while the script is running.

Here is the list of key developer-facing Roku OS 12.0 updates:

#### BrightScript APIs

*   [**Localized date and time formats**](/docs/references/brightscript/interfaces/ifdatetime.md#asdatestringlocformat-as-string-as-string) — The [roDateTime](https://developer.roku.com/docs/references/brightscript/components/rodatetime.md) component includes new **asDateStringLoc()** and **asTimeStringLoc()** methods that developers can use to get the localized date and time of a device. These new methods also enable developers to construct their own custom date and time formats.
    
*   [**IPv6 addresses returned by roDeviceInfo.getConnectionInfo() method**](/docs/references/brightscript/interfaces/ifdeviceinfo.md#getconnectioninfo-as-object) — The [roDeviceInfo.getConnectionInfo() method](/docs/references/brightscript/interfaces/ifdeviceinfo.md#getconnectioninfo-as-object) now returns an **ipv6** field, which is an array listing the IPv6 addresses used for the device connection.
    

#### Integrations

*   [**Extended Instant Resume support for apps without exit confirmation dialogs**](/docs/developer-program/media-playback/instant-resume.md) — For apps implementing [Instant Resume](/docs/developer-program/media-playback/instant-resume.md), an interruption event is now generated when the customer exits the app by pressing the back button. For apps that do not have an exit confirmation dialog, developers can now call the **customSuspend** handler when this occurs to save the current app state.

#### Tools

*   [**New ECP commands**](/docs/developer-program/dev-tools/external-control-api.md) — [ECP](/docs/developer-program/dev-tools/external-control-api.md) includes a new **query/graphic-frame-rate** command that gets the graphics rendering frame rate, and app and media events can now be now tracked via a set of new **query/fwbeacons** commands (fwbeacons/track, fwbeacons/untrack and query/fwbeacons).
    
    In addition, calling the **query/registry** ECP command now returns a new **space-available** field that provides developers with the amount of storage currently available in the device's registry, and the **query/sgnodes** command now returns a tree structure representing the app's UI, rather than a flat list of nodes.
    
    Developers can leverage these commands in their tools and web services.
    

*   [**BrightScript debug protocol (version 3.2)**](/docs/developer-program/debugging/socket-based-debugger.md) — The [BrightScript debug protocol](/docs/developer-program/debugging/socket-based-debugger.md) now supports **ADD\_CONDITIONAL\_BREAKPOINTS** requests while the script is running. When this occurs, the breakpoints are registered, queued, and then applied as soon as processing allows. This eliminates the need to wait for the script to be paused in order to apply breakpoints. Instead, the breakpoints can now be applied based on the current device state. Developers should now use the **ADD\_CONDITIONAL\_BREAKPOINTS** command instead of **ADD\_BREAKPOINTS** because ADD\_CONDITIONAL\_BREAKPOINTS is a strict superset of ADD\_BREAKPOINTS.

Roku OS 11.5
------------

**Initial rollout date**: September 12, 2022

Roku OS 11.5 includes new SceneGraph [Video](/docs/references/scenegraph/media-playback-nodes/video.md) and [Content](/docs/developer-program/getting-started/architecture/content-metadata.md) node fields that enhance the trickplay and pause screen experiences during video playback. This release also adds [device attestation tokens](/docs/references/scenegraph/control-nodes/channelstore.md#getdeviceattestationtoken) that developers can incorporate in their web services to verify that messages originated from authentic Roku devices.

In addition, Roku OS 11.5 includes features that enhance the performance of media playback and Roku devices in general and expand platform support for industry standards covering content metadata.

For tools, this release features the [Roku Resource Monitor](/docs/developer-program/dev-tools/resource-monitor.md): a new developer tool that tracks and visualizes the system memory, graphics memory, CPU, and SceneGraph nodes used by an app. Developers can use this tool to test the different screens in their app and identify consumption trends and patterns. In addition, this release includes new [External Control Protocol (ECP) query commands](/docs/developer-program/dev-tools/external-control-api.md#general-ecp-commands) that return rendezvous events and the entries in the device registry. Developers can incorporate these new queries in their test labs for debugging and performance monitoring. The [BrightScript Debug Protocol](/docs/developer-program/debugging/socket-based-debugger.md) now includes events for conditional breakpoints, compile errors in the main application and in component libraries, and improved breakpoint support for component libraries.

It is important to note that Roku OS 11.5 sunsets the [SDK1 visual screen components that were originally deprecated in 2017](https://blog.roku.com/developer/legacy-sdk); these components have been completely removed from the Roku OS. In addition, the **roUrlTransfer.enableFreshConnection()** function has been deprecated—apps should always reuse connections.

Here is the list of key developer-facing Roku OS 11.5 updates:

#### SceneGraph APIs

*   **Playback UX** — Roku's SceneGraph [Video](/docs/references/scenegraph/media-playback-nodes/video.md) and [Content](/docs/developer-program/getting-started/architecture/content-metadata.md) nodes include new fields that enable developers to integrate playback features for the trickplay and pause screen experiences such as audio and subtitle selection, playlist features such as skip, next, and queues, and autoplay recommendation features such "More like this"/"Because you watched". Customers have become accustomed to this playback experience on The Roku Channel, and it is now available to apps across the platform.
    
*   **[Content.secondaryTitle](/docs/developer-program/getting-started/architecture/content-metadata.md#descriptive-attributes)**. Adds a secondary title for the video content. This field can be used to display the release year of movies, for example.
    
*   [**Video.playbackActionButtons**](/docs/references/scenegraph/media-playback-nodes/video.md#playback-fields). Shows the buttons and other specified UI elements on the pause screen at the start of playback. This field includes properties for the button text, icon, and status (enabled/disabled). Related fields identify which pause screen button is selected and has key focus, and sets the button color, text color, and background color based on whether the button has key focus.
    
*   [**Video.pivotNode**](/docs/references/scenegraph/media-playback-nodes/video.md#ui-fields). Adds a generic renderable node that can be used to display any SceneGraph component.
    
*   [**Video.trickPlayBackgroundOverlay**](/docs/references/scenegraph/media-playback-nodes/video.md#trickplay-fields). Specifies the background overlay to be displayed whenever the playback UI is visible during the video playback experience.
    

*   [**Option to disable focus animations in ArrayGrid nodes**](/docs/references/scenegraph/abstract-nodes/arraygrid.md) — Developers can use the new **ArrayGrid.skipFocusAnimations** field to completely disable animations on ArrayGrid child nodes such as the **MarkupGrid** and **MarkupList** components. For apps implementing custom focus logic, this field can be used to eliminate the reported ~300ms period in which no component has focus after a keypress.

*   [**Device attestation token**](/docs/references/scenegraph/control-nodes/channelstore.md#getdeviceattestationtoken) — Developers can use the new [**ChannelStore** **getDeviceAttestationToken** command](/docs/references/scenegraph/control-nodes/channelstore.md#getdeviceattestationtoken) to generate a signed JSON web token (JWT) in the Roku cloud and return it to the application. This token can then be passed to the publisher's web services to verify that messages originated from genuine Roku devices. A [**getDeviceAttestation()** function](/docs/references/brightscript/interfaces/ifchannelstore.md#getdeviceattestationtokennonce-as-string-as-object) has also been added to **roChannelStore** component. This token is meant to replace the functionality previously provided by the device client certificates.

#### BrightScript APIs

*   [**Continue statements**](/docs/references/brightscript/language/program-statements.md#continue-for--continue-while) — Developers can now insert `continue` statements in `for` and `while` loops. This terminates the execution of the statements in the current iteration of the loop, and then continues execution of the loop with the next iteration.

#### Tools

*   [**Roku Resource Monitor**](/docs/developer-program/dev-tools/resource-monitor.md) — The Roku Resource Monitor tracks and visualizes the system memory, graphics memory, CPU, and SceneGraph nodes used by an app. This enables developers to test the different screens in their app and identify consumption trends and patterns. This new developer tool is intended to be used in conjunction with the BrightScript Profiler to improve app performance. For example, if the Roku Resource Monitor consistently shows increased consumption with a specific action on a screen, developers can use the BrightScript Profiler to further drill down into the application and pinpoint where to optimize the code.

*   [**New ECP query commands for performance monitoring and debugging apps**](/docs/developer-program/dev-tools/external-control-api.md#general-ecp-commands) — Developers can use the following new ECP query commands to monitor the performance of their apps and debug the apps: **query/sgrendezvous** and **query/registry**. These queries return rendezvous events and the entries in the device registry, respectively. Developers can leverage these commands, which were previously only available via the debug console, in their tools and web services.

*   [**Enhanced ECP query commands**](/docs/developer-program/dev-tools/external-control-api.md#general-ecp-commands) — The following ECP commands have been improved for the Roku OS 11.5 release:
    
    *   **query/r2d2-bitmaps**. This command now returns the file name for any asset in texture memory that cannot be attributed directly to a plug-in. In Roku OS 11.0, assets that could not be associated with a plug-in were omitted from the response.
        
    *   **query/sgnodes**. This command can now be called with a specific **channel-id**, which enables it to be used on background apps. The response now includes a **node-count** field.
        

*   [**BrightScript debug protocol updates**](/docs/developer-program/debugging/socket-based-debugger.md) — The BrightScript debug protocol (version 3.1) now includes events for compile errors in the main application and in component libraries, conditional breakpoints, and improved breakpoint support for component libraries.

*   [**Improved app compression from** **Development Application Installer**](/docs/developer-program/publishing/packaging-channels.md#packaging-with-the-development-application-installer) — The default compression algorithm in the Development Application installer has been changed to **squashfs (zstd)** from **gzip** for sideloaded apps. In addition, the conversion option **squashfs (gzip)** has been changed to **gzip**. This generally reduces the package file size.

#### Architecture

*   **Fonts** — The system fonts have been updated to provide better support for monospaced numerals. As a result, the width of characters may have changed slightly. Developers should make sure to leave space for text to expand or collapse some percentage in their app UI. Developers should not rely on exact font metrics to avoid Label nodes from being truncated or multi-line labels having varied line wrapping.

#### Deprecated/Sunset APIs

*   [**SDK1 visual screen components sunset**](/docs/references/deprecated-apis.md#deprecated-components-january-1-2018) — The [SDK1 visual screen components that were deprecated in 2017](https://blog.roku.com/developer/legacy-sdk) have been completely removed from the Roku OS. As a result, apps that still had these [sunset components](https://developer.roku.com/docs/references/deprecated-apis.md#deprecated-components-january-1-2018) as of August 22nd were disabled and removed from the Streaming Store. These apps can no longer be installed or launched unless they were migrated to SDK2 (SceneGraph).
    
*   **[roUrlTransfer.enableFreshConnection()](/docs/references/deprecated-apis.md#rourltransferenablefreshconnection)** — The Roku OS no longer supports the [**roUrlTransfer.enableFreshConnection()** function](/docs/references/brightscript/interfaces/ifurltransfer.md#enablefreshconnectionenable-as-boolean-as-boolean). Apps should always reuse connections because it is more efficient (new connections impact app performance by increasing latency and consuming more CPU).
    

Roku OS 11.0
------------

**Initial rollout date**: March 22, 2022

Roku OS 11.0 features new SceneGraph standard dialog framework components for adding multi-style text, images/notes, and button and checkbox icons to custom dialogs; BrightScript optional chaining operators for efficiently accessing possible undefined values; and ChannelStore APIs for displaying a customer's information in the Request for Information (RFI) sign-up screen. Developers of authenticated free and advertising-based video on demand (AVOD) apps can now display the RFI screen without having to first enroll in the Roku Partner Payouts Program.

In addition, Roku OS 11.0 improves trick play for live linear streams, and it includes features that enhance the performance of media playback and Roku devices in general and expand platform support for industry standards covering content metadata.

For tools, this release adds new External Control Protocol (ECP) query commands for debugging apps that developers can incorporate in their web services and then leverage in their test suite, and minor updates to the BrightScript debug protocol.

Below is a list of key developer-facing Roku OS 11.0 updates:

#### SceneGraph APIs

*   **New standard dialog framework nodes** — Roku's Standard Dialog Framework includes the following new nodes that enable developers to decorate or annotate custom dialogs and highlight the grouping of radio button and checkbox options in them:
    
    *   **[StdDlgMultiStyleTextItem](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-multi-style-text-item.md)**. A line of text with multiple styles in the content area of a custom dialog. The text may include, for example, plain and bold characters, different fonts, multiple colors, and/or emojis.
        
    *   [**StdDlgSideCardArea**](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-side-card-area.md). A freeform area on the right or left side of a custom dialog that developers can use to display images or notes.
        
    *   **[StdDlgActionCardItem](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-action-card-item.md)**. Highlighting for the child items in the content area of a custom dialog. This node enables developers to add a "more info" arrow icon, radio button icon, or check box icon to the items in the content area.
        
    *   [**StdDlgItemGroup**](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-item-group.md). Visual grouping for a set of StdDlgAreaBase child nodes in a custom dialog. Developers can use this node to reduce the vertical spacing between the StdDlgItemBase child nodes in the dialog.
        
*   **[Option for Label and TextEditBox nodes to display the end of overflowing text](/docs/references/scenegraph/label-nodes/label.md#fields)** — The [**Label**](/docs/references/scenegraph/label-nodes/label.md#fields) and [**TextEditBox**](docs/references/scenegraph/widget-nodes/texteditbox.md) nodes now include a **leadingEllipsis** flag that enables developers to specify whether to show the end or beginning of text that overflows its available width. When this flag is set to true, the end of the text is shown. For example, "the quick brown fox jumps over the lazy dog" would be truncated to "...jumps over the lazy dog". When the flag is false, the start of the text is shown ("the quick brown fox jumps...").
    

*   [**Voice keyboard enhancements**](/docs/references/scenegraph/dynamic-voice-keyboard-nodes/dynamic-keyboard-base.md#fields) — The SceneGraph [**DynamicKeyboardBase**](/docs/references/scenegraph/dynamic-voice-keyboard-nodes/dynamic-keyboard-base.md#fields)) node class now includes a **hideTextBox** flag that enables developers to hide a voice keyboard's VoiceTextEditBox.

#### BrightScript APIs

*   [**BrightScript optional chaining operators**](/docs/references/brightscript/language/expressions-variables-types.md#optional-chaining-operators) — Developers can use optional chaining operators, "?.", "?@", "?\[", and "?(", in their BrightScript code to access possibly invalid values. This enables developers to execute more concise, higher-performing code. The optional chaining operators are used to read the value of a property nested within a chain of connected objects without having to first check whether each reference in the chain does not return the BrightScript value of "invalid". If testing a reference results in "invalid", the expression short-circuits and returns "invalid".

*   [**Tagging of unused variables**](/docs/references/brightscript/language/expressions-variables-types.md#types) — Developers can now explicitly mark variables as unused in their BrightScript code by prepending an underscore to the value (for example, sub myTask(_\_x_)). This enables developers to avoid compilation errors when the unused variable has a valid purpose.

#### Roku Pay APIs

*   [**RFI sign-up screen option to display requested customer information**](/docs/references/scenegraph/control-nodes/channelstore.md#requesteduserdatainfo) — The [**ChannelStore.requestedUserDataInfo**](/docs/references/scenegraph/control-nodes/channelstore.md#requesteduserdatainfo) associative array now includes an optional **forceShowData** flag. When this flag is enabled, the RFI sign-up screen displays the actual customer information values to be shared with the app instead of just the types of information. For example, if the email address, first name, and last name are requested for sign-ups and the **forceShowData** flag is enabled, the "Let's create your account" RFI screen explicitly lists the customer's actual email address and name in bold text (for example, **Bob** **Smith**, **bsmith@roku.com**). If this flag is disabled and the customer is in the United States, the RFI screen displays "share your name and email address".

*   **Direct access to RFI screen for authenticated free and AVOD apps** — Developers of authenticated free and AVOD apps can now use the ChannelStore [**getUserData**](/docs/references/scenegraph/control-nodes/channelstore.md#getuserdata) and [**getPartialUserData**](/docs/references/brightscript/interfaces/ifchannelstore.md#getpartialuserdataproperties-as-string-requestinfo-as-object-as-object) APIs to display an RFI screen when customers sign up or sign in to the app—without having to first enroll in the [Roku Partner Payouts Program](/docs/developer-program/roku-pay/quickstart/partner-payouts.md). In this case, the RFI sign-up screen can request or display the customer's email address, phone number, and zip code; the RFI sign-in screen can request or display the customer's email address and phone number.

#### Media, DRM, and content metadata updates

*   **Improved trick play for live linear streams** — The [**Video**](/docs/references/scenegraph/media-playback-nodes/video.md) node includes the following new fields to help developers improve the user experience for trick play during live linear streams:
    
    *   A [**trickplay.liveFilledBarBlendColor**](/docs/references/scenegraph/media-playback-nodes/video.md#playback-fields) field that lets developers specify the color for the trick play progress bar during live linear streams. This color is blended with the **filledBarImageUri**.
        
    *   An [**enableLiveAvailabilityWindow**](/docs/references/scenegraph/media-playback-nodes/video.md#trickplay-fields) field that lets developers enable scrubbing of the trick play bar during the availability window of live linear streams.
        
    *   An [**enableThumbnailTilesDuringLive**](/docs/references/scenegraph/media-playback-nodes/video.md#trickplay-fields) flag that lets developers specify whether the **Video** node should report the thumbnail tiles in the **thumbnailTiles** field for live linear streams (the **thumbnailTiles** field will be added to the Video node documentation as part of the Roku OS 11.0 release).
        

*   [**Video decoder statistics**](/docs/references/scenegraph/media-playback-nodes/video.md#playback-fields) — The [**Video**](/docs/references/scenegraph/media-playback-nodes/video.md) node includes a new **decoderStats** field that provides developers with additional video playback information such as the number of frames rendered, repeated, and dropped, and the number of bit stream errors since playback started. Also included is a new **enableDecoderStats** field that allows the **decoderStats** field to receive updates.

*   [**Muting of audio during video playback**](/docs/references/brightscript/interfaces/ifvideoplayer.md#setenableaudioenable-as-boolean-as-void) — The [**roVideoPlayer**](/docs/references/brightscript/interfaces/ifvideoplayer.md#setenableaudioenable-as-boolean-as-void) component now includes a **SetEnableAudio()** function that enables developers to mute the audio during video playback. This is useful, for example, for implementing a video preview feature in an app.

*   [**Check whether the TV screen is on/off**](/docs/references/brightscript/interfaces/ifdeviceinfo.md#getdisplayproperties-as-object) — The [**ifDeviceInfo.GetDisplayProperties()**](/docs/references/brightscript/interfaces/ifdeviceinfo.md#getdisplayproperties-as-object) function now returns a new **visible** field that enables developers to check whether the TV screen is on/off. Customers can turn off their TV display while streaming an app in order to continue listening to the audio (for example, when playing music videos, conferences, or podcasts).

*   **ttp:timebase support added for DASH/TTML** — The Roku OS now supports ttp:timebase for activating subtitles.

#### Tools

*   [**ECP query commands for debugging channels**](/docs/developer-program/dev-tools/external-control-api.md#general-ecp-commands) — Developers can use the following new ECP query commands to help debug their apps: [**query/chanperf**](/docs/developer-program/dev-tools/external-control-api.md#querychanperf-example), [**query/r2d2-bitmaps**](/docs/developer-program/dev-tools/external-control-api.md#queryr2d2-bitmaps-example), **and [query/sgnodes/\[all | root | nodes?node-id=\*nodeId\*\]](/docs/developer-program/dev-tools/external-control-api.md#querysgnodesall-example)**. Developers can leverage these debugging commands, which were previously only available via the debug console, in their web services.

*   [**BrightScript debug protocol updates**](/docs/developer-program/debugging/socket-based-debugger.md#debugging-target-startup-sequence) — The BrightScript debug protocol includes the following new features: a **platform\_revision\_timestamp** field for the initial handshake, a **packet\_length** field that is included with all packets from the debugger, and runtime errors for the [EXECUTE debug response format](/docs/developer-program/debugging/socket-based-debugger.md#debugger-response-format).

Roku OS 10.5
------------

**Initial rollout date**: September 20, 2021

Roku OS 10.5 includes a SceneGraph component for creating lines of text with different fonts, colors, and sizes; a SceneGraph component for displaying help with app settings; and ChannelStore APIs for checking whether a subscription should be placed on hold because it is in recovery.

This release includes several enhancements to Roku Voice. For apps that include a profile selection screen, Roku Voice can be used to ask the viewer to select a profile and handle a voice command with the name or position of the profile. Voice keyboards include improved dictation that lets developers determine when a user has finished talking and specify which characters the keyboard accepts or blocks. The individual keys on voice keyboards can now be enabled only once the user has entered complete information (for example, all five digits in a zip code).

In addition, this release includes features that enhance the performance of media playback and Roku devices in general and expand platform support for industry standards covering content metadata.

For tools, this release adds more detailed "type mismatch" reporting to the BrightScript Debug Console and an **Execute** command to the BrightScript Debug Protocol that lets developers execute code in a specific stack frame and therefore evaluate and run expressions.

Below is a list of key developer-facing Roku OS 10.5 updates:

#### Roku OS APIs

*   [**MultiStyleLabel SceneGraph component for styling lines of text with different fonts, colors, sizes**](/docs/references/scenegraph/label-nodes/multi-style-label.md) — Developers can use the new **MultiStyleLabel** node class to create labels with multiple fonts, colors, and sizes. This enables developers to, for example, bold and/or color important text within a label and display emojis.

> As part of the Roku OS 10.5 release, a LabelBase node has been introduced to provide a single base class for the [Label](/docs/references/scenegraph/label-nodes/label.md) node and the MultiStyleLabel node. The Label node now inherits most of its functionality from LabelBase node class. Developers, however, do not need to update their code to account for this refactoring.

*   [**InfoPane SceneGraph component for displaying context-sensitive help with app settings**](/docs/references/scenegraph/label-nodes/info-pane.md) — Developers can use the new **InfoPane** node class to display an opaque, white-bordered, rounded rectangular label with text providing help for a specific setting. This component can be used to help customers successfully configure settings related to their account profile, closed captioning, parental controls, and so on.

*   [**RowList.currFocusColumn field for implementing horizontal pagination**](/docs/references/scenegraph/list-and-grid-nodes/rowlist.md#fields) — A new **currFocusColumn** field has been added to the **RowList** node to indicate which column of the currently-focused row in a RowList component currently has focus. Developers can use this field to implement a horizontal pagination mechanism for the currently focused row.

*   [**Elliptic-curve cryptography for generating digital signatures**](/docs/references/brightscript/components/rodsa.md) — Developers can use the new **roDSA** component, which provides support for the ECDSA and EdDSA (with Ed25519 form) digital signature algorithms, to provide cryptographically signed evidence that an ad request originated from an actual Roku device.

#### Roku Pay APIs

*   [**ChannelStore subscription recovery**](/docs/references/scenegraph/control-nodes/channelstore.md#getpurchases) (also available in Roku OS 10.0) — Developers can now directly use the ChannelStore API to check whether a subscription is in recovery. When a subscritpion is in recovery, Roku Pay notifies the customer once a day for multiple consecutive days (typically three) to update their method of payment in order to renew the subscription, and it attempts to charge the customer's method of payment to ensure collection of payment and continuation of service. The [**ChannelStore.getAllPurchases**](/docs/references/scenegraph/control-nodes/channelstore.md#getallpurchases) and [**getPurchases**](/docs/references/scenegraph/control-nodes/channelstore.md#getpurchases) commands now return a **status** field and an **inDunning** flag to determine whether a subscription is in the dunning state and therefore should be placed on hold. Previously, developers had to pass the **transactionId** returned by the **getAllPurchases** and **getPurchases** commands into a Roku Pay **validate-transaction** API call to determine whether a subscription was in recovery.

*   [**Instant Signup purchase flag for Roku Pay APIs**](/docs/references/scenegraph/control-nodes/channelstore.md#getpurchases) (also available in Roku OS 10.0) — Developers can now identify whether Roku Pay subscription purchases originated from Instant Signup. The ChannelStore node [**getPurchases**](/docs/references/scenegraph/control-nodes/channelstore.md#getpurchases) and [**getAllPurchases**](/docs/references/scenegraph/control-nodes/channelstore.md#getallpurchases)) commands, [**roChannelStore.getPurchases**](/docs/references/brightscript/interfaces/ifchannelstore.md#getpurchases-as-void) function, [Roku Pay **validate-transaction** web service](/docs/developer-program/roku-pay/implementation/roku-web-service.md#validate-transaction), and [Roku Pay **Sale** push notification](/docs/developer-program/roku-pay/implementation/push-notifications.md#sale) all include a new **purchaseChannel** field that is set to "web" and a **purchaseContext** field that is set to "isu" to indicate that a purchase was made via Instant Signup (for on-device purchases, these fields would be set to "device" and "iap", respectively).

#### Roku Voice APIs

*   [**Voice support for profile selection screens**](/docs/developer-program/media-playback/voice-controls/voice-profile-selector.md) — Apps with a profile selection screen can audibly and visually prompt the viewer to select a user profile and then handle a voice request with the name or position of the selected profile. This entails integrating the following APIs included in this release:
    
    *   The [**roAppManager.StartVoiceActionSelectionRequest()**](/docs/references/brightscript/interfaces/ifappmanager.md#startvoiceactionselectionrequest-as-void) function can be called upon app launch to trigger a voice request for the viewer to select a user profile on devices that are paired with a hands-free Roku Voice remote control.
    *   The [**roAppManager.SetVoiceActionStrings()**](/docs/references/brightscript/interfaces/ifappmanager.md#setvoiceactionstringsactions-as-object-as-void) function can be used by the app to register a list of text strings, such as user profile names, that can be matched to voice requests. When the name uttered by the user matches the registered text string, the matched text string is provided to the app via an roInput voice command handler (via a new **text** field included in the associative array returned by the [**roInputEvent.GetInfo()**](/docs/references/brightscript/events/roinputevent.md#getinfo-as-object) method).
    *   The [roInput voice command handler](/docs/references/brightscript/interfaces/ifinput.md#eventresponseroassociativearray-aa-as-boolean) has also been enhanced to support profile selection via ordinal numbers. For example, when a user says "first", "number one", "pick the first", "select the first", "choose the first", and so on to select a user profile within a row, the app will receive a value of "1" (via a new **ordinal** field included in the associative array returned by the [**roInputEvent.GetInfo()**](/docs/references/brightscript/events/roinputevent.md#getinfo-as-object) method) that can be used to select the corresponding profile. Ordinal numbers between 1–6 are supported.
*   [**Device paired with hands-free remote flag**](/docs/references/brightscript/interfaces/ifdeviceinfo.md#hasfeaturefeature-as-string-as-boolean) — Developers can call the roDeviceInfo.HasFeature("handsfree\_voice") function to check whether a Roku device is paired with a hands-free Roku remote control such as the Roku Voice Remote Pro. Developers can call this function before calling the [**roAppManager.StartVoiceActionSelectionRequest()**](/docs/references/brightscript/interfaces/ifappmanager.md#startvoiceactionselectionrequest-as-void) function and having Roku Voice prompt the viewer to select a user profile. In addition, this function enables developers to tailor the in-app user experience for viewers with hands-free Roku remote controls (for example, displaying voice tips and tricks in the UI).
    

*   [**Enhanced dictation for voice keyboards**](/docs/references/scenegraph/dynamic-voice-keyboard-nodes/voice-text-edit-box.md) — Developers can use the new **isDictating** field of the [VoiceTextEditBox node](/docs/references/scenegraph/dynamic-voice-keyboard-nodes/voice-text-edit-box.md) to check whether the user is currently dictating to the keyboard. This enables developers, for example, to determine whether users are done dictating and therefore can advance to the next step/screen in the UI. In addition, developers can use the new **voiceInputRegexFilter** field of the **VoiceTextEditBox** node to specify which characters may or may not be entered on the keyboard via dictation. For example, setting this field to "^\[A-Za-z0-9\_-\]\*$" prevents any special characters from being entered.

*   [**Disabling and enabling of individual keys on voice keyboards**](/docs/references/scenegraph/dynamic-voice-keyboard-nodes/dynamic-key-grid.md) — Developers can use the new **disableKey** and **enableKey** fields of the [DynamicKeyGrid node](/docs/references/scenegraph/dynamic-voice-keyboard-nodes/dynamic-key-grid.md) to control the availability of specific keys in the node's underlying [Key Definition File](/docs/references/scenegraph/dynamic-voice-keyboard-nodes/key-definition-file.md). For example, if the user is entering their zip code in an address keyboard, the "Next" key could be disabled (m.keyboard.keyGrid.disableKey = "Next") until all five digits have been entered. Once all five digits have been entered, the "Next" key could be enabled (m.keyboard.keyGrid.enableKey = "Next"). This eliminates the need to use [multiple grid modes in a Key Definition File](/docs/references/scenegraph/dynamic-voice-keyboard-nodes/key-definition-file.md#grid) to provide this functionality.

*   [**New Voice control manifest flags**](/docs/developer-program/getting-started/architecture/channel-manifest.md) — Developers can now declare whether their app supports voice controls (**supports\_voice\_roinput=1**) and whether it displays a hands-free voice profile selection screen upon launch (**voice\_action\_launch\_screen=1**).

#### Media, DRM, and content metadata updates

*   [**CDN switch event notifications**](/docs/references/scenegraph/media-playback-nodes/video.md#cdn-fields) — The [SceneGraph Video node](/docs/references/scenegraph/media-playback-nodes/video.md#cdn-fields) includes a new **cdnSwitch** field that enables developers to receive event-based notifications when the CDN is switched during content playback.

*   [**DRM error code now provided when a video player error occurs**](/docs/references/scenegraph/media-playback-nodes/video.md#playback-fields) — The [SceneGraph Video node's **error\_info** associative array](/docs/references/scenegraph/media-playback-nodes/video.md#playback-fields) includes a new **drmerrcode** field that contains any error code returned by the DRM system when a video player error occurs.

*   [**Randomizing of Widevine DRM license renewal time**](/docs/developer-program/getting-started/architecture/content-metadata.md#digital-rights-management-drm-control-attributes) — A new **lic\_acq\_window** field has been added to the [Content metadata DRM control attributes](/docs/developer-program/getting-started/architecture/content-metadata.md#digital-rights-management-drm-control-attributes) to help developers prevent their app's Widevine license server from being flooded with simultaneous requests. This **lic\_acq\_window** field is used to set the maximum amount of time (in milliseconds) that an app waits before rotating its Widevine DRM keys. The app can generate a random wait time between 0 and the value specified in the **lic\_acq\_window** field, and use the random wait time to instruct when the Video node should make its next Widevine license request.

*   The [**Video.timedMetaData**](/docs/references/scenegraph/media-playback-nodes/video.md#trickplay-fields) field can now be used to read ID3 tags embedded in an audio stream.

*   [**New hdrMode field for getting the HDR playback state of content**](/docs/references/brightscript/events/rovideoplayerevent.md#isstreamsegmentinfo-as-boolean) — The [roVideoPlayerEvent.isStreamSegmentInfo](/docs/references/brightscript/events/rovideoplayerevent.md#isstreamsegmentinfo-as-boolean) function now provides the HDR playback state. An **hdrMode** field is now returned by the event's **GetInfo()** method. This field indicates whether playback is in SDR, HDR10, Dolby Vision, HLG10, HDR10+, or advanced HDR.

*   [**Initial segment format for multi-period server-stitched DASH manifest**](/docs/specs/media/dash-if.md#updates) — Support for DASH-IF in the Roku OS has been expanded to include the initial segment format for server-stitched manifests formatted with multi-periods.

*   [**SegmentTimeline for calculating time/duration in a DASH stream**](/docs/specs/media/dash-if.md#updates) — Support for DASH-IF in the Roku OS now includes using the SegmentTimeline to precisely identify segment availability. This supports the in-progress playback of content while it is being recorded. Specifically, the Roku OS DASH implementation now supports:

*   Initialization element with sourceURL attribute in under SegmentBase element.
*   RepresentationIndex element.
*   Index segments in a different file than the media segments.
*   Index segments from multiple representations in the same file.
*   Media segments from multiple representations in the same file.
*   Non-standard AudioChannelConfiguration schema: "urn:dolby:dash:audio\_channel\_configuration:2011".

#### Architecture

*   [**New "screensaver" and "homelist" ad source parameters**](/docs/developer-program/getting-started/architecture/dev-environment.md#source-parameter) — The Roku OS now includes "ad:screensaver" and "ad:homelist" source parameters, which enable developers to attribute app launches to these specific ad types. Previously, a single "ad" source parameter was used for all the different ad types (homelist \[mini\], screensaver, and home screen banner ads). The "ad" source parameter now denotes an app launch from a home screen banner ad only.

*   [**Memory exceeded lastExitOrTerminationReasons parameters**](/docs/developer-program/getting-started/architecture/dev-environment.md#lastexitorterminationreason-parameter) — Developers can now check whether an app was exited because it exceeded per-channel memory limits while running in the foreground (EXIT\_CHANNEL\_MEM\_LIMIT\_FG) or background (EXIT\_CHANNEL\_MEM\_LIMIT\_BG).

*   [**Memory usage event notifications**](/docs/references/brightscript/components/roappmemorymonitor.md) — Developers can now receive an event notification if their app is approaching the per-app memory usage threshold. A new [**roAppMemoryMonitor**](/docs/references/brightscript/components/roappmemorymonitor.md) component has been added to support this feature. It has an [**EnableMemoryWarningEvent()**](/docs/references/brightscript/interfaces/ifappmemorymonitor.md#enablememorywarningeventenable-as-boolean-as-boolean) function that notifies an app when it has reached 80% of its memory usage limit, and a [**GetMemoryLimitPercent()**](/docs/references/brightscript/interfaces/ifappmemorymonitor.md#getmemorylimitpercent-as-int) function returns the memory limit for the app. Developers can then use the new [**roAppMemoryMonitorEvent**](/docs/references/brightscript/events/roappmemorynotificationevent.md) to get the percentage of the allocated per-app memory that has been used.

#### Tools

*   [**Detailed "type mismatch" error reporting in BrightScript debug console**](/docs/developer-program/debugging/debugging-channels.md#accessing-the-debug-console) — The BrightScript debug console now provides more specific reporting of "type mismatch" errors to help developers identify and resolve these types of bugs in their code. For example, attempting to evaluate whether an integer value equals a string in an expression (for example, if 12 = "number") now results in the following error message: `Type mismatch. Operator "=" cannot be applied to "Integer" and "String"`.

*   [**Execute debugging command added to BrightScript debug protocol**](/docs/developer-program/debugging/socket-based-debugger.md#debugging-commands) — The **Execute** debugging command (command\_code = 10) enables developers to execute code in a specific stack frame and therefore evaluate and run expressions.

#### Deprecations

*   [**wma and wmapro**](/docs/references/deprecated-apis.md#audio-node-windows-media-audio). The Roku platform no longer supports the Windows Media Audio (**wma**) and **WMApro** audio formats. See the [Audio node](/docs/references/scenegraph/media-playback-nodes/audio.md) for the current list of audio formats supported by the Roku platform.

Roku OS 10.0
------------

**Initial rollout date**: April 13, 2021

Roku OS 10.0 adds a new [**chanperf** command](/docs/developer-program/debugging/debugging-channels.md#scenegraph-debug-server-port-8080-commands) to the debug console that displays the memory and CPU usage of a sideloaded app. This provides developers with a quick, convenient way to find performance issues in different parts of their application.

In addition, developers can now upgrade the keyboards, mini keyboards, PIN pads in their apps to the new dynamic voice-enabled keyboards, which allow customers to use their voice to enter information. This release also makes Roku's standard dialog framework available to developers, which provides enhanced pre-built dialogs and the flexibility to design custom dialogs.

Other highlights include an enhancement to the [ChannelStore API](/docs/references/scenegraph/control-nodes/channelstore.md#requesteduserdatainfo) that optimizes the text displayed in the [Request for Information (RFI) screen](/docs/developer-program/roku-pay/implementation/channel-store.md#getuserdata) based on whether the customer is signing up for a subscription or signing in to their account, updates to the [ChannelStore API](/docs/references/scenegraph/control-nodes/channelstore.md#requesteduserdata) for getting additional customer information such as their birth, gender, and location (country, state, zip code), and new functions for checking the internet connectivity status on a Roku device.

This release also includes features that enhance the performance of media playback, app installation, and Roku devices in general, and it provides expanded platform support for industry standards covering content and meta-data, as well as additional and improved facilities to expedite the monitoring of app performance and memory usage.

Below is a list of key developer-facing Roku OS 10.0 updates:

#### API

*   **[Request for Information (RFI) screen enhanced with optimized displays for sign-ins and sign-ups](/docs/references/scenegraph/control-nodes/channelstore.md#requesteduserdatainfo)** — Developers can now specify whether the Roku Pay RFI screen displays sign-up or sign-in-related information. For example, if the RFI screen is configured for sign-ins, it displays a "Sign in" title and lists only the customer's email address and/or phone number. Apps using SceneGraph ChannelStore node can use the **[requestedUserDataInfo](/docs/references/scenegraph/control-nodes/channelstore.md#requesteduserdatainfo)** field when sending the [**getUserData** command](/docs/references/scenegraph/control-nodes/channelstore.md#getuserdata) to configure the RFI screen for sign-ins; apps using the roChannelStore component can set the new “requestInfo” parameter in the [**GetPartialUserData()** method](/docs/references/brightscript/interfaces/ifchannelstore.md#getpartialuserdataproperties-as-string-requestinfo-as-object-as-object). No additional steps are required for displaying sign-up information on the RFI screen.

*   **[New "birth" and "gender" return values added to ChannelStore](/docs/references/scenegraph/control-nodes/channelstore.md#requesteduserdata)** — The **[ChannelStore.requestedUserData](/docs/references/scenegraph/control-nodes/channelstore.md#requesteduserdata)** field now lets developers request the birthdate (MM/YY) and gender associated with the customer's Roku account, and return these values in the **[userData](/docs/references/scenegraph/control-nodes/channelstore.md#userdata)** field. Similarly, the roChannelStore **[GetUserData()](/docs/references/brightscript/interfaces/ifchannelstore.md#getuserdata-as-object) and [GetPartialUserData()](/docs/references/brightscript/interfaces/ifchannelstore.md#getpartialuserdataproperties-as-string-requestinfo-as-object-as-object)** methods can now be used to retrieve the customer's birthdate and gender.

*   **[roChannelStore.getUserRegionData() method for getting customer's location](/docs/references/brightscript/interfaces/ifchannelstore.md#getuserregiondata-as-object)** — The **[roChannelStore.getUserRegionData()](/docs/references/brightscript/interfaces/ifchannelstore.md#getuserregiondata-as-object)** method can be used to retrieve the state, zip code, and country associated with the customer's Roku account. (Also available in Roku OS 9.4)

*   **[New "error.generic" status added to roInput.EventResponse() method for unhandled voice commands](/docs/references/brightscript/interfaces/ifinput.md#eventresponseroassociativearray-aa-as-boolean)**. The [roInput.EventResponse()](/docs/references/brightscript/interfaces/ifinput.md#eventresponseroassociativearray-aa-as-boolean) method now takes an "error.generic" status that can be used when an app does not have any media to fulfill a voice command (for example, if the app receives a "forward" or "next" command, but there is no content to fast forward or play next, respectively). Passing this status displays "That is not available" in the Roku Voice heads-up display.

*   **[roDeviceInfo internet connectivity status methods](/docs/references/brightscript/interfaces/ifdeviceinfo.md#enableinternetstatuseventenable-as-boolean-as-boolean)** — **[EnableInternetStatusEvent()](/docs/references/brightscript/interfaces/ifdeviceinfo.md#enableinternetstatuseventenable-as-boolean-as-boolean)**, **[GetInternetStatus()](/docs/references/brightscript/interfaces/ifdeviceinfo.md#getinternetstatus-as-boolean)**, and **[ForceInternetStatusCheck()](/docs/references/brightscript/interfaces/ifdeviceinfo.md#forceinternetstatuscheck-as-boolean)** can all be used to retrieve the connectivity status of the device.

*   [**The time reported by ifDateTime.toISOString() now resolves to milliseconds**](/docs/references/brightscript/interfaces/ifdatetime.md#toisostring-as-string)**.** (Also available in Roku OS 9.4)

#### Media, DRM, and content meta-data updates

*   **Media Player performance enhancements** — Video start times have been shortened, re-buffering reduced, and picture quality improved.

*   **Roku SceneGraph (RSG) performance enhancements** — Various RSG data structures have been optimized, and off-screen content nodes are now being managed on an app's behalf. This reduces app memory consumption, allowing internal cache mechanisms to be more effective in improving performance.

*   **[Support for UTCTiming in DASH](/docs/specs/media/dash-if.md#utctiming)** — The UTCTiming element is used in DASH manifests to allow the clocks employed by the server and player to remain in close synchronization. Without this, when there is a timing discrepancy of even as little as 100ms between the local and server clocks live video play can freeze, and audio and video can fall out of sync, as the player requests unavailable, out-of-window segments.

*   [**ForwardDashQueryStringParams content metadata field**](/docs/developer-program/getting-started/architecture/content-metadata.md#playback-configuration-attributes) — This field enables apps to forward DASH manifest query parameters to segment URLS.

*   **[Video node seekMode field allows apps to specify maximum available seek accuracy](/docs/references/scenegraph/media-playback-nodes/video.md#trickplay-fields).** The app can set this field to "accurate," in order to achieve accuracy to the exact requested time, if supported by the player; otherwise seek is accurate to the nearest sync frame. (Also available in Roku OS 9.4)

*   **[Seek-to-pause is now supported through Video node enhancements](/docs/references/scenegraph/media-playback-nodes/video.md#trickplay-fields).** The bufferingStatus field now includes boolean prebufferDone and time element actualStart, which are used in conjunction with seekMode and playStart to facilitate pausing at a particular point, and resuming playback from that point. (Also available in Roku OS 9.4)

*   **[SceneGraph Video node PlayStartInfo field now contains additional timestamp information](/docs/references/scenegraph/media-playback-nodes/video.md#playback-fields)** for start of manifest and DRM loading, DRM license acquisition, and pre-buffering, which supplements already available duration information for those processes.

*   **[New SceneGraph Animation node field willBeSkipped](/docs/references/scenegraph/animation-nodes/animation.md#fields)**. This field indicates whether an animation runs or jumps to the end (effectively skipping the animation and rendering it in its final state).

*   **[DRM is no longer required for AES-128 key exchange using HLS and DASH](/docs/specs/media/content-protection.md).**

*   **[The HLS ASSOC-LANGUAGE audio rendition attribute is now supported](/docs/developer-program/media-playback/trick-mode/hls-and-dash.md#assoc-language-audio-rendition-attribute).** This **optional** attribute is used, for example, to specify that a particular rendition's audio, provided in a given spoken language dialect (e.g., Cantonese/"yue"), is represented in forced subtitles by a different but associated language (e.g., Traditional Chinese/"zh\_HANT").

*   **The DASH Role and Accessibility attributes may now be used in Adaptation Sets to make various audio tracks available for viewer selection.** This brings Roku OS into closer conformance with the DASH-IF specification.

*   **[UI graphics resolution available through External Control Protocol (ECP)](/docs/developer-program/dev-tools/external-control-api.md#general-ecp-commands)** —The [`query/device-info` ECP command](/docs/developer-program/dev-tools/external-control-api.md#querydevice-info-example) now provides a UI-resolution field. (Also available in Roku OS 9.4)

#### Architecture

*   **[Dynamic voice-enabled keyboards](/docs/references/scenegraph/dynamic-voice-keyboard-nodes/dynamic-keyboard-base.md)** — Developers can create keyboards, mini keyboards, and pin pads that can be controlled by voice. This helps speed up on-device sign-ups and sign-ins by enabling customers to speak their PIN codes when subscribing to apps and their passwords when logging in. A sample app demonstrating this feature is available [here](https://github.com/rokudev/dynamic-voice-enabled-keyboards).

*   **[Standard dialog framework](/docs/references/scenegraph/standard-dialog-framework-nodes/standard-dialog-framework-overview.md)** — Developers can use new pre-built modal pop-up dialogs and build custom ones. A sample app demonstrating this feature is available [here](https://github.com/rokudev/standard-dialog-framework).
    
    These new pre-built and custom standard keyboards are summarized as follows:
    
    *   **New pre-built message, keyboard, pin pad, and progress dialogs**. These new dialogs feature updated graphics and color palette support that enable developers to provide a consistent user experience across the dialogs in their app and across the Roku platform (developers can easily adopt the new design of Roku OS system dialogs). In addition, the keyboard and pin pad dialogs include voice entry support for faster and more convenient information entry. These new dialog nodes deprecate the [legacy versions](/docs/references/scenegraph/dialog-nodes/dialog.md).
        
    *   **Developer-defined custom dialogs**. Developers can design custom dialogs that may include a combination of text, buttons, bulleted lists, keyboards, loading indicators, and other building blocks. Custom dialogs also include all the features provided by the pre-built dialogs (voice, custom layout, and graphics). This provides developers with the flexibility to build and configure dialogs to meet their app's requirements.
        
        Some fields used to set options on the Dynamic voice-enabled keyboards and the StandardDialog nodes always print their value as “invalid” in BrightScript. Equality comparisons of these field values will also not work correctly. Setting the value of these fields from either BrightScript or XML does work correctly. These fields include:
        
        The **voiceEntryType** field of the [VoiceTextEditBox](/docs/references/scenegraph/dynamic-voice-keyboard-nodes/voice-text-edit-box.md) node. The **domain** field of the [DynamicKeyboardBase](/docs/references/scenegraph/dynamic-voice-keyboard-nodes/dynamic-keyboard-base.md) node. The **keyboardDomain** field of the [StandardKeyboardDialog](/docs/references/scenegraph/standard-dialog-framework-nodes/standard-keyboard-dialog.md) node. The **bulletType** field of the [StdDlgBulletTextItem](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-bullet-text-item.md) node. The **graphicAlign** field of the [StdDlgGraphicItem](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-graphic-item.md) node. The **keyLayout** field of the [StdDlgKeyboardItem](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-keyboard-item.md) node. The **namedTextStyle** field of the [StdDlgTextItem](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-text-item.md) node.
        

*   **[Enhanced Visual Search Results for Roku Voice](/docs/developer-program/discovery/search/implementing-search.md#visual-search-results-for-roku-voice)** - When users ask for content while in an app, the Roku UI displays a partial overlay with content matching the search request. Content from within the active app is listed in the first row of the display if the active app participates in Roku Search. The rows below include matches from other apps.

*   [**Instant Resume**](/docs/developer-program/media-playback/instant-resume.md) — Developers can implement Instant Resume in their app to save their current state upon exit and then continue playback upon relaunch. This improves the user experience by letting viewers quickly get back to the content they were watching without having to find it first.

*   **[The number of concurrent threads per running instance of an app is now limited to 100](/docs/developer-program/core-concepts/threads.md#thread-limits)** — When the instance exceeds 50 concurrent threads, Roku displays a warning on the port 8085 console. When the instance exceeds 100 threads, a “too many threads” error exception (&h29) is raised; if the app does not catch this exception, app operation is terminated, along with a corresponding stack trace. Task threads that have properly terminated and are no longer running will not count towards the limit, even if the task object itself is still valid (e.g., the state is stopped or done). As a best practice, developers should take steps to ensure that their apps always remain well under the 50-thread "warning" limit.

*   [**New manifest attribute pause\_aware**](/docs/developer-program/getting-started/architecture/channel-manifest.md#special-purpose-attributes) **and corresponding [pause button event](/docs/references/scenegraph/component-functions/onkeyevent.md)**— Use the new key event when the app strictly needs to pause, and not toggle between play and pause (as might happen, for example, during trickplay, in situations where the proper behavior is to leave fast-forward or rewind mode but _not_ immediately begin playing).

#### Tools

This release includes three new or updated port 8080 commands:

*   **[New chanperf command](/docs/developer-program/debugging/debugging-channels.md#scenegraph-debug-server-port-8080-commands)** displays memory and CPU utilization of a side-loaded app.

*   **[New remove\_plugin command](/docs/developer-program/debugging/debugging-channels.md#scenegraph-debug-server-port-8080-commands)** that deletes a particular app from the local device _as well as from other devices_ on the same Roku account. The local device, on which the remove\_plugin command is executed, must be linked to a Roku account, and deletions elsewhere don't take effect until a device synchronizes with the Streaming Store. Some system capabilities, such as RAF, can be implemented/augmented by the installation of special apps. Especially in beta-test situations, the developer can delete old versions of such channels before installing more recent (or production) versions.

*   **["sgnodes all" command extended to detail whether reference counts are held by the OS or the app's scripts](/docs/developer-program/debugging/debugging-channels.md#scenegraph-debug-server-port-8080-commands)** — A sample app demonstrating this feature is available [here](https://github.com/rokudev/sgnodes-all-demo).

#### Deprecated APIs

*   **[SteadyMaxMemPoints removed from signal beacon performance measurements](/docs/references/deprecated-apis.md#signal-beacon-steadymaxmempoints)** — As the **chanperf** command now reports actual memory figures, the **SteadyMaxMemPoints** app performance metric is no longer reported in the debugging logs when an app is exited.

*   **[roDeviceInfo.GetVersion()](/docs/references/brightscript/interfaces/ifdeviceinfo.md#getversion-as-string)** — Use the [**roDeviceInfo.GetOsVersion()** function](/docs/references/brightscript/interfaces/ifdeviceinfo.md#getosversion-as-object) instead, which was introduced in Roku 9.2 OS, to get the **major**, **minor**, **revision**, and **build** numbers of the Roku OS running on a device.

*   Apps must replace all **file://** URLs with **pkg:/** URLs.

Roku OS 9.4
-----------

**Initial rollout date**: September 29, 2020

Roku OS 9.4 introduces formal BrightScript exception handling via TRY/CATCH/THROW statements, and it adds a number of media playback features such as whitelisting/blacklisting of audio and caption tracks for different countries; support for OpenSSL 1.1.1, Widevine v16 DRM, and the WebP image format; and enhancements to DASH thumbnails for trick mode.

Below is a list of key developer-facing Roku OS 9.4 updates:

#### API

*   **[BrightScript now supports exception handling](/docs/references/brightscript/language/error-handling.md)** — Developers can use TRY/CATCH blocks and THROW expressions for handling exceptions in their apps. Developers can define code that may potentially generate errors within a TRY statement, and then provide error handling, such as printing out the error type and message, in a CATCH statement. Developers can also create custom errors with the THROW expression.

*   [**New getUserRegionData command added to SceneGraph ChannelStore node**](/docs/references/scenegraph/control-nodes/channelstore.md#getuserregiondata) — The ChannelStore node now includes a **getUserRegionData** command for retrieving the state, zip code, and country associated with the customer's Roku account. Developers can use the location information returned by this command to determine a customer's eligibility for regional-specific subscription products and content.

*   **[doOrder command status fixed](/docs/references/scenegraph/control-nodes/channelstore.md#doorder)** — The SceneGraph ChannelStore **doOrder** command now only returns a status of 2 ("interrupted") if the back button is pressed from a "Confirm Purchase" dialog.

*   **[ParseJson and FormatJson now accept "flags" parameter as a String](/docs/references/brightscript/language/global-utility-functions.md#parsejsonjsonstring-as-string-flags---as-string-as-object)** — The BrightScript ParseJson and FormatJson global utility functions now accept a String parameter, flags, for specifying the functions' options. (Note that FormatJson already accepted flags as an Integer and now accepts the String version as well.)

#### Media, DRM, and content meta-data updates

*   **Enhanced media player performance** — Numerous improvements in media player performance to minimize video start time, re-buffering, and playback failure rates.

*   **[Content-specific whitelisting/blacklisting of audio and caption tracks for different languages](/docs/developer-program/getting-started/architecture/content-metadata.md#playback-configuration-attributes)** — Audio and captioning tracks can now be blacklisted or whitelisted dynamically for individual content items. The new metadata attributes, **audioBlacklist**, **audioWhitelist**, **captionBlacklist**, and **captionWhitelist**, can be used to make resources in various languages available or unavailable dynamically, under app control, affecting the options that a viewer sees in the UI.

*   **Open SSL 1.1.1** — Roku OS now supports Open SSL 1.1.1. The OpenSSL version that was previously supported by Roku (1.0.2h) has reached end of life. OpenSSL 1.1.1 offers better performance and greater security, among other benefits.

*   **[Widevine v16](/docs/specs/media/content-protection.md#widevine)** — Roku OS now supports Widevine v16 DRM, including on older supported platforms.

*   **[WebP image format](/docs/specs/media/streaming-specifications.md#supported-image-formats)** — The Roku platform now supports the WebP image format, which provides smaller compressed image files and faster decoding and rendering.

*   **[DRM security level reporting](/docs/references/brightscript/interfaces/ifdeviceinfo.md#getdrminfoex-as-object)** — The **ifDeviceInfo.GetDrmInfoEx()** method now returns the security levels of Widevine and PlayReady DRMs.

*   **[DASH thumbnail improvements](/docs/developer-program/media-playback/trick-mode/hls-and-dash.md#dash-standard-thumbnail-tiles)** — The DASH manifest information is now provided more efficiently to the Roku Media Player, especially benefiting low-end devices.

*   **HLS and DASH trickplay thumbnails in SSAI apps now remain in sync** — A bug in the handling of discontinuities (insertion breaks) for trickplay thumbnails in apps with ads inserted server-side (SSAI) previously caused thumbnails to fall out of synch with the video content over time during playback, as more discontinuities were processed. This bug is resolved in Roku OS 9.4 for HLS and DASH streaming with standard thumbnails, but it remains a problem for apps that use BIF thumbnails. Roku recommends that developers who can switch to standard thumbnails in the context of HLS or DASH streaming should do so.

*   **[Video node includes DASH manifest information](/docs/references/scenegraph/media-playback-nodes/video.md#trickplay-fields)** — The DASH manifest is exposed through the SceneGraph Video node and is updated efficiently during live-streams, especially benefitting low-end devices.

*   [**HDCP status reporting for HDMI connections improved**](/docs/references/brightscript/interfaces/ifhdmistatus.md#gethdcpversion-as-string) — The **roHdmiStatus.getHdcpVersion()** method now returns an empty string if HDCP is disabled.

> Adobe has discontinued support for Adobe DRM. Roku OS 9.4 is the last firmware release that will support it. apps should switch to one of the following [Roku-supported DRMs](/docs/specs/media/content-protection.md) to protect content: Widevine, PlayReady, or AES-128.

#### Tools

*   **[Component library compilation errors on port 8085](/docs/references/scenegraph/control-nodes/componentlibrary.md#loading-component-libraries)** — Compilation info/failure messages for Roku SceneGraph component libraries when running side-loaded apps now appear on port 8085 of the debug console.

#### Deprecated APIs

*   The following keys in the [**manifestData** field of the SceneGraph Video node](/docs/references/scenegraph/media-playback-nodes/video.md#trickplay-fields) are deprecated as of Roku OS 9.4: **mpd** and **periods**. Developers can use the **xml** key to acquire information that was provided via the deprecated fields.

Roku OS 9.3
-----------

**Initial rollout date**: April 7, 2020

Roku OS 9.3 includes features to enhance the performance of media playback and Roku devices in general, and expand platform support for industry standards covering content and meta-data. This release also features additional and improved facilities to expedite troubleshooting, performance monitoring, automated testing, and debugging of apps.

Finally, the Roku SceneGraph version defaults to version 1.2 as of Roku OS 9.3. As a result, **use of eval() will result in a compilation error.**

> Apps using eval() will not run on Roku OS 9.3 (unless rsg\_version has been set to 1.1, which is **not** recommended).
> 
> Developers **must** take immediate action to ensure that their apps do not use the eval() function, if at all possible. See "Architecture," below, for more details.

Here is a list of key developer-facing Roku OS 9.3 updates:

#### API

*   **[New signal beacon for login and user selection dialogs](/docs/developer-program/performance-guide/measuring-channel-performance.md#measuring-channel-launch-times)** — Developers can now measure loading times for dialogs and screens that are displayed before the app's home page (for example, login, user selection, and network error dialogs/screens).

*   **[HasFeature() now allows checking for soundbar hardware](/docs/references/brightscript/interfaces/ifdeviceinfo.md#hasfeaturefeature-as-string-as-boolean)** — ifDeviceInfo.HasFeature() now accepts the feature string "soundbar\_hardware". HasFeature() will return **true** if the device has soundbar hardware (i.e., speakers, the master volume of which can be changed directly by program control) but is _not_ a Roku TV.
    
*   **[ifDeviceInfo.GetOSVersion() now includes a "revision" field](/docs/references/brightscript/interfaces/ifdeviceinfo.md#getosversion-as-object)** in the associative array returned by the method. This field corresponds to the third octet in the return value of the legacy GetVersion() method.
    

*   **[The SceneGraph RowList node now supports a fixedFocus option](/docs/references/scenegraph/list-and-grid-nodes/rowlist.md#fields)** for the rowFocusAnimationStyle field. This option is similar to the existing fixedFocusWrap option, but _without_ the latter's wrapping behavior during navigation.

*   **[Single-field observers can capture multiple-field "snapshots"](/docs/references/brightscript/interfaces/ifsgnodefield.md#setfieldfieldname-as-string-value-as-object-as-boolean)** — The observeField() and observeFieldScoped() methods of SceneGraph nodes can now specify a list of additional fields (that are located in the same node as the primary field), the values of which will be captured when the state of the primary field changes. The corresponding roSGNodeEvent will provide those additional values via its GetInfo() method.

#### Media, DRM, and content meta-data updates

*   **Performance enhancements** — These include an increase in effective video bitrate, and reductions in the rates of video start time, re-buffering, and playback failure.

*   **[Get media-player state information using ECP query/media-player](/docs/developer-program/dev-tools/external-control-api.md#querymedia-player-example)** — This External Control Protocol query returns a collection of information about the state of the media player, which can be useful in debugging and general troubleshooting.

*   **[Support for industry standard thumbnail tiles](/docs/developer-program/media-playback/trick-mode/hls-and-dash.md)** — For Roku SceneGraph apps, Roku OS now supports the "[DASH Interop spec v4.3](https://dashif.org/docs/DASH-IF-IOP-v4.3.pdf), Section 6.2.6. Tiles of thumbnail images." VideoNode now has a standard Roku OS rendered UI for DASH or HLS trickplay on VOD content.

*   **[HTTP header control for DRM key/license requests](/docs/developer-program/getting-started/architecture/content-metadata.md#drmhttpagent-for-handling-drm-keylicense-requests-separately)** — Apps now have the ability to set HTTP headers on DRM key/license requests, independently of other HTTP headers.

*   **[SceneGraph Video node trickplay fields now include positionInfo](/docs/references/scenegraph/media-playback-nodes/video.md#trickplay-fields)** — This read-only Associative Array contains the positions of the last-rendered video and audio samples, respectively. Both positions are expressed as double(-floats), and the unit is one second.

*   **[New content meta-data drmParams attribute to support Widevine](/docs/developer-program/getting-started/architecture/content-metadata.md#digital-rights-management-drm-control-attributes)** — The serviceCert attribute allows setting the Widevine service certificate.

*   **More granular DASH MPD Manifest data now accessible** — Apps can now obtain all relevant data from the DASH MPD Manifest.

*   **[Verimatrix DRM is deprecated](/docs/specs/media/content-protection.md)** — As of Roku OS 9.3, support for Verimatrix DRM has been removed from the firmware. Make sure that content in your app is protected using one of the following Roku-supported DRMs: Microsoft PlayReady or Widevine. Click [here](/docs/specs/media/content-protection.md) for more information on implementing these DRMs.

*   **[Adobe DRM is deprecated](/docs/specs/media/content-protection.md)** — As of Roku OS 9.3, support for Adobe DRM is deprecated. The plugin will be removed from Roku OS in our Fall firmware update. Please make sure that content in your app is protected using one of the following Roku-supported DRMs: Microsoft PlayReady or Widevine. Click [here](/docs/specs/media/content-protection.md) for more information on implementing these DRMs.

#### Architecture

*   **[rsg\_version manifest flag defaults to 1.2](/docs/developer-program/getting-started/architecture/channel-manifest.md#special-purpose-attributes)** — The **rsg\_version** attribute in the [manifest](/docs/developer-program/getting-started/architecture/channel-manifest.md#special-purpose-attributes) now defaults to 1.2 (**rsg\_version=1.2**). As of Roku OS 9.0, setting the **rsg\_version** attribute to 1.2 enables an internal mechanism for processing component <script> tags that optimizes the resulting compiled script code. This results in a reduced initial startup time and lesser memory usage while preserving compatibility.The deprecated **eval()** function is not compatible with **rsg\_version 1.2**; therefore, developers must do one of the following to keep their apps running if their apps use this function:1. (Recommended) Remove all usage of the deprecated **eval()** function. If you are using the **eval()** function to initialize data, use the [parseJSON()](/docs/references/brightscript/language/global-utility-functions.md#parsejsonjsonstring-as-string-as-object) function instead.2. Update the **rsg\_version** attribute in the manifest to **1.1** (**rsgversion=1.1**).

#### Tools

*   **[Dynamic breakpoints and step commands added to BrightScript Debug Protocol](/docs/developer-program/debugging/socket-based-debugger.md)** — The socket-based BrightScript debug protocol now includes dynamic breakpoints and step commands. Integrated Development Environments (IDEs) tightly integrated with the BrightScript debug protocol can be enhanced with these features, which enable developers to navigate through and inspect the state of the application and view its execution flow.

#### Miscellaneous

*   **[Visual Search Results for Roku Voice](/docs/developer-program/discovery/search/implementing-search.md#roku-voice-search-results)** (U.S. only) — This new aspect of Roku Voice provides developers who participate in Roku Search with enhanced discovery opportunities. When using Roku Voice to search for movies, shows or popular genres, users will now see a more visual, easy to browse display of movie and TV show artwork rather than a text-based list of options. This new search results screen orders the results in categorized rows that include relevant movies, shows, short-form content and more for simple navigation and quick discovery of entertainment. Once a user selects the specific movie or show they want to watch, they'll see an unbiased list of apps that offer that title, ordered by price (including free when available), so they can choose the viewing option that's best for them.

Roku OS 9.2
-----------

**Initial rollout date**: September 24, 2019

Roku OS 9.2 includes a variety of media updates that allow developers to optimize playback and further secure their protected content. This firmware update also introduces APIs that enable developers to further customize app UIs.

A list of key developer-facing Roku OS 9.2 updates is included below.

#### API

*   **[ZoomRowList enhancement](/docs/references/scenegraph/list-and-grid-nodes/zoomrowlist.md#row-decoration-component-fields)** — Developers can draw a custom row decoration under the items in a ZoomRowList.
*   **[File System last mounted times](/docs/references/brightscript/interfaces/iffilesystem.md#getvolumeinfopath-as-string-as-object)** — Developers can get the time when a USB drive was last mounted on a Roku device.
*   [**New API for getting Roku OS version**](/docs/references/brightscript/interfaces/ifdeviceinfo.md#getosversion-as-object) — Developers can call the **roDeviceInfo.GetOSVersion()** method to get the Roku OS running on a device.

#### Media playback

*   **[CDN switching](/docs/developer-program/getting-started/architecture/content-metadata.md#cdn-switching)** — Developers can switch Content Delivery Networks (CDNs) during playback to load balance traffic and failover to different servers in order to help optimize performance.
*   **Forced narrative subtitles** — The Roku OS now supports the display of forced narrative subtitles on the video player. This enables a dialog or on-screen text (for example, newspaper headlines, street signs, and so on) to be translated into alternate languages to help viewers understand the words being spoken or displayed.
*   **Support for templated DASH streams that have Widevine** — The Roku media player now supports playback of DASH streams that have both templated representation and Widevines licenses.
*   **DASH/HLS multi-license support** — Developers can protect content with resolution-specific licenses. This means developers can, for example, secure the 4K version of content with a Widevine level 1 license, and the FHD and lower versions with a Widevine level 2 license.

#### Deprecated APIs

*   **Roku device MAC Address via roDeviceInfo.GetConnectionInfo** — The [roDeviceInfo.GetConnectionInfo()](/docs/references/brightscript/interfaces/ifdeviceinfo.md#getconnectioninfo-as-object) method no longer returns a device's MAC address. Developers can use the [roDeviceInfo.GetChannelClientId](/docs/references/brightscript/interfaces/ifdeviceinfo.md#getchannelclientid-as-string) method to uniquely identify devices.
*   **AudioLanguageSelected attribute** — The [AudioLanguageSelected](/docs/developer-program/getting-started/architecture/content-metadata.md#track-id-attributesUsers) content metadata attribute no longer can be used to specify the language track to be used when content has multiple language tracks. Users can select their preferred audio language on-device in the **Settings > Audio > Audio Preferred Language** screen.

Roku OS 9.1
-----------

**Initial rollout date:** April 9, 2019

Roku OS 9.1 adds new line-level debugging to the BrightScript Profiler tool, which enables developers to better pinpoint high memory and CPU usage. In addition, this update adds signal beacons to measure video start time, app change time, and app exit times, which helps developers verify that their app's performance meets certification requirements.

Below is a list of new APIs, media updates, and tools for developers. Changes to deprecated APIs are listed as well.

> The `roDeviceInfo.GetDeviceUniqueId()` function now returns all zeros instead of a device ID. Apps that are still using this function in an authentication flow will fail until an app update is published. Developers should migrate to the [`roDeviceInfo.GetChannelClientId()`](/docs/references/brightscript/interfaces/ifdeviceinfo.md#GetChannelClientId) function to get a device ID for their app. Key Roku OS 9.1 features:

#### APIs

*   [**Encryption/decryption API**](/docs/references/brightscript/components/rodevicecrypto.md) – Developers can now encrypt and decrypt data on a device using a key that is unique per app, device, or model. Using an app key, for example, developers can encrypt data for an app so that it may only be decrypted by that same app. In this case, a developer could provision credentials or an API key from the cloud to devices securely. With a device key, for example, a developer could implement a secure-storage algorithm.
    
*   [**Performance testing**](/docs/developer-program/performance-guide/measuring-channel-performance.md) – Developers can now measure the performance of user-initiated actions on their apps to validate that their apps meet certification requirements. The Roku OS automatically records key app performance metrics such as video start time, app change time, and app exit times via signal beacons (markers for the start and stop points of user-initiated actions). In addition, developers can manually add signal beacons to their applications to measure and record app launch times, which cannot be detected automatically by the Roku OS. Developers can then use the debug console to view log entries for these app performance metrics.
    
*   [**Voice command handling**](/docs/developer-program/media-playback/voice-controls/transport-controls.md) – Developers can implement voice controls to respond to voice commands such as "fast forward", "rewind", "pause", "resume", "start over", "replay", and so on. These voice commands may be sent from the Roku voice remote, Roku mobile app, or a virtual assistant such as Amazon Alexa or Google Assistant.
    
*   [**Purchase history API**](/docs/references/scenegraph/control-nodes/channelstore.md#getAllPurchases) – Developers can now get a customer's purchase history, which makes it easier to determine free-trial eligibility in subscription renewal flows.
    
*   [**Enhanced partner account creation**](/docs/references/scenegraph/control-nodes/channelstore.md#storechannelcreddata) – Developers can now use the ChannelNode to store an OAuth token, custom token, or other custom data and then retrieve the credential during authentication. This is the same functionality that has been available with the roChannelStore SDK1 component since firmware release 8.1.
    
*   [**Audio/video codec change detection**](/docs/references/brightscript/events/rodeviceinfoevent.md) – Developers can now detect when the audio or video codec has changed (for example, the Roku is plugged into a different A/V receiver or TV) and then check the current audio/video playback capability.
    

#### Media, DRM, and content meta-data updates

*   [**Media player error and diagnostics reporting**](/docs/references/scenegraph/media-playback-nodes/video.md) – Developers now have access to more detailed error reporting to help diagnose video play errors. When an error occurs, the new reporting will explain why media playback failed and, if applicable, which syntax or feature in the content is incompatible.

#### BrightScript Profiler features

*   [**Line-level memory and CPU usage diagnostics**](/docs/developer-program/dev-tools/brightscript-doc.md#line-level-profiling) — Developers can now collect profile data for each line of BrightScript source code to more clearly identify where memory or CPU usage is high.

#### Changes to Deprecated APIs

*   [**roDeviceInfo.GetDeviceUniqueId()**](/docs/references/brightscript/interfaces/ifdeviceinfo.md#getdeviceuniqueid-as-string) – The `roDeviceInfo.GetDeviceUniqueId()` method now returns a string of zeroes instead of the 12-character alphanumeric string for the device serial number. Developers should use the [`roDeviceInfo.GetChannelClientId()`](/docs/references/brightscript/interfaces/ifdeviceinfo.md#getchannelclientid-as-string) method to get a 12-character device ID for their app. For an overview of the consumer features added in Roku OS 9.1, visit the Roku Blog.

Roku OS 9
---------

**Initial rollout date:** October 23, 2018

Roku OS 9 introduces a new manifest flag which adds drastic improvements to the memory footprint and launch times of Roku SceneGraph (RSG) apps. All RSG apps should set the "rsg\_version=1.2" manifest entry to run the new, higher performing SceneGraph update. This update also adds memory profiling capabilities to the BrightScript Profiler tool, enabling developers to better identify memory leaks in their apps.

Below is a list of new APIs, tools, performance enhancements, and media updates for developers.

#### SceneGraph enhancements

*   **New manifest flag for "rsg\_version=1.2"** — By adding this new manifest entry, developers enable tremendous memory savings and app launch time improvements in RSG apps. [The "rsg\_version=1.2" manifest entry](/docs/developer-program/getting-started/architecture/channel-manifest.md#special-purpose-attributes) enables a new internal mechanism for processing component <script> tags that optimizes the resulting compiled script code. This results in a major reduction in the app's initial startup time and uses dramatically less memory while preserving total compatibility. Initial startup time is typically reduced by approximately 30% when this manifest flag is set. Memory savings range from 10 - 20MiB in a moderately complex app, with up to 40MiB saved in a complex app with extensive component hierarchies.
*   **eval() is no longer supported for "rsg\_version=1.2"** — In order to realize the load time performance and memory benefits enabled by the "rsg\_version=1.2" entry, eval() can no longer be supported. Any use of eval() will cause compilation and runtime errors if "rsg\_version=1.2" is in the app’s manifest.
*   **Faster AssociativeArray access** — Read and write access into and out of AssociativeArray fields on nodes, and retrieval of AssociativeArrays using roSGNodeEvent.getData() has been made 5x faster. The semantics of AssociativeArray fields are copy on read and write, and copy on roSGNodeEvent.getData(). Apps that heavily use AAs can expect dramatic speed increases that directly translate to user-perceivable operations.
*   **Faster rendezvous** — This change enables an auxiliary thread to handle rendezvous operations when the render thread is occupied with tasks that don't need rendezvous protection. The result is dramatic speed-ups for rendezvous operations, particularly on Roku devices with lesser processing power.
*   **Faster component creation** — Node creation times have been improved in Roku OS 9.
*   **ZoomRowList component** — [ZoomRowList](/docs/references/scenegraph/list-and-grid-nodes/zoomrowlist.md), a RowList component where the focused item is zoomed in, is now available for developers.
*   **roSGNode.threadInfo() method** — A new diagnostic function, [threadInfo()](/docs/references/brightscript/interfaces/ifsgnodefield.md), has been added to the [ifSGNodeField](/docs/references/brightscript/interfaces/ifsgnodefield.md) interface. With few exceptions, this function may be called from any component, on any thread, in any function, at any time.

#### New BrightScript Profiler features

The [BrightScript Profiler](/docs/developer-program/dev-tools/brightscript-profiler.md) now includes a memory profiling tool that can be used to help developers identify memory leaks or memory that is allocated during app operation without ever being freed. Roku OS 9 also adds support for streaming of profiling data to a local network host.

#### Media, DRM, and content meta-data updates

*   **Dash EventStream** - Dash EventStream elements are supported in Roku OS 9.
*   **\[BETA\] Opening Widevine DRM CBCS decryption mode** — Roku OS 9 adds CBCS decryption support for [Widevine DRM](/docs/specs/media/content-protection.md#widevine) in DASH and HLS streams. At this stage, Widevine support is considered in beta on the Roku platform.
*   **\[BETA\] DASH XLink support** - Roku OS 9 adds DASH XLink support, including EventStream events that are surfaced to the app through the [timedMetaData](/docs/references/scenegraph/media-playback-nodes/video.md#fields) field.
*   **Widevine key rotation** - Roku OS 9 also adds support for Widevine key rotation and license renewal for Dash and HLS content.

#### Miscellaneous

*   New manifest entry for a "game" app — Developers can now set the ["game" manifest entry](/docs/developer-program/getting-started/architecture/channel-manifest.md#special-purpose-attributes) (game=1) to avoid audio delays in their game apps.
*   roList indexing is no longer disturbed by array index access — The behavior of roList indexing has been modified to yield more intuitive results and resolve bugs. As of Roku OS 9, when implementing roList, ifEnum enumeration and ifList enumeration will use a separate and independent internal 'pointers' to the current element, instead of a "current integer index" variable. This has been done to ensure the ifList index position does not corrupt the roList index when the array read/write operators are used.
*   Programmatic access to BIFs through BrightScript — Two new fields, getNearestFrame and nearestFrame, have been added to the [BifDisplay](/docs/references/scenegraph/media-playback-nodes/video.md#fields) component so that developers can now access BIFs programmatically in their apps. Previously a BrightScript app had to use the built-in trickplay UI to access these BIFs.

For an overview of the consumer features added in Roku OS 9, visit the [Roku Blog](https://blog.roku.com/os-9-release-notes).

Roku OS 8.2
-----------

**Initial rollout date:** September 26, 2018

Roku OS 8.2 is a firmware update focused primarily on firmware optimizations and bug fixes, along with new features that will enable Roku TV models to work seamlessly with the upcoming Roku TV Wireless Speakers. This update introduces no new features, APIs, console logs, or tooling about which developers should be mindful.

For our consumer release notes, [see here](https://support.roku.com/article/228844467-roku-os-software-release-notes).

Roku OS 8.1
-----------

**Initial rollout date:** May 1, 2018

#### Media, DRM, and content meta-data updates

*   **PlayReady 3 Update** — All Roku devices with MStar chips update to the [PlayReady 3](/docs/specs/media/content-protection.md#playready) library with Roku OS 8.1. Previously they included PlayReady 2.5.
*   **\[BETA\] Opening Access to Widevine DRM** — Roku OS 8.1 adds support for [Widevine DRM](/docs/specs/media/content-protection.md#widevine) for DASH streams. At this stage, Widevine support is considered in beta on the Roku platform.
*   **Digital Rights Management (DRM) control attributes** — Content metadata control attributes for DRM have been added to the Roku OS.
    
    *   **Passing custom HTTP headers to licensing requests** — Developers looking to pass custom HTTP headers with a licensing request can now set those headers using the [ifHttpAgent](/docs/references/brightscript/interfaces/ifhttpagent.md) interface methods on the [Video](/docs/references/scenegraph/media-playback-nodes/video.md) node.
*   **Media Player content metadata updates** — Two content metadata attributes of the Media Player have been updated and three new attributes have been added:
    
    *   [PlayDuration](/docs/developer-program/getting-started/architecture/content-metadata.md#playback-configuration-attributes) is no longer used by the media player.
    *   [BookmarkPosition](/docs/developer-program/getting-started/architecture/content-metadata.md#playback-configuration-attributes) is being deprecated.
        
        *   The existing PlayStart attribute should be used instead as it has been modified to allow apps to seek to positions prior to PlayStart. the Roku OS will continue to support BookmarkPosition to maintain the backward compatibility, but apps should plan a migration to use PlayStart.
    *   A new content meta-data attribute, [ClipStart](/docs/developer-program/getting-started/architecture/content-metadata.md#playback-configuration-attributes), sets the clip start position.
    *   A new content meta-data attribute, [ClipEnd](/docs/developer-program/getting-started/architecture/content-metadata.md#playback-configuration-attributes), sets the clip end position.
    *   A new content meta-data attribute, [LiveBoundsPauseBehavior](/docs/developer-program/getting-started/architecture/content-metadata.md#playback-configuration-attributes), allows an app to customize Media Player behavior on live streams when playing in the earliest part of a DVR buffer.

#### Deprecated APIs

Five [roDeviceInfo](/docs/references/brightscript/components/rodeviceinfo.md) methods are being deprecated and replaced with similar APIs (as seen in the chart below).

The deprecated APIs will remain in the Roku OS and continue to work for one year; they will be removed from the Roku OS in the Spring 2019 OS update. **Developers must update their apps to use the new APIs within the next year.**

Below is a complete list of the APIs deprecated as of Roku OS 8.1.

| Deprecated API | Replacement API |
| --- | --- |
| GetDrmInfo() | [GetDrmInfoEx()](/docs/references/brightscript/interfaces/ifdeviceinfo.md#getdrminfoex-as-object) |
| GetAdvertisingId() | [GetRIDA()](/docs/references/brightscript/interfaces/ifdeviceinfo.md#getrida-as-string) |
| IsAdIdTrackingDisabled() | [IsRIDADisabled()](/docs/references/brightscript/interfaces/ifdeviceinfo.md#isridadisabled-as-boolean) |
| GetClientTrackingId() | [GetChannelClientId()](/docs/references/brightscript/interfaces/ifdeviceinfo.md#getchannelclientid-as-string) |
| GetDeviceUniqueId() | N/A — Use [GetChannelClientId()](/docs/references/brightscript/interfaces/ifdeviceinfo.md#getchannelclientid-as-string) |

#### General API Enhancements

*   **Memory-level notification** — This release adds a memory-level notification API ([generalMemoryLevel](/docs/references/brightscript/components/rodeviceinfo.md)) to roDeviceInfoEvent to fire notifications to the app. Apps can also query the memory level directly using [two new methods](/docs/references/brightscript/interfaces/ifdeviceinfo.md#enablelowgeneralmemoryeventenabled-as-boolean-as-dynamic) of the [roDeviceInfo](/docs/references/brightscript/components/rodeviceinfo.md) component.
*   **GetUserCountryCode() API** — To determine the country associated with a user’s Roku account, a new method [GetUserCountryCode()](/docs/references/brightscript/interfaces/ifdeviceinfo.md#getusercountrycode-as-string) as String was added to [roDeviceInfo](/docs/references/brightscript/components/rodeviceinfo.md).
*   **roRegex.MatchAll()** — A new method [MatchAll()](/docs/references/brightscript/interfaces/ifregex.md#matchallstr-as-string-as-object), has been added to [roRegex](/docs/references/brightscript/components/roregex.md). This adds the ability to return all matches of a specific regular expression pattern in the target string.
*   **Getting captions mode from device event** — The developer can now call GetInfo() on a device event to know the current global setting for closed caption mode property using [isCaptionModeChanged()](/docs/references/brightscript/events/rodeviceinfoevent.md).
*   **API to determine if a Roku TV is Energy Star Compliant** — Developers can determine if a Roku powered TV is Energy Star Compliant by using the [roDeviceInfo.HasFeature("energy\_star\_compliant")](/docs/references/brightscript/interfaces/ifdeviceinfo.md#getusercountrycode-as-string) API.
*   **storeChannelCredData API** — This OS update introduces a new roChannelStore method, [StoreChannelCredData()](/docs/developer-program/authentication/universal-authentication-protocol-for-single-sign-on.md), that allows apps to store information in our backend which they can retrieve later using GetChannelCred(). Calling this new API allows developers to store OAuth tokens for a signed-in user so that when the app is launched on a new Roku device, the app can request the stored information, identify their customer, and automatically sign them in.

#### SceneGraph Updates

*   **ReplaceChildren() ignores extra items in the replace list** — When using replaceChildren() to update the content of each item in a [markupGrid](/docs/references/scenegraph/list-and-grid-nodes/markupgrid.md), if the developer supplies more items than there are in the original list (going from 4 items to 5), the 'extra' items are ignored and not added as children.
*   **Mobile or ECP keypress events now appear in onKeyEvent()** — Literal key keypress events (such as keyboard letters, and so forth) that are sent to via the mobile app or [ECP](/docs/developer-program/dev-tools/external-control-api.md) keydown/keyup commands, now go to the onKeyEvent() handler. Previously, only keys that corresponded to remote keys went to the onKeyEvent handler.
*   **SimpleLabel** - Roku OS version 8.1 introduces [SimpleLabel](/docs/references/scenegraph/renderable-nodes/simplelabel.md) which is a lightweight complement node to the [Label](/docs/references/scenegraph/label-nodes/label.md) node. It supports simplified font style specification and is more memory efficient than the Label node.

Roku OS 8
---------

**Initial rollout date:** October 2, 2017

#### Performance & optimization

*   **fps\_display command** — A new command, [fps\_display](/docs/developer-program/debugging/debugging-channels.md), has been added to Telnet port 8080 to display frames-per-second and free memory on-screen. Developers can leverage this tool to optimize their app UI.
*   **Registry ReadMulti and WriteMulti APIs** — [roRegistrySection](/docs/references/brightscript/components/roregistrysection.md) adds two new APIs, **WriteMulti** and **ReadMulti** — to allow apps to read/write multiple keys at a time.
*   **\[BETA\] New file system for data caching** — A new file system, [cachefs:](/docs/developer-program/getting-started/architecture/file-system.md), has been introduced to allow applications to cache data to volatile or persistent storage. Users who extend the persistent storage available on their device by adding an SD card will see the biggest benefit as application data will survive reboots and benefit from additional cache space to improve performance. Users without extended storage will also benefit from the use of a shared in-memory cache that is automatically managed by the system to optimize for the most recently used assets.
*   **RSG platform performance improvements** — Many improvements have been built into the Roku OS itself, enabling better support for low-end devices. All apps automatically inherit these benefits, with no action required from the developer.
    
    *   <script> include files no longer incur an expensive copy for each component that includes it.
    *   The time penalty for rendezvous has been reduced.
    *   The per-node memory penalty has been significantly reduced.
    *   Image caching has been added for all apps.

#### SceneGraph updates

*   **Support for RSG 1.0 functionality is deprecated** — Starting with Roku OS 8, support for the “[rsg\_version=1.0](/docs/developer-program/getting-started/architecture/channel-manifest.md#special-purpose-attributes)” manifest flag is deprecated. This deprecation means that the 1.0 features continue to work in Roku OS 8, but will no longer be supported (and thus should not be expected to work) starting with our next major firmware release. Apps affected by the change in Roku’s [observer callback model](/docs/developer-program/core-concepts/handling-application-events.md) introduced in Roku OS 7.5 should be updated accordingly.
*   **Video node updates** — Many new fields have been added to the [Video](/docs/references/scenegraph/media-playback-nodes/video.md) node:
    
    *   **captionStyle** allows apps to style closed captions.
    *   **contentBlocked** determines whether the current content is blocked.
    *   **supplementaryAudioVolume** sets the volume of the description tracks separately from the main audio track.
    *   **availableAudioTracks** has been updated to return/include audio description tracks, which are typically seen on broadcast TV.
*   **itemHasFocus field for item components** — A new optional field "itemHasFocus" has been added for RSG item components: [MarkupList](/docs/references/scenegraph/layout-group-nodes/markuplist.md), [MarkupGrid](/docs/references/scenegraph/list-and-grid-nodes/markupgrid.md), [RowList](/docs/references/scenegraph/list-and-grid-nodes/rowlist.md) and [TargetGroup](/docs/references/scenegraph/layout-group-nodes/targetgroup.md). It stores a boolean value that indicates whether the item component currently is the focused item. Only one item component of any of the nodes should have itemHasFocus set to true.
*   **ParentalControlPinPad** — Roku OS 8 contains a new node, [ParentalControlPinPad](/docs/references/scenegraph/renderable-nodes/rectangle.md). It is a variant of the PinPad component, but with a few key differences:
    
    *   The pin, pinLength, and secureModefields are made private.
    *   If the user enters the correct pin, a 2-hour override of content blocking begins, similar to the system behavior on Roku TV.
    *   If the user enters an incorrect PIN, the text fields are cleared automatically.
    *   A new field, pinSuccess, exists for blocking content.
*   **Rectangle node blendingEnabled support** — A blendingEnabled field has been added to the RSG [Rectangle](/docs/references/scenegraph/renderable-nodes/rectangle.md) component that specifies if the rectangle should be alpha blended with the nodes behind it.

#### System overlay & closed caption updates

*   **Improvements to the system overlay** — The behavior of the Roku system overlay has been modified, such that the system overlay now slides in whenever the \* button is pressed, the Video node is in focus, and the app does not have its OnKeyEvent() handler fired. When the Video node is not in focus, the system overlay does not slide in and the OnKeyEvent() handler is fired.
*   **System overlay notification event** — A new notification has been added to [roDeviceInfo](/docs/references/brightscript/components/rodeviceinfo.md). Apps can get notified when a system overlay is displayed.
*   **roDeviceInfoEvent update** — A new event, isCaptionModeChangedEvent, has been added to [roDeviceInfoEvent](/docs/references/brightscript/events/rodeviceinfoevent.md) to enable developers to check if the user changes the closed caption mode or track.
*   **Closed caption track selection** — It is no longer necessary for a app to partake in the CC track selection, apart from adding any tracks to the list of available tracks. the Roku OS now selects a CC track based on the preferred caption language selection in the system preferences. When the selected language is not available, it defaults to the system's UI language.

#### Miscellaneous

*   **Case-preserving quoted keys in Associative Arrays** — The quoted keys in [Associative Array](/docs/references/brightscript/components/roassociativearray.md) literals are now case-preserving. This change improves the readability of your code and is compatible with JSON usage.
    
*   **CEC status events** — A [roCECStatusEvent](/docs/references/brightscript/events/rocecstatusevent.md) has been added for set-top-boxes to determine their active display source status. Apps subscribing to the event will be notified when the active-source status of the device changes per the CEC message traffic.
    

Roku OS 7.7
-----------

**Initial rollout date:** June 20, 2017

Roku OS 7.7 focuses mainly on bug fixes and firmware optimizations to increase performance of Roku SceneGraph (RSG) apps.

#### SceneGraph additions and modifications

*   **New event added for DASH manifest updates** — A new field, `manifestData`, has been added to the [Video node](/docs/references/scenegraph/media-playback-nodes/video.md) to detect the periods in a DASH manifest before they are played back. One major use case for this is to display ad markers in the trickplay progress bar.
    
*   **New field to reflect current design resolution** — A read-only field, [`currentDesignResolution`](/docs/references/scenegraph/scene.md), has been added to Scene nodes to determine which of the supported design resolutions is currently being used by RSG.
    
*   **UI changes to the RowList & ArrayGrid components** — Two new fields have been added to the [RowList](/docs/references/scenegraph/list-and-grid-nodes/rowlist.md) and [ArrayGrid](/docs/references/scenegraph/abstract-nodes/arraygrid.md) components to provide greater control over the UX:
    
    *   **RowList** — `rowCounterRightOffset`  
        Used to specify the location of the right edge of the row counter relative to right edge of the RowList's clipping rectangle.
    *   **RowList** — `showRowCounterForShortRows`  
        Determines whether the row counter is shown for all rows.
    *   **ArrayGrid** — `fadeFocusFeedbackWhenAutoScrolling`  
        Determines whether to fade the focus feedback indicator while scrolling multiple items.
    *   **ArrayGrid** — `currFocusFeedbackOpacity` Provides access to the current opacity of the focus feedback indicator.
*   **New field to play animations in reverse** — A "reverse" boolean field has been added to the [`FloatFieldInterpolator`](/docs/references/scenegraph/animation-nodes/floatfieldinterpolator.md), [`ColorFieldInterpolator`](/docs/references/scenegraph/animation-nodes/colorfieldinterpolator.md), and [`Vector2DFieldInterpolator`](/docs/references/scenegraph/animation-nodes/vector2Dfieldinterpolator.md) RSG nodes to allow for interpolated values to be computed in reverse.
    
*   **Component compile time optimizations** — Roku OS 7.7 includes several BrightScript compile time optimizations that significantly improve app launch times. In particular, RSG apps defining many components with the same script files will benefit from the largest app launch time enhancements.
    

> These optimizations are in the Roku OS and require no action from the developer.

#### Additional updates

*   **Manifest addition for confirming app launches** — An optional field, "[confirm\_partner\_button](/docs/developer-program/getting-started/architecture/channel-manifest.md#launch-requirement-attributes)", has been added to the manifest to confirm app launches before leaving the current app after a partner button was pressed on the Roku remote. Use this feature to minimize the number of unintended app launches after a user accidentally hits a partner button while fast forwarding or rewinding content.
    
*   **Manifest entry for overriding network connectivity HUD** — Roku OS 7.7 introduces a system-level display for indicating when media playback is interrupted due to network connection failures. However, apps that have designed their own error dialogue for these interruptions can suppress this pop-up HUD by including a new flag in their manifest. The manifest entry to override the HUD is “[suppress\_unconnected\_hud=1](/docs/developer-program/getting-started/architecture/channel-manifest.md#special-purpose-attributes)”.
    

> For more information on the **connectivity HUD**, please read the related [support article.](https://support.roku.com/article/208755728-what-to-do-if-you-can)

*   **New logTypes added to ifSystemLog** — [`ifSystemLog`](/docs/references/brightscript/interfaces/ifsystemlog.md) now supports a new logType: "http.complete". When enabled, the “http.complete” events will be sent to Roku after an http transfer is completed for adaptive streams. This event consolidates information related to a cURL transfer such as:
    
    *   DNS look up time,
    *   connection latency,
    *   transfer speed
    *   and number of bytes.

While Roku OS 7.7 is focused almost entirely on bug fixes and developer optimizations, it does include a few new consumer features.

For our consumer release notes, visit the [Roku Blog](https://blog.roku.com/roku-os-7-7-release-notes/).

Roku OS 7.6
-----------

**Initial rollout date:** April 11, 2017

#### SceneGraph updates

*   **TVOD APIs** — New APIs have been added to the RSG [ChannelStore](/docs/references/scenegraph/control-nodes/channelstore.md) component to support in-app purchases. ([roChannelStore](/docs/references/brightscript/components/rochannelstore.md))
*   **New function for cloning an entire node tree** — The clone() function has been added to [ifSGNodeDict](/docs/references/brightscript/interfaces/ifsgnodedict.md) to clone an entire node tree, or just the node depending on the boolean value passed.
*   **Convert structures containing arrays into an RSG node tree** — An “update” function has been added to [ifSGNodeChildren](/docs/references/brightscript/interfaces/ifsgnodechildren.md). Use ifSGNodeChildren.update() to convert objects with arrays and/or associative arrays into node trees.
*   **Improved rotation animation** — Fixed a rotation [animation](/docs/references/scenegraph/animation-nodes/animation.md) issue for the following device model groups: 2450X, 2500X, 27XXX, 37XXX, and 5000X. ([FloatFieldInterpolator](/docs/references/scenegraph/animation-nodes/floatfieldinterpolator.md))

#### BrightScript updates

*   **Microphone APIs** — Added a [roMicrophone](/docs/references/brightscript/components/romicrophone.md) component and [roMicrophoneEvent](/docs/references/brightscript/events/romicrophoneevent.md) for capturing voice input from the user. Note that apps in the Kids & Family category can not use these APIs.
*   **HTTP/2 support** - [roUrlTransfer](/docs/references/brightscript/components/rourltransfer.md) objects now support HTTP/2. Among the benefits, HTTP/2 support allows for connection sharing, which is accomplished by establishing all roUrlTransfers that could share a connection from the same Task thread.
*   **Conditional compilation** — BrightScript now supports [conditional compilation](/docs/references/brightscript/language/conditional-compilation.md), which allows blocks of code to be run only while set to true.
*   **API to count node impressions** — Two new fields — enableRenderTracking and renderTracking — have been added to RenderableNode to check whether a node is fully or partially rendered within the bounding rectangle of the screen. Developers can use this information to track node impressions.
*   **Import BrightScript files using relative URIs** — Developers can now specify URIs relative to the XML component’s file for the /<[script](/docs/references/scenegraph/xml-elements/script.md)/> element’s “uri” attribute.
*   **New functions added to [ifDeviceInfo](/docs/references/brightscript/interfaces/ifdeviceinfo.md)** -
    
    *   GetGraphicsPlatform queries the device to see if it supports OpenGL or DirectFB. The function takes no arguments. The return is either “opengl” or “directfb” as a string.
    *   GetClientTrackingId is an alias for the existing GetPublisherId function. The alternative function name is meant to help developers remember to use publisher ID instead of the device ESN.

#### BrightScript debugger updates

*   **BrightScript profiler tool** — A BrightScript profiler tool has been added to Roku OS to gather important metrics such as CPU usage and function “wall-clock” times. Use this tool to analyze performance and increase code efficiency. ([BrightScript profiler documentation](/docs/developer-program/dev-tools/brightscript-profiler.md);[visualization tool](https://devtools.web.roku.com/profiler/viewer/))
*   **Rendezvous logging** — Information on the thread rendezvous can now be accessed from within the developer console. To toggle this log setting, telnet to the device port 8080 and enter “enhanced\_dev\_log rendezvous \[on|off\]”. ([Testing and debugging Roku apps](/docs/developer-program/debugging/debugging-channels.md))
*   **Node operation performance metrics** — Debug command “sgperf” has been added to port 8080 to track roSGNode operations by thread, whether it’s a create- or a subsequent-operation on an existing node, and whether it involved a rendezvous. ([Testing and debugging Roku apps](/docs/developer-program/debugging/debugging-channels.md))
*   **Shorthand debugger commands** — Shorthand alternatives can now be used to replace many debugger commands. ([Testing and debugging Roku apps](/docs/developer-program/debugging/debugging-channels.md))

#### New [manifest](https://github.com/rokudev/docs/blob/master/develop/specifications/manifest.md) entry

*   splash\_rsg\_optimization=1: Remove flicker between the splash screen and initial screen during app launch of SceneGraph apps

#### UI watchdog

UI watchdog was re-enabled in version 7.6.

The UI Watchdog is a timer that runs on the Roku system and ensures overall stability of the platform by forcing a reboot of the system if it appears to be hung. During normal system operation the timer (watchdog timeout value) is periodically reset to ensure that a reboot is not triggered. In the case of the UI Watchdog, the Roku OS will give a 3 second grace period for a sideloaded app locking/over-taxing the Render thread before a system reboot is triggered (for a Streaming Store installed app, the Roku OS gives a 10 second grace period).

Roku OS 7.5
-----------

**Initial rollout date:** November 1, 2016

#### SceneGraph updates

*   [Thread rendezvous](/docs/developer-program/core-concepts/threads.md#task-node-thread-rendezvous-timeout) no longer timeout and will wait indefinitely.
    
*   New components:
    
    *   [TargetGroup](/docs/references/scenegraph/layout-group-nodes/targetgroup.md)
    *   [TargetList](/docs/references/scenegraph/list-and-grid-nodes/targetlist.md)
    *   [TargetSet](/docs/references/scenegraph/layout-group-nodes/targetset.md)
    *   [SoundEffect](/docs/references/scenegraph/media-playback-nodes/soundeffect.md) node
*   New and updated fields:
    
    *   [<interface>](/docs/references/scenegraph/xml-elements/interface.md): added roArray, rect2D, and rect2DArray types
    *   [LayoutGroup](/docs/references/scenegraph/layout-group-nodes/layoutgroup.md): "custom" alignment value for horizAlignment and vertAlignment to explicitly set translation values for each child layout
    *   [Poster](/docs/references/scenegraph/renderable-nodes/poster.md) node: bitmapMargins - set to an associative array containing margin information for 9-patch images
    *   [Animation](/docs/references/scenegraph/animation-nodes/animation.md): optional - set to true to skip animations on lower performing devices
    *   [Functional Fields](/docs/developer-program/core-concepts/handling-application-events.md#HandlingApplicationEvents-FunctionalFields)
        
        *   procedural functions that can be called on components directly
    *   [Overhang](/docs/references/scenegraph/sliding-panels-nodes/overhang.md) - added optionsText and optionsMaxWidth to customize the text next to the options (![roku815px - (star)](images/icons/emoticons/star_yellow.png)) symbol
    *   [RowList](/docs/references/scenegraph/list-and-grid-nodes/rowlist.md): rowTitleComponentName - specify an XML component to render text in place of the row label
    *   findNode() arguments and nodeType fields are now case insensitive
    *   ChannelStore node commands have been serialized to ensure that one command finishes before the next begins
    *   Components in [Component Libraries](/docs/references/scenegraph/control-nodes/componentlibrary.md) can be extended
    *   Component Libraries can be unsigned if delivered over HTTPS
    *   New [Dialog](/docs/references/scenegraph/dialog-nodes/dialog.md) fields: titleColor, titleFont, numberedBullets, bulletText, graphicWidth, graphicHeight, width, maxHeight
    *   New [ifSGNodeField](/docs/references/brightscript/interfaces/ifsgnodefield.md) methods: observeFieldScoped(), unobserveFieldScoped()

#### BrightScript updates

*   New components:
    
    *   [roAudioGuide](/docs/references/brightscript/components/roaudioguide.md) [ifAudioGuide](/docs/references/brightscript/interfaces/ifaudioguide.md)

*   Updated components:
    
    *   ifChannelStore: [GetIdentity()](/docs/references/brightscript/interfaces/ifchannelstore.md#getidentity-as-integer) - returns a unique number for this object that can be used to identify whether events originated from this object by comparing with [roChannelStoreEvent](/docs/references/brightscript/events/rochannelstoreevent.md).GetSourceIdentity().
    *   [ifTuner](/docs/references/brightscript/interfaces/iftuner.md#getchannelinfo-channel_id-as-string-asobject): GetChannelInfo().delivery\_system, source\_data.network\_id, source\_data.transport\_stream\_id
    *   ifAppManager: [SetAutomaticAudioGuideEnabled(enabled as Boolean)](/docs/references/brightscript/interfaces/ifappmanager.md#setautomaticaudioguideenabledenabled-as-boolean-as-void)
        
        *   enable/disable automatic Audio Guide and override any manifest setting
    *   Content Meta-Data - [Playback Configuration Attributes](/docs/developer-program/getting-started/architecture/content-metadata.md#playback-configuration-attributes):
        
        *   ForwardQueryStringParams - controls whether query string parameters from initial HLS stream manifest requests are forwarded to subsequent segment download requests
        *   IgnoreStreamErrors - continue playback when encountering any streaming related errors
        *   AdaptiveMinStartBitrate - minimum startup bitrate to start streaming with a variant equal to or greater than the value specified
        *   AdaptiveMaxStartBitrate - maximum startup bitrate to start streaming with a variant less than or equal to the value specified
        *   PlayStart - cannot be overridden by a seek operation
        *   BookmarkPosition - can be overridden by a seek operation; this value takes precedence over PlayStart
    *   [roVideoPlayerEvent](/docs/references/brightscript/events/rovideoplayerevent.md):
        
        *   isStreamSegmentInfo.GetMessage() - supports segment information for HLS, DASH, and Smooth streams
        *   isRequestFailed().GetInfo():
            
            *   ClipIdx - The zero starting index of the item in the content list this event is related to
            *   Ignored - true if the error was ignored and the player skipped to the next item in the content list
        *   isPlaybackPosition().GetInfo():
            
            *   ClipIdx - The zero starting index of the item in the content list this event is related to
            *   ClipPos - player position relative to the start of the clip in milliseconds
    *   [ifVideoPlayer](/docs/references/brightscript/interfaces/ifvideoplayer.md):
        
        *   [Play()](/docs/references/brightscript/interfaces/ifvideoplayer.md#play-as-boolean)
            
            *   starts playback at the seek position if seek was called prior to play. If seek was not called, the player advances its current position to the next item in the content list and starts playing that item
        *   [Stop()](/docs/references/brightscript/interfaces/ifvideoplayer.md#stop-as-boolean)
            
            *   stops playback and resets the seek position, keeping the player’s current position unchanged
        *   [SetContentList()](/docs/references/brightscript/interfaces/ifvideoplayer.md#setcontentlistcontentlist-as-object-as-void)
            
            *   Resets the current player position, the next time Play() is called playback will start at the first item of the content list (Unless Seek() is called prior); prefetching updates
    *   [ifDeviceInfo](/docs/references/brightscript/interfaces/ifdeviceinfo.md):
        
        *   [EnableScreensaverExitedEvent()](/docs/references/brightscript/interfaces/ifdeviceinfo.md#enablescreensaverexitedeventenable-as-boolean-as-dynamic) - set to true to enable events to indicate when the user has exited the screensaver
        *   [IsAudioGuideEnabled()](/docs/references/brightscript/interfaces/ifdeviceinfo.md#isaudioguideenabled-as-dynamic)\- returns true if Audio Guide is enabled on a supported device
        *   [EnableAudioGuideChangedEvent()](/docs/references/brightscript/interfaces/ifdeviceinfo.md#enableaudioguidechangedeventenable-as-boolean-as-dynamic)\- set to true to receive Audio Guide events
    *   [roDeviceInfoEvent](/docs/references/brightscript/events/rodeviceinfoevent.md):
        
        *   GetInfo().audioGuideEnabled
        *   GetInfo().exitedScreensaver
    *   [ifStringOps](/docs/references/brightscript/interfaces/ifstringops.md): Escape(), Unescape(), EncodeUri(), DecodeUri(), EncodeUriComponent(), DecodeUriComponent()
    *   [ifTextToSpeech](/docs/references/brightscript/interfaces/iftexttospeech.md): GetRate(), SetRate(), GetPitch(), SetPitch()
    *   [ifAssociativeArray](/docs/references/brightscript/interfaces/ifassociativearray.md): Items()
        
        *   Returns an array containing the associative array key/value pairs in lexicographical order of key. Each item is in the returned array is an associative array with 'key' and 'value' fields.

#### New [manifest](https://github.com/rokudev/docs/blob/master/develop/specifications/manifest.md) entries

*   automatic\_audio\_guide\_disabled: disable Audio Guide within an app
*   usb\_media\_handler: auto launch apps when a USB device is inserted
*   rsg\_version: change the type of [observer callback model](/docs/developer-program/core-concepts/handling-application-events.md#HandlingApplicationEvents-ObserverCallbackModels) used

#### BrightScript debugger updates

*   Port 8085 now provides context for all threads and port 8089-8093 will no longer be used.
    
    *   STOP, breaks, and continue will stop/resume all threads. Prior to 7.5, only one thread would stop/resume.
    *   See the overview on [Debugging SceneGraph applications](https://github.com/rokudev/docs/blob/master/develop/guides/debugging.md#scenegraph-applications) for more details.
*   New 8085 commands:
    
    *   threads: list all current executed suspended threads
    *   thread <id>: select a suspended thread to debug
*   New 8080 commands:
    
    *   loaded\_textures: display the current set of images loaded into texture memory
    *   sgversion: change the [observer callback model](/docs/developer-program/core-concepts/handling-application-events.md#HandlingApplicationEvents-ObserverCallbackModels)

#### External Control Protocol additions

*   [Roku TV commands](/docs/developer-program/dev-tools/external-control-api.md): query/tv-channels, query/tv-active-channel, launch/tvinput.dtv
*   [search commands](/docs/developer-program/dev-tools/external-control-api.md): query and launch Roku Search-driven content

#### Media Player updates

*   Fast Video Start can now prebuffer from non-zero positions, allowing for prebuffering of content in “Continue Watching” lists
*   Live DASH streaming support
*   The Roku MediaPlayer now automatically detects and plays a video even if the file type is not specified. All major file types — HLS, DASH, Smooth and MP4 — are detected
*   Video player automatically scales when changing to a different stream with different aspect ratios

Roku OS 7.2
-----------

**Initial rollout date:** June 21, 2016

This release adds two notable features. A text to speech feature has been added to allow all Roku applications to provide audible spoken versions of the user interface. Also, an option to buffer a video stream without actually playing it is now included, to provide a "fast start" video playback capability to your applications. You can use this option to begin buffering the video stream while a user is reading a description of the video, and then start the actual playback when the user selects it. Roku SceneGraph also supports this new option, as well as built-in support for Audio and Video node playlists, improved HTTPS support, improved debugging, and several other new features.

#### SceneGraph updates

*   A prebuffer option has been added to the control field of the Audio and Video nodes to allow buffering of media playback prior to the user starting the media item ([Audio](/docs/references/scenegraph/media-playback-nodes/audio.md), [Video](/docs/references/scenegraph/media-playback-nodes/video.md), [Playing Videos](Playing-Videos_1608528.html)).
*   Screensavers can now be created in SceneGraph ([Screensavers](/docs/developer-program/media-playback/screensavers.md)).
*   New debugging commands are available ([Debugging SceneGraph Applications](Debugging-SceneGraph-Applications_3736509.html), [ifSGNodeChildren](/docs/references/brightscript/interfaces/ifsgnodechildren.md)).
*   The ChannelStore node class has been added for in-app purchase support in SceneGraph applications ([ChannelStore](/docs/references/scenegraph/control-nodes/channelstore.md)).
*   The Task node has been modified ([Task](/docs/references/scenegraph/control-nodes/task.md), [SceneGraph Threads](/docs/developer-program/core-concepts/threads.md)).
*   A bufferingStatus field has been added to the Audio node ([Audio](/docs/references/scenegraph/media-playback-nodes/audio.md)).
*   Timed meta-data is now supported for both Audio and Video node playback ([Audio](/docs/references/scenegraph/media-playback-nodes/audio.md), [Video](/docs/references/scenegraph/media-playback-nodes/video.md)).
*   Audio and Video nodes now have built-in support for playlists that can play several media items in sequence ([Audio](/docs/references/scenegraph/media-playback-nodes/audio.md), [Video](/docs/references/scenegraph/media-playback-nodes/video.md)).
*   HTTPS support is now available for all SceneGraph nodes ([roHttpAgent](/docs/references/brightscript/components/rohttpagent.md)).
*   A MaxVideoDecodeResolution field has been added to the Video node ([Video](/docs/references/scenegraph/media-playback-nodes/video.md)).
*   New fields have been added to the Video node to allow customizing the internal ProgressBar node ([Video](/docs/references/scenegraph/media-playback-nodes/video.md)).
*   New fields have been added to the Video node to allow customizing the internal TrickPlayBar node ([Video](/docs/references/scenegraph/media-playback-nodes/video.md)).
*   The order of field setting of component-based lists and grids has changed ([MarkupList](/docs/references/scenegraph/layout-group-nodes/markuplist.md), [MarkupGrid](/docs/references/scenegraph/list-and-grid-nodes/markupgrid.md), [RowList](/docs/references/scenegraph/list-and-grid-nodes/rowlist.md)).
*   Several new methods have been added to the ifSGNodeChildren interface ([ifSGNodeChildren](/docs/references/brightscript/interfaces/ifsgnodechildren.md)).

#### Component updates

*   roVideoPlayer and roVideoScreen interface Prebuffer() method added to allow buffering of video playback prior to the user starting the video ([ifVideoPlayer](/docs/references/brightscript/interfaces/ifvideoplayer.md), [ifVideoScreen](/docs/references/brightscript/interfaces/ifvideoscreen.md), [Fast Video Start](Fast-Video-Start_4262645.html)).
*   A text-to-speech component has been added to support audible spoken versions of the user interface ([roTextToSpeech](/docs/references/brightscript/components/rotexttospeech.md), [ifTextToSpeech](/docs/references/brightscript/interfaces/iftexttospeech.md), [roTextToSpeechEvent](/docs/references/brightscript/events/rotexttospeechevent.md), [Text to Speech](/docs/developer-program/media-playback/text-to-speech.md)).
*   New methods have been added to roUniversalControlEvent that improve distinguishing between remote control and keyboard key presses, and the key press and release events ([roUniversalControlEvent](/docs/references/brightscript/events/rouniversalcontrolevent.md)).

#### BrightScript debugger updates

*   Commands to step over and out of functions have been added ([Debugging Your Application](/docs/developer-program/debugging/debugging-channels.md)).
*   Special commands to debug SceneGraph applications have been added ([Debugging SceneGraph Applications](Debugging-SceneGraph-Applications_3736509.html)).

Roku OS 7.1
-----------

**Initial rollout date:** April 5, 2016

The 7.1 firmware release incorporates several BrightScript and BrightScript component improvements. There is now support for playing broadcast and cable content on a Roku TV which includes a tuner. SceneGraph has numerous improvements to the Video node, and new capabilities such as passing global data between components, passing parameters to callback functions, localization, and downloading libraries of SceneGraph components.

#### SceneGraph updates

*   Libraries of SceneGraph components can now be loaded and used at the start of a SceneGraph application ([**ComponentLibrary**](/docs/references/scenegraph/control-nodes/componentlibrary.md))
*   SceneGraph components can now be extended from other custom components ([**Creating Custom Components**](Creating-Custom-Components_4260778.html)).
*   A `uri` field type has been added to better support URL resolution and features like certificates and cookies ([**Content Meta-Data**](/docs/developer-program/getting-started/architecture/content-metadata.md)).
*   Support for localization/internationalization string translations and automatic localized graphic image insertion ([**SceneGraph Localization**](/docs/developer-program/core-concepts/localization.md)).
*   Automatic scaling of image files to a specified size on download, with aspect ratio preserving options ([**Poster**](/docs/references/scenegraph/renderable-nodes/poster.md), [**PosterGrid**](/docs/references/scenegraph/list-and-grid-nodes/postergrid.md)).
*   Parameters can now be passed to observer callback functions ([**ifSGNodeField**](/docs/references/brightscript/interfaces/ifsgnodefield.md)).
*   Global application data can now be more easily shared between components, using an `m.global` object reference ([**SceneGraph Data Scoping**](/docs/developer-program/core-concepts/data-scoping.md)).
*   Support for node identity comparison ([**ifSGNodeDict**](/docs/references/brightscript/interfaces/ifsgnodedict.md)).
*   Support for dynamic additions to interface fields for all nodes, allowing all node fields to be observed ([**ifSGNodeField**](/docs/references/brightscript/interfaces/ifsgnodefield.md), [**Node**](/docs/references/scenegraph/node.md)).
*   Video node class includes several new fields to configure trick play and other playback features ([**Video**](/docs/references/scenegraph/media-playback-nodes/video.md)).
*   Focus indicators for list and grids can now be customized by blending the indicator colors ([**ArrayGrid**](/docs/references/scenegraph/abstract-nodes/arraygrid.md)).
*   New XML markup component interfaces:
    
    *   onChange takes an associative array and a function name (**[<interface>](interface_1608549.html)**)
    *   calling functions from an associative array is now supported (**[<interface>](interface_1608549.html)**)

#### BrightScript language updates

added increment (`++`) and decrement (`–`) operators to allow integer increment and decrement operations to have effect on a variable ([**Expressions, Variables, and Types**](/docs/references/brightscript/language/expressions-variables-types.md))

added the following assignment operators to support mathematical and bitshift operations with numeric operands ([**Expressions, Variables, and Types**](/docs/references/brightscript/language/expressions-variables-types.md)):

*   +=
*   \-=
*   \*=
*   /=
*   \\=
*   <<=
*   \>>=  
    

ReadAsciiFile() now supports UTF-16 files ([**Global Utility Functions**](/docs/references/brightscript/language/global-utility-functions.md))

#### BrightScript language fixes

*   Print now always explicitly prints the component type for enumerable objects. Previously, it would just print the contents of enumerable objects, and did not identify the container object itself, which could lead to confusion ([**Program Statements**](/docs/references/brightscript/language/program-statements.md)).
    
*   Print and FormatJSON no longer have side effects on enumation state when accessing enumerable objects (associative array, array, list, and so forth) ([**Program Statements**](/docs/references/brightscript/language/program-statements.md), [**Global Utility Functions**](/docs/references/brightscript/language/global-utility-functions.md))
    
    Example:
    
    aa={a:2,b:1,c:3} : for each x in aa : print x;" from ";aa : end for
    
    Previously:
    
    a from ' ...
    
    Now:
    
    a from ' ...  
    c from ' ...  
    b from ' ...
    

#### Component changes

*   roTuner and associated interfaces have been added to support playing broadcast and cable content from a tuner (**[roTuner](/pages/createpage.action?spaceKey=sdkdoc&title=roTuner&linkCreation=true&fromPageId=1611545)**)
*   roProgramGuide and associated interfaces have been added to support broadcast content program guide data (**[roProgramGuide](/pages/createpage.action?spaceKey=sdkdoc&title=roProgramGuide&linkCreation=true&fromPageId=1611545)**)
*   roSlideShow SetLoop added (**[roSlideShow](/docs/references/brightscript/components/roslideshow.md)**)
*   roTextureManager ifHttpAgent added (**[roTextureManager](/docs/references/brightscript/components/rotexturemanager.md)**)
*   roUrlTransfer GetToString(), AsyncGetToString() now support UTF-16 files (**[roUrlTransfer](/docs/references/brightscript/components/rourltransfer.md)**)
*   roAppManager/ifAppManager SetUserSignedIn() method added to indicate that a user has signed into the app (**[roAppManager](/docs/references/brightscript/components/roappmanager.md)**)
*   roArray/ifArraySort Sort() method was added (**[roArray](/docs/references/brightscript/components/roarray.md)**)
*   roArray/ifArraySort SortBy() method was added (**[roArray](/docs/references/brightscript/components/roarray.md)**)
*   roArray/ifArraySort Reverse() method was added (**[roArray](/docs/references/brightscript/components/roarray.md)**
*   roString/ifStringOps Split() method was added (**[roString](/docs/references/brightscript/components/rostring.md)**)

Roku OS 7.0
-----------

**Initial rollout date:** November 6, 2015

##### SceneGraph XML API

A new user interface programming API has been added. Information on this new API can be found in:

*   [SceneGraph XML Guide](/docs/developer-program/core-concepts/scenegraph-xml/overview.md)
*   [SceneGraph Reference](/docs/developer-program/core-concepts/core-concepts.md)
*   [SceneGraph XML Tutorial](/docs/developer-program/core-concepts/xml-components/overview.md)

#### Roku Search and follow

Users can now follow content from the Roku homescreen **Search** in addition to **My Feed**. This allows you to have users who choose to follow a particular search term (a movie, director, or an actor) to receive automatic updates when your latest content includes that term.

#### Roku 4 support

Support is now included for the Roku 4 Streaming Media Player. This Roku Player features greatly enhanced video resolution output up to 2160p (ultra-high definition, or UHD). This Roku Player also allows the creation and use of user interfaces with 1080p (full high-definition, or FHD) resolution. The Roku 4 Streaming Media Player includes a much more powerful quad core ARM processor and decoding support for the HEVC (high-efficiency video code) codec to allow efficient streaming of 2160p video content.

#### ECP install command

An install command has been added to the ECP to allow deep-linking to uninstalled apps.

#### BrightScript language

*   Associative array literals can now specify key names as string literals (quoted strings).
*   added aa.Keys to return the keys for an associative array
*   added a 64-bit LongInteger type

#### BrightScript components

**roAssociativeArray**

*   added Function Keys() As Object

**roDeviceInfo**

*   added Functions [CanDecodeVideo()](/docs/references/brightscript/interfaces/ifdeviceinfo.md#candecodevideovideo_format-as-object-as-object), [CanDecodeAudio()](/docs/references/brightscript/interfaces/ifdeviceinfo.md#candecodeaudioaudio_format-as-object-as-object), and [GetDrmInfo()](/docs/references/brightscript/interfaces/ifdeviceinfo.md#getdrminfo-as-object) to [ifDeviceInfo](/docs/references/brightscript/interfaces/ifdeviceinfo.md) interface.

Roku OS 6.2
-----------

**Initial rollout date:** April 9, 2015

#### Roku Advertising Framework

*   Added the [Roku Advertising Framework](/docs/developer-program/advertising/roku-advertising-framework.md) to natively integrate advertising capabilities

#### BrightScript language

*   Now supports embedded quotation mark characters in string literals

#### BrightScript components

##### ifDateTime changes

*   Added [GetDayOfWeek()](/docs/references/brightscript/interfaces/ifdatetime.md#getdayofweek-as-integer) as Integer
*   Added [GetTimeZoneOffset()](/docs/references/brightscript/interfaces/ifdatetime.md#gettimezoneoffset-as-integer) as Integer
*   Added [ToISOString()](/docs/references/brightscript/interfaces/ifdatetime.md#toisostring-as-string) as String

##### ifDraw2D changes

*   Added [DrawPoint(x as Integer, y as Integer, size as Float, rgba as Integer) as Void](/docs/references/brightscript/interfaces/ifdraw2d.md#drawpointrgba-as-integer-size-as-float-x-as-integer-y-as-integer-as-void)

Roku OS 6.1
-----------

**Initial rollout date:** December 4, 2014

#### BrightScript language

*   now supports integer division operator '\\'
*   now supports integer bitshift operators '<<' and '>>'
*   roAssociativeArray Count function was added
*   parameter validation diagnostics have been added to core components
*   roString Replace method was added.
*   ParseJSON bug fixes
*   FormatJSON bug fixes
*   global function FindMemberFunction was added.
*   floats are now auto-boxed for method calls
*   global function Val has a new overload for parsing from hexadecimal strings etc.
*   global function StrI has a new overload for formatting hexadecimal strings etc.

#### BrightScript debugger

*   bscs 'Summarize BrightScript Component instances' command was added
*   brkd 'Break on BrightScript diagnostics' command was added

#### BrightScript components

##### roDeviceInfo changes

*   Added Function GetModelDetails() As Object
*   Added Function GetFriendlyName() As String
*   Added Function GetCreationTime(Void) As String
*   Added Function GetAudioDecodeInfo(Void) As Object
*   Added Function GetVideoDecodeInfo(Void) As Object
*   Added Function GetAdvertisingId(Void) As String
*   Added Function IsAdIdTrackingDisabled(Void) As Boolean
*   Added Function GetPublisherId(Void) As String
*   Added Function GetRandomUUID(Void) As String

##### roMessageDialog changes

*   Added Function UpdateButton(id As Integer, title As String) As Boolean

Roku OS 5.4
-----------

**Initial rollout date:** April 14, 2014

#### New in this release

*   Two new content metadata structures for controlling closed captions: SubtitleConfig and SubtitleTracks. Details of how to use these to control captions [can be found here](/docs/developer-program/media-playback/closed-caption.md).
*   Two new caption renderer functions for retrieving all caption tracks in a stream and for setting the current track: ifCaptionRenderer.GetSubtitleTracks() and ChangeSubtitleTrack(). Details about these two new functions [can be found here](/docs/references/brightscript/interfaces/ifcaptionrenderer.md#getsubtitletracks-as-object).
*   Bug fix: On the 2450X and 2500X platforms, the ifChannelStore.DoOrder() function was always returning false even if the corresponding purchase was successful.

Roku OS 5.3
-----------

**Initial rollout date:** December 17, 2013

Version 5.3 introduced user configurable closed caption settings. The Roku settings UI now includes controls for turning captions on or off at the system level. These settings control closed caption behavior for all apps. Closed captions on instant replay are also controlled from these settings.

Roku OS 5.2
-----------

**Initial rollout date:** October 8, 2013

Version 5.2 introduced a new security model for sideloading apps. Accessing the web interface for the device now requires a userid and password to log in. Please see the article here for more details: [http://blog.roku.com/developer/2013/10/08/security-enhancements-added-to-channel-development](http://blog.roku.com/developer/2013/10/08/security-enhancements-added-to-channel-development)

#### New in this release

*   Security enhancements to app sideloading
    
*   roListScreen.SetUpBehaviorAtTopRow()
    
*   Closed Captioning support added to roVideoPlayer, roCaptionRenderer added
    
*   HLS ID3 events added to BrightScript
    

Roku OS 5.1
-----------

**Initial rollout date:** August 5, 2013

#### New in this release

*   In-stream 608 captions support
    
*   updates to roVideoScreen events
    
*   FLAC container support (local playback)
    

Roku OS 5.0
-----------

**Initial rollout date:** June 5, 2013

Version 5.0 of the Roku OS was released to all second and later generation devices. The home screen introduces a completely new look and feel for navigating my apps, the app store, and settings. This release does not introduce any new screens or templates to the SDK.

#### New in this release

*   Updated home screen user interface
    
*   Increase Brightscript function limit beyond 1024
    
*   Miscellaneous fixes for gaming remotes
    
*   Memory improvements to the OS
    
*   Improved ECP security
    

Roku OS 4.9
-----------

**Initial rollout date:** November 12, 2012

#### New in this release

*   Roku billing - in-app subscription support in BrightScript
    
*   SMPTE TT CC (MP4, HLS, Smooth Streaming)
    
*   RoTextureManager 2D component
    

Roku OS 4.8
-----------

**Initial rollout date:** July 3, 2011

We've had our heads down working diligently on new firmware features and supporting new hardware. Hello Streaming Stick! In v4.8, we have some new developer SDK features to share with you. We are continuing our Roku OS version numbering scheme with v3.1 currently released to all "Classic" or "Roku1" models and major version 4.8 coming soon to all Roku2 models.

We are maturing as a company, and with that comes new legal requirements. In v4.8, we are asking our development community to agree to the development terms directly on the box before it can sideload and apps. As soon as your developer mode box updates to v4.8, you may find you are unable to sideload apps. You will need to re-enable developer mode by entering the following remote control sequence: 3x Home, 2x Up, Right, Left, Right, Left, Right. After entering "Enable Installer" on the secret screen, it will present you with the developer terms that you must read and scroll through and then click down to "I Agree". The box will then reboot with the sideloading installer enabled.

The Roku Team

#### New in this release

*   Internationalization and Localization support. (Currently localizing to en\_US, fr\_CA, es\_ES, de\_DE)
*   Smooth Streaming with PlayReady Support
*   In-app purchasing of new content, upgrades, features.
*   Native, fast [ParseJSON()](/docs/references/brightscript/language/global-utility-functions.md#parsejsonjsonstring-as-string-as-object) function.

#### Compatibility issues

Remember to re-enable developer mode in v4.8!

Roku OS 4.1
-----------

**Initial rollout date:** December 21, 2011

With v4.1, Roku is now supporting the “Roku 2” generation of boxes. We’ve tried to keep the Roku SDK compatible across all the different models and have highlighted hardware and SDK differences in a new Section 1.4 of the Developer Guide. Our Roku OS version numbering requires a little explanation as major version 3 is currently released to all “Classic” models and major version 4 is release to all “Currently Selling” models. We continue to have minor releases planned on both of these major release branches. All features from the v3.0 beta have made it into the final v3.0 and 4.1.

We understand that we haven’t exposed all the functionality the Roku 2 platform has to offer to the entire Roku Developer Community. Roku has a good track record of taking security issues seriously. There are many such issues to work through before we can expose low level OpenGL interfaces in a secure manner that the content owners in our community are also comfortable with. We are working diligently toward that end.

We appreciate all the hard work the Roku Developer Community has put into developing some great applications on the Roku platform. We are happy that the Roku 2 has been well received by the market and are looking forward to continued shared success with the Roku Developer Community and all the great new apps you can create.

#### New in this release

• Roku 2 platform support.  
• Brightscript Plugin for Eclipse  
• Updated videoPlayer sample application  
• All v3.0 beta features are now fully supported on classic models running v3.0 and Roku 2 models running v4.1:

*   BrightScript v3.0 that includes:
    
    *   performance improvements
    *   typed values in function parameters and returns
    *   improved auto-boxing and type promotion
    *   explicit programmer controlled garbage collection
    *   better statement stepping in source level debugger
    *   collections can include intrinsic values rather than only objects
    *   2D Graphics APIs:  
        • roScreen  
        • roBitmap  
        • roRegion  
        • roCompositor  
        • roSprite  
        • roAudioResource  
        • roFont  
        • roFontRegistry  
        • roFontMetrics
*   New Platform Components
    
    *   roSocketAddress
    *   roStreamSocket
    *   roDataGramSocket
*   New ECP “input” command to pass user defined input parameters to your app.

#### Compatibility issues

Please note that we have deprecated support for Macrovision and WMV video. We still have support for CGMS (Copy Guard Management System) protection for analog outputs and HDCP protection for digital output. There has been very little use of WMV video, and if anyone has content out there it can be converted to MP4 with several transcoding applications, including ffmeg (please see our encoding guide for example usage).

Roku OS 3.0
-----------

**Initial rollout date:** April 18, 2011

We’re making the 3.0 Beta firmware available to all developers who request it. If your box isn’t already part of the developer beta group, send a private developer forum message to RokuKevin. Include the serial number of the Roku units you would like to run the 3.0 beta on.  
It is very important that all developers regression test their applications on version 3.0 and note any incompatibilities. You may need to publish an update to your application to make it compatible with v3.0.

There are some exciting new features in the v3.0 SDK that will support developers building 2D games for the Roku box. We encourage all game developers to support both HD and SD modes. About half of the Roku’s out there still run in SD mode. We’ve added screen level scaling to support developers using one set of graphics assets and a single game engine running in both HD and SD modes. Although v3.0 has not been released to end users yet, we are now encouraging discussion about v3.0 features on the developer forum.

#### New in this release

*   BrightScript v3.0 that includes:
    
    *   performance improvements
    *   typed values in function parameters and returns
    *   improved auto-boxing and type promotion
    *   explicit programmer controlled garbage collection 
    *   better statement stepping in source level debugger
    *   collections can include intrinsic values rather than only objects
    *   2D Graphics APIs:
        
        *   roScreen
        *   roBitmap
        *   roRegion
        *   roCompositor
        *   roSprite
        *   roAudioResource
        *   roFont
        *   roFontRegistry
        *   roFontMetrics
*   New Platform Components
    
    *   roSocketAddress
    *   roStreamSocket
    *   roDataGramSocket
*   New ECP “input” command to pass user defined input parameters to your app.

The new 2D Graphics components are considered part of the core BrightScript language and are documented in the BrightScript Reference. The new platform components are documented in the Component Reference. New v3.0 components have their own sections and new methods on previously existing components are called out with their own “Since v3.0” sections.

#### Compatibility issues

BrightScript v3.0 is stricter in some ways than BrightScript v2.0. Areas in your app with variables that are used before initialized, or return statements that return a different type than specified in the function declaration may cause runtime errors in v.30 that may have run successfully in v2.0.

It is very important that all developers regression test their applications on version 3.0 and note any incompatibilities. You may need to publish an update to your application to make it compatible with v3.0.

Roku OS 2.9
-----------

**Initial rollout date:** March 31, 2011

With the release of firmware v2.9 build 1553, we are excited to share our latest Developer documentation. We have added several new features that developers can take advantage of. Many of you have already seen the new Premium Developer Program. With a premium developer account you can charge for applications in the Roku app store and Roku will handle the billing for you. To sign up for a premium developer account you simply need to provide your tax id and agree to the new terms and conditions. Our new v2.9 SDK helps support paid applications with the ability to launch the app store to purchase your application. You can create a free “Lite” app that includes a banner ad that up-sells to a premium app. When the user clicks on the ad, the “Buy” page is launched in the app store. There is an example of this in the roPosterScreen section of the component reference.

Please refer to the Component Reference Section 7 for an introduction to the two new components in v2.9. The roAudioMetadata component gives you access to metadata included in many audio files. It recognizes ID3 tags and supports cover art. The roImageMetadata component gives you access to metadata in image files.

Version 2.9 updates the grid component by letting the developer control the “Up” button behavior and giving developers the ability to stack grid screens without a lot of extraneous code.

Thanks for all you’ve developed so far. We’re looking forward to all the new ones you’re busy working on.

The Roku Team

#### New in this release

*   MKV playback on local USB devices.
*   Developer control of the Up button behavior on the top row of the Grid Screen.
*   Stackable Grid Screens.
*   Streaming Store can be launched to purchase “Premium” app from within “Lite” app
*   Get ID3 tags and other metadata from your audio files
*   Get EXIF and other metadata from your image files

New v2.9 components have their own section in the reference and new methods on previously existing components are called out with their own “Since v2.9” sections.

Roku OS 2.8
-----------

**Initial rollout date:** November 18, 2010

It’s been a short time since we last updated you, but we still have a few things worth sharing in this release of the SDK. We’ve added developer specified HLS stream switching strategies, new commands in the External Control API, and customizable GridScreen layouts.

We appreciate your support of the Roku platform and always welcome your feedback.  
The Roku Team

#### New in this release

*   Developer controlled HLS stream switching strategies for improved playback ability.
*   Multiple Grid layouts: flat-movie, flat-portrait, flat-landscape, flat-square, and flat-16x9
*   Developer customized Grid Focused Border image, and Grid Descripton callout box image.
*   Use .png and .gif images as Grid posters.
*   Ability to get the Roku’s IPAddress within your app. This will enable the External Control API to be utilized directly within your app.

New v2.8 components have their own section in the reference and new methods on previously existing components are called out with their own “Since v2.8” sections.

#### Compatibility issues

We have maintained backward compatibility with the v2.7 SDK. Some have experienced video playback issues with their HLS streams. The number one issue was incorrect aspect ratios and resolutions. We’ve addressed most of these issues with a new v2.8 build (1158), but we have requested that any other HLS playback regression issues from v2.7 be posted to a sticky thread on our forum. We will attempt to address them all in a timely manner.

Roku OS 2.7
-----------

**Initial rollout date:** November 7, 2010

This release brings several new features to the Roku SDK, as well as support for the additional hardware capabilities of the new Roku models. The new models add 1080p playback capability and a new 12 button remote control. The new remote control will come with the Roku XD and Roku XDS. The Roku HD will continue to ship a 9 button remote. However, the 12 button remote will be available for purchase separately. The 12 button remote will also work on the older Roku models, providing the installed base access to the new button capabilities with only a remote control purchase. While not all users will have the 12 button remote, we are strongly encouraging developers to add support for the three new remote control buttons.

The “Instant Replay”, is implemented entirely in the Roku OS and will work on all apps during video playback without any changes to developer apps. The “Back” button works by default on most screens, but needs to be enabled on dialogs if the screen close behavior is desired. The “Info” button is intended to provide additional contextual information at various points within apps. It is up to developers to use the new features in the roMessageDialog and support the “Info” button usage pattern of launching context menus and dialogs. We have included a simpleinfo sample app in this release that illustrates the info button usage.

We are also introducing 1080p video playback support on the Roku XD and XDS models. Updated Information on supported encoding resolutions is included in the new Encoding Guide. We encourage developers to add 1080p streaming content at bitrates below 4.0Mbps.

A much anticipated addition to the SDK is the new roGridScreen component which presents the user with a scrolling grid as an alternative to the poster screen interface. The simplegrid sample app demonstrates how to use this new feature.

Below is the complete list of new features in this release.

We appreciate your support of the Roku platform and welcome your feedback.

#### New in this release

*   Support for new Remote Buttons - “Back”, “Instant Replay”, and “Info” buttons support ease of use, better trick play, and contextual menus.
*   1080p playback support – When the user sets his display to 1080p, any content with meta data parameters for FullHD and a FrameRate of 24 or 30 will playback at 1080p 24 fps or 1080p 30 fps.
*   Grid Component – The grid screen enables users to easily navigate large collections of content.
*   External Control Protocol – The ability to control the Roku over the network. It’s now possible to create sophisticated iPhone, Android, and Blackberry apps.
*   Paragraph Screen Default Menu Item – You can now control the button that is highlighted on the paragraph screen so that selection dialogs work as expected.
*   Message Dialog Overlay Support – Expected to be popular when used in conjunction with the “Info” button to display contextual information.
*   Content Meta-Data parameters – New parameters provide more control over video playback: min/max bandwidth, and audio stream selection.
*   New Documentation Guides – The External Control Guide illustrates how to create remote control apps that work over the network. The Encoding Guide gives useful guidelines for encoding video content that is compatible with the Roku Streaming Player.
*   Simpleinfo sample application - shows how to use the roMessageDialog with overlay on top of a roPosterScreen when the “Info” button is pressed.
*   SimpleGrid sample application – shows how to use the roGridScreen component to display many rows of items.
*   AudioApp sample application – adds an application screensaver.

New v2.7 components have their own section in the reference and new methods on v2.4 components are called out with their own “Since v2.7” sections.

#### Compatibility issues

We have maintained backward compatibility with the v2.7 SDK. However, developers need to be aware of the new hardware models and update their apps to take advantage of the new features. If your back end services do any type of authentication based on model numbers, or you have any code that is based on model numbers you will need to update your code.

If any of your BrightScript code is enabling certain features based on model number, we have a new roDeviceInfo.HasFeature() method that will enable you to code this logic in a more forward-looking manner.If you don’t account for the new “Back” and “Info” buttons in your code, users may think your app does not behave correctly.

On most screens, the back button will automatically send an event that matches the isScreenClosed() predicate. However, this behavior would break many modal dialogs that do not expect to receive an isScreenClosed()event because they are waiting for a state change or reacting to user input that must be answered. We chose not to break these apps and instead did not enable the back button by default on the roMessageDialog component. We did provide a method to enable the back button on roMessageDialogs that can successfully handle an isScreenClosed() event. You should survey your app for any roMessageDialog components that should enable the back button with EnableBackButton(true). The “Info” button will enable you to pop-up any screen of your choosing. There are two new events added to support this new button. Events matching isButtonInfo()return the button focus of any on screen buttons in when the Info remote key is pressed. Events matching isListItemInfo()return the index of the focused poster when the Info remote key is pressed. The simpleinfo sample application shows basic support for the “Info” button that also demonstrates an overlay dialog on a poster screen. When isRemoteKey()events are propogated to your script, the event.GetIndex() for the Info key is 10.

Roku OS 2.6
-----------

**Initial rollout date:** June 28, 2010

The 2.6 SDK release adds a number of new components to the Roku Platform SDK and introduces a new user interface for developers on the Streaming Store for managing your apps.

The Streaming Store Developer Site now provides support for managing application dependencies based on minimum required Roku OS version or hardware capabilities. For example, if your application requires the features of a specific firmware release or a hardware feature, you can specify this dependency and ensure your application is only published to the correct systems. We recommend studying the App Packaging and Publishing Guide for more information about the Streaming Store versioning support.

We have added a number of new components to the SDK and expanded the API’s for some of our existing components. Be sure to check out the new roImageCanvas component, which allows much greater freedom for laying out custom types of screens. We’ve also added API’s to open up the USB port on the Roku XR for developers, support for HTTP Live Streaming, plus many other new features.

We hope you enjoy these new features and we’re anxious to see the new types of applications that you develop with these capabilities. Thanks again for your support.

#### Compatibility issues

The 2.6 SDK release adds additional events. Please be sure your event loops ignore unknown events. If your code is exiting event loops rather than just ignoring unknown events your application may have undefined behavior.

Important Notes

*   Please review the App Packaging and Publishing guide for more information about the new versioning support and how it impacts your application deployments in the Streaming Store.
*   We have changed the behavior of the Home remote control key. In v2.6, it now immediately kills your application and returns to the home screen. If your app was previously relying on a graceful application exit to do cleanup and bookkeeping, you will need to modify your application. You will want to modify your app to periodically update playback positions, positions in poster screens, search results, etc. This should not wait until application exit, as that could happen to you at any time.

#### New in this release

*   HTTP Live Streaming (HLS) – This is Roku’s implementation of Apple’s adaptive bitrate streaming solution. This feature provides support for both windowed, “live” and adaptive bit-rate VOD streaming capabilities.
*   Image Canvas Screen – A clean slate for creating custom screens. This object will allow you to place text and graphics wherever on the screen you desire. You can see an example in the SDK clock sample app.
*   Custom Font Support – Include your own TrueType (TTF) or Open Type (OTF) fonts in your application for use on the Image Canvas.
*   CA-Cert Bundle – For applications that refer to many different feeds, we’ve included a collection of CA-Certs that is the trusted set from the Firefox browser in a common filesystem. Any application can now easily trust this same set without increasing the size of its package.
*   Customizable Video Player – A video player that allows you play a video in a region on the screen and/or programmatically control playback. When used in conjunction with Image Canvas, you can combine video, images and text on a single screen.
*   USB support – For those of you that have Roku XR boxes or want to develop applications that make use of USB storage. Basic support for USB hotplug events and automounting of USB volumes is included in v2.6. Support for a variety of USB devices and the VFAT, NTFS, HFS and HFS Plus file systems.
*   File System access – You will be able to enumerate available file systems and access the content stored on them.
*   SRT subtitle support – If the content you are playing has an available SRT file for subtitles, enabling subtitle display will be as simple as specifying a path to the SRT file.
*   ScreenSavers – Create standalone screen saver applications that can run whenever the Roku Streaming Player is idle or create a custom screen saver for your app.
*   Perl-Compatible Regular Expressions – String manipulation just got a whole lot easier!
*   Application Logging Support – It’s now easier to gather statistics in your application and send them back to your own logging server.

There are lots of other changes in this release and these are just some highlights that we wanted to specifically mention. Please check the Component Reference for additional details. New v2.6 components have their own section in the reference and new methods on v2.4 components are called out with their own “Since v2.6” sections.

Roku OS 2.4
-----------

**Initial rollout date:** December 17, 2009

This release unites our Streaming Store development activities with the SDK. There are a few implications for developers during the transition that we’d like to highlight. Our legacy applications will not appear on the player until it syncs to our Streaming Store. The Streaming Store is not yet deployed in Production, so Netflix and Amazon will not appear on your player after the upgrade. These apps will eventually reappear on your players as the backend services are upgraded.

We’ve provided this firmware update early so that you have an opportunity to develop with this release before the Streaming Store beta is available. After you update your software build, the only features that will be visible on the home screen will be Settings and any developer application that you’ve installed manually. We plan to distribute at least one more SDK release before we get to feature complete for the launch, so we’re still adding more features and fixes on your behalf. We think that most of these enhancements are things that will be useful to a wide variety of developers.

#### Compatibility issues

There have been significant changes to our file system APIs. We’ve implemented these changes so that they are backward compatible for a limited time. Any deprecated API calls will be displayed in the debugger with a warning message. The samples applications were updated to use the new file specification format. Please refer to the BrightScript and Component Reference manuals for more information. Backward compatibility will be removed in the next release, so please update as soon as possible.

#### Update instructions

The Roku player will automatically update to the new version within the next 1-2 days.

We hope you force your player to download the new version immediately by following these steps  
1) Press the HOME button on the remote control.  
2) Use the arrow keys to highlight the “settings” icon and press the SELECT button.  
3) Press the right arrow several times until you see “player info” and press SELECT.  
4) Highlight “check for update” and press SELECT.  
5) SELECT “yes”.  
5) Wait for the software to download, and then SELECT “ok” to restart.  
Note: If you already have the new version, a message will appear letting you know your version is current.

#### Important notes

*   This release includes new tools for packaging your application for deployment. Included in the SDK is the ChannelPackagingAndPublishing document. This document provides a step-by-step guide to the packaging process. Please be sure to review this document, since it will answer many questions about how applications will be deployed onto the Streaming Store.
*   The Streaming Store linking screen is included in this release and there are a few situations you could encounter it and get stuck. If you reset your box to factory defaults or change your network settings, this could occur. We don’t want you to link your box at this time, so we’ve provided the following instructions to help you bypass this screen if necessary.

Display the secret screen using the following key sequence:

Home 5x, FastForward 3x, Rewind 2x

After pressing this key sequence, the “secret screen” will appear. Select the “cycle channel store server” option until the text “<bypass account linking>” is displayed and then press the “back” button to exit the screen.

The software update options on this screen are controlled via the server and are not functional for developers. Just ignore these options, since they won’t work anyway.

#### New in this release

*   Documentation: There continue to be lots of changes to the documentation set, mostly to the Component Reference manual. The documentation has been reformatted with section numbers to make cross-referencing easier. New features have been added and additional details were provided on some video playback topics. The new file system changes are included as well as lots of API updates. There are several new docs in the set, such as the Channel Packaging and Publishing document mentioned above.
*   More Theme Attributes – We added quite a few more attributes changing colors within the UI. The paragraph and registration screens now support color attributes, as well as font color changes to the buttons and filter banners. These still work the same way as they have in the past and allow you to set an HTML Hex color value to override the default color scheme.
*   Flexible Image Scaling – We’ve added new scaling options for artwork that’s used in the Poster Screen, Slide Show or Banner Ads. The new options allow you to specify how you’d like odd-sized artwork scaled to file the destination area.
*   Image Styles – We’ve added additional styles to several screens for 16x9 and square aspect ratio artwork. There are more changes in the works in this area, which will be coming soon. Many of you have different size and aspect ratio artwork and providing more types of frames, plus better scaling capabilities will help to take advantage of all the existing artwork out there.
*   Display Mode API – Many developers have asked how they can find out the current display mode for the device. Check out the roDeviceInfo component for new APIs to access info about the users display settings.

There are lots of other changes in this release and these are just some highlights that we wanted to specifically mention. Please check the documentation for additional details.

Optimization techniques
=======================

SGNode initialization
---------------------

**Offload Initialization**

Keep init() in the main scene and its static children as minimal as possible. Having too much "upfront" initialization will cause the app to take a long time loading the main scene. Leave as much initialization as possible for the task thread function.

Data flow
---------

**Copying Nodes**

When copying nodes, do not simply call:

    node2.setFields(node1.getFields())
    

Setting nonexistent fields in a node will invoke additional internal verification and warning outputs to the debug console, causing UI lag. Instead, do something like:

    function cloneNode(oldNode as Object) as Object
      newNode = createObject("roSGNode",oldNode.subtype()) 'subtyped node should automatically have all the fields of the original node
      newNode.setFields(oldNode.getFields())
      return newNode
    end function
    

**ContentNode vs. associative arrays**

Use [ContentNode](/docs/references/scenegraph/control-nodes/contentnode.md) fields to represent complex trees of nested data that are expensive to copy, since they will be passed by reference. Use associative arrays to store small, shallow data structs. Associative arrays will be deep-copied through fields (pass-by-value) and has the advantage of keeping parallelization safer and more efficient.

**Avoiding onChange in Task threads**

If you'd like a Task node to execute a function in response to a field change, use the overloaded version of [**observeField()**](/docs/references/brightscript/interfaces/ifsgnodedict.md) to send an roSGNodeEvent to your message port. Do this instead of setting **onChange** in the field you want to watch. While this is certainly not necessary, it might improve visual performance since onChange is usually executed on the render thread.

StdDlgItemGroup
===============

Extends [StdDlgItemBase](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-item-base.md)

The **StdDlgItemGroup** node is used to visually group a set of StdDlgAreaBase child nodes in a custom dialog. Developers can use this node to reduce the vertical spacing between the StdDlgItemBase child nodes. For [**StdDlgActionCardItem**](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-action-card-item.md) nodes, the **StdDlgItemGroup** node enforces the rule that when multiple items **StdDlgActionCardItem** nodes have their **iconType** field set to "radiobutton", only one may have its **selected** status be set to "true".

The **StdDlgItemGroup** node may contain one or more [**StdDlgItemBase**](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-item-base.md) child nodes (for example, StdDlgTextItem, StdDlgGraphicItem, and so on) as its children. It will visually group those child **StdDlgItemBase** nodes by reducing the amount of vertical space between them. However, the primary benefit of the StdDlgItemGroup node is managing **StdDlgActionCardItem** child nodes that have their **iconType** field set to "radiobutton".

![roku815px - actionCards-radio-checkbox-items](https://image.roku.com/ZHZscHItMTc2/actionCards-radio-checkbox-items.jpg)

> See the [**stdDlgActionCardItem** documentation](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-action-card-item.md#radiobutton-icontype) for code demonstarting how to use the **StdDlgItemGroup** node in a custom dialog.

#### Fields

| Field | Type | Default | Access Permission | Description |
| --- | --- | --- | --- | --- |
| selectedIndex | integer | 0   | READ\_WRITE | The index of the currently selected [StdDlgAreaBase](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-area-base.md) child node. This field is updated when the user selects any of the [StdDlgActionCardItem](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-action-card-item.md) child nodes.  <br>  <br>This field can also be updated via BrightScript to change which child node in the StdDlgItemGroup is selected.  <br>  <br>When this field is updated and it corresponds to a [StdDlgActionCardItem](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-action-card-item.md) node that has its **iconType** field set to "radiobutton", the **StdDlgItemGroup** node enforces the "only 1 of _n_" rule for radio buttons by setting the **iconStatus** field of the other radio button action card items to "false". |

Sample app
----------

You can download and install a [sample app](https://github.com/rokudev/standard-dialog-framework) that demonstrates how to create a custom dialog that includes action card items in an item group.

Signup requirements and best practices
======================================

SVOD and TVOD apps (and other subscription services) participating in Roku Pay can maximize subscription revenue by minimizing the number of screens and keypresses in the on-device sign-up workflow. Otherwise, customers may abandon the sign-up workflow if prompted to enter their email address or other personal information in an account creation screen because it requires too many keypresses.

The following graphic demonstrates the standard Roku on-device sign-up workflow, which includes just a maximum of four screens: the landing page, the request for information (RFI) screen, the plan selection screen (if your app has multiple subscription products such as monthly and annual plans), and the order confirmation screen. Using this workflow requires as few as three or four keypresses.

![roku815px - img](https://image.roku.com/ZHZscHItMTc2/sign-up-flow-optimal.gif)

> **Certification requirement**: For SVOD and TVOD apps (and other subscription services) to pass certification, they must use an on-device Roku Pay billing flow. The Request for Information (RFI) screen must be displayed during the on-device sign-up flow to enable customers to share their Roku customer account information with apps. Only if the user declines the request, may apps require the customer to manually enter their information.

Implementing this streamlined user experience involves two different aspects: the on-device sign-up UI and the integrations that support it. This document explains both of these areas.

On-device sign-up UI
--------------------

The on-device sign-up workflow should adhere to the standards and best practices specified in this section. This includes the order of the screens, the copy used in the screens, and when customer information is sent to the app's backend system in order to check for an existing account and create a new one.

For standards and best practices for designing the sign-in UI, see [Sign-in requirements and best practices](/docs/developer-program/roku-pay/signin-best-practices.md).

### Screen order

As explained in the introduction, the on-device sign-up workflow should typically have a maximum of four screens (listed in the recommended order):

1.  **Landing page**. Provides call-to-action for subscribing. Includes entry to the sign-up and sign-in flows.

2.  **RFI screen** (Roku Pay built-in). Enables customers to grant the app access to their Roku account information (name, email address, street address, zip code, phone number, and so on). This makes it so apps can (1) check whether the user has an existing account before the purchase and (2) create a user account in their backend system on the behalf of the customer after the purchase has been completed. Only request the minimum information needed to create a user account in your system.

> **Certification requirement**: Apps must display the RFI screen in the sign-up flow to pass certification.

3.  **Plan selection screen**. Provides the pricing and features of subscription products offered by . If a plan has additional features that the customer can purchase (for example, an MVPD app may offer sports or movie add-ons for a base package), a separate screen may be used to list the features available for purchase.

4.  **Order confirmation screen** (Roku Pay built-in). Enables customers to confirm their method of payment, review the terms of the subscription, enter a PIN code (if required), and complete the purchase. Once the customer has completed the purchase, access to content should be granted without any additional steps. In addition, the app can then create a user account for the customer in their system.
    
    The order of the RFI and plan selection screens can be reversed; however, it is recommended that the RFI screen is displayed first to check whether the user already has an existing account before selecting a subscription plan.
    

### Screen copy

The RFI and order confirmation screens are provided by Roku Pay. The text displayed in these screens is controlled by the Roku OS and cannot be modified.

The publisher provides the copy used for the landing page and the plan selection screen. The language in these pages should be clear, concise, and persuasive. Specifically, apps should adhere to the following best practices for the text in these pages:

*   **Landing page**. The landing page should have a clear call-to-action to subscribe. It should be clear about any price points, and highlight any free trial or promotional pricing offers.

*   **Plan selection screen**. The plan selection screen should disclose all material terms and provide a summary of services and charges (apps are responsible for disclosing obligations about their service and fees). This screen should clearly articulate the benefits of each plan. For example, if an app offers monthly and annual plans, this screen can highlight the percentage savings of the annual plan compared to the monthly one. For apps that do have monthly and annual plans, default to the monthly plan to reduce potential refund requests.

### Checking and creating user accounts

As previously described, the RFI screen enables customers to grant the app access to their Roku account information. Apps can use this information to check whether the user has an existing account before the purchase and create a user account in their backend system after the purchase. The specific timing to be used and information to be sent for checking and creating user accounts is as follows:

*   **When to check for an existing user account.** Once the customer clicks **Continue** in the RFI screen, the app can get the user's email address and send it to their backend system to check whether that email address is already linked to an active subscription for which the publisher is already handling billing.

*   **When to create a new user account**. Only once the customer has completed the order confirmation screen and purchased a subscription may the app use the customer's information (name, email address, street address, zip code, phone number, and so on) to create a new user account in their backend system. Apps can then auto-generate a temporary password and then email customers with instructions to reset it.

Integrations
------------

Roku offers a number of integrations that enable apps to provide customers with a seamless on-device sign-up experience. Implementing these integrations helps apps increase the number of successful subscriptions and purchases, and it ensures that your app complies with Roku's [app certification requirements related to purchasing](/docs/developer-program/certification/certification.md#2-purchases).

Some integrations are required only if your app meets the stated streaming thresholds; however, implementing all of these integrations is recommended for all apps.

| Integration | Streaming threshold |
| --- | --- |
| [On-device authentication](#on-device-authentication) | Required for all SVOD and TVOD apps. |
| [On-device upgrade/downgrade](#on-device-upgradedowngrade) | Required for all SVOD and TVOD apps. |
| [Automatic Account Link](#automatic-account-link) | Required for all apps with user accounts that have streamed more than an average of **1 million hours** per month over the last three months. |
| [Abandonment tracking](#abandonment-tracking) | Required for SVOD apps that have streamed more than an average of **5 million hours** per month over the last three months. |

### On-device authentication

On-device authentication enables customers to start a subscription from your on-device app UI. This integration uses the [ChannelStore APIs](/docs/references/scenegraph/control-nodes/channelstore.md#getallpurchases) to manage the on-device user experience of the purchase flow through Roku Pay. It includes a complete suite of APIs for implementing the on-device purchasing, entitlement, and authentication workflows.

![on-device-auth-schematic](https://image.roku.com/ZHZscHItMTc2/on-device-auth-schematic-v2.jpg)

For more information, click [here](/docs/developer-program/authentication/on-device-authentication.md#creating-new-roku-subscriptions-through-roku-pay).

> **Certification requirement**: All SVOD and TVOD apps (and other subscription services) must implement On-device authentication.

### On-device upgrade/downgrade

On-device upgrade/downgrade enables customers to seamlessly switch plans directly from their devices, while making sure they are billed properly. Your app can then target different audiences with the best plan in order to maximize content monetization. This integration uses the [ChannelStore](/docs/references/scenegraph/control-nodes/channelstore.md#doorder) and [Roku Pay web service](/docs/developer-program/roku-pay/implementation/roku-web-service.md) APIs to handle upgrades/downgrades.

![roku815px - subscription-plans](https://image.roku.com/ZHZscHItMTc2/subscription-plans-v4.jpg)

For more information, see [On-device upgrade and downgrade](/docs/developer-program/roku-pay/implementation/on-device-upgrade-downgrade.md).

> **Certification requirement**: All SVOD and TVOD apps (and other subscription services) must implement On-device upgrade/downgrade.

### Automatic Account Link

Automatic account link automatically signs customers into your app when they activate additional Roku devices linked to their same Roku account.

![roku815px - automatic account link flow chart](https://image.roku.com/ZHZscHItMTc2/AAL.jpg)

For more information, click [here](/docs/developer-program/authentication/universal-authentication-protocol-for-single-sign-on.md).

> **Certification requirement**: All apps requiring a user account to login and that have streamed more than an average of 5 million hours per month over the last three months must implement Automatic Account Link.
> 
> This requirement is also applicable to new subscription services projected to reach the specified streaming hour threshold shortly after launch.

### Abandonment tracking

With abandonment tracking, your apps fires events upon loading each page within your app's signup flow to help track where users may be abandoning the process.

![roku815px - abandonment-tracking](https://image.roku.com/ZHZscHItMTc2/tracking-abandonment-v5.png)

For more information, click [here](/docs/developer-program/roku-pay/implementation/tracking-signup-abandonment.md).

> **Certification requirement**: All subscription services that have streamed more than an average of 5 million hours per month over the last three months must implement abandonment tracking in their signup workflow. This requirement is also applicable to new subscription services projected to reach the specified streaming hour threshold shortly after launch.

DynamicKeyboard
===============

Extends [DynamicKeyboardBase](/docs/references/scenegraph/dynamic-voice-keyboard-nodes/dynamic-keyboard-base.md "**DynamicKeyboardBase**")

The **DynamicKeyboard** node is similar to the [legacy **Keyboard** node](/docs/references/scenegraph/widget-nodes/keyboard.md), but with additional voice entry functionality. It enables text entry of alphanumeric and Latin characters, and voice entry of alphanumeric characters. It is typically used for entering email addresses or passwords.

The key layout is fixed based on the node's pre-built Key Definition File.

![roku815px - dynamic-keyboard-voice](https://image.roku.com/ZHZscHItMTc2/dynamic-keyboard-voice.jpg)

Fields
------

The DynamicKeyboard node inherits all its fields from its parent [DynamicKeyboardBase](/docs/references/scenegraph/dynamic-voice-keyboard-nodes/dynamic-keyboard-base.md) node class. See the [DynamicKeyboardBase](/docs/references/scenegraph/dynamic-voice-keyboard-nodes/dynamic-keyboard-base.md) and its base classes ([Group](/docs/references/scenegraph/layout-group-nodes/group.md) and [Node](/docs/references/scenegraph/node.md)) for descriptions of the fields that can be configured.

Default VoiceTextEditBox settings
---------------------------------

| Field | Type | Default | Description |
| --- | --- | --- | --- |
| voiceEntryType | string | "alphanumeric" | The type of characters accepted via voice entry. |
| voiceEnabled | boolean | true | Specifies whether voice entry is enabled for the text edit box of the dynamic keyboard. |
| maxTextLength | integer | 75  | The maximum number of characters that may be entered into the text edit box of the dynamic keyboard. |

Sample app
----------

You can download and install a [sample app](https://github.com/rokudev/dynamic-voice-enabled-keyboards) that demonstrates how to create and configure a dynamic voice-enabled keyboard.

roRegion
========

The roRegion component is used to represent a subsection of a bitmap.

The region is specified with an x,y, width, and height as well as a time field for use with animated sprites and a wrap field which causes the region to wrap during scrolling. The roRegion is a common parameter used by the drawing functions of [roBitmap](/docs/references/brightscript/components/robitmap.md "roBitmap"). Wrap and Time are used by [roCompositor](/docs/references/brightscript/components/roCompositor.md "roCompositor"). roRegion is also used to specify a pretranslation (x,y) for the draw, rotate, and scale operation. The pretranslation is normally used to specify the center of the region. The scaling operation is controlled by the scalemode specified in the region.

This object is created with parameters to initialize the x,y coordinates, width, height. If time and wrap are desired, use the SetTime() and SetWrap().

`CreateObject("roRegion", Object bitmap, Integer x, Integer y, Integer width, Integer height)`

Supported interfaces
--------------------

*   [ifRegion](/docs/references/brightscript/interfaces/ifregion.md "ifRegion")

ifImageMetadata
===============

Implemented by
--------------

| Name | Description |
| --- | --- |
| [roImageMetadata](/docs/references/brightscript/components/roimagemetadata.md "roImageMetadata") | The roImageMetadata component provides developers access to image file metadata included in many .jpg EXIF headers |

Supported methods
-----------------

### SetUrl(url as String) as Void

#### Description

Sets the URL to the image. Only file URLs are supported

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| url | String | The URL of the image. |

### GetMetadata() as Object

#### Description

Returns a set of simple and common image metadata

#### Return Value

An associative array containing the following key-value pairs with image metadata:

| Name | Type | Description |
| --- | --- | --- |
| width | Integer | Width of the image in pixels |
| height | Integer | Height of the image in pixels |
| orientation | String | *   "Top-left"<br>*   "Top-right"<br>*   "Bottom-right"<br>*   "Bottom-left"<br>*   "Left-top"<br>*   "Right-top"<br>*   "Right-bottom"<br>*   "Left-bottom" |
| datetime | roDateTime | The creation time of the image such as the time a photo was taken |
| comment | String | User specified comment string. This is often referred to as a caption |

### GetThumbnail() as Object

#### Description

Returns a thumbnail image if one is embedded in the image metadata and the corresponding associative array with image data. This only generates a thumbnail if one exists.

#### Return Value

An associative array that with **bytes** and **type** keys with the image data:

| Name | Type | Description |
| --- | --- | --- |
| bytes | roByteArray | The image data |
| Type | Integer | The type of image, which is most likely "image/jpeg", but could also be "image/png". |

### GetRawExif() as Object

#### Description

Returns all of the raw EXIF metadata.

#### Return Value

An associative array with all of the raw EXIF metadata. See the [EXIF section](/docs/references/brightscript/components/roimagemetadata.md#exif-background) for details about EXIF metadata.

### GetRawExifTag(ifd as Integer, tagnum as Integer) as Dynamic

#### Description

Returns the raw data for an Exif tag. The method provides direct access to a specific raw EXIF tag

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| ifd | Integer | The ifd of the Exif tag. |
| tagnum | Integer | The tag number of the Exif tag. |

#### Return Value

The raw data of an Exif tag. It the Exif tag doesn't exist it returns invalid.

roVideoPlayer
=============

The roVideoPlayer component implements a video player with programmatic controls.

This object is created with no parameters:

`CreateObject("roVideoPlayer")`

Supported interfaces
--------------------

*   [ifVideoPlayer](/docs/references/brightscript/interfaces/ifvideoplayer.md "ifVideoPlayer")
*   [ifHttpAgent](/docs/references/brightscript/interfaces/ifhttpagent.md "ifHttpAgent")
*   [ifSetMessagePort](/docs/references/brightscript/interfaces/ifsetmessageport.md "ifSetMessagePort")
*   [ifGetMessagePort](/docs/references/brightscript/interfaces/ifgetmessageport.md "ifGetMessagePort")

Supported events
----------------

*   [roVideoPlayerEvent](/docs/references/brightscript/events/rovideoplayerevent.md "roVideoPlayerEvent")

Roku Advertising Watermark
==========================

Publishers can send ad measurement beacons with the Roku Advertising Watermark to verify that they were generated by a Roku device. This helps protect publishers from device spoofing, which increases the value of their ad inventory. The Roku Advertising Watermark is a signed JSON web token (JWT) that is generated by an API that is only available on authentic Roku devices. It is then automatically appended in the HTTP header of ad measurement beacons sent by the [Roku Advertising Framework (RAF)](/docs/developer-program/advertising/integrating-roku-advertising-framework.md) to bot mitigation platform HUMAN and 3rd-party ad measurement platforms. This enables publishers to attest that the ad measurement beacons came from a genuine Roku device.

> Apps must fire all measurement beacons client-side via RAF to pass certification. This automatically applies the Roku Advertising Watermark to the measurement beacons, which attests that the beacons originated from authentic Roku devices.

Prerequisites
-------------

Publishers must do the following to send ad measurement beacons with the Roku Advertising Watermark:

1.  [Integrate the Roku Advertising Framework (RAF)](/docs/developer-program/advertising/integrating-roku-advertising-framework.md) in their app.
2.  Verify that their app meets all [advertising-related certification requirements](/docs/developer-program/certification/certification.md#1-advertising).

Getting started
---------------

To get started with the Roku Advertising Watermark integration, follow these steps:

1.  Verify that your app meets the listed [prerequisites](#prerequisites).
2.  Program your app application to fire all ad measurement beacons through RAF using one of the client-side or server-side implementations in this document.

Implementing the Roku Advertising Watermark
-------------------------------------------

Publishers can use one of the following client-side or server-side integrations to send ad measurement beacons with the Roku Advertising Watermark:

*   Client-side ad insertion.
*   Client-side ad stitching.
*   Server-side ad request via the **[stitchedAdsInit()](/docs/developer-program/advertising/raf-api.md#stitchedadsinitadpodarray-as-roarray)** function (recommended for server-side integrations).
*   Server-side ad request via the **[fireTrackingEvents()](/docs/developer-program/advertising/raf-api.md#firetrackingeventsadstructure-as-object-ctx-as-object-as-boolean)** function.

### Client-side ad insertion

The app does the following:

1.  Calls the **[setAdUrl()](/docs/developer-program/advertising/raf-api.md#setadurlurl-as-string)** to specify the publisher's 1st or 3rd-party ad server URL.
2.  Calls the **[getAds()](/docs/developer-program/advertising/raf-api.md#getadsmsg-as-string-as-object)** function to send an ad request and get back a parsed ad response with the ads to be rendered before or during playback of the selected content.
3.  Calls the **[showAds()](/docs/developer-program/advertising/raf-api.md#showadsads-as-object-ctx-as-object-view-as-object-as-boolean)** function to render the ads. This method automatically fires the appropriate ad measurement beacons at the times specified in the ad response.

For more information: [RAF integration guide](/docs/developer-program/advertising/integrating-roku-advertising-framework.md#client-side-ad-insertion)

### Client-side ad stitching

The app does the following:

1.  Calls the **[setAdUrl()](/docs/developer-program/advertising/raf-api.md#setadurlurl-as-string)** to specify the publisher's 1st or 3rd-party ad server URL.
2.  Calls the **[getAds()](/docs/developer-program/advertising/raf-api.md#getadsmsg-as-string-as-object)** function to send an ad request and get back a parsed ad response with the ads to be rendered before or during playback of the selected content.
3.  Calls the [**constructStitchedStream**()](/docs/developer-program/advertising/raf-api.md#constructstitchedstreamcontentmetadata-as-object-ads-as-object-as-object) function to create a single playlist containing the ads returned by the **getAds()** function and the content to be played.
4.  Calls the [**renderStitchedStream()**](/docs/developer-program/advertising/raf-api.md#renderstitchedstreamcsasstream-as-object-view-as-object-as-boolean) method to render the constructed playlist, which contains the ads. This method automatically fires the appropriate ad measurement beacons at the times specified in the ad response.

For more information: [RAF integration guide](/docs/developer-program/advertising/integrating-roku-advertising-framework.md#client-side-ad-insertion)

### Server-side ad request via stitchedAdsInit() function

_Recommended for server-side integrations_

The app passes the entire ads payload to RAF and allows it to render the app UI and dispatch the ad measurement beacons at the appropriate time. This implementation function ensures that the required Roku ad experience is used and interactive ads can be shown.

For more information:

*   [Server-side ad insertion](/docs/developer-program/advertising/ssai-adapters.md)
*   [RAF API reference](/docs/developer-program/advertising/raf-api.md#stitchedadsinitadpodarray-as-roarray)

### Server-side ad request via fireTrackingEvents

The app passes the ad measurement beacons directly to RAF and specifies when RAF should fire them.

For more information:

*   [Server-side ad insertion](/docs/developer-program/advertising/ssai-adapters.md)
*   [RAF API reference](/docs/developer-program/advertising/raf-api.md#firetrackingeventsadstructure-as-object-ctx-as-object-as-boolean)

ifChannelStore
==============

Implemented by
--------------

| Name | Description |
| --- | --- |
| [roChannelStore](/docs/references/brightscript/components/rochannelstore.md "roChannelStore") | allows the application to perform a purchase of an in-app product or upgrade an app |

Supported methods
-----------------

### GetIdentity() as Integer

#### Description

Returns a unique number for this object that can be used to identify whether a roChannelStoreEvent event originated from this object, by comparing with the roChannelStoreEvent object's GetSourceIdentity() value.

> The value can be any arbitrary value as assigned by the Roku OS, and should only be used for comparison purposes. For example, the value should not be used as an array index.For use as a look-up key, you can use GetIdentity().ToStr() as an associative array key.

#### Return Value

The unique number generated for the object.

### GetCatalog() as Void

#### Description

Requests the list of in-app products that are linked to the running app.

If successful, a subsequent [roChannelStoreEvent](/docs/references/brightscript/events/rochannelstoreevent.md "roChannelStoreEvent") will be received that contains an roList of roAssociativeArray items. Each associative array will contain the following parameter names with specified value type:

| Parameter | Type | Description |
| --- | --- | --- |
| code | string | The **Product Identifier** that was entered in the [In-App Products page in the Developer Dashboard](/docs/developer-program/roku-pay/quickstart/in-channel-products.md#product-basics). |
| name | string | The item name (this name will also be set as the description). |
| quantity | Integer | For one-time purchase/consumable products only. The number of the product purchased (for example "1000" game points, "3" viewings of a movie rental). |
| productType | string | The product type (ex. "MonthlySub") |
| cost | string | Localized cost of the product with local currency symbol |
| freeTrialQuantity | integer | If the product has a free trial offer, the length of the trial period. For example, **1** for a 1-month free trial or **7** for a 7-day free trial. |
| freeTrialType | string | If the product has a free trial offer, the unit of time used by the trial ("Days" or "Months") |
| trialCost | integer | If the product uses introductory pricing, the discounted price. |
| trialQuantity | integer | If the product uses introductory pricing, the number of months the discounted pricing is applicable. |
| trialType | string | Set to "months" for all products. All products using introductory pricing use "months" as the unit of time for the trial. |
| status | string | Indicates whether the product has been "saved" or "approved for sale". |
| purchaseDate | String | The subscription purchase date |

### GetStoreCatalog() as Void

#### Description

Requests the list of globally available in-app products, which are available to all apps.

If successful, a subsequent [roChannelStoreEvent](/docs/references/brightscript/events/rochannelstoreevent.md "roChannelStoreEvent") will be received that contains an roList of roAssociativeArray items. Each associative array will contain the following parameter names with specified value type:

| Parameter | Type | Description |
| --- | --- | --- |
| code | string | The product identifier |
| cost | String | The localized cost of the item with local currency symbol. |
| name | string | The item name |
| description | String | The product description. |
| SDPosterUrl | string | The URL for the standard definition image of the product. |
| HDPosterUrl | string | The URL for the high definition image of the product. |

### GetPurchases() as Void

#### Description

Requests the list of purchases associated with the current user account.

If successful, a subsequent [roChannelStoreEvent](/docs/references/brightscript/events/rochannelstoreevent.md "roChannelStoreEvent") will be received that contains an roList of roAssociativeArray items. Each associative array will contain the following parameter names with specified value type:

| Parameter | Type | Description |
| --- | --- | --- |
| code | string | The **Product Identifier** that was entered in the [In-app Products page in the Developer Dashboard](/docs/developer-program/roku-pay/quickstart/in-channel-products.md#product-basics). |
| cost | string | Localized cost of the item (prior to purchase) with local currency symbol |
| expirationDate | string | The subscription expiration date ([ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format) |
| freeTrialQuantity | integer | The free trial amount associated with the freeTrialType. For example, **1** for a 1-month free trial or **7** for a 7-day free trial. |
| freeTrialType | string | The free trial type ("Days" or "Months") |
| inDunning | string | A flag that indicates whether the purchased subscription is past due state because of an invalid method of payment.  <br>  <br>This flag is set to "true" if the subscription is in the dunning state. In this case, check the **status** field to determine whether to grant the customer access to content:  <br><br>*   If the **status** field is set to "Valid", the subscription is in a grace period and the viewer can access content.<br>*   If the **status** field is set to "Invalid", the subscription is on hold and the viewer cannot access content. If the viewer adds a valid method of payment, the subscription will be automatically renewed and the status will become "Valid". |
| name | string | The item name (this name will also be set as the description). |
| productType | string | The product type (ex. "MonthlySub") |
| purchaseChannel | string | Indicates where the Roku Pay subscription purchase was made:  <br><br>*   **web**. Subscription was purchased from [Roku.com](http://roku.com/) (for example, through [Instant Signup](/docs/developer-program/discovery/instant-signup.md) during the device activation).<br>*   **device**. Subscription was purchased on the Roku device (through the on-device sign-up flow). |
| purchaseContext | string | Indicates how the subscription purchase was made:  <br><br>*   **isu**. Subscription was purchased via [Instant Signup](/docs/developer-program/discovery/instant-signup.md).<br>*   **iap**. Subscription was purchased via an in-application purchase. |
| purchaseDate | string | The purchase date ([ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format) |
| purchaseId | string | The transaction ID |
| qty | integer | The quantity purchased |
| renewalDate | string | The subscription renewal date ([ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format) |
| status | string | Indicates whether the purchase is for a current subscription ("Valid") or for a subscription that has been canceled, expired, or terminated ("Invalid") |
| trialCost | integer | If the product uses introductory pricing, the discounted price. |
| trialQuantity | integer | If the product uses introductory pricing, the number of months the discounted pricing is applicable. |
| trialType | string | Set to "months" for all products. All products using introductory pricing use "months" as the unit of time for the trial. |

### GetAllPurchases() as Void

#### Description

The **getAllPurchases** function is similar to the [**getPurchases** function](#getpurchases-as-void) except that it requests the historical list of all canceled, expired, and terminated subscriptions over the lifetime of the current user account—in addition to the active subscriptions. You can use this method to leverage purchase history in order to implement subscription renewal flows and more easily determine if subscriptions have expired.

If successful, a subsequent [roChannelStoreEvent](/docs/references/brightscript/events/rochannelstoreevent.md "roChannelStoreEvent") will be received that contains an roList of roAssociativeArray items.

### SetOrder(order as Object, orderInfo as Object) as Void

#### Description

Sets the current Order (shopping cart) to the elements specified in the parameter, which must be an roList of roAssociativeArray items.Passing an empty roList clears the Order, like calling ClearOrder().

#### Parameters

NameTypeDescriptionorderroList of roAssociativeArray itemsEach roAssociativeArray in the roList contains the following fields:

| Name | Type | Description |
| --- | --- | --- |
| code | String | The product identifier |
| qty | Integer | The quantity purchased |

orderInforoAssociativeArrayThis parameter is used for subscription upgrades and downgrades. If it is not specified, the action is a product purchase. It contains the following fields:

| Name | Type | Description |
| --- | --- | --- |
| action | String | The action to be performed, which may be one of the following:<br><br>*   "Upgrade": The order is an upgrade from one subscription product to another.<br>*   "Downgrade": The order is a subscription downgrade. |

  
**Example**

    m.store = CreateObject("roChannelStore")​
    ' Populate myOrderItems
    myOrderInfo.action = "Upgrade"
    m.store.setOrder(myOrderItems, myOrderInfo)
    

  
See [On-device upgrade and downgrade](/docs/developer-program/roku-pay/implementation/on-device-upgrade-downgrade.md#calling-the-roku-web-service-validate-transaction-api) for how to implement Roku Pay web services for upgrades/downgrades.

### ClearOrder() as Void

| Name | Return Type | Description |
| --- | --- | --- |
| ClearOrder | Void | Clears the current Order (shopping cart). After this call, the Order is empty |

### DeltaOrder(code as Object, qty as Integer) as Integer

#### Description

Applies a change in quantity to one item in the current Order (shopping cart).

*   If the item identified by code is not in the **Order**, it is added with the specified **qty**.
*   If the item already exists in the **Order**, **qty** is added to the quantity of this item in the **Order**.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| code | String | The product identifier. |
| qty | Integer | The quantity purchased. This may be a negative number. |

#### Return Type

The quantity of the item remaining in the Order after applying the change. If the returned value is zero or negative, the item is deleted from the Order.

### GetOrder() as Object

#### Description

Retrieves the current Order.

#### Return Value

The returned object is an roList of roAssociativeArray items, where each item contains the following parameter names with specified value type:

| Name | Type | Description |
| --- | --- | --- |
| code | String | The product identifier. |
| qty | Integer | The quantity purchased. |

### DoOrder() as Boolean

#### Description

Displays the Streaming Store Product Purchase Screen populated with information from the current Order.

The user can then either approve and complete the purchase, or cancel the purchase. In the case that the user approves, the app should wait for and respond to the roChannelStoreEvent.isRequestSucceeded event to get the details of the completed transaction.

#### Return Value

A flag indicating whether the user approved the order (true if the order was approved; false otherwise).

### FakeServer(enable as Boolean) as Void

It is recommended that developers use [billing testing](/docs/developer-program/roku-pay/testing/billing-testing.md) instead of this method.

#### Description

This test mode short circuits communication to the Streaming Store. It makes other methods get their responses to async queries and operations from configuration files, rather than actual server communication.

> Do not call this method in a production app.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| enable | Boolean | If enable is true, enables a test mode for the roChannelStore component. |

To use this test method, create a **csFake** folder and add the following XML files to it in order to simulate web service request and response data:

*   **csfake/GetCatalog.xml**: Simulates the list of products available for purchase in the app.
*   **csfake/GetPurchases.xml**: Simulates the list of products already purchased by the user.
*   **csfake/PlaceOrder.xml**: Contains information about the product to be ordered.
*   **csfake/CheckOrder.xml**: Verifies the validity of the order placed. For example, if the **order** and **id** values in the PlaceOrder and CheckOrder XML files do not match, the fake server will report an error in the order processing.

See the [SimpleChannelStore sample app](https://github.com/rokudev/samples/tree/master/roku%20pay/SimpleChannelStore) for how to use this testing method.

### GetUserData() as Object

#### Description

The GetUserData() function provides a way to request user authorization to share the user’s account information with the calling app.

The primary use case of this method is to facilitate partner account creation/updating within apps that have a customer billing relationship with Roku.

For example, a developer may have a Roku app that offers a VOD subscription to users. This subscription may require an account with the content provider. The GetUserData() method could be called to read the user’s account information in order to prepopulate an account registration screen.

#### Return Value

When called, the method presents a dialog screen containing the user’s account information, along with two buttons labeled Share and Don’t Share.

*   If the user presses the **Cancel** button, GetUserData() returns invalid.
*   If the user presses the **Continue** button, GetUserData() returns an roAssociativeArray containing the following Roku account information for the app user (all values are Strings):
    
    *   firstname
    *   lastname
    *   email
    *   street
    *   city
    *   state
    *   zip
    *   country
    *   phone
    *   birth ("YYYY-MM")
    *   gender ("Male", "Female", or unspecified)

> For authenticated free and AVOD apps that are not enrolled in the [Roku Partner Payouts Program](/docs/developer-program/roku-pay/quickstart/partner-payouts.md), a limited set of account information is returned:
> 
> *   **Sign-up RFI screen**: email, phone, and zip.
> *   **Sign-in RFI screen**: email and phone.

### GetPartialUserData(properties as String, requestInfo as Object) as Object

#### Description

This function works like GetUserData(), but allows the caller to specify which user data elements to return. The specified values are also displayed in the user data dialog screen.

#### Parameters

NameTypeDescriptionpropertiesStringA comma-separated list of the attribute names to be returned. For example, to return only the email address and first name of the user's account, you would call GetPartialUserData("email, firstname"). The full set of user account properties that can be queried with the function is:  

*   firstname
*   lastname
*   email
*   street
*   city
*   state
*   zip
*   country
*   phone
*   birth
*   gender

requestInfo  
roAssociativeArraySpecifies whether the RFI screen is used for customer sign-ups or sign-ins. This may be one of the following values:  

| Field | Type | Default | Description |
| --- | --- | --- | --- |
| context | string | "signup" | Specifies the context of the RFI screen, which may be one of the following values:  <br><br>*   "signup": The RFI screen displays a "Let's create your account" title and lists the customer information specified in the [**requestedUserData** field](#requesteduserdata). The RFI screen uses the sign-up context by default.<br>*   "signin: "The RFI screen displays a "Sign in" title and lists only email or phone attributes, if specified in the [**requestedUserData** field](#requesteduserdata). Other attributes are ignored, even if specified.<br><br>  <br>See the [Sign-in example](#sign-in-example) for how to use this field. |

forceShowDataBooleanIf true, the RFI screen displays the values of the requested customer information to be shared with the app (for example, Jone Doe, [j](mailto:bmsith@roku.com)[on.doe@emailaddress.com](mailto:on.doe@emailaddress.com)).  
  
By default, this flag is set to false, which means that the default RFI screen for the region is used. For example, in the US, the RFI screen displays the type of customer information being requested (email address, name, and so on).  
  
This flag has no effect if the context field is set to "signin" (the RFI sign-in screen always displays the customer information values).  
  
**Example**:  

    store = CreateObject("roChannelStore")
    
    ' Doesn't show user data in dialog unless necessary in he user's region.
    userData = store.GetPartialUserData("email,firstname,lastname,gender,birth")
    ' Show user data values in dialog.
    userData = store.GetPartialUserData("email,firstname,lastname,gender,birth", {context: "signup", forceShowData: true})
    ' forceShowData currently has no effect in signin context, as the shared data is always shown.
    userData = store.GetPartialUserData("email", {context: "signin", forceShowData: false})
    

#### Return Value

An roAssociativeArray containing the Roku account information passed in the method.

> For authenticated free and AVOD apps that are not enrolled in the [Roku Partner Payouts Program](/docs/developer-program/roku-pay/quickstart/partner-payouts.md), a limited set of account information may be requested and returned:

*   **Sign-up RFI screen**: email, phone, and zip.
*   **Sign-in RFI screen**: email and phone.

#### Sign-up example

    store = CreateObject("roChannelStore")
    
    ' Request user's email, phone, first name, and last name for sign-up
    userData = store.GetPartialUserData("email, phone, firstname, lastname")
    

#### Sign-in example

    store = CreateObject("roChannelStore")
    
    ' Request user's email for sign-in
    userData = store.GetPartialUserData("email", {context: "signin"})
    

### GetUserRegionData() as Object

#### Description

Retrieves the state, zip code, and country associated with the customer's Roku account. The location information returned by this command can be used to determine a customer's eligibility for regional-specific subscription products and content.

#### Return Value

An associative array that contains the following fields:

| Field | Type | Description |
| --- | --- | --- |
| state | string | The state associated with the customer's Roku account. |
| zip | string | The zip code associated with the customer's Roku account. |
| country | String | The country associated with the customer's Roku account. |

### StoreChannelCredData(data as String) as Object

#### Description

Stores an access token, oAuth token, or other authentication artifact that can be retrieved by calling the [GetChannelCred()](/docs/references/brightscript/interfaces/ifchannelstore.md#getchannelcred-as-object)method. This data is stored securely in the Roku cloud and can be retrieved by other devices linked to the same Roku account. This method can be used to store an authentication artifact with Roku for a signed in user, associating that user with a particular Roku account. For more information, see [Automatic Account Link](/docs/developer-program/authentication/universal-authentication-protocol-for-single-sign-on.md).

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| data | String | An OAuth token, custom token, or other custom data to be stored. |

#### Return Value

This command returns an roAssociativeArray with the following values:

KeyTypeValueresponsejsonA string in JSON format, with the following key-value pairs:  

| Key | Type | Description |
| --- | --- | --- |
| status | string | The request status, which may be "success" or "failure". |
| error | string | A description of the error (if any). This will be set to "none" for a successful request. |
| error\_detail | string | A detailed description of the service error (if any). This value will be null (uninitialized) for a successful request. |

  
  
if billing is not enabled for the app, this field will include a string with a service error message.statusIntegerAn integer representing the request status. A successful request will return a status of 0.

### GetChannelCred() as Object

#### Description

Retrieves a Roku Partner Unique Customer Identifier (roku\_pucid), or retrieves an access token, oAuth token, or other authentication artifact (channel\_data).

#### Return Value

An associative array that contains the following fields:

KeyTypeDescriptionchannelIDstringThe app ID (ex. "2213" for Roku Media Player)errorCodestringA description of the service error (if any). This will be an empty string for a successful request.jsonstringA string in JSON format, with the following key-value pairs:

| Key | Type | Description |
| --- | --- | --- |
| error | string | A string containing an error message (if any). This value will be `null` (uninitialized) for a successful request. |
| roku\_pucid | string | This is an agnostic ID (in UUID format) representing the user. This value will be identical when retrieved in the same app across devices linked to the same Roku account.  <br>  <br>The PUCID can be used in place of requiring the user to enter their email address or username again (for example, when setting up a new device on the same Roku account). |
| token\_type | string | Type of the returned token, e.g. `"urn:roku:pucid:token_type:pucid_token"` |
| channel\_data | string | The access token, oAuth token, or other authentication artifact stored in the Roku cloud.  <br>  <br>This field is not returned if the [StoreChannelCredData](#storechannelcreddata) command is not used to store an artifact in the Roku cloud. |

  
If the request fails, this json string will be empty.publisherDeviceIDstringA unique identifier of the device.statusintegerAn integer representing the request status. A successful request will return a status of 0.

### GetDeviceAttestation(nonce as String) as String

Generates a signed JSON web token (JWT) in the Roku cloud and returns it to the app. This token can then be used by the publisher's web services to verify that a message originated from a genuine Roku device. The following example demonstrates how to generate the device attestation token:

    store  = CreateObject("roChannelStore")
    nonce = GetRandomHexString(16)
    token = store.GetDeviceAttestation(nonce)
    

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| nonce | String | A random number used to generate the JWT token. This can be, for example, a hash of the user's account ID that can be verified by the publisher's services. |

#### Return Value

The generated JWT token. The following demonstrates a sample JWT that is returned to the app. Developers can use a [JWT debugger](https://jwt.io/#debugger-io) to decode this token.

    eyJ4NXUiOiJodHRwczovL2V4YW1wbGUucm9rdS5jb20vc2FtcGxlY2VydCIsInR5cCI6IkpXVCIsImFsZyI6IlJTMjU2In0.eyJuYmYiOjE2NTYzNzQyNzQsIngtcm9rdS1hdHRlc3RhdGlvbi1kYXRhIjp7Im5vbmNlIjoiNUUwNjkyRTBBMzg5RjRGNiIsImNoYW5uZWxJZCI6ImRldiIsImRldmVsb3BlcklkIjoiY2FhNzNmYmI1ZTc1YTQ2YTRiNjExNGRlNTFhNWFkYTdkNjE2ZTJlZCIsInRpbWVzdGFtcE1zIjoxNjU2Mzc3ODczOTkwfSwiaXNzIjoidXJuOnJva3U6Y2xvdWQtc2VydmljZXM6ZGV2aWNlLWF0dGVzdGF0aW9uIiwiZXhwIjoxNjU2NDY0Mjc0fQ.nywDvSUys27oeaQZ3yXwNBfOnXbO-TUDuekOPZYjSssfZhNhWwRXvPLbJKHcNMR5Z0vFOQLVDFeqEVGauIMxMEke5UFLuCRxhr3ayBJJPt_BPfrEFbAvYjFEGdKkxJqYUhuFE38R8lU2k7dhO0iFxDw1Qq7W4w8_7CjmDy4YFf7IfyhV7Vf2kGiOx5C94Niw5N2td3s21F3z77Rq_bofQ51DOKIwo_cDVuvPQnDyxG-CNEydZKCZZwGPYCKEHMPrIOOXJ-S9ZjArgaEpBUpMXWJibFxnkpVUVzbC22GEaqz_SjOJXFMQU7TaCKkDeCYVKylgKwCvbvHRDlgogf7kqg
    

##### Verifying the JWT

To verify the JWT, developers must [download the Roku device attestation token certificate](https://devtools.web.roku.com/device_attestation_token_cert/RokuDeviceAttestationIntermediateCA.cert.pem) and authenticate that the token is signed by that certificate (see [https://jwt.io/introduction](https://jwt.io/introduction) for more information on JWT verification methods). The decoded JWT contains the following fields

##### Decoded JWT

The decoded JWT contains the following fields:

    "x-roku-attestation-data": {
        "nonce": "5E0692E0A389F4F6",
        "channelId": "dev",
        "developerId": "caa73fbb5e75a46a4b6114de51a5ada7d616e2ed",
        "timestampMs": 1656377873990
     }
    

### RequestPartnerOrder(orderInfo as roAssociativeArray, productID as String) as Object

#### Description

Checks the user's billing status and is a prerequisite for ConfirmPartnerOrder() when doing transactional purchases.

#### Parameters

KeyTypeDescriptionorderInforoAssociativeArraySpecifies the product to be ordered from a TVOD app. The order contains the following fields:  

| Field | Type | Description |
| --- | --- | --- |
| priceDisplay | string | The original price of the product. |
| price | string | The final price of the product, including any discounts. |
| title | string | A description of the product (for example, the name of a rental movie). |
| couponCode | string | An alphanumeric string entered by the customer to receive a discounted price on the product. |
| contentKey | string | The publisher-specific SKU (or other unique identifier) for the product. |

productIDStringThe product identifier as entered on the Developer Dashboard when the product was created

#### Return Value

If the order is successful, an roAssociativeArray is returned that contains the following keys with string values:

*   **id**. This ID must be passed in the confirmOrderInfo parameter in ConfirmPartnerOrder() method.
*   **status**. Success.
*   **tax**. Cost of tax (if applicable).
*   **total**. Total cost of transaction.

If the order fails, an roAssociativeArray is returned that contains the following keys with string values:

*   **errorCode**. An error code representing why the transaction failed.
*   **errorMessage**. An error message explaining why the transaction failed.
*   **failed**. Failure.

### ConfirmPartnerOrder(confirmOrderInfo as roAssociativeArray, productID as String) as Object

#### Description

This function is equivalent to doOrder() for transactional purchases. The user's billing status must first be confirmed with RequestPartnerOrder() prior to calling this function.

#### Parameters

KeyTypeDescriptionconfirmOrderInforoAssociativeArrayConfirms the product being ordered from a TVOD app. The order contains the following fields:  

| Field | Type | Description |
| --- | --- | --- |
| orderId | string | The orderID generated by Roku, which is included in the roAssociativeArray returned by the [RequestPartnerOrder()](#requestpartnerorderorderinfo-as-roassociativearray-productid-as-string-as-object) method. |
| priceDisplay | string | The original price of the product. |
| price | string | The final price of the product, including any discounts. |
| title | string | The name of the product to be displayed on customers' invoices. |
| couponCode | string | An alphanumeric string entered by the customer to receive a discounted price on the product. |
| contentKey | string | The publisher-specific SKU (or other unique identifier) for the product. |

  
The currency symbol may not be included in the **price** or **priceDisplay** values.productIDStringThe product identifier as entered on the Developer Dashboard when the product was created

#### Return Value

If the order is successful, an roAssociativeArray is returned that contains the following keys with string values:

*   **purchaseId**. The transaction ID..
*   **status**. Success.

If the order fails, an roAssociativeArray is returned that contains the following keys with string values:

*   **errorCode**. An error code representing why the transaction failed.
*   **errorMessage**. An error message explaining why the transaction failed.
*   **status**. Failure.

Reserved words
==============

Like other programming languages, BrightScript has a number of reserved words that have specific meanings to the Roku platform.

> These words cannot be used for other purposes in your apps.

These words include:

*   And
*   Box
*   CreateObject
*   Dim
*   Each
*   Else
*   ElseIf
*   End
*   EndFunction
*   EndIf
*   EndSub
*   EndWhile
*   Eval
*   Exit
*   ExitWhile
*   False
*   For
*   Function
*   GetGlobalAA
*   GetLastRunCompileError
*   GetLastRunRunTimeError
*   Goto
*   If
*   Invalid
*   Let
*   LINE\_NUM
*   Next
*   Not
*   ObjFun
*   Or
*   Pos
*   Print
*   Rem
*   Return
*   Run
*   Step
*   Stop
*   Sub
*   Tab
*   Then
*   To
*   True
*   Type
*   While

Enhanced Subscription Recovery testing
======================================

If you are using [enhanced subscription recovery](/docs/developer-program/roku-pay/subscription-recovery/subscription-on-hold.md), you can use the **subscription-recovery** test API to manually force subscriptions into different states (active, in-grace period, on-hold, passively canceled, and recovered). This helps expedite the testing of your enhanced subscription recovery integration.

Prerequisites
-------------

Making subscription-recovery test API calls requires a beta app, test user account, and transaction validation method ([push notifications](/docs/developer-program/roku-pay/implementation/push-notifications-jwt.md) or [API calls](/docs/developer-program/publishing/channel-publishing-guide.md#beta-channel-guidelines)). Complete the following steps so that you can generate new subscriptions, and receive and verify state changes:

1.  Create a [beta version of your app](/docs/developer-program/publishing/channel-publishing-guide.md#beta-channel-guidelines).
2.  [Create a test user](/docs/developer-program/roku-pay/quickstart/test-users.md) and link it to your beta app.
3.  (Recommended) Integrate [Roku Pay push notifications](/docs/developer-program/roku-pay/implementation/push-notifications-jwt.md) in your backend system. This enables you to receive and verify subscription state changes in near real-time. Otherwise, you can verify changes by pulling transaction data via Roku Pay [validate-transaction API calls](/docs/developer-program/publishing/channel-publishing-guide.md#beta-channel-guidelines).
4.  Enable [Enhanced Subscription Recovery](/docs/developer-program/roku-pay/subscription-recovery/settings.md#enabling-enhanced-subscription-recovery) in the Developer Dashboard for your beta app.

Once you have successfully tested Enhanced Subscription Recovery with the beta version of your app, you can [publish the updated production version of your app](/docs/developer-program/publishing/channel-publishing-guide.md#updating-an-existing-channel) and then enable [Enhanced Subscription Recovery](/docs/developer-program/roku-pay/subscription-recovery/settings.md#enabling-enhanced-subscription-recovery) for it.

> You must publish the updated version of your **production** app before enabling Enhanced Subscription Recovery for it. If you do not do this, customers will be unable to purchase a subscription for your app until the on-hold period has elapsed.

Testing subscription recovery
-----------------------------

To move subscriptions into different states and verify your subscription recovery integration, follow these steps:

1.  Purchase a new subscription to your beta app with the test user account. You cannot run subscription recovery testing on existing subscriptions.

> Do not use free trial products for testing subscription recovery. This is because canceling a free trial moves the subscription directly into the on-hold state where it can no longer be moved into a different state.

2.  Record the transaction ID generated by the purchase of the new subscription. You will need to pass this in the subsequent subscription-recovery test API calls.
    
3.  Make **subscription-recovery** test API calls in chronological order of the subscription lifecycle (failing to follow the listed order may trigger unexpected notifications and block the subscriptions):
    
    a. active
    
    b. in-grace
    
    c. on-hold
    
    d. passively canceled
    
    e. recovered (from in-grace or on-hold states)
    
4.  Use Roku Pay push notifications or Roku Pay [validate-transaction API calls](/docs/developer-program/publishing/channel-publishing-guide.md#beta-channel-guidelines) to verify that your back-end system is receiving and processing subscription state changes.
    
5.  Void transactions before starting another subscription test with the same user and product. Do not reuse already-tested subscriptions; testing must be done on new signups.
    

> Limit calls to less than 10 requests per minute (RPM). Developers exceeding this limit may lose access to the test APIs.

Subscription recovery test API methods
--------------------------------------

The **subscription-recovery** test API includes a set of POST methods for changing the state of subscriptions. Changes in the subscription state may take 10–30 minutes.

| #   | Usecase | Subscription state change | Method | URL |
| --- | --- | --- | --- | --- |
| 1   | Move an active subscription to the in-grace state | active → in-grace | POST | [https://apipub.roku.com/test/subscription-recovery/grace-period-state/{partnerApiKey}/{transactionId}](https://apipub.roku.com/test/subscription-recovery/grace-period-state/%7BpartnerApiKey%7D/%7BtransactionId%7D) |
| 2   | Move an in-grace subscription to the on-hold state | in-grace → on-hold | POST | [https://apipub.roku.com/test/subscription-recovery/passive-onhold-state/{partnerApiKey}/{transactionId}](https://apipub.roku.com/test/subscription-recovery/passive-onhold-state/%7BpartnerApiKey%7D/%7BtransactionId%7D) |
| 3   | Passively cancel a subscription | *   in-grace → canceled<br>*   on-hold → canceled | POST | [https://apipub.roku.com/test/subscription-recovery/deactivated-state/{partnerApiKey}/{transactionId}](https://apipub.roku.com/test/subscription-recovery/deactivated-state/%7BpartnerApiKey%7D/%7BtransactionId%7D) |
| 4   | Recover a subscription | *   in-grace → recovered<br>*   on-hold → recovered | POST | [https://apipub.roku.com/test/subscription-recovery/recover/{](https://apipub.roku.com/test/subscription-recovery/recover/%7BdevToken%7D/%7BtransactionId)[partnerApiKey](https://apipub.roku.com/test/subscription-recovery/deactivated-state/%7BpartnerApiKey%7D/%7BtransactionId)}/{transactionId} |

API reference
=============

Construction
------------

### Roku\_Ads() as Object

This is the main entry point for instantiating the ad interface. This object manages ad server requests, parses ad structure, schedules and renders ads, and triggers tracking beacons.

The Roku ad parser/renderer object returned has global scope because it is meant to represent interaction with external resources (the ad server and any tracking services) that have persistence and state independent of the ad rendering within a client application.

Control
-------

### fireTrackingEvents(adStructure as Object, ctx as Object) as Boolean

#### Description

Triggers event tracking, including parameter substitution for Nielsen DAR, when library client code handles the ad rendering. This method can be used in scenarios where the RAF ad renderer is not used (for example, custom ad rendering or server-stitched ads).

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| adStructure | Object | Can refer to a pod (array) of ads or a single ad. Must at least contain a Tracking array member (see [Ad Structure example](/docs/developer-program/advertising/integrating-roku-advertising-framework.md#ad-structure)), and may optionally contain an ‘adServer’ member string. |
| ctx | Object | Structure to capture context-specific trigger conditions. ‘type’ key-value pair used to trigger events of a specific type. ‘time’ key-value pair used to trigger time-dependent events at or prior to this time |

#### Return Value

A flag indicating whether all beacons of the requested type were successfully fired.

### getAds(msg as string) as Object

#### Description

Gets the set of ads to be rendered now. This method may be called with no parameters or with a **msg** parameter.

*   When called with no parameters, this function returns the full list of all ad pods parsed from the ad server response.
*   When called with the **msg** parameter, this function can be used as an event listener in the client application’s main video playback loop to check whether midroll or postroll ads should be shown or not.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| msg | String | Optional, depending on use case. Typically, this would be a message returned from a [WaitMessage()](/docs/references/brightscript/interfaces/ifmessageport.md#waitmessagetimeout-as-integer-as-dynamic) call on the message port of the [roVideoScreen](/docs/references/brightscript/components/rovideoscreen.md) or [roVideoPlayer](/docs/references/brightscript/components/rovideoplayer.md) object during content playback.  <br>  <br>This allows determination of which ads are scheduled for rendering based on playback position, user action, or other conditions. |

#### Return Value

Available ad pod(s) scheduled for rendering or invalid, if none are available

### showAds(ads as Object, ctx as Object, view as Object) as Boolean

#### Description

Renders any ads scheduled for display.

When this method is called with an array of ad pods (for example, using the value returned from the initial call to the [getAds()](/docs/developer-program/advertising/raf-api.md#client-ad-insertion) method), this is interpreted to mean that any preroll ad pod present should be rendered.

Client applications should always check the return value. If it is false, an application should exit content playback and return to the content selection screen. Typically, this occurs when the user presses the “Back” button during ad playback.

#### Parameters

| **Argument** | **Type** | **Required**? | **Description** |
| --- | --- | --- | --- |
| ads | array of ad pods | required | Ads to be rendered. Can represent either a single pod of ads or an array of ad pods. |
| ctx | associative array | optional | An associative array that allows client code to provide new offset and total to ad counter to support use cases involving interleaving RAF rendering with custom rendering within a single pod of ads. When used, it should be in the form of:  <br>  <br>`{ start: Integer, total: Integer }`  <br>  <br>For example, `{ start: 1, total: 4 }` would display as: "Ad 1 of 4" in the top left corner during ad playback. |
| view | renderable node | required (for SceneGraph applications) | Parameter representing a renderable node to which the ad UI can be parented.  <br>  <br>The **view** parameter allows SceneGraph rendering of ads into an app that uses SceneGraph for content rendering.  <br><br>*   For server-stitched use case, this should be the Video node of the content player.<br>*   For non-stitched use cases, this can be any renderable node in the scene whose lifetime is guaranteed during the duration of ad rendering. Render any ads scheduled for display.<br><br>  <br>The dimensions of the view object will be used to position RAF's UI elements, so it must be properly sized. Having dimensions larger than the current video playback resolution can place RAF UI elements such as the progress bar off screen. |

#### Return Value

A flag indicating whether the ad pod was rendered to completion. This will be false if the user exited before render completion.

Configuration
-------------

### setAdUrl(url as String)

#### Description

Sets the ad URL to be used for a new [getAds()](/docs/developer-program/advertising/raf-api.md#client-ad-insertion) request.

> You can only receive payment for ads shown in your application when the Roku Ad Framework is properly configured with a valid URL assigned by your ad service or by Roku.
> 
> Please contact adsupport@roku.com to discuss monetization options and obtain an ad URL if you wish to use Roku to fill ad inventory in your application.
> 
> Using the default URL is useful only for development and testing purposes and you will not receive payment for ad impressions from the default URL.

#### Parameters

| Argument | Type | Description |
| --- | --- | --- |
| url | String | The URL to be set as the current ad service request. Since version 2.14, supports parsing ads from local xml files in tmp:/, e.g., raf.setAdURL("tmp:/myVASTorVMAPorSMRX.xml").  <br>  <br>To use the default Roku ad service, call the **setAdUrl()** method without the url parameter. |

### getAdUrl() as String

#### Description

Gets the currently-configured ad server URL, or the default Roku ad server URL if none has been configured.

#### Return Value

The current ad server URL.

### setAdPrefs(useRokuAdsAsFallback as Boolean, maxRequests as Integer)

#### Description

Configures general ad request preferences.

The default is for Roku to backfill ads if this method is not called or **useRokuAdsAsFallback** is not set to false

#### Parameters

| Argument | Type | Description |
| --- | --- | --- |
| useRokuAdsAsFallback  <br>  <br>_Deprecated_ | Boolean | Indicates whether the default Roku backfill ad service URL should be used in case the client-configured URL fails to return any renderable ads.  <br>  <br>_This parameter has been deprecated and will be ignored in future updates to the RAF library._ |
| maxRequests | Integer | The maximum number of attempts the [getAds()](#getadsmsg-as-string-as-object) function is allowed to make. For example, if the first attempt to the client-configured URL fails to return any renderable ads and this field is set to 2, and the **useRokuAdsAsFallback** field is set to false, then a second attempt is made to the same client-configured URL. |

### setAdConstraints(maxHeight as Integer, maxWidth as Integer, maxBitrate as Integer, supportedMimeTypes as Object)

#### Description

Configures media constraints to filter renderable video ads.

By default, the MIME types are configured for “video/mp4”, “video/mp4-h264”, “video/x-mp4”, “application/x-mpegurl”, and “application/json”.

Any additional known types can be mapped to their stream format by setting this parameter before calling [getAds()](/docs/developer-program/advertising/raf-api.md#client-ad-insertion).

#### Parameters

| Argument | Type | Description |
| --- | --- | --- |
| maxHeight | Integer | Maximum vertical dimension of renderable ad (in pixels). |
| maxWidth | Integer | Maximum horizontal dimension of renderable ad (in pixels). |
| maxBitrate | Integer | Maximum allowable bitrate for renderable ad streams (in Kbps) |
| supportedMimeTypes | Object | Associative array with entries of the form:  <br>  <br>`{“mimeType” : “stream- Format”}` |

### setAdBreaks(contentLength as Integer, adBreakTimes as Integer)

#### Description

Configures content playback parameters, which can be used for scheduling relative-positioned ad breaks in VMAP ad service responses.

*   If your application uses VMAP ad URLs and they are configured to use “nn%” timeOffset values, then you must specify the contentLength prior to calling [getAds()](/docs/developer-program/advertising/raf-api.md#client-ad-insertion).
*   If VMAP is configured to use “#mm” timeOffset values, you must first specify a set of ad break times.
*   Calling with empty parameters will reset these to invalid values.

The content length can also be set independently via [setContentLength()](/docs/developer-program/advertising/raf-api.md#setcontentlengthlength-as-integer) if ad break times are not required.

#### Parameters

| Argument | Type | Description |
| --- | --- | --- |
| contentLength | Integer | Total length of video content (in seconds). |
| adBreakTimes | Integer | Array of suggested offsets into content playback to insert ad breaks (in seconds). |

### setAdExit(enabled as Boolean)

**Note: setAdExit() is deprecated and disabled - check showAds() return value instead**

~\#### Description~

~The default behavior is to enable exiting during ad rendering (for example, via the “Back” button) to return to content selection screen in the application.~

~Some use cases may require disabling this behavior if the user should not be allowed to skip ads when there is no applicable content selection mechanism.~

~\#### Parameters~

~| Argument | Type | Description |~ ~| -------- | ------ | ------------------------------------------------------------ |~ ~| enabled | Boolean | Enables ad exit behavior during rendering. |~

### importAds(adPodArray as Object)

#### Description

Resets the internal ad pod cache to allow client code to import a set of ads from unsupported ad service response formats or when aggregating ads from multiple ad services.

The application is responsible for ensuring that the ad pods in the array contain all the required data members.

#### Parameters

| Argument | Type | Description |
| --- | --- | --- |
| adPodArray | Object | Array of ad pods structured in accordance with the required [Ad Structure](/docs/developer-program/advertising/integrating-roku-advertising-framework.md#ad-structure). |

### enableJITPods(enabled as Boolean)

_Available since version 2.4_

#### Description

For applications that use a VMAP or SmartXML ad response to structure multiple ad pods, including midrolls, the JIT (or “Just In Time”) feature can be used to avoid pre-fetching all ad metadata before the content playback begins.

When enabled, ad call redirects for midrolls are deferred until a certain time before the ad pod is rendered. This mechanism relies on the host app’s continuous use of the BrightScript **getAds()** API method with the content video position event to determine when to resolve the deferred ads.

> JIT is used as a global setting; if the app has mixed content streams, where some content should not use JIT (such as server-stitched ads), then the host app is responsible for disabling this functionality before any ad calls are made for such streams.

#### Parameters

| Argument | Type | Description |
| --- | --- | --- |
| enabled | Boolean | Enables “Just In Time” fetching of midroll ads. By default, JIT is disabled and must be explicitly enabled via this API. |

### enableInPodStitching(isIPS as Boolean)

_Available since version 2.14_

#### Description

"In-pod stitching" (IPS) mode brings some of the benefits from [CSAS API](/docs/developer-program/advertising/csas.md) to apps using the classic CSAI API [showAds()](/docs/developer-program/advertising/raf-api.md#showadsads-as-object-ctx-as-object-view-as-object-as-boolean). When IPS mode is enabled and _showAds()_ is called for an ad break with multiple ads, it would stitch together the video clips for playback, prebuffering the next ad in the background while the current ad is finishing. The viewer experience is better because of the fast transitions between ads. Conversely, when IPS is disabled, each video plays individually and a few seconds are spent in a buffering screen between the ads.

#### Parameters

| Argument | Type | Description |
| --- | --- | --- |
| isIPS | Boolean | Whether to enable IPS (in-pod stitching) for showAds() |

### setLimitAdTracking(enabled as Boolean)

_Available since version 3.1_

For apps that collect explicit in-app consent for ad targeting (for example, to adhere to GDPR), this function specifies the value of the [ROKU\_ADS\_LIMIT\_TRACKING URL parameter macro](/docs/developer-program/advertising/integrating-roku-advertising-framework.md#url-parameter-macros) to be passed into beacons and ad requests.

This function cannot override the ROKU\_ADS\_LIMIT\_TRACKING value if the customer has cleared the **Personalize ads** check box in the **Settings > Privacy** menu.

#### Parameters

| Argument | Type | Description |
| --- | --- | --- |
| enabled | Boolean | Sets the [ROKU\_ADS\_LIMIT\_TRACKING URL parameter macro](/docs/developer-program/advertising/integrating-roku-advertising-framework.md#url-parameter-macros) to be passed into beacons and ad requests to either 1 (true; ad targeting is disabled for the customer) or 0 (false; ad targeting is disabled for the customer). |

### setTrackingCallback(callback as Function, obj as Object)

#### Description

Allows library client to set a callback function to be called when ad tracking events are fired or checked.

Callback functions must have the following signature:

    Sub CallbackFunc(obj = Invalid as Dynamic, eventType = Invalid as Dynamic, ctx = Invalid as Dynamic)
    

*   The obj parameter is an opaque object always passed through to the callback.
    
*   The eventType, if set, is a string specifying a tracking event that is fired. Event names correspond to [Tracking](/docs/developer-program/advertising/integrating-roku-advertising-framework.md#tracking-events).
    
*   The ctx is an optional associative array that encapsulates metadata associated with VAST-specified macros or ad render progress. Each member of the ctx array should separately be considered optional (for example, client code should check for valid values before operating on these data members). Generally, if `ctx.eventType` is not set, then `ctx.time` should be set and indicate ad render progress:
    

      {
          errType: String,
          errCode: String,
          errMsg : String,
          time : Int | Float (playback position, in s),
          url : String (rendered asset URI),
          ad : Associative Array representing ad structure for current ad,
          adIndex: Int (logical index of current ad within ad pod)
      }
    

#### Parameters

| Argument | Type | Description |
| --- | --- | --- |
| callback | Function | Function matching the required function signature . |
| obj | Object | The object to be passed to the callback function. |

### setDebugOutput(enabled as Boolean)

#### Description

Enables a library client to configure extended debug output, which is disabled by default.

#### Parameters

| Argument | Type | Description |
| --- | --- | --- |
| enabled | Boolean | Enables extended debug logging. |

### getLibVersion() as String

#### Description

Gets the RAF library version.

#### Return Value

The library version in the following format: “`<major>.<minor>`”

General audience measurement
----------------------------

### enableAdMeasurements(enabled)

_Available since version 2.1_

#### Description

Applications using audience measurement features must explicitly enable the framework to operate on the custom impression tag parameters. This function is used in conjunction with the [setContentGenre()](/docs/developer-program/advertising/raf-api.md#setcontentgenregenres-as-string-kidscontent-as-boolean), [setContentId()](/docs/developer-program/advertising/raf-api.md#setcontentidid-as-string), and [setContentLength()](/docs/developer-program/advertising/raf-api.md#setcontentlengthlength-as-integer) APIs to provide measurement data to third-party ad measurement platforms such as NielsenDAR, ComScore CCR, and ComScore VCE.

> Contact [adsupport@roku.com](mailto:adsupport@roku.com) for more information on how to use audience measurement features.

#### Parameters

| Argument | Type | Description |
| --- | --- | --- |
| enabled | Boolean | Enables audience identifiers in measurement tags. |

### setContentGenre(genres as String, kidsContent as Boolean)

#### Description

Enables potential ad targeting by specifying a set of genre tags to associate with the content or the ad request.

To clear genre tags, pass an empty string in the **genres** parameter or omit it.

The semantics and implementation of targeting based on genre values are dependent on the configured ad server, but for a list of currently-supported tags supported by the Roku ad server, see [Roku Genre Tags](/docs/developer-program/advertising/integrating-roku-advertising-framework.md#roku-genre-tags).

#### Parameters

| Argument | Type | Description |
| --- | --- | --- |
| genres | String | Comma-delimited string or array of genre tag strings. |
| kidsContent | Boolean | Optional. Specify whether content is targeted towards children (true) or not (false).  <br><br>> Per Roku's [certification requirements](https://developer.roku.com/docs/developer-program/certification/certification.md#1-advertising), apps with child-directed content must set this flag to **true** if serving ads during child-directed content. |

### setContentId(id as String)

#### Description

Enables potential ad targeting on a video content item by specifying its identifier.

Passing an empty string or omitting the **id** parameter will clear the content ID.

#### Parameters

| Argument | Type | Description |
| --- | --- | --- |
| id  | string | The content video item on which ad targeting may potentially be allowed. |

### setContentLength(length as Integer)

#### Description

Configures the content length to extend ad targeting properties for Nielsen DAR.

This method may also be used to determine VMAP relative ad break times.

Omitting the **length** parameter will clear any content length that was previously set.

#### Parameters

| Argument | Type | Description |
| --- | --- | --- |
| length | integer | Total length of content (in seconds). |

Nielsen DAR
-----------

> The Nielsen DAR APIs have been deprecated. Use the [general audience measurement APIs instead](#general-audience-measurement).

### setNielsenGenre(genre as String)

#### Description

Enables ad campaign measurement using Nielsen DAR tags by specifying a primary genre for the content being played, according to the Nielsen genres defined in [Nielsen DAR Genre Tags](/docs/developer-program/advertising/integrating-roku-advertising-framework.md#nielsen-dar-genre-tags).

**Examples**:

“CS” for a “Seinfeld” episode. “N” for a “60 Minutes” episode.

#### Parameters

| Argument | Type | Description |
| --- | --- | --- |
| genre | String | The primary content genre to be passed into Nielsen DAR tags. |

### setNielsenAppId(id as String)

Enables ad campaign measurement using Nielsen DAR tags.

The value of this application ID is uniquely assigned to your application by Nielsen and must be configured before rendering any ads containing Nielsen beacons.

#### Parameters

| Argument | Type | Description |
| --- | --- | --- |
| id  | String | The Nielsen-assigned application ID. |

Nielsen DCR
-----------

### getNielsenContentData() as String

#### Description

Provides an encrypted Nielsen RIDA parameter string for apps using the Nielsen SDK for DCR measurements.

#### Return Value

Encrypted Nielsen RIDA parameter string.

Client stitched ads
-------------------

### constructStitchedStream(contentMetaData as Object, ads as Object) as Object

#### Description

Merges a video feed and a set of one or more ad pods into a single playlist for playback via the [renderStitchedStream()](#renderstitchedstreamcsasstream-as-object-view-as-object-as-boolean) function.

#### Parameters

| Argument | Type | Required? | Description |
| --- | --- | --- | --- |
| contentMetaData | Content Node | Required | The content metadata of the video feed to be combined into the stitched stream. |
| ads | roArray | Required | Array of ad breaks to be combined into the stitched stream using RAF's [ad structure](https://developer.roku.com/docs/developer-program/advertising/integrating-roku-advertising-framework.md#ad-structure) format.  <br>  <br>The object may been parsed earlier from VMAP/SMRX by calling  <br>`raf.setAdURL(myAdTag): adBreaks = raf.getAds()`. |

#### Return Value

A single video stream containing the specified video feed and ads.

### renderStitchedStream(csasStream as Object, view as Object) as Boolean

#### Description

Renders a video stream that uses client-side ad stitching.

Tracking events are triggered automatically during ad rendering by this method.For client applications that perform their own ad rendering, the valid event types that must be handled are represented in the `tracking` array of the [Ad Structure](/docs/developer-program/advertising/integrating-roku-advertising-framework.md#ad-structure).

For client-side stitched streams, the app will also get tracking events during content playback in addition to those received during ad rendering.

#### Parameters

| Argument | Type | Description |
| --- | --- | --- |
| csasStream | Object | The video stream returned by [constructStitchedStream()](#constructstitchedstreamcontentmetadata-as-object-ads-as-object-as-object) method. |
| view | Object | A renderable node to which the ad UI can be attached. This enables the rendering of ads for apps that use SceneGraph for content rendering.  <br>  <br>The dimensions of the view object will be used to position RAF's UI elements, so it must be properly sized. Having dimensions larger than the current video playback resolution can place RAF UI elements such as the progress bar off screen. |

#### Return Value

A flag indicating whether the stream played to completion. This is false if the user exited playback before the stream completed.

Server stitched ads
-------------------

### stitchedAdsInIt(adPodArray as roArray)

#### Description

Imports ad metadata to be used for server-stitched ad rendering and resets the internal state before handling events.

The application is responsible for ensuring that the ad pods in the array contain all the required data members. In particular, for server-stitched ads, all time-dependent tracking beacons (Impression and quartile beacons) must have a valid time data member set, with a value relative to the entire stitched stream. For example, if a 30-second ad starts at 10:00 within the stitched stream, its Impression beacons should have track.time = 600.0 and its Midpoint beacons should have track.time = 615.0, and so on.

This method is used in conjunction with [stitchedAdHandledEvent()](/docs/developer-program/advertising/raf-api.md#server-stitched-ads) to implement ad rendering within server-stitched video streams.

#### Parameters

| Argument | Type | Description |
| --- | --- | --- |
| adPodArray | roArray | Set of ad pods structured in accordance with the required [Ad Structure](/docs/developer-program/advertising/integrating-roku-advertising-framework.md#ad-structure). |

### stitchedAdHandledEvent(msg as Object, player as Object) as roAssociativeArray

#### Description

Determines whether a stitched ad is being rendered, lets the ad renderer attempt to handle the event, and returns metadata about the ad and the event handled state.

This method is only intended for use in rendering server-stitched ads.

The advertising framework must first be initialized using the stitchedAdsInit() method before calling this method.

#### Parameters

| **Argument** | **Type** | **Description** |
| --- | --- | --- |
| player | Object | Player interface to allow ad renderer to control stitched video stream. If invalid or not specified, only beacons will be fired, and no interaction will be allowed or additional UI rendered during ad display.  <br>  <br>This parameter may be either the roVideoPlayer instance used to play the stitched stream, or an roAssociativeArray that contains methods congruent to the ifVideoPlayer interface. The roAssociativeArray is used in case there is additional client code that should be executed when an ad renderer controls the stream (for example, analytics).  <br>  <br>If the player parameter is passed as an roAssociativeArray in an app where video is played with roVideoPlayer (non-RSG), the app must contain the following methods:<br><br>    {<br>      ' Returns message port for player<br>      GetMessagePort : Function() as Object,<br>    <br>      ' Pauses a stitched video stream<br>      Pause : Function() as Boolean,<br>    <br>      ' Resumes a paused stitched stream<br>      Resume : Function() as Boolean,<br>    <br>      ' Seeks to absolute position (in ms) within stream<br>      Seek : Function(offsetMs as Integer) as Boolean,<br>    <br>      ' Plays stitched video stream<br>      Play : Function() as Boolean,<br>    <br>      ' Stops stitched video stream<br>      Stop : Function() as Boolean<br>    }<br>    <br><br>  <br>  <br>For SceneGraph apps that use a Video node for stitched ad playback, the **player** parameter should be an roAssociativeArray of the following form:<br><br>    {<br>      sgNode : video, ' the video node which will render the stitched stream<br>      port : port ' the message port on which (at least) the "position" and "state" fields of<br>      the above video node are observed<br>    } |
| msg | Object | Returned object from a Wait() call on the message port used by the stitched video player. May be consumed by the ad renderer to measure playback state or provide user interactivity with stitched ad. |

#### Return Value

*   If a stitched ad is being rendered, this method returns an roAssociativeArray that represents the current ad context and state. The return value is of the form:
    
          {
              adIndex : Integer, 'Index of current ad within pod
              adPodIndex : Integer, 'Index of current pod
              evtHandled : Boolean, 'True if event was handled by ad renderer
              adExited : Boolean, 'True if user exited ad rendering
              adCompleted : Boolean, 'True if ad has completed rendering
          }
        
    

*   If no stitched ad is being rendered, this method returns **Invalid**.

*   If the return value indicates that there is a stitched ad being rendered and that the event was handled by the renderer, the client application must take no action on that event. If the ad was exited, the client app should stop playback and return to the content selection screen.

Buffer screen customization
---------------------------

### setAdBufferScreenContent(contentMetaData as Object)

#### Description

Enables the client application to set metadata for the content populating the default ad buffer screen. contentMetaData conforms to the format defined in [Content Meta-Data](/docs/developer-program/getting-started/architecture/content-metadata.md) and can contain any or all of the following:

    {
      HDBackgroundImageUrl : String (URL for HD background image),
      SDBackgroundImageUrl : String (URL for SD background image),
      HDPosterUrl : String (URL for HD video poster),
      SDPosterUrl : String (URL for SD video poster),
      Title : String (Content title),
      Description : String (Content description)
    }
    

#### Parameters

| Argument | Type | Description |
| --- | --- | --- |
| contentMetaData | roAssociativeArray | Contains metadata representing information to be displayed in the default ad buffer screen. |

### enableAdBufferMessaging(enableMsg as Boolean, enableProgressBar as Boolean)

#### Description

Enables the client application to display messaging text and a progress bar on the default ad buffer screen.

#### Parameters

| Argument | Type | Description |
| --- | --- | --- |
| enableMsg | Boolean | Enables ad messaging text on the default ad buffer screen. The default value is true. |
| enableProgressBar | Boolean | Enables an ad buffering progress bar on the default ad buffer screen. The default value is true. |

### setAdBufferScreenLayer(zOrder as Integer, contentMetaData as Object)

#### Description

Enables the client application to set individual layer metadata for the custom ad buffer UI. contentMetaData conforms to the format defined in [Content Meta-Data](/docs/developer-program/getting-started/architecture/content-metadata.md).

The values that can be passed in the **zOrder** and **contentMetaData** parameters are specified by roImageCanvas.

#### Parameters

| Argument | Type | Description |
| --- | --- | --- |
| zOrder | Integer | Layer index to be used to display the **contentMetaData**. |
| contentMetaData | roAssociativeArray | The metadata for this UI layer. |

### clearAdBufferScreenLayers()

#### Description

Enables the client application to clear all metadata in all layers previously set for the custom buffer screen.

### setAdBufferRenderCallback(callback as Function, obj as Object, timeout as Integer)

#### Description

Enables the client application to set a callback function and timeout value for ad buffering events, to provide opportunity for analytics methods or animation of elements on custom buffer screen.

#### Parameters

| Argument | Type | Description |
| --- | --- | --- |
| callback | Function | The callback function to receive ad buffer events. The default value is Invalid. This function must have the following signature:  <br>`Function(obj as Dynamic, eventType as String, ctx as Dynamic) as Void`  <br>  <br>The **eventType** parameter can take the following values:  <br><br>*   BufferingStart<br>*   BufferingEnd<br>*   ReBufferingStart<br>*   ReBufferingEnd<br>*   Progress<br>*   Timeout<br><br>  <br>The **ctx** parameter is an roAssociativeArray that can contain the following:<br><br>    {<br>        'array of content metadata set via setAdBufferScreenLayer, or Invalid<br>         canvasLayers : roArray of roAssociativeArrays,<br>    <br>        'progress percentage [0-100]. Optional, only for "Progress" event type<br>         progress : Integer<br>    <br>        'ad metadata for currently buffering ad<br>        ad : roAssociativeArray,<br>    <br>        'index of current ad within pod<br>        adIndex : Integer<br>    } |
| obj | Object | The object to be passed to the callback function. The default value is Invalid. |
| timeout | Integer | The number of milliseconds to wait on buffer events before timing out. The default value is 0 (no timeout). |

ifTextToSpeech
==============

> To implement CVAA/screen reader support in your app, use the [roAudioGuide](/docs/references/brightscript/components/roaudioguide.md) component object. The roTextToSpeech component object is typically used for book readers and other special-purpose applications.

Implemented by
--------------

| Name | Description |
| --- | --- |
| [roTextToSpeech](/docs/references/brightscript/components/rotexttospeech.md "roTextToSpeech") | The roTextToSpeech component provides text to speech capabilities to applications |

Supported methods
-----------------

### Say(text as String) as Integer

#### Description

Returns an ID for the spoken string to notify observer callbacks about a specific spoken string.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| text | String | The UTF8 text to be spoken.  <br>  <br>Punctuation such as commas and periods can be used to add pauses to the speech playback.  <br>  <br>Typically, special characters are generally not spoken; however, you can pass in the appropriate text such as "question mark" to have a special character be spoken (do not use the symbol). |

#### Return Value

The ID for the spoken string.

### Silence(duration as Integer) as Integer

#### Description

Causes text to speech to continue to suppress any application background sound for the amount of time specified by `duration`.

This can be used to add clarity for longer spoken text that may have pauses that might otherwise allow application background sound to be heard.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| duration | Integer | The amount of time to suppress application background sound |

#### Return Value

The duration for the speech suppression.

### Flush() as Void

#### Description

Interrupts and stops any current text to speech spoken string, to be used when the app does not want to the text to speech to continue.

### IsEnabled() as Boolean

#### Description

Checks whether text-to-speech is enabled. Text-to-speech may be enabled or disabled for various technical reasons (for example, on some platforms, text-to-speech may only be enabled once in connected mode). This is not affected by the state of any of its clients. In particular, it does not depend on whether a CVAA compliant accessibility feature is enabled or not.

#### Return Value

A flag indicating whether text-to-speech is enabled.

### GetAvailableLanguages() as Object

#### Description

Returns an array containing the current list of languages available for text-to-speech.

#### Return Value

A list of languages.

### SetLanguage(name as String) as Void

#### Description

Sets the language specified by `name` for text to speech, from one of the available languages returned by the [GetAvailableLanguages()](#getavailablelanguages-as-object) method.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| name | String | The text-to-speech language to be used. |

### GetLanguage() as String

#### Description

Returns the name of the currently-selected text-to-speech language.

#### Return Value

The language name.

### GetAvailableVoices() as Object

#### Description

Returns an array containing the current list of voices available for text-to-speech.

#### Return Value

A list of voices.

### SetVoice(name as String) as Void

#### Description

Sets the voice specified by name for text to speech, from one of the available voices returned by the [GetAvailableVoices()](#getavailablevoices-as-object) method.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| name | String | The available text-to-speech voice to be used |

### GetVoice() as String

#### Description

Returns the currently-selected voice.

#### Return Value

The selected voice.

### GetVolume() as Integer

#### Description

Returns the volume at which text is spoken. The value ranges from 0 for muted to 1000 for the highest volume. The default value is 1000.

#### Return Value

The volume.

### SetVolume(volume as Integer) as Void

#### Description

Sets the volume at which text is spoken.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| volume | Integer | The volume at which text is spoken. The value ranges from 0 for muted to 1000 for the highest volume. The default value is 1000. |

### GetRate() as Integer

#### Description

Returns the rate at which text is spoken. The value ranges from -40 to 200 with a default value of 0.

#### Return Value

The rate.

### SetRate(rate as Integer) as Void

#### Description

Sets the rate at which text is spoken.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| rate | Integer | The rate at which text is to be spoken. The possible values range from -40 to 200. |

### GetPitch() as Integer

#### Description

Returns the pitch at which text is spoken. The possible values range from -60 to +60.

#### Return Value

The pitch.

### SetPitch(pitch as Integer) as Void

#### Description

Sets the pitch at which text is spoken.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| pitch | Integer | The pitch at which text is to be spoken. The possible values range from -60 to +60. |

ifCompositor
============

Implemented by
--------------

| Name | Description |
| --- | --- |
| [roCompositor](/docs/references/brightscript/components/rocompositor.md "roCompositor") | The roCompositor allows the composition and animation of multiple roBitmaps and roRegions |

Supported methods
-----------------

### SetDrawTo(destBitmap as Object, rgbaBackground as Integer) as Void

#### Description

Sets the destBitmap ([roBitmap](/docs/references/brightscript/components/robitmap.md "roBitmap") or [roScreen](/docs/references/brightscript/components/roscreen.md "roScreen")) and the background color.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| destBitmap | Object | The bitmap to be drawn. |
| rgbaBackground | Integer | The background color to be used. |

### Draw() as Void

#### Description

Draws any dirty sprites (that is, whatever is new or has changed since the last Draw). No compositor or sprite operations will be reflected on the display until Draw() is called. After calling Draw(), you must call Finish() (if single buffered) or SwapBuffers() (if double buffered) before the changes will be user visible

### DrawAll() as Void

#### Description

Redraws all sprites even if not dirty. After calling Draw(), you must call Finish() (if single buffered) or SwapBuffers() (if double buffered) before the changes will be user visible

### NewSprite(x as Integer, y as Integer, region as Object, z as Integer) as Object

#### Description

Creates a new sprite, using an roRegion to define the sprite's bitmap. Position the sprite at coordinate x,y. If z is provided, position the sprite in front of all other sprites with equal or lower z value. Sprites with negative z values are not rendered or displayed on the screen.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| x   | Integer | The x-coordinate of the sprite. |
| y   | Integer | The y-coordinate of the sprite. |
| region | Object | The region to be used to define the sprite's bitmap. |
| z   | Integer | The z-coordinate of the sprite. |

#### Return Value

Returns an [roSprite](/docs/references/brightscript/components/rosprite.md "roSprite") object.

### NewAnimatedSprite(x as Integer, y as Integer, regionArray as Object, z as Integer) as Object

#### Description

Creates a new sprite that consists of a sequence of frames to be animated. The frames are defined by the regionArray which is an [roArray](/docs/references/brightscript/components/roarray.md "roArray") of [roRegions](/docs/references/brightscript/components/roregion.md "roRegions"). Position the sprite at coordinate x,y. If z is provided, position the sprite in front of all other sprites with equal or lower z value

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| x   | Integer | The x-coordinate of the sprite. |
| y   | Integer | The y-coordinate of the sprite. |
| regionArray | Object | The frames to be animated. |
| z   | Integer | The z-coordinate of the sprite. |

#### Return Value

Returns an [roSprite](/docs/references/brightscript/components/rosprite.md "roSprite") object.

### AnimationTick(duration as Integer) as Void

#### Description

Moves all animated sprites. Sprites will not animate unless you call this function regularly.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| duration | Integer | The number of ms since the last call. |

### ChangeMatchingRegions(oldRegion as Object, newRegion as Object) as Void

#### Description

Provides a global search and replace of sprite [roRegions](/docs/references/brightscript/components/roregion.md "roRegions"). Replaces regions that match oldRegion with newRegion

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| oldRegion | Object | The sprite roRegion to be replaced. |
| newRegion | Object | The new sprite roRegion to be used. |

roMessagePort
=============

A Message Port is the place messages ([events](/docs/developer-program/core-concepts/event-loops.md)) are sent.

When using BrightScript, you would not call these functions directly. Instead, use the "Wait" BrightScript statement.

This object is created with no parameters:

`CreateObject("roMessagePort")`

Supported interfaces
--------------------

*   [ifMessagePort](/docs/references/brightscript/interfaces/ifmessageport.md "ifMessagePort")

Panel
=====

Extends [**Group**](/docs/references/scenegraph/layout-group-nodes/group.md)

The Panel node is used to create sliding panels for app UI, similar to those in the Roku OS home screen.

Fields
------

FieldTypeDefaultAccess PermissionUsepanelSizestringnarrowWRITE\_ONLY**Write-Only**  
Specifies one of the default panel sizes. Setting the field causes the width and leftPosition fields to be set to values that match the RSG preferred layout for a panel of the specified size.  
  

| Value | Meaning |
| --- | --- |
| narrow | Set the width and leftPosition fields to the values for a narrow Panel |
| medium | Set the width and leftPosition fields to the values for a medium width Panel |
| wide | Set the width and leftPosition fields to the values for a wide Panel |
| full | Set the width and leftPosition fields to the values for a full width Panel |

  
  
Note that PanelSet usage mandates that whenever two Panels are visible, they should include either one narrow and one wide panel or two medium width panels. If one Panel is visible, it's panelSize should be set to "full".widthfloat388READ\_WRITESpecifies the width of the panel in pixels. In most cases, this should be set by setting the panelSize field to one of the pre-configured settings.heightfloat\-1READ\_WRITESpecifies the height of the panel. In most cases, this will be set by the PanelSet and should treated as a read-only value.leftPositionfloat105READ\_WRITESpecifies the horizontal position of the panel relative to the left edge of the PanelSet (which is a the left edge of the display by default). In most cases, this should be set by setting the panelSize field to one of the pre-configure settings.overhangTitlestring""READ\_WRITEWhen the panel is used as part of the OverhangPanelSetScene, setting the overhangTitle field will cause that text to be displayed as the title in the overhang when the panel slides into the left position of the PanelSet.clockTextstring""READ\_WRITEWhen the panel is used as part of the OverhangPanelSetScene, setting the clockText field will cause that text to be displayed instead of the clock in the overhang when the panel slides into the left position of the PanelSet.optionsAvailableBooleanfalseREAD\_WRITEWhen the panel is used as part of the OverhangPanelSetScene, setting optionsAvailable will enable/disable the options button handling when the panel slides into the left position of the PanelSet. The overhang's options prompt will change appearance to provide feedback to the user that the options button is enabled/disabled.leftOrientationBooleanfalseREAD\_WRITEWhen the panel is used as part of the OverhangPanelSetScene, leftOrientation will be set to true when the panel moves into the left position of the PanelSet and set to false when the panel moves into the right position of the PanelSet.leftOnlyBooleanfalseREAD\_WRITEThe leftOnly field provides information to the PanelSet that this Panel should never appear in the right position of the PanelSet. When the panels are sliding back towards the home position (as a result of a **Left** or **Back** key press), and the panel slides into the right position, the PanelSet initiates another slide in the same _back_ direction so that the panel does not end up on the right.hasNextPanelBooleanfalseREAD\_WRITEThe hasNextPanel field provides information to the PanelSet as to whether or not this panel has another panel to its right. If set to true, the PanelSet's right arrow indicator is displayed and pressing the right arrow button on the remote triggers the PanelSet to move the focus one panel to the right, sliding the Panels as needed to make sure the panel that has the focus ends up onscreen. If set to false, the PanelSet's right arrow indicator is not displayed and the right arrow button does not trigger any change to the focused panel.isFullScreenBooleanfalseREAD\_WRITEThe isFullScreen field indicates that this panel should be the only panel displayed (i.e. it will take up both the left and right positions in the PanelSet.goBackCountinteger1READ\_WRITESetting goBackCount field to a value greater than 1 causes the PanelSet to move the focus back that many panels when the user presses the left arrow button, sliding the Panels as needed to make sure the panel that has the focus ends up onscreen.selectButtonMovesPanelForwardBooleantrueREAD\_WRITEWhen set to true, pressing the OK/Select button on the remote control causes the PanelSet focus to move to the next panel.isOffscreenLeftBooleanfalseREAD\_WRITEThis field is set by the PanelSet to indicate that the panel is positioned offscreen of the left edge of the PanelSet. This field is often observed to cancel outstanding load requests for images that are displayed on the panel.

Sample app
----------

[PanelExample](https://github.com/rokudev/samples/tree/master/ux%20components/sliding%20panels/PanelExample) is a sample app demonstrating Panel in action.

ifProgramGuide
==============

Implemented by
--------------

| Name | Description |
| --- | --- |
| [roProgramGuide](/docs/references/brightscript/components/roprogramguide.md) | Represents Electronic Program Guide (EPG) information from the tuner. |

Supported methods
-----------------

### GetChannels(id as Integer) as Object

#### Description

Returns the list of logical channel numbers on which the given program ID can be found.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| id  | Integer | The program ID containing to be returned. |

### GetNowNextPrograms(channel as String) as Dynamic

#### Description

Returns details about the current and next program on an app.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| channel | String | The app number for which programs are to be retrieved. |

#### Return Value

An roAssociativeArray containing two roArray components: one for the current program and another for the next program on the app. Each roArray contains the following key/value pairs detailing the program:

| **Key** | **Type** | **Value** |
| --- | --- | --- |
| name | String | Descriptive name for the program. |
| id  | String | ID for the program, not guaranteed to be unique, suitable for passing to GetChannels. |
| description | String | Longer description for the program. |
| category | String | Genre of the program, such as Drama, Sport, and so forth. |
| start\_time | roDateTime | Starting time of this program. |
| duration | Integer | Length of this program in seconds. |
| subtitles | String | (Optional) If present indicates this program has subtitles. |
| format | roAssociativeArray | Indicates the media format, with the following keys, all of which are optional. The value for each key is the Boolean string "true" to indicate the format option. |
| Rating | roAssociativeArray | (Optional) Rating and parental guidance information. |
| link | roAssociativeArray | (Optional) Links to other related programs. |
| content\_metadata | Content Meta­ Data object | Name, description, start\_time, duration and format of this program. |
| Rating Region UK DTT | String | **UK digital terrestrial TV only**  <br>  <br>(Optional) A JSON object encoded as string representing viewer guidance type and description. |
| Link HD simulcast | String | **UK digital terrestrial TV only\*\***  <br>  <br>(Optional) A JSON object encoded as string representing a list of other service\_id and event\_id pairs on which this program is simultaneously broadcast in HD. |

### GetVersion() as Integer

#### Description

Returns an integer which is incremented each time the underlying data in the guide changes.

#### Return Value

The version number of the program guide.

### GetPrograms(startTime as roDateTime, channel as String, endTime as roDateTime) as Object

#### Description

Returns the programs falling within the given time range.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| startTime | roDateTime | The start time programs must fall within to be retrieved. |
| channel | String | The app number for which programs are to be retrieved. |
| endTime | roDateTime | The end time programs must fall within to be retrieved. |

#### Return Value

An roArray of programs falling within the given time range (returns invalid if the given channel is unknown). Each entry in the array contains an roAssociativeArray containing the following details of a program:

| **Key** | **Type** | **Value** |
| --- | --- | --- |
| name | String | Descriptive name for the program. |
| id  | String | ID for the program, not guaranteed to be unique, suitable for passing to GetChannels. |
| description | String | Longer description for the program. |
| category | String | Genre of the program, such as Drama, Sport, and so forth. |
| start\_time | roDateTime | Starting time of this program. |
| duration | Integer | Length of this program in seconds. |
| subtitles | String | (Optional) If present indicates this program has subtitles. |
| format | roAssociativeArray | Indicates the media format, with the following keys, all of which are optional. The value for each key is the Boolean string "true" to indicate the format option. |
| Rating | roAssociativeArray | (Optional) Rating and parental guidance information. |
| link | roAssociativeArray | (Optional) Links to other related programs. |
| content\_metadata | Content Meta­ Data object | Name, description, start\_time, duration and format of this program. |
| Rating Region UK DTT | String | **UK digital terrestrial TV only**  <br>  <br>(Optional) A JSON object encoded as string representing viewer guidance type and description. |
| Link HD simulcast | String | **UK digital terrestrial TV only\*\***  <br>  <br>(Optional) A JSON object encoded as string representing a list of other service\_id and event\_id pairs on which this program is simultaneously broadcast in HD. |

<component>
===========

The <component> element defines all aspects of the component defined in a SceneGraph XML component file. Every SceneGraph XML component file must have exactly one <component> element that contains all other XML elements in the file, which may include:

*   an [<interface>](/docs/references/scenegraph/xml-elements/interface.md) element that defines the interface fields of the component
*   zero or more [<script>](/docs/references/scenegraph/xml-elements/script.md) elements that define the BrightScript code used by the component
*   a [<children>](/docs/references/scenegraph/xml-elements/children.md) element that contains the child <node> elements (either the built-in node classes or node classes extended from them) for the component, declared in XML markup

Attributes
----------

The following attributes define a <component> XML element:

| Attribute | Required | Description |
| --- | --- | --- |
| name | required | Specifies the name of the component, that allows you to create the component in your application. For example, if the name of the component is `CastMemberInfo`, you could create instances of the component declaratively in a child node element of a component <children> element (`<CastMemberInfo/>`), or using BrightScript in a <script> element (`createObject("roSGNode","CastMemberInfo")`).  <br>  <br>The name attribute is case-sensitive. You cannot successfully create or declare a component unless the component name exactly matches the name attribute, including case. Also be aware that two components with the exact same name in the same application components directory will have undefined and generally undesirable results if you attempt to create a component object with that name in the application. |
| extends | optional | Specifies the name of the built-in or extended SceneGraph scene or node class whose functionality is extended by this component.  <br>  <br>For example, `extends="Group"` specifies that the component has all of the functionality of the [Group](/docs/references/scenegraph/layout-group-nodes/group.md) node class (it can have child nodes, has translation/scale/rotation fields, and so forth).  <br>  <br>By default, a component extends the [Group](/docs/references/scenegraph/layout-group-nodes/group.md) node class. |
| initialFocus | optional | Specifies the ID of a node declared in the XML file to have the initial remote control focus when the component is instantiated. |
| version | optional | Specifies the version of the SceneGraph API. The default is 1.0 if not specified. |

Example
-------

The following <component> element defines a component named `GridPanelExample`, that contains <interface>, <script>, and <children> elements.

**<component> element example**

    <component name = "GridPanelExample" extends = "GridPanel" initialFocus = "examplePosterGrid" >
    
      <interface >
        <field id = "gridcontenturi" type = "uri" onChange = "readpostergrid" />
      </interface>
    
      <script type = "text/brightscript" >
    
        <![CDATA[
    
        sub init()
          m.top.panelSize = "full"
          m.top.isFullScreen = true
          m.top.leftPosition = 130
          m.top.focusable = true
          m.top.hasNextPanel = false
          m.top.createNextPanelOnItemFocus = false
          m.top.grid = m.top.findNode("examplePosterGrid")
        end sub
    
        sub readpostergrid()
          m.readPosterGridTask = createObject("roSGNode", "ContentReader")
          m.readPosterGridTask.contenturi = m.top.gridcontenturi
          m.readPosterGridTask.observeField("content", "showpostergrid")
          m.readPosterGridTask.control = "RUN"
        end sub
    
        sub showpostergrid()
          m.top.grid.content = m.readPosterGridTask.content
        end sub
    
        ]]>
    
      </script>
    
      <children >
    
        <PosterGrid
          id = "examplePosterGrid"
          basePosterSize = "[ 512, 288 ]"
          caption1NumLines = "1"
          numColumns = "2"
          numRows = "2"
          itemSpacing = "[ 20, 20 ]" />
    
      </children>
    
    </component>

<script>
========

The <script> element allows the definition of functions to initialize the component, and to respond to events (including key events) and field value changes. The BrightScript interfaces for the SceneGraph nodes used by BrightScript are the same interfaces defined for [roSGNode](/docs/references/brightscript/components/rosgnode.md) objects.

You can include any type of BrightScript object declarations, definitions, and creation, and the related functions to operate on the BrightScript objects, in a <script> element, except for certain objects and functions that must be used asynchronously in a [Task](/docs/references/scenegraph/control-nodes/task.md) node (see [BrightScript support](/docs/developer-program/core-concepts/scenegraph-brightscript/brightscript-support.md)). In addition, there are two functions that are declared specifically for use in SceneGraph component <script> elements:

*   [init()](/docs/references/scenegraph/component-functions/init.md)
*   [onKeyEvent()](/docs/references/scenegraph/component-functions/onkeyevent.md)

Relative URIs
-------------

BrightScript files can be imported using relative URIs. If the uri does not specify a complete `pkg:` file path, the uri will be interpreted as a file path relative to the XML file.

For example, given an XML file called MainScene.xml located at:

    pkg:/components/framework/MainScene.xml
    

A `.brs` file can have the following uri:

    <script type="text/brightscript" uri="Task.brs" />
    

and resolve to:

    pkg:/components/framework/Task.brs
    

Attributes
----------

The <script> element has two attributes:

| Attribute | Required | Description |
| --- | --- | --- |
| type | required | A string defining the type of the script. This should be set to `"text/brightscript"` for BrightScript code. |
| uri | optional | A string specifying an external file that contains script code associated with the component. This file must be located in the `pkg:/components` directory of the application, and have the `.brs` extension for BrightScript code. |

Examples
--------

Here's an example of a BrightScript function that creates a component named StopWatch parented to the root node of the component, and sets its `translation` field to x=100, y=200:

**BrightScript component creation**

    function createStopwatch(parent as object) as object
      stopWatch = m.top.createChild("StopWatch")
      stopWatch.translation = [100, 200]
      return stopWatch
    end function
    

The <script> element contains zero or more BrightScript functions. Because BrightScript can contain special characters reserved for XML, the body of the <script> element must be enclosed in an XML `CDATA` section. For example:

**Embedding BrightScript code in XML**

    <script type = "text/brightscript" >
    
      <![CDATA[
    
      function createStopwatch(parent as object) as object
        stopWatch = m.top.createChild("StopWatch")
        stopWatch.translation = [100, 200]
        return stopwatch
      end function
    
      ]]>
    
    </script>
    

The `CDATA` section can contain any valid BrightScript code, including any BrightScript library.

BrightScript code can also be included from an external file using the uri attribute of the <script> element:

    <script type = "text/brightscript" uri = "pkg:/components/VideoTheater.brs" />
    

XML component files may include more than one <script> element. This allows for the dividing the BrightScript code into logical groupings, as well as including BrightScript source from more than one external file.

ParentalControlPinPad
=====================

ParentalControlPinPad is a variant of the [PinPad component](/docs/references/scenegraph/widget-nodes/pinpad.md "PinPad component"), although it does have a few key differences: The pin, pinLength, and secureMode fields are made private (i.e., not accessible to BrightScript, and secureMode set to true).

There are two use cases for the ParentalControlPinPad node:

*   If the user enters the correct pin, a 2-hour override of content blocking starts, similar to the system behavior on RokuTV
*   If the user enters an incorrect PIN, the text fields are cleared automatically

Fields
------

ParentalControlPinPad includes a new field, pinSuccess for blocking content:

| Field | Type | Default | Description |
| --- | --- | --- | --- |
| pin | string | ""  | Contains the string of numbers that have been entered. |
| pinLength | integer | 4   | Contains the maximum number of digits that can be entered |
| pinSuccess | string | incomplete | **Read-only**  <br>"true": Content is now unblocked  <br>"false": Pin incorrect, "incomplete": a full pin is not entered |
| secureMode | boolean | true | When set to true, each digit entered is displayed briefly, then replaced with an asterisk. When false, the entered digits always remain visible. |
| keyColor | color | 0xffffffff | Specifies the color of the key labels and icons when the keyboard does not have the focus |
| focusedKeyColor | color | 0xffffffff | Specifies the color of the key labels and icons when the keyboard has the focus |
| pinDisplayTextColor | color | 0xffffffff | Specifies the color of the numbers displayed in the pin display boxes |
| keyboardBitmapUri | string | ""  | Specifies the URI of an image file to be loaded to replace the default keyboard image drawn underneath the numeric keys and icons. Note that this image must be carefully designed so that the key positions match the default image. Template images for SD, HD and FHD resolutions are provided below. |
| pinDisplayBitmapUri | string | ""  | Specifed the URI of an image file to be loaded to replace the default box drawn underneath each entered digit in the pin display. This should be a 9-patch image so that it can be stretched to appropriate size depending on the pinLength field. |
| focusBitmapUri | string | ""  | Specifies the URI of an image file to be loaded to replace the keyboard focus indicator. This should be a 9-patch image so that it can be stretched to the appropriate size for the double width keys. |
| showPinDisplay | boolean | true | Specifies whether or not the pin display that shows the entered digits is visible. In most cases, it is desirable to display the entered digits so that the user can see the string as it is entered. In some cases though, you might want to only show the keyboard part of the PinPad node.  <br>  <br>In those cases, the pinfield of the node will still contain the string entered by the user, so that it can displayed in some different manner. |

Reverting Roku beta OS to production on devices
===============================================

Developers enrolled in the Roku beta program can revert their devices running a beta OS back to the latest production build in a self-serve manner.

Switching from beta to production Roku OS
-----------------------------------------

To switch from beta to production, use your Roku remote control to access the OS update screen (press Home x 5, FFWD x 3, RWD x 2; 🏠🏠🏠🏠🏠, ⏩⏩⏩, ⏪⏪) navigate to the **Cycle software update server** option, press the **Options** (\*) button, and then select the displayed production build. The Roku OS on your device will be downgraded to the latest production version. Your device will stay on the production build until the next time it calls Roku’s servers for a system update.

![roku-beta-os-rollback roku815px](https://image.roku.com/ZHZscHItMTc2/roku-beta-os-rollback.jpg)

> Roku devices typically call for a system update only when idle; the updates seldom occur during an active session. If your device fails or reboots, it will default back to the beta build. As a result, you will need to manually revert the device back to production, if required (for example, if you are attempting to resolve a production bug).

Switching back from production to beta Roku OS
----------------------------------------------

To switch back to the latest beta build, do a system update by navigating to **Settings > System > System Update**.

Accessing Roku OS beta builds
-----------------------------

To get access to Roku beta OS builds, [join the Roku beta program](https://rokutestingportal.centercode.com/key/rdbp). Participating in the beta program enables developers to regression test their apps against the forthcoming OS before it ships to production, as well as get a head start in implementing new features or removing deprecated APIs in the latest Roku OS before the general release.

ifLocalization
==============

Implemented by
--------------

| Name | Description |
| --- | --- |
| [roLocalization](/docs/references/brightscript/components/rolocalization.md "roLongInteger") | The roLocalization object provides functions to assist in localization |

Supported methods
-----------------

### GetPluralString(count as Integer, zeroString as String, oneString as String, pluralString as String) as String

#### Description

Replaces "^n" in pluralString with count and returns the result.

#### Parameters

| Name | Type |
| --- | --- |
| count | Integer |
| zeroString | String |
| oneString | String |
| pluralString | String |

#### Return Value

The result of the operation. If count is 0, this returns zeroString. If count is 1, it returns oneString.

#### Examples

`GetPluralString(count, "0 books", "1 book", "^n books")`

### GetLocalizedAsset(dirName as String, fileName as String) as String

Returns an appropriate asset path based on the user's currently selected language.

If the user's current language setting is French (fr\_CA), and the file exists, then this would return "pkg:/locale/fr\_CA/images/MyImage.png".

If the file does not exist in the current locale directory, then this will search the directory locale/default/. If it exists there, it will return it; otherwise, it will check the directory locale/en\_US/. If it still can't find the file, then it will return an empty string.

A list of currently supported locales can be found at [ifDeviceInfo.GetCurrentLocale](/docs/references/brightscript/interfaces/ifdeviceinfo.md#getcurrentlocale-as-string "ifDeviceInfo.GetCurrentLocale").

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| dirName | String | The name of a subdirectory in the directory pkg:/locale/XX\_YY/ where XX\_YY is the current language setting. |
| fileName | String | The name of the file. |

#### Return Value

An asset path.

#### Example

`GetLocalizedAsset("images", "MyImage.png")`.

ifSocketAsync
=============

The ifSocketAsync interface provides asynchronous socket features that utilize a full-featured select loop in the Roku OS that communicates to the application using a BrightScript [roMessagePort](/docs/references/brightscript/components/romessageport.md "roMessagePort"). This interface is valid on roStreamSocket and roDataGramSocket objects that were assigned a BrightScript port via [SetMessagePort()](/docs/references/brightscript/interfaces/ifsetmessageport.md).

Implemented by
--------------

| Name | Description |
| --- | --- |
| [roDataGramSocket](/docs/references/brightscript/components/rodatagramsocket.md "roDataGramSocket") | The roDataGramSocket component enables Brightscript apps to send and receive UDP packets |
| [roStreamSocket](/docs/references/brightscript/components/rostreamsocket.md "roStreamSocket") | The roStreamSocket component enables BrightScript apps to accept and connect to TCP streams as well as send and receive data with them |

Supported methods
-----------------

### IsReadable() as Boolean

#### Description

Checks whether underlying select determines non-blocking read is possible.

#### Return Value

A flag indicating whether underlying select determines non-blocking read is possible.

### IsWritable() as Boolean

#### Description

Checks whether underlying select determines non-blocking write is possible.

#### Return Value

A flag indicating whether underlying select determines non-blocking write is possible.

### IsException() as Boolean

#### Description

Checks whether underlying select determines non-blocking read of OOB data is possible.

#### Return Value

A flag indicating whether underlying select determines non-blocking read of OOB data is possible.

### NotifyReadable(enable as Boolean) as Void

#### Description

Enables roSocketEvent events to be sent via the message port when the underlying socket becomes readable.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| enable | Boolean | A flag specifying whether roSocketEvent events are to be sent when the underlying socket becomes readable. |

### NotifyWritable(enable as Boolean) as Void

#### Description

Enables roSocketEvent events to be sent via the message port when the underlying socket becomes writable.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| enable | Boolean | A flag specifying whether roSocketEvent events are to be sent when the underlying socket becomes writable. |

### NotifyException(enable as Boolean) as Void

#### Description

Enables roSocketEvent events to be sent via the message port when the underlying socket gets an exception or OOB data.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| enable | Boolean | A flag specifying whether roSocketEvent events are to be sent when the underlying socket gets an exception or OOB data. |

### GetID() as Integer

#### Description

Returns a unique identifier that can be compared to the value returned by the [roSocketEvent.getSocketID()](/docs/references/brightscript/events/rosocketevent.md#getsocketid-as-integer) method to match the underlying socket to receive the event.

#### Return Paramters

A unique ID.

ifAudioPlayer
=============

Implemented by
--------------

| Name | Description |
| --- | --- |
| [roAudioMetadata](/docs/references/brightscript/components/roaudiometadata.md "roAudioMetadata") | The Audio Player object provides the ability to setup the playing of a series of audio streams |

Supported methods
-----------------

### SetContentList(contentList as Object) as Void

#### Description

Sets the content list to be played by the Audio Player.

#### Parameters

An array of associative arrays (Content Meta-Data objects) representing the information for each stream to be played. See [Content Meta-Data](/docs/developer-program/getting-started/architecture/content-metadata.md " Content Meta-Data") for details on the attributes for each element in the array.

### AddContent(contentItem as Object) as Void

#### Description

Adds a new ContentMetaData item to the end of the content list for the Audio Player.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| contentItem | Object | The new ContentMetaData item to be added to the content list. |

### ClearContent() as Void

#### Description

Clears the content list.

### Play() as Boolean

#### Description

Puts the Audio Player into play mode starting at the current item in the Content List. This will stop any currently playing content.

#### Return Value

A flag indicating whether the Audio Player was successfully set to play mode.

### Stop() as Boolean

#### Description

Stops the Audio Player from playing or pausing and cleanup.

#### Return Value

A flag indicating whether the Audio Player was successfully stopped.

### Pause() as Boolean

#### Description

Puts the Audio Player into pause mode. It is an error to Pause if player is not in play mode.

#### Return Value

A flag indicating whether the Audio Player was successfully set to pause mode.

### Resume() as Boolean

#### Description

Puts the Audio Player into play mode starting from the pause point. It is an error to Resume if the player is not in pause mode.

#### Return Value

A flag indicating whether the Audio Player was successfully set to play mode.

### SetLoop(enable as Boolean) as Void

#### Description

Enables/disables the automatic replaying of the Content List.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| enable | Boolean | Set to true to have the Audio Player automatically begin playing the first item in the content list after playing the last item.  <br>  <br>Set to false to have the Audio Player stop after playing the last item in the content list. |

### SetNext(item as Integer) as Void

#### Description

Sets the next item in the Content List to be played.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| item | Integer | Item is the zero-based index of the item in the content list. This item will be played after the currently playing item finishes. |

### Seek(offsetMs as Integer) as Boolean

#### Description

Set the start point of playback for the current item to offsetMs milliseconds.

*   If the item is currently playing, playback will be interrupted and will restart at the specified offset.
*   If the item is not currently playing, playback will begin at the specified offset when Play() is called.

#### Parameters

| Type | Name | Description |
| --- | --- | --- |
| Integer | offsetMs | The offset to be used to determine the start point of the current content item. |

#### Return Value

A flag indicating whether the Audio Player was successfully set to the specified offset.

### SetTimedMetaDataForKeys(keys\[\] as Dynamic) as Void

#### Description

Specifies the timedMetaData keys that the app is interested in receiving from the timedMetaData event.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| keys\[\] | Dynamic | The set of keys to be received from the timedMetaData event.  <br>  <br>If the keys array is empty, all the timed metadata associated with the current stream is sent with the isTimedMetaData event.  <br>  <br>If the keys array is invalid, then do not return any keys to the BrightScript app.  <br>  <br>Any keys not specified with this method are deleted by the Roku OS and never returned to the BrightScript application. |

roLongInteger
=============

roLongInteger is the object name corresponding to the intrinsic LongInteger object.

Supported interfaces
--------------------

*   [ifLongInt](/docs/references/brightscript/interfaces/iflongint.md "ifLongInt")
*   [ifToStr](/docs/references/brightscript/interfaces/iftostr.md "ifToStr")

ifSocketStatus
==============

Implemented by
--------------

| Name | Description |
| --- | --- |
| [roDataGramSocket](/docs/references/brightscript/components/rodatagramsocket.md "roDataGramSocket") | The roDataGramSocket component enables Brightscript apps to send and receive UDP packets |
| [roStreamSocket](/docs/references/brightscript/components/rostreamsocket.md "roStreamSocket") | The roStreamSocket component enables BrightScript apps to accept and connect to TCP streams as well as send and receive data with them |

Supported methods
-----------------

### eAgain() as Boolean

#### Description

Checks whether an EAGAIN error has occurred.

#### Return Value

A flag indicating whether an EAGAIN error has occurred.

### eAlready() as Boolean

#### Description

Checks whether an EALREADY error has occurred.

#### Return Value

A flag indicating whether an EALREADY error has occurred.

### eBadAddr() as Boolean

#### Description

Checks whether an EBADADDR error has occurred.

#### Return Value

A flag indicating whether an EBADADDR error has occurred.

### eDestAddrReq() as Boolean

#### Description

Checks whether an EDESTADDRREQ error has occurred.

#### Return Value

A flag indicating whether an EDESTADDRREQ error has occurred.

### eHostUnreach() as Boolean

#### Description

Checks whether an EHOSTUNREACH error has occurred.

#### Return Value

A flag indicating whether an EHOSTUNREACH error has occurred.

### eInvalid() as Boolean

#### Description

Checks whether an EINVALID error has occurred.

#### Return Value

A flag indicating whether an EINVALID error has occurred.

### eInProgress() as Boolean

#### Description

Checks whether an EINPROGRESS error has occurred.

#### Return Value

A flag indicating whether an EINPROGRESS error has occurred.

### eWouldBlock() as Boolean

#### Description

Checks whether an EWOULDBLOCK error has occurred.

#### Return Value

A flag indicating whether an EWOULDBLOCK error has occurred.

### eSuccess() as Boolean

Checks whether there are no errors (the error number is 0).

### eOK() as Boolean

#### Description

Checks whether there is no hard error, but possibly one of the following async conditions: EAGAIN, EALREADY, EINPROGRESS, EWOULDBLOCK.

#### Return Value

A flag indicating whether an EOK error has occurred.

ifRemoteInfo
============

Implemented by
--------------

| Name | Description |
| --- | --- |
| [roRemoteInfo](/docs/references/brightscript/components/roremoteinfo.md "roRemoteInfo") | The roRemoteInfo component provides an interface to obtain attributes about the Roku remote control that is currently connected to the Roku device. Note that a Roku remote control device that is paired with a device, may not be the one that is currently connected (a single remote is typically connected to a device at a time). |

Supported methods
-----------------

### GetModel(remoteIndex as Integer) as Integer

Returns the model number of the specified Roku remote control. For example, this function returns 135 for an RC135 remote that is connected to the Roku device.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| remoteIndex | Integer | The index for a Roku remote control that is currently connected to the Roku device. In addition to specific remote index, the following values may be specified:  <br><br>*   \-1: The most recently used remote.<br>*   0: The first connected remote (this is typically the only remote that is connected to the device). |

#### Return Values

The model number of the specified Roku remote control, or 0 if the specified remote does not exist.

### IsAwake(remoteIndex as Integer) as Boolean

Checks whether the specified Roku remote control is awake.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| remoteIndex | Integer | The index for a Roku remote control that is currently connected to the Roku device. In addition to specific remote index, the following values may be specified:  <br><br>*   \-1: The most recently used remote.<br>*   0: The first connected remote (this is typically the only remote that is connected to the device). |

#### Return Values

A flag indicating whether the specified Roku remote control is awake.

### HasFeature(feature as String, remoteIndex as Integer) as Boolean

#### Description

Checks if the specified Roku remote control supports the passed in feature string.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| feature | String | The feature to be checked, which may be one of the following values:<br><br>*   "bluetooth"<br>*   "wifi"<br>*   "motion"<br>*   "audio"<br>*   "voicecapture"<br>*   "findremote"<br>*   "hasMuteSwitch" (_Available since Roku OS 13.0_; enables developers to check whether a Roku remote control includes a hands-free voice switch). |
| remoteIndex | Integer | The index for a Roku remote control that is currently connected to the Roku device. In addition to specific remote index, the following values may be specified:  <br><br>*   \-1: The most recently used remote.<br>*   0: The first connected remote (this is typically the only remote that is connected to the device). |

#### Return Values

A flag indicating whether the Roku remote control supports the passed in feature string.

roSystemLog
===========

The roSystemLog component enables the application to receive events from the Roku Streaming Player that are intended for reporting errors and trends, rather than trigger a response to a user action.

All of the log event messages are sent to the roMessagePort that is registered on the [roSystemLogEvent](/docs/references/brightscript/events/rosystemlogevent.md "roSystemLogEvent") object. See roSystemLogEvent for details on the messages.

This object is created with no parameters:

`CreateObject("roSystemLog")`

The roSystemLog component requires specific Design Patterns in your BrightScript Application. Take care to:

*   Use one roMessagePort throughout the application (instead of creating a new roMessagePort for each screen).
*   Create one roSystemLog instance at startup that remains for the entire lifetime of the application.
*   Create the roSystemLog instance on the main thread (it cannot be created on a task thread).
*   Pass the global roMessagePort referenced in the first bullet point to SetMessagePort() on the roSystemLog component.
*   Enable the desired log types using EnableType().
*   Handle the [roSystemLogEvents](/docs/references/brightscript/events/rosystemlogevent.md "roSystemLogEvents") in all message loops.

Supported interfaces
--------------------

*   [ifSystemLog](/docs/references/brightscript/interfaces/ifsystemlog.md "ifSystemLog")

roAppMemoryNotificationEvent
============================

The [roAppMemoryMonitor](/docs/references/brightscript/components/roappmemorymonitor.md "roAppMemoryMonitor") component sends the **roAppMemoryNotificationEvent** with the percentage of memory consumed by the app compared to per-app memory limit.

Supported methods
-----------------

### GetInfo() as Object

Returns an associative array with the following key/value pair:

| Name | Description |
| --- | --- |
| memoryUsagePercent | The percentage of memory consumed by the app compared to per-app memory limit. |

ifTextureRequest
================

Implemented by
--------------

| Name | Description |
| --- | --- |
| [roTextureRequest](/docs/references/brightscript/components/rotexturerequest.md "roTextureRequest") | An roTextureRequest is used to make requests to the roTextureManager |

Supported methods
-----------------

### GetId() as Integer

#### Description

Returns a unique id for the request.

#### Parameters

The unique ID.

### GetState() as Integer

#### Description

Returns the state of the request.

#### Return Value

The state value, which may be one of the following:

| Value | State |
| --- | --- |
| 0   | Requested |
| 1   | Downloading |
| 2   | Downloaded |
| 3   | Ready |
| 4   | Failed |
| 5   | Cancelled |

### SetAsync(async as Boolean) as Void

#### Description

Sets the request to be either asynchronous (true) or synchronous (false). The default is asynchronous

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| async | Boolean | The method used to send the request: asynchronous (true) or synchronous (false). |

### SetSize(width as Integer, height as Integer) as Void

#### Description

Sets the desired size of the roBitmap. The default is to return a bitmap in its native size.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| width | Integer | The width of the roBitmap. |
| height | Integer | The height of the roBitmap. |

### SetScaleMode(mode as Integer) as Void

#### Description

Sets the scaling mode to be used.

#### Parameters

NameTypeDescriptionmodeIntegerThe scaling mode to be used, which may be one of the following values:  
  

| Value | Scaling mode |
| --- | --- |
| 0   | Nearest neighbor (fast). This is the default. |
| 1   | Bilinear (smooth) |

StdDlgButton
============

Extends [Group](/docs/references/scenegraph/layout-group-nodes/group.md "**Group**")

**StdDlgButton** is the class used for each button in the [button area](/docs/references/scenegraph/standard-dialog-framework-nodes/standard-dialog-framework-overview.md#structure). The buttons are displayed in the order in which they are listed as children of the [**StdDlgButtonArea** node](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-button-area.md). The size and layout of each button are controlled by the StandardDialog layout algorithm. **StdDlgButton** nodes should only be used as children of a **StdDlgButtonArea** node.

![roku815px - std-dlg-button](https://image.roku.com/ZHZscHItMTc2/std-dlg-button-3.jpg)

Fields
------

| Field | Type | Default | Access Permission | Description |
| --- | --- | --- | --- | --- |
| text | string | ""  | READ\_WRITE | The text to be displayed on the button |
| disabled | boolean | false | READ\_WRITE | Specifies whether the button can receive focus. If this field is set to true, the button has an inactive appearance and is unable to receive focus. |

init()
======

Allows initialization and other scripted control of a SceneGraph XML component.

If the <script> element contains the definition of a function named init() that has no parameters, that function will be invoked after the XML file has been parsed, and the nodes contained in the file have been created and had their fields set to the values in the XML. Typical uses of the init() function are to cache roSGNode values in the script global variable that will be frequently used in other functions in the script, and to set up field observers that will call other BrightScript functions when the observed field changes value. See [Component initialization order](/docs/developer-program/core-concepts/xml-components/component-initialization-order.md) for complete information on the initialization order for components defined in XML, and the implications of that initialization order for field settings and observer functions.

#### Syntax

    sub init()
      ...
    end sub
    

#### Example

If the XML file contains a Poster node element with id="MyPoster", the XML file below will be parsed, creating the Poster node, then the init() function will be called to cache a pointer to that node, set up an observer of the Poster node translation field, and print the value of the Poster node translation field in the console whenever it changes.

**Using the init() function in XML**

    <?xml version="1.0" encoding="utf-8" ?>
    
    <component>
    
    <script type="text/brightscript" >
    <![CDATA[
    
    function posterTranslationChanged()
        print "MyPoster's translation field changed to "; m.poster.GetField("translation")
    end function
    
    function init()
        m.poster = m.top.FindNode("MyPoster")
        m.poster.ObserveField("translation", "posterTranslationChanged")
    end function
    
    ]]>
    </script>
    
    <children>
    
    <Poster id = "MyPoster" />
    
    </children>
    
    </component>

ProgressDialog
==============

> Roku OS 10.0 introduced a new [StandardProgressDialog node](/docs/references/scenegraph/standard-dialog-framework-nodes/standard-progress-dialog.md "**Standard Progress Dialog**"), which features updated graphics and color palette support. This enables developers to provide a consistent user experience across the progress dialogs in their app. Developers should replace the legacy ProgressDialog nodes in their app with the new [StandardProgressDialog nodes](/docs/references/scenegraph/standard-dialog-framework-nodes/standard-progress-dialog.md "**Standard Progress Dialog**").
> 
> To upgrade a legacy progress dialog to the standard version, prepend "Standard" to the node type. For example, change `progressdialog = createObject("roSGNode", "ProgressDialog")` to `progressdialog = createObject("roSGNode", "StandardProgressDialog")`.

Extends [**Dialog**](/docs/references/scenegraph/dialog-nodes/dialog.md "**Dialog**")

The ProgressDialog node class is a special type of Dialog node that includes the dialog title region and a spinning icon as the body of the dialog. The ProgressDialog node class uses a BusySpinner node to display the spinning icon.

The message, bulleted text, graphic, and button regions of the dialog should all be empty. If those dialog regions are not empty, the layout of the dialog will likely not look correct.

> Not all Roku Player hardware supports arbitrary rotations. In particular, some hardware only supports 90 degree rotation increments. In those cases, the icon will step through 90 degree, 180 degree, 270 degree and back to 0 degree rotations, rather than spin smoothly.

Fields
------

| Field | Type | Default | Access Permission | Description |
| --- | --- | --- | --- | --- |
| busySpinner | BusySpinner | system default | READ\_WRITE | Provides access to the BusySpinner node used by the ProgressDialog node so that the spinner icon and rotation direction can be customized |

Sample app
----------

[ProgressDialogExample](https://github.com/rokudev/samples/tree/master/ux%20components/dialogs/ProgressDialogExample) is a sample app demonstrating ProgressDialog in action.

Getting started
===============

Integrating Roku Pay in an app is seamless. Roku Pay includes a SceneGraph ChannelStore component that contains a complete suite of APIs for managing on-device authentication, purchases, free trial offers, upgrades/downgrades, and access to content. In addition, Roku Pay includes a RESTful API and push notifications that are integrated into an app's backend system for validating, refunding, and canceling purchases.

To get started with a Roku Pay integration and test it in an app without incurring any actual charges, you first need to login to the [Developer Dashboard](https://developer.roku.com/developer) and do the following:

*   [Enroll in the Roku Partner Payouts Program](#roku-partner-payouts-program)
*   [Specify the monetization methods for the app](#monetization)
*   [Add in-app products](#in-channel-products)
*   [Create test users](#test-users)
*   [Set up Roku Pay web services](#roku-pay-web-services)

> Make sure you have [created a Roku account](https://my.roku.com/signup) and [enrolled in the Roku Developer Program](https://developer.roku.com/enrollment/standard) before completing this quickstart.

Roku Partner Payouts Program
----------------------------

To monetize content in an app by offering subscriptions and one-time purchases, you need to provide contact information, a payout method (direct deposit/ACH, wire transfer, or PayPal), and tax forms. See [Publisher payouts](/docs/developer-program/roku-pay/quickstart/partner-payouts.md) for more information.

![roku815px - payout-contact-info](https://image.roku.com/ZHZscHItMTc2/payout-contact-info-v2.png)

Monetization
------------

Specify the monetization methods for your app by selecting which in-app products it will contain: **in-channel subscriptions** and/or **in-channel one-time purchases**. See [Setting the monetization method](/docs/developer-program/roku-pay/quickstart/monetization-method.md) for more information.

![roku815px - monetization-method](https://image.roku.com/ZHZscHItMTc2/monetization-method-v4c.png)

In-app products
---------------

Once your app is enabled for billing testing, you need subscription and one-time purchase products to test with. You can add one or more products to your app in a few steps. Provide basic information such as the name, unique code, and app for the product, and configure its pricing. You can also offer free trial periods and discounts for subscription products. See [Adding in-app products](/docs/developer-program/roku-pay/quickstart/in-channel-products.md) for more information.

![roku815px - in-channel-product.jpg](https://image.roku.com/ZHZscHItMTc2/in-channel-product-v3.png)

Test Users
----------

Test Users can purchase in-app products on development apps without generating charges. Enter the email address of the Roku account linked to the device used for billing testing and then select the app being tested. When your testing Roku Pay in your development app, a payment method will still be required at the time of purchase; however, no charges will actually be made to the test user's method of payment. See [Creating test users](/docs/developer-program/roku-pay/quickstart/test-users.md) for more information.

![roku815px - manage-test-users](https://image.roku.com/ZHZscHItMTc2/manage-test-users-v2.png)

Roku Pay web services
---------------------

Roku Pay includes web services that developers can integrate into their publisher's backend system for validating, refunding, and canceling transactions related to subscriptions and one-time purchases. Validating transactions is especially critical because it enables apps to check whether customers are entitled to content. The Roku Pay web services make this easy by returning a single `isEntitled` flag that indicates whether to grant access. In addition to pulling transactions via the Roku Pay web services, publishers can receive metadata about the transactions in near real-time via push notifications. See [Setting up Roku Pay web services](/docs/developer-program/roku-pay/quickstart/setting-up-web-services.md) to get your Roku Pay API Key and provide a push notification URL.

![roku815px - web-api-settings](https://image.roku.com/ZHZscHItMTc2/roku-pay-api-key-v4.png)

Implementing Roku Search
========================

Roku Search aggregates content from participating apps into a single, indexed search feed. It helps users find content quickly by entering or saying the name of a movie, TV show, actor/actress, and so on. By participating in Roku Search, any content in your app that matches a query is automatically listed in the search results. This provides opportunities to convert searches into subscriptions and rentals, drive users to your app, and increase engagement.

> This document covers the step to prepare and submit your app to participate in Roku Search. To review the Roku Search feed schema itself, see the [Search feed](/docs/specs/search/search-feed.md) specification.

Overview
--------

Roku Search is listed in the main menu of the Roku home screen. Users can use their Roku remote control or Roku mobile app to enter or say their search, and then Roku Search displays content matching the query. If the search is for an actor, actress, or director, users can select content related to the person or view their filmography and then select content. The search results also include [Roku Zones](#roku-zones), which users can select to view a curated selection of content related to the query from apps across the Roku platform.

![roku815px - search results](https://image.roku.com/ZHZscHItMTc2/search-young-rock-query.jpg "searchresults")

When users select a content item, the content details screen provides options for watching the item (from free or subscription). It also provides information about the item such as the title, star rating, release year, parental rating, run time, genre, description, cast, and director.

![roku815px - search channels](https://image.roku.com/ZHZscHItMTc2/search-young-rock-channels.jpg "searchchannels")

Users can then select an app, which launches it and takes them directly to the selected content or a content springboard (via [deep linking)](/docs/developer-program/discovery/implementing-deep-linking.md). If the app is not already installed, it is first added upon being selected.

After completing a search, users can add the results to My Feed, which provides updates on previous searches (for example, a newly added movie starring a previously searched actress).

Integrating Roku Search
-----------------------

Integrating Roku Search in your app entails the following steps:

1.  Create a search feed (create and validate a test feed first, and then provide the full feed).
    
    *   Test feed: Create a test feed with just a few entries (one per each type of content in your catalog). This makes it easier to verify and troubleshoot your search integration before submitting the whole feed.
        
    *   Full feed: Once the test feed has successfully been validated, submitted, and verified with your beta app following steps 1–5, add all the entries in your catalog to your feed and then repeat steps 2–5.
        

2.  Validate the search feed:
    
    a. Use an [online JSON format validator](https://jsonlint.com/) to verify that your feed is using properly formatted JSON.
    
    b. Use an [online JSON schema validator](https://go.roku.com/json-schema-validator) to verify that your feed adheres to Roku's search feed schema.
    

3.  Submit the search feed using the [self-serve tool](https://developer.roku.com/apps/search/overview) in the Developer Dashboard.
    
4.  Test the app with your validated search feed.
    
    *   Verify that the content in your feed appears in Roku Search queries.
        
    *   Verify that selecting content from Roku Search deep links to your app with the proper playback experience.
        

5.  Send [authentication events](/docs/developer-program/discovery/search/prioritizing-authenticated-channels-in-roku-search.md) (for SVOD and TVE apps).

### Search feed submission video demo

The following video demonstrates how to validate and submit a search feed.

 <img src='https://image.roku.com/ZHZscHItMTc2/search-feed-submission-flow.png' alt='Roku Developer Dashboard: Submitting a search feed'

### Creating a search feed

Apps participating in Roku Search must provide a [search feed](/docs/specs/search/search-feed.md), which is a JSON document that contains the metadata for each content item in an app's catalog. Metadata includes the ID, type, title, description, genre, rating, release date, and artwork for the content item.

The content metadata is stored in Roku's master database and is available for matching searches. It is also used to display information about the item after it has been selected.

For content metadata to be added to the Roku Search master database, the search feed must conform to [Roku's JSON schema](/docs/specs/search/search-feed.md#schema) and be validated by Roku. See the [Search Feed specification](/docs/specs/search/search-feed.md) for more information on configuring a search feed so that it passes validation. The spec includes detailed information about each metadata field to be included in the search feed, and it provides the [JSON schema](/docs/specs/search/search-feed.md#schema) and [sample feeds](/docs/specs/search/search-feed.md#sample-feeds) that you can reference.

> To make testing and troubleshooting your Roku Search integration easier, create a short test feed following the [schema](/docs/specs/search/search-feed.md#schema). This test feed should contain a single entry for each type of content in your catalog (movie, television episode, short-form video, and so on). For testing episodic television content, you can provide all the episodes within a single season of a series.
> 
> By starting with a test feed, you can make sure that the search feed integration works end-to-end with all the different content types in your catalog. You can then use the small feed as a template for adding the rest of your catalog to the feed. You can use the sample feeds in the [Search Feed specification](/docs/specs/search/search-feed.md) as templates for adding entries to your feed. The sample feeds adhere to the feed spec and pass validation.

#### Third-party support for integrating Roku Search

Apps can work with third-party vendors such as [Universal Search and Discovery](https://universalsearch.io/get-started) (USAND) or [Instant TV Channel](https://www.instanttvchannel.com/roku/search-feed) to onboard their content feed into Roku Search. These services provide outsourced feed ingestion and metadata delivery services for the Roku platform.

### Validating the search feed

Once the search feed has been created and is hosted online, verify that the [JSON is formatted correctly](https://jsonlint.com/), [adheres to Roku's search feed schema](/docs/specs/search/search-feed.md#schema), and [includes all the required metadata](https://developer.roku.com/apps/search/validator).

1.  Use an [online JSON format validator](https://jsonlint.com/) to make sure that your feed is using properly formatted JSON. Feeds with incorrect JSON formatting will be rejected by Roku's search feed submission tool.
    
    ![roku600px - search-implementation-json-lint](https://image.roku.com/ZHZscHItMTc2/search-implementation-json-lint.png)
    

2.  Use an [online JSON schema validator](https://go.roku.com/json-schema-validator) to verify that your feed adheres to Roku's search feed schema. You can use the provided link and then copy and paste your feed into the validator. Non-compliant feeds will prevent content from being ingested.
    
    ![roku600px - search-implementation-json-valid-schema](https://image.roku.com/ZHZscHItMTc2/search-implementation-json-valid-schema.png)
    
3.  Use Roku's search feed validator in the Developer Dashboard to verify that your feed includes all the required metadata following these steps:
    
    a. In the Developer Dashboard, click **Search feed validator** under **Channel**.
    
    ![roku600px - search-feed-validator-select](https://image.roku.com/ZHZscHItMTc2/search-feed-validator-select.png)
    
    b. In the **Search feed validator** page, enter the URL of the app's search feed:
    
    ![roku600px - search-feed-validator-select](https://image.roku.com/ZHZscHItMTc2/search-feed-validator-enter-feed-url.png?version=1&modificationDate=1712004894000&api=v2)
    
    c. Click **Validate**. Validation testing of your search feed is completed within approximately 15 minutes.
    
    ![roku600px - search-feed-validator-select](https://image.roku.com/ZHZscHItMTc2/search-feed-validator-validating-feed.png)
    
    d. Once the validation testing has been completed, the **Feeds validated in the last 7 days** column displays the percentage of entries in the feed that have passed validation, and the **Status** column lists whether the feed **Passed** or **Failed** validation. A status of "Passed" means that your feed complies with Roku's search feed schema; a status of "Failed" means a part of your feed does not adhere to the schema. This means that your feed can have a status of "Passed" while having less than 100% of the entries validated.
    
    ![roku600px - search-feed-validator-passed](https://image.roku.com/ZHZscHItMTc2/search-feed-validator-passed.png)
    
    e. Click the percentage to view the errors and warnings in your feed to open the Validation report for your feed. This report lists the number of entries in the feed that have passed/failed validation, lists the different errors and warnings in your feed and the number of entries with that specific error or warning, and provides a link to download the report. The errors must be resolved to pass validation; warnings indicate items that passed validation but could be improved if additional metadata fields were provided. Correct the entries and then re-validate your feed.
    
    ![roku600px - search-feed-validator-errors-warnings](https://image.roku.com/ZHZscHItMTc2/search-feed-validator-report.png)
    

### Submitting a search feed

Once you have validated your search feed, you can submit your feed following these steps:

1.  Go to the [Developer Dashboard](https://developer.roku.com/dev/dashboard), and then click **Search feeds** under **Channel**.

2.  The **Search feeds** page opens. It lists the status of all your Search 2.0 and legacy search feeds (to edit a legacy feed, [contact Partner Success](https://developer.roku.com/contact)). Click **New search feed**.
    
    ![roku600px - roku-search-feed-validation-errors](https://image.roku.com/ZHZscHItMTc2/search-feeds-index-page-v3.png)
    

3.  In the **New search feed** page, enter the following information:
    
    ![roku600px - roku-search-feed-validation-ui-v2](https://image.roku.com/ZHZscHItMTc2/roku-search-feed-validation-ui-v3a.png)
    
    | Item | Description |
    | --- | --- |
    | Channel | Select the app to be linked to your search feed. Only public apps that have been published can be selected.To publish your search feed at the same time you publish your app, contact [Partner Success](https://developer.roku.com/contact). |
    | Feed URL | Enter the URL where your search feed is hosted. The search feed is a JSON file with content metadata from one or more sources. See the [**Roku Search Feed 2.0**](https://developer.roku.com/docs/specs/search/search-feed.md) specification for how to create your feed.  <br>  <br>Optionally, you can protect your search feed with basic HTTP authentication and provide the username and password credentials. If your search feed uses basic HTTP authentication, select **Basic Authentication** from the **Feed Authentication Type** field, and then enter the **Username** and **Password** for the feed. |
    | Provider list logo | Upload a 143X113 PNG of your app logo with rounded corners. |
    | Teaser logo | Upload a 165X60 PNG of your app logo with rounded corners. |
    | Email | Enter the email address to receive the search feed validation results. |
    

4.  Click **Submit**. The **Search feeds** page displays the status of the feed submission. To process changes to your search feed (for example, adding new content), you need to resubmit your feed.
    
    ![roku600px - search-status](https://image.roku.com/ZHZscHItMTc2/search-status-validated-100-v3.png)
    
    | Field | Description |
    | --- | --- |
    | Channel | The app associated with the search feed. |
    | Validated content | The percentage of the feed that has been successfully indexed without error. This number is updated approximately every 4 hours. You can click this field to view the current **Feed ingestion report**. |
    | Last feed ingestion | A UTC timestamp indicating when the feed was last ingested. |
    | Status | The current state of the feed ingestion, which may be one of the following values:  <br>  <br><br>*   **Submitted**: The feed has been submitted for validation. It takes up to 15 minutes for feed validation to begin; therefore, the status will not change during this initial period. Once the validation check has been completed, you will receive an email message with the results.<br>*   **Feed Validated**: The feed has passed validation, and it is now undergoing deep linking certification testing.<br>*   **Published**: The feed has passed validation and certification testing, and it is now live in production.<br>*   **Expired**: The feed has no ingestion results available from the past week or longer. This typically occurs for feeds that have never been published to production and have been pending for some time. However, it may also occur when a previously-published feed has become unreachable and therefore has failed validation for over a week. In either scenario, you must manually re-submit the app to ingest the feed again.<br>*   **Rejected**: The feed failed validation during the initial setup.<br>*   **Error**: A previously published feed is now failing validation. Existing content in the feed may still be available in production, but any updates to the feed are not being successfully ingested and are therefore not available in production (new content items do not appear in search). |
    

5.  To open the **Feed ingestion report**, click the percentage under the **Validated content** column. This report lists the number of entries in the feed that has passed/failed validation, lists the errors and warnings in your feed, and provides a link to download the report.
    
    The **Errors and Warnings** table in the report groups and counts any issues in your feed by the error type. You can then click an error type to get all the entries with that specific error or warning. The error types with the highest number of entries with that issue are listed first. You can also search for a specific content ID in your feed to check whether that entry has any errors.
    
    You can click **Edit search feed** to update the URL, logos, and validation email for your feed. You can click **Revalidate feed** once you have fixed the errors in your feed to ingest additional content. You may submit a feed a maximum of 20 times per week.
    
    ![roku600px - feed-ingestion-report](https://image.roku.com/ZHZscHItMTc2/feed-ingestion-report-error-table-v2.png)
    

6.  Download the error report, which is provided in JSON format. Warnings indicate issues that do not prevent an entry from being successfully indexed but could be improved if additional metadata fields were provided. Errors indicate individual entries that failed to be indexed and must be fixed. Use the error report to correct these entries and re-submit your feed until it is validated.
    
    ![roku600px - downloaded-error-report](https://image.roku.com/ZHZscHItMTc2/search-error-report.png)
    

7.  Once your search feed has been validated, the self-serve phase of the integration is complete. In the next phase, which is testing, you will work with Roku Partner Success to verify that deep linking has been integrated into your app per the [implementation guide](https://developer.roku.com/docs/developer-program/discovery/implementing-deep-linking.md).

8.  To update the feed URL, logos, validation email, click the feed under **Search feed status**, edit the properties, and then click **Submit**.

### Testing the app

When you initially submit a search feed, [a beta version of your app](/docs/developer-program/publishing/channel-publishing-guide.md#beta-channel-guidelines) is automatically created in your developer account. The app is named "`<channelName>` SearchBeta", and it is listed in the **Search testing channels** section on the **Beta channels** page. You can use this beta app to test your app's [deep linking implementation](https://developer.roku.com/docs/developer-program/discovery/implementing-deep-linking.md) in order to verify that the app is successfully integrated with Roku Search.

![roku600px - search-beta-channel](https://image.roku.com/ZHZscHItMTc2/search-beta-channel.png)

To test your app's search integration, follow these steps:

1.  Install the beta app that was automatically created in your developer account using the app's access code.

> The beta app is only created for new feeds upon their initial submission. Resubmitting an existing feed does not generate a beta app (for existing feeds submitted before January 31, 2024, contact [contact Roku Partner Success](mailto:partnersuccess@roku.com) to get the beta app).

2.  Search for content items in your feed and verify that they are included in the search results. This process confirms that your feed has been ingested into Roku Search. If results do not appear in Roku Search, confirm that the feed follows the [schema](/docs/specs/search/search-feed.md#schema) and it includes all the required metadata. If you need further help with this step, [contact Roku Partner Success](mailto:partnersuccess@roku.com).
    
    a. Search for each type of content (movie, series, tvSpecial, and shortform) in your feed in Roku Search.
    
    b. Click on search results and verify expected [deep linking behavior](/docs/developer-program/discovery/implementing-deep-linking.md#mediatype-behavior) for each applicable mediatype. For series/episodic content, test both series and episode level watch options in Roku search to complete testing.
    
    *   **Series:** Clicking the series level watch option triggers a deep link command to app with and episode contentId and mediatype series. See the [deep linking documentation](/docs/developer-program/discovery/implementing-deep-linking.md#mediatype-behavior) for more information on the required launch behavior.
    *   **Episode:** Clicking "Episodes" on the series search result screen leads to a season/episodic menu. Selecting an episode and clicking a watch option triggers a deep link command with the associated episode content ID and mediaType episode. See the [deep linking documentation](/docs/developer-program/discovery/implementing-deep-linking.md#mediatype-behavior) for more information on the required launch behavior.
3.  Resubmit your updated beta app in the Developer Dashboard. Keep the beta app synchronized with the production app by continually updating the beta package with a copy of the latest version of the production package. This is required to pass deep linking certification.
    

4.  Once you have verified that the search integration is working correctly, contact Roku Partner Success Roku will use the auto-created beta app to test your app's [deep linking implementation](https://developer.roku.com/docs/developer-program/discovery/implementing-deep-linking.md) and verify that the app is successfully integrated with Roku Search.

> **Information about auto-created beta apps**
> 
> *   The auto-created beta apps do count towards the limit of 10 beta apps per developer account.
> *   A developer account may have a maximum of four auto-created beta apps.
> *   The auto-created beta apps cannot be deleted (they are automatically removed 120 days after being created).
> *   If a user on your team cannot access to the auto-created beta app, manually grant them access via the [User Management page in the Developer Dashboard](https://developer.roku.com/user/access).

### Troubleshooting with a sideloaded app

You can sideload an app and use it to troubleshoot the search integration following these steps:

1.  Use the [Roku Deep Linking Tester](/docs/developer-program/discovery/implementing-deep-linking.md#using-the-rokudeep-linking-tester) or manually [send deep link requests to your app via ECP](/docs/developer-program/discovery/implementing-deep-linking.md#using-ecp-commands-for-testing-deep-linking) to verify that deep links to content in your app from Roku search are working as expected. This method enables you to pass specific content IDs and mediaTypes in order to confirm that your app is properly launching content for the different mediaTypes it supports.

2.  If deep links are not launching into the playback experience per the content item's **mediaType**, make sure the app code has implemented deep linking according to the [Deep Linking specification](/docs/developer-program/discovery/implementing-deep-linking.md#implementing-deep-linking).
    
    If the Deep Linking Tester launches content into the correct playback experience, but on-device testing does not, make sure that the **playId** in the search feed is synced to the **contentId** in the app.
    

### Sending authentication events

SVOD and TVE apps must [send authentication events](/docs/developer-program/discovery/search/prioritizing-authenticated-channels-in-roku-search.md) to Roku to communicate the authentication status of customers when their app is launched. This is a [certification requirement](/docs/developer-program/certification/certification.md#4-channel-operation), and it drives engagement because it ensures that your SVOD or TVE app is listed above non-authenticated apps in the Roku Search content providers list.

### Updating search feeds

You can upload changes to your search feed and resubmit your feed to update Roku Search with your current content (changes are not processed unless you resubmit your feed in the Developer Dashboard). Search feed updates may take up to 24 hours to be propagated to Roku Search.

Participating in additional discovery programs
----------------------------------------------

By participating in Roku Search, your app is eligible for three more discovery programs that provide additional exposure: [Visual Search Results for Roku Voice](#visual-search-results-for-roku-voice), [Roku Zones](#roku-zones) and [Save List](#save-list).

### Visual Search Results for Roku Voice

The Roku UI displays content matching users' voice requests for a movie, TV show, short-form video, or other content.

If a user requests content on a specific app (for example, "Bob the Builder on The Roku Channel" or "find Bob the Builder on The Roku Channel") when outside an app, the Roku UI opens a page with matching content from that app in the top row. The rows below list relative [Roku Zones](#roku-zones) and TV shows, movies, and short-form videos from other apps in the Roku platform that are participating in Roku Search.

If the voice request does not include a specific app (for example, "Bob the Builder" or "find Bob the Builder"), the Roku UI just displays the relative content from apps in the Roku platform that are participating in Roku Search. When the user selects a content item, the content details screen provides options for playing the item (from free or subscription apps).

When users ask for content while in an app, the Roku UI displays a partial overlay with content matching the search request. Content from within the active app is listed in the first row of the display if the active app participates in Roku Search. The rows below include matches from other apps.

> This feature is currently available to customers in the United States only.

![roku815px - roku-discovery-zones-superhero](https://image.roku.com/ZHZscHItMTc2/roku-voice-vsr-channel.jpg)

### Roku Zones

Roku Zones provides a curated selection of relevant content from apps across the Roku platform. It lets users find content and apps related to a specific genre or topic. For example, search results for "Avengers" could include a "Superhero Movies & TV Zone" that lists curated superhero-related movies and TV shows.

![roku815px - roku-discovery-zones-superhero](https://image.roku.com/ZHZscHItMTc2/roku-discovery-zones-superhero-1.png)

### Save List

When customers search for content, they can add the movies and TV shows that they find to their **Save List**. They can they access their saved content by navigating to the **What to Watch** menu, which includes a **Save List** content row.

![roku815px - savelist](https://image.roku.com/ZHZscHItMTc2/save-list-populated.png)

Language and regional support
-----------------------------

The following table lists each region where Roku Search is available and the primary language:

| Region | Primary language |
| --- | --- |
| **North America** |     |
| United States | English |
| Canada | English |
| **Europe** |     |
| United Kingdom | English |
| Ireland | English |
| Germany | German |
| **Latin America** |     |
| Argentina | Spanish |
| Brazil | Portuguese |
| Chile | Spanish |
| Colombia | Spanish |
| Costa Rica | Spanish |
| El Salvador | Spanish |
| Guatemala | Spanish |
| Honduras | Spanish |
| Mexico | Spanish |
| Nicaragua | Spanish |
| Panama | Spanish |
| Peru | Spanish |
| **Asia Pacific** |     |
| Australia | English |

For more information on participating in Roku Search in multiple regions and multiple languages, see the [Roku Search feed specification](/docs/specs/search/search-feed.md#multiregion-and-multilanguage-support).

ifString
========

Implemented by
--------------

| Name | Description |
| --- | --- |
| [roChannelStoreEvent](/docs/references/brightscript/events/rochannelstoreevent.md "roChannelStoreEvent") | The roChannelStore sends an roChannelStoreEvent in response to a call to any of several Get\* methods in ifChannelStore |
| [roPath](/docs/references/brightscript/components/ropath.md "roPath") | The roPath component provides developers an easy way to create valid file system paths |
| [roString](/docs/references/brightscript/components/rostring.md "roString") | Object equivalent for intrinsic type 'String' |
| [roUrlEvent](/docs/references/brightscript/events/rourlevent.md "roUrlEvent") | The roUrlTransfer component sends the roUrlEvent component |

Supported methods
-----------------

Interface equivalent for intrinsic type String.

Also implemented by selected objects that can return a string representation.

### GetString() As String

#### Description

Gets the string value stored in the calling String object.

#### Return Value

The string value stored in the calling String object.

### SetString(value As String) As Void

#### Description

Sets the calling String object to the specified string value.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| value | String | The string value to be set on the calling String object. |

### IsEmpty() as Boolean

#### Description

Checks whether a string is empty.

#### Return Value

A flag indicating whether the string is empty (true), or contains characters (false).

#### Example

    a = "myString"
    b = ""
    
    print a.isEmpty() ' --> false
    print b.isEmpty() ' --> true

ifDouble
========

> Interface equivalent for intrinsic type Double

Implemented by
--------------

| Name | Description |
| --- | --- |
| [roDouble](/docs/references/brightscript/components/rodouble.md "roDouble") | roDouble is a legacy object name, corresponding to the intrinsic Double object |

Supported methods
-----------------

### GetDouble() As Double

#### Description

Gets the double value stored in the calling Double object.

#### Return Value

The double value stored in the calling Double object.

### SetDouble(value As Double) As Void

#### Description

Sets the calling Double object to the specified double value.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| value | Double | The double value to be set on the calling Double object. |

ifPath
======

| Name | Description |
| --- | --- |
| [roPath](/docs/references/brightscript/components/ropath.md "roPath") | The roPath component provides developers an easy way to create valid file system paths |

Supported methods
-----------------

### Change(path as String) as Boolean

#### Description

Modifies or changes the current path via the specified relative or absolute path.

| Name | Return Type | Parameters | Return Value | Description |
| --- | --- | --- | --- | --- |
| Change | Boolean | ${changeparamTable} | Returns true if the resulting path is valid, otherwise false |     |

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| path | String | The new relative or absolute file system path to be used. |

#### Return Value

A flag indicating whether the path was successfully changed.

### IsValid() as Boolean

#### Description

Checks whether the current path is valid (the path is correctly formed). This does not check whether the file actually exists.

#### Return Value

A flag indicating whether the current path is valid.

### Split() as Object

#### Description

#### Return Value

An [roAssociativeArray](/docs/references/brightscript/components/roassociativearray.md "roAssociativeArray") that contains the following keys:

| Name | Type | Description |
| --- | --- | --- |
| basename | String | The filename, without parent directories or extension. |
| extension | String | The filename, with extension, without parent directories. |
| filename | String | The filename. |
| parent | String | The parent directory, or empty if in a root directory. |
| phy | String | The PHY volume. |

#### Example (Brightscript Debugger Interactive Shell)

    > mypath = CreateObject("roPath", "pkg:/source/appMain.brs")
    > ? myPath.Split()
    parent: pkg:/source/
    extension: .brs
    phy: pkg:
    basename: appMain
    filename: appMain.brs

StandardKeyboardDialog
======================

Extends [StandardDialog](/docs/references/scenegraph/standard-dialog-framework-nodes/standard-dialog.md "**Standard Dialog**")

The **StandardKeyboardDialog** node enables text and voice entry of strings consisting of alphanumeric characters as well as many commonly used symbols. It is similar to the legacy [KeyboardDialog](/docs/references/scenegraph/dialog-nodes/keyboarddialog.md) node, but includes voice entry functionality, which is provided through its internal **DynamicKeyboard** node.

![roku815px - keyboard-dialog](https://image.roku.com/ZHZscHItMTc2/keyboard-dialog.jpg)

Structure
---------

The StandardKeyboardDialog is comprised of the following areas and building block nodes:

*   StdDlgTitleArea.
*   StdDlgContentArea, which may contain the following items:
    
    *   Zero or more StdDlgTextItem nodes.
    *   One StdDlgKeyboardItem containing a DynamicKeyboard node
*   StdDlgButtonArea, which may contain zero or more StdDlgButton nodes.

Fields
------

| Field | Type | Default | Access Permission | Description |
| --- | --- | --- | --- | --- |
| title | string | ""  | READ\_WRITE | The title to be displayed at the top of the dialog. |
| message | array of strings | \[ \] | READ\_WRITE | One or more blocks of text, which are typically used to describe information about the data to be entered. Each string in the array is displayed as a separate block of text with the standard amount of space left between the blocks.  <br><br>> Minimize the message length to avoid having a scrollbar automatically added to the content area. If multiple strings are specified or any string is too long, the dialog may not be able to fit within the height of the display. |
| buttons | array of strings | \[ \] | READ\_WRITE | List of buttons to be displayed in the button area at the bottom of the dialog. Each string in the buttons array adds a new button to the button area.  <br><br>> Minimize the number of buttons in the dialog to ensure that all buttons are visible without the user having to scroll up and down. |
| textEditBox | VoiceTextEditBox node | The keyboard item's VoiceTextEditBox node | READ | The internal VoiceTextEditBox node used by this dialog's internal keyboard. This field should be used only to access the fields of this internal node. |
| keyboardDomain | string | "generic" | READ\_WRITE | The type of text to be entered. This may be used by the keyboard to modify the voice entry method and to determine when a valid string has been entered. This may be one of the following values:  <br><br>*   "email": letter-by-letter dictation for emails.<br>*   "numeric": letter-by-letter dictation for PIN codes, zip codes, and other numeric input.<br>*   "alphanumeric": letter-by-letter dication for street addresses or other sequences of numbers and letters.<br>*   "generic": Full word input for search queries or other sequences of numbers, letters and symbols.<br>*   "password": letter-by-letter dication for passwords. |
| text | string | ""  | READ\_WRITE | The default string to be displayed in the keyboard's text edit box. When the user enters the text, this field is updated with the currently entered string. |

Sample app
----------

You can download and install a [sample app](https://github.com/rokudev/standard-dialog-framework) that demonstrates how to create a standard keyboard dialog.

ifEVPDigest
===========

Implemented by
--------------

| Name | Description |
| --- | --- |
| [roEVPDigest](/docs/references/brightscript/components/roevpdigest.md "roEVPDigest") | The EVP Digest component provides an interface to the OpenSSL EVP library of message digest algorithms |

Supported methods
-----------------

### Setup(digestType as String) as Integer

#### Descriptions

Initializes a new message digest context.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| digestType | String | The supported digest algorithm from openssl, listed at roEVPDigest. |

#### Return Value

Returns 0 on success or non-zero on failure.

### Reinit() as Integer

#### Description

Re-initializes an existing message digest context. This can be called to reuse an existing [roEVPDigest](/docs/references/brightscript/components/roevpdigest.md "roEVPDigest") object to digest new data.

#### Return Value

Returns 0 on success or non-zero on failure.

### Process(bytes as Object) as String

#### Description

Digests the provided data.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| bytes | Object | An [roByteArray](/docs/references/brightscript/components/robytearray.md) containing digested data |

#### Return Value

A Hex string (Digested array data).

#### Example

      x = evp.Process(bytes)
    

is equivalent to

      evp.Reinit()
      evp.Update(bytes)
      x = evp.Final()
    

### Update(bytes as Object) as Void

#### Description

Adds more data to be digested.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| bytes | Object | An [roByteArray](/docs/references/brightscript/components/robytearray.md) containing data to be added to the current digest |

### Final() as String

#### Description

Returns the digest of data passed in by previous calls to [Update()](#updatebytes-as-object-as-void) as a hex string.

#### Return Value

Hex string (digest of data)

Memory management
=================

Texture memory
--------------

A common offense is simply using too much texture memory. It's important to realize that simply using a larger image does not necessarily ensure a higher quality end result. Rather, using unnecessarily large images will more often than not result in performance issues. All Roku devices have a dedicated amount of texture memory, which varies largely from device to device. Each _unique_ image you would like to display on your app will take up a certain amount of the limited texture memory (however, reusing the same image on multiple nodes will not take up more memory). More specifically, the **size in bytes** of the image file does not matter (so compressing your images is inconsequential), rather, the **pixel dimension** of the image is strictly important. Images are loaded into texture memory in the form of bitmaps, taking up 4 bytes per pixel (RGBA). A quick calculation (width x height x 4B) can help you approximate how much texture memory your images will be taking up.

Here is a small list of the amount of texture memory available to your app to use on various devices:

*   [Tyler](/docs/specs/hardware.md#roku-models-and-features): 20 MB
*   [Giga](/docs/specs/hardware.md#roku-models-and-features): 44-45 MB
*   [Mustang/Austin](/docs/specs/hardware.md#roku-models-and-features): 60 MB

If your app ends up going over any of these limits by trying to display more than what the texture memory can allow for, then your app will run into unexpected behavior on those devices. A common symptom is flickering images or slow content loading, as bitmaps will be constantly unloaded and reloaded onto memory in an effort to manage the excess images. Even if your images do not use up all the texture memory on a device, your app will load slower in general if it contains larger images.

### How to see texture memory

1.  Side load your app using one of the normal methods
2.  Run your app and navigate in the UI to where you think there might be an issue.
3.  telnet to your roku at port 8080.
4.  If your app is SceneGraph run this command: "loaded\_textures". Be aware that there is a texture cache, so images that are not visible can be cleared automatically.
5.  if your app is pre-SceneGraph, 2D API or template, run this command: "r2d2\_bitmaps."

### How to avoid going over memory limits

#### Make images smaller

The simplest solution! If you're planning on displaying an image on a 200x200 Poster node, don't load in and render a 1920x1080 image. It will work, but it'll be a waste of system resources for no real benefit. A quick calculation puts a 1920x1080 image at using a whopping (1920•1080•4 = **~8.3MB**) of memory, while the appropriately sized 200x200 image will only take up **~0.16MB**. Using the loadWidth and loadHeight fields of a Poster node would be an equivalent solution to resizing the images themselves.

#### Use minimalistic item renderers

The fewer elements, the better. Use [Rectangle](/docs/references/scenegraph/renderable-nodes/rectangle.md) nodes, which do not require a bitmap loaded into memory, over [Poster](/docs/references/scenegraph/renderable-nodes/poster.md) nodes whenever possible. Keep in mind that even bitmaps for elements like focus rings and keyboard backgrounds take up texture memory - so take care to not use unnecessarily large images for these.

### Debugging texture memory performance

Using r2d2_bitmaps to check the amount of texture memory available:_

![roku815px - texturememory](https://image.roku.com/ZHZscHItMTc2/texturememory.png "texturememory")

You can check your texture memory usage by telnetting to port 8080 on your Roku device and running the command “r2d2\_bitmaps”. This command will output a list of memory addresses representing the assets loaded into texture memory, their width and height, as well as their size in bytes. At the bottom, it also shows the available memory you have on your device left, the amount used, and the amount that the device has in total. If your app uses multiple high resolution images (e.g. more than two 1920 x 1080 images), you will notice that the available memory will hit a peak somewhere less than the max amount and keep fluctuating between values as the texture memory manager tries offloading assets and reloading them back in to manage memory. Make sure to use the performance techniques listed in this guide so that your app doesn't run into these problems!

System memory (DRAM)
--------------------

*   Roku devices have anywhere from **256 MB DRAM** on the lowest end devices, to **1.5 GB DRAM** on the [Dallas](/docs/specs/hardware.md#roku-models-and-features) platform.
    
*   While many applications like **image processing or 3D modeling software** benefit greatly from a large amount of RAM, this is usually not the case for apps running on Roku OS.
    
*   For nearly all apps, **RAM will not be a bottleneck for performance** unless you have a serious memory leak somewhere.
    
*   An app is far more likely to hit the texture memory or CPU ceiling than to ever run out of RAM, and your app is sandboxed such that the Roku device will always allocate and save enough RAM for video buffering. In addition, if your app uses a large amount of RAM it will simply be killed before performance hits are noticeable.
    

### Viewing system memory

**For SceneGraph apps**

For SceneGraph apps, just like above, run the app and `port 8080`. Then run `sgnodes all`

**For pre-SceneGraph apps**

For pre-SceneGraph apps, telnet to the console; hit **^C** to break into the debugger; run `bcs` or `bscs`

> This is also useful for SceneGraph apps.

StdDlgButtonArea
================

Extends [StdDlgAreaBase](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-area-base.md "**StdDlgAreaBase**")

The **StdDlgButtonArea** node is always positioned at the bottom of the [StandardDialog](/docs/references/scenegraph/standard-dialog-framework-nodes/standard-dialog.md). It contains zero or more child nodes of type [**StdDlgButton**](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-button.md) or a type that extends **StdDlgButton**. Each of the **StdDlgButton** nodes provides an option to perform some task related to the purpose of the dialog. For example, dialogs often have "Continue" and "Cancel" buttons in the bottom area. The buttons are positioned and sized so that they are arranged vertically in the order in which their **StdDlgButton** child nodes are listed.

A dialog may only have a single button area, and the button area is optional.

![roku815px - std-dlg-button-area](https://image.roku.com/ZHZscHItMTc2/std-dlg-button-area.jpg)

Fields
------

The **StdDlgButtonArea** node does not have any fields.

roByteArray
===========

The byte array component is used to contain and manipulate an arbitrary array of bytes.

This object contains functions to convert strings to or from a byte array, as well as to or from ascii hex or ascii base 64. Note that if you are converting a byte array to a string, and the byte array contains a zero, the string conversion will end at that point. roByteArray will autosize to become larger as needed. If you wish to turn off this behavior, then use the SetResize() function. If you read an uninitialized index, "invalid" is returned. roByteArray supports the [ifArray](/docs/references/brightscript/interfaces/ifarray.md "ifArray") interface, and so can be accessed with the array \[\] operator. The byte array is always accessed as unsigned bytes when using this interface. roByteArray also supports the ifEnum interface, and so can be used with a "for each" statement.

**Example**

    ba=CreateObject("roByteArray")
    ba.FromAsciiString("leasure.")
    if ba.ToBase64String()<>"bGVhc3VyZS4=" then stop
    
    ba=CreateObject("roByteArray")
    ba.fromhexstring("00FF1001")
    if ba[0]<>0 or ba[1]<>255 or ba[2]<>16 or ba[3]<>1 then stop
    
    ba=CreateObject("roByteArray")
    for x=0 to 4000
        ba.push(x)
    end for
    
    ba.WriteFile("tmp:/ByteArrayTestFile")
    ba2=CreateObject("roByteArray")
    ba2.ReadFile("tmp:/ByteArrayTestFile")
    if ba.Count()<>ba2.Count() then stop
    for x=0 to 4000
        if ba[x]<>ba2[x] then stop
    end for
    
    ba2.ReadFile("tmp:/ByteArrayTestFile", 10, 100)
    if ba2.count()<>100 then stop
    for x=10 to 100
        if ba2[x-10]<>x then stop
    end for
    

Supported interfaces
--------------------

*   [ifByteArray](/docs/references/brightscript/interfaces/ifbytearray.md "ifByteArray")
*   [ifArray](/docs/references/brightscript/interfaces/ifarray.md "ifArray")
*   [ifArrayGet](/docs/references/brightscript/interfaces/ifarrayget.md "ifArrayGet")
*   [ifArraySet](/docs/references/brightscript/interfaces/ifarrayset.md "ifArraySet")
*   [ifArraySlice](/docs/references/brightscript/interfaces/ifarrayslice.md)
*   [ifEnum](/docs/references/brightscript/interfaces/ifenum.md "ifEnum")

roBoolean
=========

roBoolean is the object equivalent for intrinsic type Boolean.

This is useful in the following situations:

*   When an object is needed, instead of an intrinsic value. For example, "roList" maintains a list of objects. If an Boolean is added to roList, it will be automatically wrapped in an roBoolean by the language interpreter. When a function that expects a BrightScript Component as a parameter is passed a boolean, BrightScript automatically creates the equivalent BrightScript Component.
*   If any object exposes the ifBoolean interface, that object can be used in any expression that expects an intrinsic value.

Supported interfaces
--------------------

*   [ifBoolean](/docs/references/brightscript/interfaces/ifboolean.md "ifBoolean")
*   [ifToStr](/docs/references/brightscript/interfaces/iftostr.md "ifToStr")

Overhang
========

Extends [**Group**](/docs/references/scenegraph/layout-group-nodes/group.md)

The Overhang node provides a information bar that is displayed at the top of a screen in many Roku apps. The regions occupied by the overhang can be filled with either a solid color or a bitmap.

On the left side, a logo bitmap and/or a string can be displayed. If both are displayed, a vertical divider is drawn to separate them. The string is typically set to display a reminder to the user of their current location in the interface. For example, in the Roku homescreen, the string is set to "Search" while the user in the search entry portion of the user interface. Then when the user explores a search result, the string is changed to reflect the name of the content being explored.

On the right side, a clock and/or an indicator that the options key (\*) is available can be displayed. If both are displayed, a vertical divider is drawn to separate them.

The appearance and contents of the Overhang can be customized by setting its fields to the desired values.

Fields
------

| Field | Type | Default | Access Permission | Use |
| --- | --- | --- | --- | --- |
| color | color | 0x232323ff | READ\_WRITE | Specifies that the area occupied by the Overhang should be filled with the specified color.  <br>  <br>The color field and the backgroundUri field are "last one wins" fields. Whichever of these fields is set later overrides the other one. |
| backgroundUri | uri | ""  | READ\_WRITE | Specifies the URI of a bitmap that is used to fill the area occupied by the overhang.  <br>  <br>The color field and the backgroundUri field are "last one wins" fields. Whichever of these fields is set later overrides the other one. |
| logoUri | uri | ""  | READ\_WRITE | Specifies the URI of a bitmap to be drawn on the left side of the overhang.  <br>  <br>If both a logo and a title are specified, the logo will be displayed to the left of the title, separated by a vertical divider. |
| logoBaselineOffset | float | 0   | READ\_WRITE | Specifies a vertical adjustment to be applied to the logo to adjust its alignment relative to the overall overhang. The logo is positioned so that its baseline (as specified by this field) aligns with the baseline of the options prompt on the right side of the overhang |
| title | string | ""  | READ\_WRITE | Specifies a string to be displayed on the left side of the overhang. It will be drawn to the right of the logo, if a logo is specified.   <br>  <br>If both a logo and a title are specified, the logo will be displayed to the left of the title, separated by a vertical divider. |
| titleColor | color | 0xddddddff | READ\_WRITE | Specifies the color of the title text |
| showClock | Boolean | Based on device setting | READ\_WRITE | Specifies whether or not the Clock is displayed as part of the annotations that appear on the right side of the Overhang. If both the clock and the options prompt are shown, the clock will be displayed to the left of the options prompt, separated by a vertical divider.  <br>  <br>The default value is based on the device's clock format setting (Settings > System > Time > Clock format). If the clock format is set to off, the default value is false; otherwise, it is true. |
| clockColor | color | 0xddddddff | READ\_WRITE | Specifies the color of the clock text |
| clockText | string | ""  | READ\_WRITE | Specifies an alternate string to display in the clock location on the right side of the overhang. If the clockText field is set to a non-empty string, that string will replace the clock display. Setting the clockText field back to an empty string will restore the display of the clock. |
| showOptions | Boolean | false | READ\_WRITE | Specifies whether the Options prompt is displayed in as part of the annotations that appear on the right side of the Overhang. The **optionsAvailable** field must also be set to true to display the options prompt.  <br>  <br>If both the clock and the options prompt are shown, the clock will be displayed to the left of the options prompt, separated by a vertical divider. |
| optionsColor | color | 0xddddddff | READ\_WRITE | Specifies the color of the options indicator when the options key is available (i.e. the showOptions field is set to true) |
| optionsDimColor | color | 0xdddddd44 | READ\_WRITE | Specifies the color of the options indicator when the options key is not available (i.e. the showOptions field is set to false) |
| optionsIconColor | color | 0xffffffff | READ\_WRITE | Specifies a color to tint the neutral colored options icon displayed in the overhang when the options key is available (i.e. the showOptions field is set to true). If no color is specified, the options icon will be white. |
| optionsIconDimColor | color | 0xffffffff | READ\_WRITE | Specifies a color to tint the neutral colored options icon displayed in the overhang when the options key is not available (i.e. the showOptions field is set to false). If no color is specified, the options icon will be pale gray. |
| optionsAvailable | Boolean | false | READ\_WRITE | Specifies whether the Options key is currently available. |
| optionsText | string | ""  | READ\_WRITE | Sets the text next to the Options (\*) symbol in the overhang. |
| optionsMaxWidth | float | 0.0 | READ\_WRITE | Set the max width (in pixels) to ellipsize optionsText. It has a default value of 0.0 meaning there is no max width restriction. This field does nothing if optionsText is not set. |
| leftDividerUri | uri | ""  | READ\_WRITE | Specifies the URI of the bitmap to be used as the divider between the logo and the title on the left side of the overhang |
| leftDividerVertOffset | float | 0   | READ\_WRITE | Specifies a vertical offset to add to the position of the divider between the logo and the title on the left side of the overhang. By default, the bottom of the divider bitmap is drawn at baseline offset of the logo bitmap, as specified by the logoBaselineOffset field. |
| rightDividerUri | uri | ""  | READ\_WRITE | Specifies the URI of the bitmap to be used as the divider between the clock and the options prompt on the right side of the overhang |
| rightDividerVertOffset | float | 0   | READ\_WRITE | Specifies a vertical offset to add to the position of the divider between the clock and the options prompt on the left side of the overhang. By default, the vertical center of the divider bitmap is aligned to the vertical center of the options prompt. |
| height | float | 115 | READ\_WRITE | Specifies the height of the Overhang region. Typically this value is not overridden. |

Sample app
----------

[OverhangExample](https://github.com/rokudev/samples/tree/master/ux%20components/sliding%20panels/OverhangExample) is a sample app demonstrating Overhang in action.

ifSGNodeHttpAgentAccess
=======================

The ifSGNodeHttpAgentAccess interface allows you to get an [roHttpAgent](/docs/references/brightscript/components/rohttpagent.md "roHttpAgent") object from a SceneGraph node, and set an roHttpAgent object for a nod

Implemented by
--------------

| Name | Description |
| --- | --- |
| [roSGNode](/docs/references/brightscript/components/rosgnode.md "roSGNode") | The roSGNode object is the BrightScript equivalent of SceneGraph XML file node creation |

Supported methods
-----------------

### getHttpAgent() as Object

#### Description

Returns the roHttpAgent object for the node.

#### Return Value

The roHttpAgent object for the node, which may be one of the following:

*   the node roHttpAgent object, if it was set using setHttpAgent()
*   the roHttpAgent object of the closest ancestor node that has an roHttpAgent set
*   the default roHttpAgent object for the application that contains the node

### setHttpAgent(HTTP\_agent as Object) as Boolean

Sets an roHttpAgent object for the node.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| HTTP\_agent | Object | The roHttpAgent object to be set for the node. |

#### Return Value

A flag indicating whether the roHttpAgent object was successfully set.

Statement summary
=================

BrightScript supports the following familiar looking statement types:

    If / Then / Else If / Else / End If  
    For / To / End For / Step / Exit For  
    For Each / In / End For / Exit For  
    While / End While / Exit While
    Try / Catch / End Try
    Throw
    Function / End Function / As / Return  
    Print (or ?)
    Rem (or ')  
    Goto  
    Dim  
    End  
    Stop
    

BrightScript is not case sensitive.

Each statement's syntax is documented precisely later in the manual.

For example:

    function Main() as Void 
        dim cavemen[10] 
        cavemen.push("fred")
        cavemen.push("barney")
        cavemen.push("wilma")
        cavemen.push("betty") 
        for each caveman in cavemen
            print caveman
        end for 
    end function
    

Each line may contain a single statement, or a colon ( : ) may be used to separate multiple statements on a single line.

    myname = "fred"
    if myname="fred" then yourname = "barney" : ? yourname

Creating test users
===================

Test users can make in-app purchases free-of-charge for testing purposes. This is useful for testing the Roku Pay integration in an app.

> In order for a test user to make free in-app purchases on an app:
> 
> *   The test user must be associated with the app being tested.
> *   The test user's Roku account must be linked to the Roku device on which the app is installed.

Adding a test user
------------------

To create a test user and add apps to it, follow these steps:

1.  In the [Developer Dashboard](https://developer.roku.com/developer), select **Test Users** under **Monetization**.
    
    ![roku600px -  - test users](https://image.roku.com/ZHZscHItMTc2/test-user-dashboard-2-v3.jpg)
    

2.  The **Manage test users** index page lists the email addresses and apps for each test user. Click **Add New Test User**.
    
    ![roku600px - manage-test-user-index](https://image.roku.com/ZHZscHItMTc2/manage-test-user-index-v2.png)
    

3.  In the **Test User Email** box, enter the email address of the test user. The test user must be the app's [root account user](/docs/features/dashboard/user-access-management.md).

4.  From the **Channels** list, select one or more apps on which the test user can make free purchases.
    
    ![roku600px - add-test-user](https://image.roku.com/ZHZscHItMTc2/add-test-user-v2.png)
    

5.  Click **Add**. The test user is listed in the **Manage test users** index page.

6.  To edit the email address or apps of the test user, click **Edit**, make changes, and then click **Update**.

Viewing and voiding transactions
--------------------------------

You can view all the transactions made by test users on your apps. You can also void all the transactions made by the test user on a specific to re-test the purchase workflows on that app with that test user. To view and void the transactions of a test user, follow these steps:

1.  Under the **Transactions** column in the test user's row, click **View**.

2.  The **Test user transaction** page lists each transaction made by the test user per app, including the purchase date, app name, transaction ID (used by the Roku Pay Web Service API for validating, refunding, and canceling purchases), and product name.
    
    ![roku815px - void-test-user-transaction](https://image.roku.com/ZHZscHItMTc2/void-test-user-transaction-v2a.png)
    

3.  To void the transactions made by the test user on a specific app, click **Void transactions**. All transactions made by the test user on that app are permanently deleted. The transaction IDs of the voided transactions are not accessible via the Roku Pay Web Service API.

roAppManager
============

The roAppManager component is used to returns information about the app.

Supported interfaces
--------------------

*   [ifAppManager](/docs/references/brightscript/interfaces/ifappmanager.md "ifAppManager")

ifAudioGuide
============

> Please note this component is only available on the following devices: Roku Streaming Stick (3600X), Roku Express (3700X) and Express+ (3710X), Roku Premiere (4620X) and Premiere+ (4630X), Roku Ultra (4640X), and any Roku TV running Roku OS version 7.5 and later.

Implemented by
--------------

| Name | Description |
| --- | --- |
| [roAudioGuide](/docs/references/brightscript/components/roaudioguide.md "roAudioGuide") | Returns information about the application |

Supported methods
-----------------

### Say(text as String, flushSpeech as Boolean, dontRepeat as Boolean) as Integer

#### Description

Returns an ID for the spoken string to notify observer callbacks about a specific spoken string. This ID can be used with the [roTextToSpeechEvent](/docs/references/brightscript/events/rotexttospeechevent.md "roTextToSpeechEvent").This method will automatically split up text to reduce lag. Due to this automatic splitting, the roTextToSpeechEvent 0 ("Started speech") event for the returned ID may not be sent until later than expected. The roTextToSpeechEvents 1 ("Speech has completed") and 2 ("Speech has been flushed") events are sent at the expected times.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| text | String | The string to be spoken.  <br>  <br>Punctuation such as commas and periods can be used to add pauses to the speech playback.  <br>  <br>Typically, special characters are generally not spoken; however, you can pass in the appropriate text such as "question mark" to have a special character be spoken (do not use the symbol). |
| flushSpeech | Boolean | Set to true to make the screen reader immediately stop speaking any other speech before speaking.  <br>  <br>Set to false to make the screen reader wait until any current speech is done before speaking. |
| dontRepeat | Boolean | Set to true to ignore calls to the say() method with the same text.  <br>  <br>Set to false to speak when calls to the say() method are sent with the same text. |

#### Return Value

An ID associated with the spoken string to be used to notify observer callbacks.

### Flush()

#### Description

Interrupts and stops any current text to speech spoken string, to be used when the application does not want the text to speech to continue.

> This call is equivalent to the [roTextToSpeech.Flush()](/docs/references/brightscript/interfaces/iftexttospeech.md#flush) method, and stops speech started by the [roAudioGuide.Say()](#saytext-as-string-flushspeech-as-boolean-dontrepeat-as-boolean-as-integer) and [roTextToSpeech.Say()](/docs/references/brightscript/interfaces/iftexttospeech.md#saytext-as-string-as-integer) methods.

### Silence(duration as Integer) as Integer

#### Description

If the screen reader is enabled, causes text to speech to continue to suppress any application background sound for the amount of time specified by duration (in milliseconds).This can be used to add clarity for longer spoken text that may have pauses that might otherwise allow application background sound to be heard. This method does nothing if screen reader is currently disabled.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| duration | Integer | The number of milliseconds to suppress application background sounds. |

#### Return Value

The number of milliseconds that the background sound has been silenced.

ifGetMessagePort
================

Implemented by
--------------

| Name | Description |
| --- | --- |
| [roHdmiStatus](/docs/references/brightscript/components/rohdmistatus.md "roHdmiStatus") | The HDMI status component provides an interface to the current HDMI operational status |
| [roScreen](/docs/references/brightscript/components/roscreen.md "roScreen") | The roScreen component provides a full screen drawing surface that can be stacked and that you can receive input events from |
| [roUrlTransfer](/docs/references/brightscript/components/rourltransfer.md "roUrlTransfer") | A roUrlTransfer object transfers data to or from remote servers specified by URLs |
| [roTextToSpeech](/docs/references/brightscript/components/rotexttospeech.md "roTextToSpeech") | The roTextToSpeech component provides text to speech capabilities to applications |

Supported methods
-----------------

### GetMessagePort() as Object

#### Description

Returns the message port (if any) currently associated with the object

#### Return Value

The message port.

TargetList
==========

Extends [**TargetGroup**](/docs/references/scenegraph/layout-group-nodes/targetgroup.md)

The TargetList node class adds useful functionality to the TargetGroup node by making is easy to set up lists and rows of items with limited amounts of scripting required. In particular, TargetList provides a built-in focused/unfocused transition, as well as a simple way to implement various focus management policies (i.e. fixed focus, floating focus, etc.). It also provides default key handling for navigating the list or row.

### Fixed Focus Set-up

To set up a fixed focus list or grid, set the focusedTargetSet field to a TargetSet that describes a set of rectangular target regions where each item will be rendered. If you want to have a transition between the layouts for when the TargetList is focused and when it is unfocused, set the unfocusedTargetSet field to a TargetSet that describes a set of rectangular target regions for the unfocused case. Make sure to specify which of the target regions should contain the focused item either by setting the targetIndex field of the focusedTargetSet or by setting the TargetGroup's defaultTargetSetFocusIndex field.

**focusedTargetSet1**

    focusedTargetSet1 = createObject("roSGNode", "TargetSet")
    m.tList1.focusedTargetSet = [ focusedTargetSet1 ]
    
    focusedTargetSet1.targetRects = [
        { x:-178, y:-64, height:134, width:240 },
        { x:72, y:-96, height:202, width:360 }, ' rectangle in focus (Item 1)
        { x:442, y:-64, height:134, width:240 },
        { x:692, y:-64, height:134, width:240 },
        { x:942, y:-64, height:134, width:240 },
        { x:1192, y:-64, height:134, width:240 }
    ]
    focusedTargetSet1.color = "0x00202020AA"
    focusedTargetSet1.focusIndex = 1
    

**unfocusedTargetSet**

    unfocusedTargetSet.targetRects = [
        { x:-100, y:-64, height:134, width:240 },
        { x:150, y:-64, height:134, width:240 },
        { x:400, y:-64, height:134, width:240 },
        { x:650, y:-64, height:134, width:240 },
        { x:900, y:-64, height:134, width:240 },
        { x:1150, y:-64, height:134, width:240 }
    ]
    unfocusedTargetSet.color = "0x00202020AA"
    

### Floating Focus Set-up

To set up a floating focus list or grid, set the focusedTargetSet field to a TargetSet that describes a set of rectangular target regions where each item will be rendered. For each possible layout of focused items, specify a TargetSet node that shows the layout of all the target regions, then set the focusedTargetSet field to an array containing those TargetSet nodes.

In the graphic below, the first row contains 4 fully visible rectangles (excluding the two partially visible items on each end). In order to create a floating focus effect, each fully visible rectangle is defined by its own TargetSet that describes a set of rectangles, their sizes, their positioning, and which rectangle is in focus within the TargetSet. In the first TargetSet (when Item 1 is in focus), we define the size and positioning of all the rectangles within the first row. The focusIndex ("1") is also set to the index within the array of targetRects we want to be in focus.

When the focus moves to Item 2, the layout of the first row is defined by another TargetSet defining the size and positioning of Item 2 and the positioning and sizes of the adjacent rectangles. The same is also true when Item 3 is in focus and when Item 4 is in focus. An unfocusedTargetSet can also be defined for unfocused rows like the 2 rows below the row in focus seen below.

**focusedTargetSet array**

    focusedTargetSet1 = createObject("roSGNode", "TargetSet")
    focusedTargetSet2 = createObject("roSGNode", "TargetSet")
    focusedTargetSet3 = createObject("roSGNode", "TargetSet")
    focusedTargetSet4 = createObject("roSGNode", "TargetSet")
    m.tList1.focusedTargetSet = [ focusedTargetSet1, focusedTargetSet2, focusedTargetSet3, focusedTargetSet4 ]
    

**Additional TargetSets for floating focus**

    focusedTargetSet2.targetRects = [
        { x:-178, y:-64, height:134, width:240 },
        { x:72, y:-64, height:134, width:240 },
        { x:322, y:-96, height:202, width:360 }, ' rectangle in focus (Item 2)
        { x:692, y:-64, height:134, width:240 },
        { x:942, y:-64, height:134, width:240 },
        { x:1192, y:-64, height:134, width:240 }
    ]
    focusedTargetSet2.color = "0x00202020AA"
    focusedTargetSet2.focusIndex = 2
    
    focusedTargetSet3.targetRects = [
        { x:-178, y:-64, height:134, width:240 },
        { x:72, y:-64, height:134, width:240 },
        { x:322, y:-64, height:134, width:240 },
        { x:572, y:-96, height:202, width:360 }, ' rectangle in focus (Item 3)
        { x:942, y:-64, height:134, width:240 },
        { x:1192, y:-64, height:134, width:240 }
    ]
    focusedTargetSet3.color = "0x00202020AA"
    focusedTargetSet3.focusIndex = 3
    
    focusedTargetSet4.targetRects = [
        { x:-178, y:-64, height:134, width:240 },
        { x:72, y:-64, height:134, width:240 },
        { x:322, y:-64, height:134, width:240 },
        { x:572, y:-64, height:134, width:240 },
        { x:822, y:-96, height:202, width:360 }, ' rectangle in focus (Item 4)
        { x:1192, y:-64, height:134, width:240 }
    ]
    focusedTargetSet4.color = "0x00202020AA"
    focusedTargetSet4.focusIndex = 4
    

#### Notes

*   To set up floating focus, it is important that all of the TargetSet's specify the same number of target rectangles and for the TargetSet's focusIndex fields to increase by 1 for each TargetSet in the focusedTargetSet field. In the example below, each TargetSet contains an array of 6 rectangles with the focus set to index 1 in focusedTargetSet1, index 2 in focusedTargetSet2, index 3 in focusedTargetSet3, and index 4 in focusedTargetSet4.
*   Setting up an unfocused layout works the same as in the fixed focus case above. Make sure that you do not specify a focusIndex for the unfocusedTargetSet (or set it equal to the default value of -1). Doing this keeps the focus index unchanged when the list loses, then regains focus.

![roku815px - floatingFocus](https://image.roku.com/ZHZscHItMTc2/floatingFocus.gif "floatingFocus")

> Each unfocused TargetList is referencing the same unfocusedTargetSet

Fields
------

| Field | Type | Default | Access Permission | Description |
| --- | --- | --- | --- | --- |
| focusedTargetSet | array of TargetSet nodes | \[ \] | READ\_WRITE | Specifies one or more TargetSet's to be used when the TargetList has the focus. If a single TargetSet is specified, focus will stay fixed on the targetRect of that TargetSet that corresponds to the TargetGroup's focus index. The focus index will come from the TargetSet if explicitly specified or from the TargetGroup's defaultTargetSetFocusIndex field if not.  <br>  <br>If focusedTargetSet includes more than one TargetSet node, that defines a sequence of TargetSet's that will be advanced through as the user presses the advance or reverse key. When advancing, the focus floats from one TargetSet's to the next TargetSet in the array until the last element of the focusedTargetSet is reached, at which point the focus is fixed to the last element and the items begin to scroll.  <br>  <br>When reversing, the focus floats from one TargetSet to the previous TargetSet in the array until the first element of the focusedTargetSet is reached, at which point the focus is fixed to the first element and the items begin to scroll.  <br>  <br>See above for more discussion of setting up fixed and floating focus use cases. |
| unfocusedTargetSet | TargetSet | invalid | READ\_WRITE | Specifies the TargetSet to be used when the TargetList does not have the focus. |
| advanceKey | string | "down" | READ\_WRITE | Specifies which remote button will move the focus forward. For vertical lists, this will typically be set to "down". For horizontal rows, this will typically be set to "right". |
| reverseKey | string | "up" | READ\_WRITE | Specifies which remote button will move the focus backward. For vertical lists, this will typically be set to "up". For horizontal rows, this will typically be set to "left". |

Sample app
----------

[TwoRowFixedFocus](https://github.com/rokudev/samples/tree/master/ux%20components/screen%20elements/target_group/TwoRowFixedFocus) is a sample app demonstrating TargetList in action.

<children>
==========

The <children> element contains the SceneGraph node XML markup elements. The <children> element allows XML schema validation of your SceneGraph XML components using XSD by wrapping them in a container element (XSD requires that the order of elements be deterministic, and so for validation to work, SceneGraph node elements must be contained in an element themselves).

The SceneGraph node markup elements contained in the <children> element may include a special XML element attribute, `role`. The `role` attribute allows a node element to be defined as a child node of a parent node, and the child node to be assigned as the value of the parent node field identified by the `role` attribute value:

    <ParentNode >
      <ChildNode 
        role = "parentnode_fieldname" 
        ... />
    </ParentNode>

roSystemLogEvent
================

roSystemLogEvents are sent when enabled via [roSystemLog](/docs/references/brightscript/components/rosystemlog.md "roSystemLog"). roSystemLogEvent has the following method:

Supported methods
-----------------

### GetInfo() as Object

Returns an AssociativeArray containing information describing the event, which may be one of the following values:

| Key | Type | Description |
| --- | --- | --- |
| LogType | String | Identifies the specific type of event. Valid types are listed at [roSystemLog](/docs/references/brightscript/components/rosystemlog.md "roSystemLog"). |
| DateTime | roDateTime | The GMT time of the event, with a resolution of one second. |

If LogType is "http.connect" or "http.error", the event AA contains the base keys and the following additional keys:

| Key | Type | Description |
| --- | --- | --- |
| Url | String | The URL that was requested |
| OrigUrl | String | The original URL. If the original URL was redirected, then Url represents the new redirected URL and OrigURL the original. OrigURL is included so that it's easy to correlate between events and URLs passed to components |
| Method | String | The HTTP method. "GET", "POST", or "HEAD" |
| Status | String | If LogType is "http.connect", this will be "ok". Otherwise, it will be one of the following:<br><br>*   unknownerror<br>*   dnsfailure<br>*   dnstimeout<br>*   noroutetohost<br>*   connectiontimeout<br>*   connectionrefused<br>*   untrustedcert<br>*   expiredcert<br>*   nocipher<br>*   handshakefailed<br>*   generalsocketerror<br>*   httperror |
| TargetIp | String | The IP address of the target server |
| HttpCode | Integer | The IP address of the target server |

If LogType is "bandwidth.minute", the event AA contains the base keys and the following additional key:

| Key | Type | Description |
| --- | --- | --- |
| Bandwidth | Integer | Measured bandwidth in kbps |

roDateTime
==========

The roDateTime provides an interface to obtain the current date/time for the player and manipulate date/times.

This component provides several options for obtaining attributes about the date/time. All times are GMT unless they are converted to the system timezone with a call to the method: toLocalTime().

This object is created with no parameters:

`CreateObject("roDateTime")`

The date/time of the object is set to the current system time when the object is created. The date/time represented by the object can be changed by calling Mark(), FromSeconds(), or FromISO8601String().

**Example**

    date = CreateObject("roDateTime")
    print "The date is now "; date.AsDateString("long-date")
    

Supported interfaces
--------------------

*   [ifDateTime](/docs/references/brightscript/interfaces/ifdatetime.md "ifDateTime")

> Some Roku OS versions may implement ifDateTime as ifRoDateTime

ifDateTime
==========

Implemented by
--------------

| Name | Description |
| --- | --- |
| [roDateTime](/docs/references/brightscript/components/rodatetime.md "roDateTime") | The roDateTime provides an interface to obtain the current date/time for the player and manipulate date/times |

Supported methods
-----------------

### Mark() as Void

#### Description

Sets the date/time value to the current UTC date and time.

> roDateTime objects are automatically marked on creation.

### ToLocalTime() as Void

#### Description

Offsets the date/time value from an assumed UTC date/time to a local date/time using the system time zone setting. This function is not idempotent, and multiple calls will do multiple timezone adjustments to the time yielding an incorrect result.

### GetTimeZoneOffset() as Integer

#### Description

Returns the offset in minutes from the system time zone to UTC. For example, if the system time zone is in PDT / UTC-7 the value returned would be 420.

> The time zone offset is returned for the current date/time, regardless of the object's date/time value.

#### Return Value

Minutes of offset as Integer.

### AsSeconds() as Integer

#### Description

Returns an Integer representing the date/time as the number of seconds from the Unix epoch (00:00:00 1/1/1970 GMT).

#### Return Value

Number of seconds as Integer.

### AsSecondsLong() as Object

#### Description

Returns a LongInteger representing the date/time as the number of seconds from the Unix epoch (00:00:00 1/1/1970 GMT).

#### Return Value

Number of seconds as a LongInteger.

### FromSeconds(numSeconds as Integer) as Void

#### Description

Sets the date/time value using the number of seconds from the Unix epoch.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| numSeconds | Integer | The number of seconds from the Unix epoch. |

### FromSecondsLong(numSeconds as LongInteger) as Void

#### Description

Sets the date/time value using the number of seconds from the Unix epoch.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| seconds | Integer or LongInteger | The number of seconds from the Unix epoch. |

### ToISOString() as String

#### Description

Returns an ISO 8601 representation of the date/time value.

#### Return Value

ISO 8601 as String, e.g. "2021-03-25T18:53:03+0000"

### ToISOString(format as String) as String

#### Description

Returns an ISO 8601 representation of the date/time value with milliseconds precision.

#### Parameters

| Name | Type | Format |
| --- | --- | --- |
| format | String | The format of the date string to be returned, which is "milliseconds" |

#### Return Value

ISO 8601 as String with milliseconds precision, e.g. "2021-03-25T18:53:03.220+0000"

### FromISO8601String(dateString as String) as Void

#### Description

Sets the date/time using a string in the ISO 8601 format. For example "YYYY-MM-DD HH:MM:SS" e.g "2009-01-01 01:00:00.000" or "2009-01-01T01:00:00.000".

> This function is unaware of the local time zone, so these time formats are effectively UTC even though the ISO 8601 spec says they should be in local time. The above formats are also the only formats recognized by this function, even though the ISO 8601 spec contains other valid formats.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| dateString | String | The ISO-8601 string to be used to set the date and time. |

### asDateStringLoc(format as String) as String

_Available since Roku OS 12.0_

#### Description

Returns the localized date of the device.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| format | String | Specify the format of the date string to be returned:<br><br>*   full<br>*   long<br>*   medium<br>*   short<br>*   custom formatting string using date symbols (for example, "MMM d, y") |

#### Custom date formatting values

| Date symbol | Description |
| --- | --- |
| EEE | Day of week, abbreviated |
| EEEE | Day of week long name |
| d   | Day of month, numeric, minimum digits |
| dd  | Day of month, numeric, 2 digits, zero pad if needed |
| M   | Month, numeric, minimum digits |
| MM  | Month, numeric, 2 digits, zero pad if needed |
| MMM | Month - short name |
| MMMM | Month - long name |
| y   | Year, numeric, minimum digits |
| yy  | Year, numeric, two low-order digits, zero pad if needed |

#### Return Value

A date string corresponding to the specified format:

| Format | Example |
| --- | --- |
| full | Friday, January 20, 2023 |
| long | January 20, 2023 |
| medium | Jan 20, 2023 |
| short | 1/20/23 |
| custom (for example, "MM.EEE/y") | 01.Fri/2023 |

### asTimeStringLoc(format as String) as String

_Available since Roku OS 12.0_

#### Description

Returns the localized time of the device.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| format | String | Specify the format of the time string to be returned:<br><br>*   short<br>*   short-h12<br>*   short-h24<br>*   custom formatting string using time symbols (for example, "h:mm a") |

#### Custom time formatting values

| Time symbol | Description |
| --- | --- |
| h   | hour (12-hour), minimum digits |
| hh  | hour (12-hour), 2 digits, zero pad if needed |
| H   | hour (24-hour), minimum digits |
| HH  | hour (24-hour), 2 digits, zero pad if needed |
| m   | minute, minimum digits |
| mm  | minute, 2 digits, zero pad if needed |
| a   | AM PM, abbreviated |

#### Return Value

A time string corresponding to the specified format:

| Format | Example |
| --- | --- |
| short | 11:25 pm |
| short-h12 | 11:25pm |
| short-h24 | 23:25 |
| custom (for example, "h:mm") | 11:25 |

### AsDateString(format as String) as String

#### Description

Returns the date/time formatted string.

> Day names, month names, separators, and order of fields may vary depending on the current locale.

#### Parameters

NameTypeDescriptionformatString

| Format |
| --- |
| long-date |
| short-weekday |
| no-weekday |
| short-month |
| short-month-short-weekday |
| short-month-no-weekday |
| short-date |
| short-date-dashes |

#### Return Value

A dateString corresponding to the specified format.

| Format | Example dateString |
| --- | --- |
| long-date | Tuesday October 9, 2012 |
| short-weekday | Tue October 9, 2012 |
| no-weekday | October 9, 2012 |
| short-month | Tuesday Oct 9, 2012 |
| short-month-short-weekday | Tue Oct 9, 2012 |
| short-month-no-weekday | Oct 9, 2012 |
| short-date | 10/9/12 |
| short-date-dashes | 10-9-12 |

> The order of the fields in both short-date formats is changed depending on the current locale:

| Locale | Field Order |
| --- | --- |
| Canada | YYYY/MM/DD |
| United States | MM/DD/YY |
| UK and rest of world | DD/MM/YY |

### AsDateStringNoParam() as String

#### Description

Returns the date/time in long-date format.

#### Return Value

A date/time string in long-date format (for example, Tuesday October 9, 2012)

### GetWeekday() as String

#### Description

Returns the day of the week.

> This function always returns the canonical English day of week names, regardless of the current locale. For a locale-independent index, see the [GetDayOfWeek()](#getdayofweek-as-integer) function.

#### Return Value

Week value as a String (e.g. "Monday").

### GetYear() as Integer

#### Description

#### Return Value

| Name | Return Type | Return Value | Description |
| --- | --- | --- | --- |
| GetYear | Integer | Year value as an Integer, e.g. 2015 | Returns the date/time value's year |

### GetMonth() as Integer

#### Description

Returns the date/time value's month.

#### Return Value

Month value as an Integer (1=Jan, 12=Dec).

### GetDayOfMonth() as Integer

#### Description

Returns the date/time value's day of the month.

#### Return Value

Month value as an Integer (1-31).

### GetHours() as Integer

#### Description

Returns the date/time value's hour within the day.

#### Return Value

Hour value as an Integer (0-23)

### GetMinutes() as Integer

#### Description

Returns the date/time value's minute within the hour.

#### Return Value

Minute value as an Integer (0-59)

### GetSeconds() as Integer

#### Description

Returns the date/time value's second within the minute.

#### Return Value

Second value as an Integer (0-59).

### GetMilliseconds() as Integer

#### Description

Returns the date/time value's millisecond within the second.

#### Return Value

Millisecond value as an Integer (0-999).

### GetLastDayOfMonth() as Integer

#### Description

Returns the date/time value's last day of the month.

#### Return Value

Day as an Integer (28-31)

### GetDayOfWeek() as Integer

#### Description

Returns the date/time value's day of week.

#### Return Value

Day value as an Integer (Sunday=0, Monday=1, ..., Saturday=6).

StdDlgAreaBase
==============

Extends [Group](/docs/references/scenegraph/layout-group-nodes/group.md)

The **StdDlgAreaBase** node is the base class and provides the common functionality for the three StandardDialog area nodes: [**StdDlgTitleArea**](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-title-area.md), [**StdDlgContentArea**](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-content-area.md) and [**StdDlgButtonArea**](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-button-area.md).

Fields
------

The StdDlgAreaBase node does not have any fields.

roHttpAgent
===========

All SceneGraph nodes can use the roHttpAgent component to support cookies, custom HTTP headers, and support secure HTTP file transfer protocols, such as passing certificates to the server as part of a URL transfer. An roHttpAgent component object is created by default for all SceneGraph nodes for this purpose. The roHttpAgent object supports the [ifHttpAgent](/docs/references/brightscript/interfaces/ifhttpagent.md "ifHttpAgent") interface used by many BrightScript components to allow secure HTTP file transfer protocols. Child nodes of a SceneGraph node automatically inherit the parent roHttpAgent object, unless a new roHttpAgent object is created, or an existing roHttpAgent is set for a child node. There are two roSGNode [ifSGNodeHttpAgentAccess](/docs/references/brightscript/interfaces/ifsgnodehttpagentaccess.md "ifSGNodeHttpAgentAccess") interface methods that allow a specific roHttpAgent object to be selected and set for a specific SceneGraph node.

An roHttpAgent object is created automatically for all SceneGraph nodes, or can be created with no parameters:

`CreateObject("roHttpAgent")`

> SceneGraph Audio and Video nodes always create a new roHttpAgent object and do not share it, and can use a different mechanism for HTTPS and cookie support, that involves setting certificates and cookies as Content Meta-Data attributes for the node ContentNode.

Supported interfaces
--------------------

*   [ifHttpAgent](/docs/references/brightscript/interfaces/ifhttpagent.md "ifHttpAgent")

Playing Videos
==============

Playing any type of video requires just one SceneGraph node class: [Video](/docs/references/scenegraph/media-playback-nodes/video.md).

To play a video, you must first prepare the files to be served to the Roku Player:

*   the video files must have been encoded in one of the formats supported by a Roku Player (see [Streaming specifications](/docs/specs/media/streaming-specifications.md))
*   if you want to use an adaptive bitrate switching scheme, the video files must be configured to use the supported adaptive bitrate scheme you want (see [Streaming specifications](/docs/specs/media/streaming-specifications.md))
*   you must also include any supporting files for special playback options you want, such as _trick play_ (see [Trick mode](/docs/developer-program/media-playback/trick-mode/trick-mode.md))

Then, in your application, you must:

*   set the various playback configuration options for your video in a ContentNode using Content Meta-Data (see [Content Meta-Data](/docs/developer-program/getting-started/architecture/content-metadata.md)) attributes
*   assign the ContentNode to the `content` field of the Video node
*   set other Video node fields for all other video playback appearance and function configuration you want for your particular video (or videos)

Then, when a user selects a video to play, you set the Video node `control` field to `play`, in a callback function triggered by the user selection event.

Examples
--------

Here are two example applications showing selecting and playing videos. These examples demonstrate the use of the RowList node class to create a custom content grid and Video node for video playback. The second example also shows how to create a very simple details screen for displaying more information about selected content before video playback. They also show how to load and parse an MRSS feed so you can see how to populate your apps with dynamic content.

*   [Simple\_Grid\_and\_Video](https://github.com/rokudev/samples/blob/master/ux%20components/lists%20and%20grids/Simple_Grid_with_Details_and_Video)
*   [Simple\_Grid\_with\_Details\_and\_Video](https://github.com/rokudev/samples/blob/master/ux%20components/lists%20and%20grids/Simple_Grid_with_Details_and_Video)

Here is another example application that uses the same content feed, but renders the UI as a PanelSet.

*   [PanelSet\_and\_Video](https://github.com/rokudev/samples/blob/master/media/PanelSet_and_Video)

And here is a simple example using the same basic content with a LabelList node for selecting the video to play. The XML file containing the Content Meta-Data is included and read from the `pkg:/server/videocontent.xml` file. Since the entire application including the Content Meta-Data is contained within the application package, you can see how the Content Meta-Data is parsed and translated into a ContentNode, which supplies the items displayed in the LabelList node, and then how the video is played when the user selects a video from the list.

*   [VideoList](https://github.com/rokudev/samples/blob/master/ux%20components/lists%20and%20grids/VideoList)

Setting focus on the video node
-------------------------------

You must set focus on the Video node while playback is occurring for the trick play bar and some other user interface options to be used. After playback has finished, you will generally want to set focus back on the user interface element (usually a list or grid or custom video "details" screen) from which the user selected the video.

Setting up your server video content meta-data files
----------------------------------------------------

For your server content meta-data XML files, always ensure that all attribute strings containing the ampersand (&) character is properly escaped by replacing it with the HTML entity `&amp;`. (This is particularly important because many video stream URLs include this character.) Also remember to properly escape all XML special characters in the attribute strings, and use the correct HTML entities to format your descriptive content meta-data attributes.

Media playlists
---------------

Both the Audio and Video nodes support the use of playlists, which are lists of several media items to play in sequence rather than a single media item. If a playlist is used, setting the `loop` field to true causes the entire playlist to play again after the last item in the playlist completes.

To set an Audio or Video node to play several media items in sequence:

1.  Set the `content` field to a ContentNode containing a child ContentNode for each media item in the playlist.
2.  Set the `contentIsPlaylist` field to true.

After setting the `control` field to `play`, you can control the playback as follows:

*   to stop playing the current media item in the playlist, or end playback if the current item is the last in the playlist, set the `skipcontent` option of the `control` field
*   set the `nextContentIndex` field to an index of another item in the playlist to be played after the current item finishes, rather than the next item in the sequence
*   for Audio nodes, you can observe and use the `contentIndex` field value to control the appearance of the screen while the audio item is playing, such as showing the title of a song when that song begins playing

Configuring video stream buffering
----------------------------------

_All_ digital video players must buffer a certain amount of the video data stream before video playback can occur. These buffering operations appear to the user as a delay between the time the user selects the video to play, and the time when the video begins to play. The Video node class includes special internal node instances to indicate to the user that the video data stream is buffering, whether before initial playback, or after buffering must occur again because the video playback is interrupted by an unexpected slowdown in the video stream transfer rate. (Video playback interruptions are more likely to occur if you do not take advantage of some type of adaptive bitrate configuration of the video playback, such as using a segmented adaptive video playback scheme such as HLS, as described in [Streaming specifications](/docs/specs/media/streaming-specifications.md).)

To indicate to the user that the video stream is buffering, the Video node class includes two instances of an internal ProgressBar node, which, if set to be visible, appear at the bottom center of the video playback screen area automatically when video buffering is occurring.

![roku815px - bufferbar40crop](https://image.roku.com/ZHZscHItMTc2/bufferbar40crop.jpg "bufferbar40crop")

These progress bars are configured in BrightScript by setting the fields of the internal ProgressBar nodes as follows:

*   `retrievingBar` for the progress bar that appears when the video stream is being buffered prior to initial playback
*   `bufferingBar` for the progress bar that appears when the video stream must be buffered again after an unexpected stream transfer rate slowdown

These internal ProgressBar nodes have fields for configuring their appearance, such as setting the color of the portion of the bar that indicates the amount of buffering that has been accomplished. These fields must be set in BrightScript. Other Video node fields are available for configuring other aspects of the internal ProgressBar nodes, such as setting the color of the text of the progress bar. These fields can be set in either BrightScript or XML markup.

To set the internal node fields in BrightScript, the Video node object must be available within the scope of the BrightScript function that will set the fields. For example, if a Video node was declared and partially defined in XML markup, you must use the `findNode()` function to declare the node object and access the internal retrieving bar node fields:

    m.video = m.top.findNode("channel_video_node_id")
    ...
    m.video.retrievingBar.internal_node_field = internal_node_field_value
    ...
    

> Since you should always set the `control` field of a Video node in BrightScript, you should always declare a Video node object in BrightScript anyway, either by creating the object in BrightScript, or using the `findNode()` function.

Fast start media playback
-------------------------

Both the Audio and Video node classes also include a special control option to reduce or eliminate the apparent delay before media playback begins (_fast start_). All digital video requires some time after a video is selected to begin playback, and video (and audio) files streamed over HTTP add network transfer rates to this buffering time. You can configure your application to reduce or eliminate this apparent delay to the user by setting the Video (or Audio) node `control` field to `prebuffer`, at a time when the user has moved focus to a description of the media item, but before the user actually starts the playback. The media stream will buffer in the background while the user is reading the description of the media item. Then, if and when the user actually selects the media item to play, you can set the `control` field to `play` as usual.

For example, if you have designed your SceneGraph application to have a screen that shows a description of a video, with a button to actually begin playback, you can use the `prebuffer` option of the `control` field in a callback function triggered by the screen focus event as follows:

    sub setDetailsScreenFocus()
      if m.top.isInFocusChain() and not m.buttons.hasFocus() and not m.videoPlayer.hasFocus() then
        m.buttons.setFocus(true)
        ' prebuffer video while user is reading the details screen
        m.videoPlayer.control = "prebuffer"
      end if
    end sub
    

Then write the callback function for the playback button press event that includes:

    m.videoPlayer.control = "start"
    

If the user has taken a few seconds to read the details screen, the video will start immediately after the playback button is pressed. An sample app demonstrating Fast Video Start can be found here: [FastVideoStart](https://github.com/rokudev/samples/blob/master/media/FastVideoStart).

MPEG-4 playback
---------------

For MPEG-4 (mp4) video files without segmented adaptive bitrate switching files, set the ContentNode `streamformat` meta-data attribute to `mp4`, and the `url` attribute to the URL of the MPEG-4 video file.

Segmented video playback
------------------------

For the most basic segmented video playback, you only need to set the `URL` and `StreamFormat` field values in a ContentNode, assign the ContentNode to the `content` field of the Video node, then set the Video node `control` field value to `play` to start the video. For example:

    videoContent = createObject("RoSGNode", "ContentNode")
    videoContent.url = "video_URI"
    videoContent.streamformat = "hls"
    m.video = m.top.findNode("video_node_ID")
    m.video.content = videoContent
    m.video.control = "play"
    

Segmented video playback with PlayReady DRM
-------------------------------------------

If you include PlayReady DRM in your DASH video stream, set the following Content Meta-Data attributes in your ContentNode:

*   `encodingtype`
*   `encodingkey`
*   `streamformat`
*   `url`

Configuring trick play
----------------------

For more advanced video playback (for example, incorporating "trick play" DVD-like scene indexing functionality), there are fields in the Video node and the associated ContentNode to provide this functionality.

Trick play can be supported for a video in two ways. One option is to generate and provide a set of BIF files for the video. For this approach, see our documentation on [BIF file creation using the Roku BIF tool](/docs/developer-program/media-playback/trick-mode/bif-file-creation.md).

The second option is to provide trickplay images in DASH or HLS, using the respective industry standards. You can learn more about this approach in our trickplay implementation documentation for [HLS and DASH](/docs/developer-program/media-playback/trick-mode/hls-and-dash.md).

After you have created the trickplay files for a video, you must place the files on a server, and then configure the Video node to access the files by setting the associated ContentNode using the trick play attributes described in Content Meta-Data (see [Content Meta-Data](/docs/developer-program/getting-started/architecture/content-metadata.md)).

### Configuring trick play appearance

The Video node class includes an internal TrickPlayBar node to provide the user interface for trick play. You can customize the appearance of this internal node by accessing its fields in BrightScript in the same manner as the internal ProgressBar nodes (see [Configuring video stream buffering](/docs/developer-program/core-concepts/playing-videos.md#PlayingVideos-Configuringvideostreambuffering)).

Configuring closed captions
---------------------------

Adding closed caption support is a simple matter of configuring the subtitleconfig video node content element. See [SceneGraphCaptionsDemo](https://github.com/rokudev/samples/blob/master/media/SceneGraphCaptionsDemo) for an example of using side loaded TTML captions in your app.

Reading and assigning video configuration Content Meta-Data from your server
----------------------------------------------------------------------------

Generally you will want to have all of your content meta-data configuration of a particular video in an XML/JSON file on your server. You can then read this file, convert it to a ContentNode, and set up the related user interface and video configuration for your video in your Roku application.

This XML/JSON file should contain the strings or links to all the information you need to present the video to the user for selection, and to configure the video playback. In almost all cases, you should be able to use the attributes listed in Content Meta-Data (see [Content Meta-Data](/docs/developer-program/getting-started/architecture/content-metadata.md)) which are all recognized as field names for a ContentNode. In the rare cases where you require a custom attribute not found in Content Meta-Data, you can create a custom ContentNode by adding <interface> fields, or possibly by setting up a parallel associative array that can be accessed using the same user interface element node indexing that you use for accessing ContentNodes.

### Descriptive Content Meta-Data

Descriptive content meta-data attributes are used to communicate information to allow the user to select a video for playback. Most of the attributes are either optional, or are specific to a particular type of video. Set these attributes as you want for your user interface design, and the types of videos you offer. The descriptive meta-data attributes are:

*   `contenttype`
*   `title`
*   `titleseason`
*   `description`
*   `watched`
*   `length`
*   `releasedate`
*   `rating`
*   `starrating`
*   `userstarrating`
*   `shortdescriptionline1`
*   `shortdescriptionline2`
*   `episodenumber`
*   `numepisodes`
*   `actors`
*   `actor`
*   `directors`
*   `director`
*   `categories`
*   `category`
*   `hdbranded`
*   `ishd`
*   MPAA and TV Ratings (icon identifiers)

> If you participate in the Roku Search program, you can use the information in the XML feed you supply to Roku for many of the meta-data attributes listed above. See [Roku Search](/docs/features/engagement/roku-search.md) for complete details.

### Video configuration Meta-Data

See [Content Meta-Data](/docs/developer-program/getting-started/architecture/content-metadata.md) for the complete list of video configuration meta-data.

### Example video Meta-Data XML Task node file reader

The following is an example of a Task node that reads an XML file from a server containing descriptive and configuration meta-data for videos. The Task node converts the XML file attributes for each video, and builds the corresponding ContentNode with the attribute data. The Task node should be created, have an observer callback set for the `videocontent` <interface> field, configured with the URL of the server XML file as the `metadatauri` <interface> field, then run. When the ContentNode is complete, it is assigned to the `videocontent` <interface> field of the Task node, which then triggers the callback function to configure lists or grids for each video item, and allow the configuration meta-data to be assigned to a Video node that plays the video.

**Example video Content Meta-Data Task node**

    <component name = "MetaDataCR" extends = "Task" >
    
      <interface>
        <field id = "metadatauri" type = "uri" value = "" />
        <field id = "videocontent" type = "node" />
      </interface>
    
      <script type = "text/brightscript" >
    
        <![CDATA[
    
        sub init()
          m.top.functionName = "getContent"
        end sub
    
        sub getContent()
          videocontent = createObject("RoSGNode","ContentNode")
          metadataxml = createObject("roXMLElement")
    
          ' uncomment/conditionalize for development package XML transfers (pkg:/server/foo.xml)
          xmlstring = ReadAsciiFile(m.top.metadatauri)
          metadataxml.parse(xmlstring)
    
          ' uncomment/conditionalize for published channel Internet XML transfers (http://serverdomain/foo.xml)
          ' readInternet = createObject("roUrlTransfer")
          ' readInternet.setUrl(m.top.metadatauri)
          ' metadataxml.parse(readInternet.GetToString())
    
          if metadataxml.getName()="MetaData"
            for each video in metadataxml.GetNamedElements("video")
              videoitem = videocontent.createChild("ContentNode")
              videoItem.setFields(video.getAttributes())
            end for
          end if
          m.top.videocontent = videocontent
        end sub
    
        ]]>
    
      </script>
    
    </component>
    

Sample Apps
-----------

The table below summarizes all of the downloadable samples demonstrating the video playback features introduced in this section.

| Sample App | Description |
| --- | --- |
| [Simple\_Grid\_and\_Video](https://github.com/rokudev/samples/blob/master/ux%20components/lists%20and%20grids/Simple_Grid_and_Video) | Video player in a simple grid UI. |
| [Simple\_Grid\_with\_Details\_and\_Video](https://github.com/rokudev/samples/blob/master/ux%20components/lists%20and%20grids/Simple_Grid_with_Details_and_Video) | Video player in a simple grid UI with details page. |
| [PanelSet\_and\_Video](https://github.com/rokudev/samples/blob/master/media/PanelSet_and_Video) | Video player in a simple PanelSet UI. |
| [VideoList](https://github.com/rokudev/samples/blob/master/ux%20components/lists%20and%20grids/VideoList) | Video player with content selected from a LabelList. |
| [FastVideoStart](https://github.com/rokudev/samples/blob/master/media/FastVideoStart) | Sample demonstrating how to use Fast Video Start. |
| [SceneGraphCaptionsDemo](https://github.com/rokudev/samples/blob/master/media/SceneGraphCaptionsDemo) | Sample demonstrating how to integrate closed caption support. |

ifSocketConnection
==================

Implemented by
--------------

| Name | Description |
| --- | --- |
| [roStreamSocket](/docs/references/brightscript/components/rostreamsocket.md "roStreamSocket") | The roStreamSocket component enables BrightScript apps to accept and connect to TCP streams as well as send and receive data with them |

Supported methods
-----------------

Each of these operations except listen() is either synchronous or asynchronous as determined by the socket's blocking behavior. If there is a valid assigned roMessagePort, the blocking behavior is considered asynchronous (non-blocking). Otherwise, the blocking behavior is considered synchronous.

### Listen(backlog as Integer) as Boolean

#### Description

Puts the socket into the listen state.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| backlog | Integer | The limit for the queue of incoming connections |

#### Return Value

A flag indicating whether listening can be done (generally, if bound address is valid).

### IsListening() as Boolean

Checks whether if the [listen()](#listenbacklog-as-integer-as-boolean) method has been successfully called on this socket.

#### Return Value

A flag indicating whether the [listen()](#listenbacklog-as-integer-as-boolean) method has been successfully called on this socket.

### Connect() as Boolean

#### Description

Establishes a connection.

#### Return Value

A flag indicating whether a socket connection has successfully been created. The connection might still not be complete if the socket is non-blocking

### Accept() as Object

#### Description

Accepts incoming requests.

#### Return Value

An roStreamSocket if the connection is pending; invalid otherwise. Use status to distinguish among success (eSuccess() or isConnected()), not ready (eOK()), and error.

### IsConnected() as Boolean

#### Description

Checks whether a [connect](#connect-as-boolean) or [accept](#accept-as-object) function has been completed on this socket.

#### Return Value

A flag indicating whether a connection has been established or accepted on this socket.

ifSocket
========

Implemented by
--------------

| Name | Description |
| --- | --- |
| [roDataGramSocket](/docs/references/brightscript/components/rodatagramsocket.md "roDataGramSocket") | The roDataGramSocket component enables Brightscript apps to send and receive UDP packets |
| [roStreamSocket](/docs/references/brightscript/components/rostreamsocket.md "roStreamSocket") | The roStreamSocket component enables BrightScript apps to accept and connect to TCP streams as well as send and receive data with them |

Supported methods
-----------------

These are the basic binding and data transfer operations used on both [roStreamSocket](/docs/references/brightscript/components/rostreamsocket.md "roStreamSocket") and [roDataGramSocket](/docs/references/brightscript/components/rodatagramsocket.md "roDataGramSocket"). They are synchronous or asynchronous as determined by the socket's blocking behavior. If there is a valid assigned [roMessagePort](/docs/references/brightscript/components/romessageport.md "roMessagePort"), the blocking behavior is considered asynchronous (non-blocking). Otherwise, the blocking behavior is considered synchronous.

### Send(data as Object, startIndex as Integer, length as Integer) as Integer

#### Description

Sends up to length bytes of data to the socket.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| data | Object | A [roByteArray](/docs/references/brightscript/components/robytearray.md "roByteArray") containing the data to be sent. |
| startIndex | Integer | The index of the byte array from which to start sending data. |
| length | Integer | The amount of data to be sent to the socket. |

#### Return Value

The number of bytes sent.

### SendStr(data as String) as Integer

#### Description

Sends the whole string to the socket, if possible.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| data | String | A string containing the data to be sent. |

#### Return Value

The number of bytes sent.

### Receive(data as Object, startIndex as Integer, length as Integer) as Integer

#### Description

Reads data from the socket.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| data | Object | A [roByteArray](/docs/references/brightscript/components/robytearray.md "roByteArray") containing the data to be stored. |
| startIndex | Integer | The index of the byte array from which to start reading data. |
| length | Integer | The amount of data to be read from the socket. |

#### Return Value

The number of bytes read.

### ReceiveStr(length as Integer) as String

Reads data from the socket and stores the result in a string.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| length | Integer | The amount of data to be read from the socket. |

#### Return Value

The received byte length string. If no bytes are received, the string is empty.

### Close() as Void

Performs an orderly close of socket. After a close, most operations on the socket will return invalid.

On blocking sockets, this clears the receive buffer and blocks until the send buffer is emptied. Neither buffer may be read or written afterward.

On non-blocking sockets, both the send and the receive buffer may be read but not written.

### SetAddress(sockAddr as Object) as Boolean

#### Description

Sets the address using a BSD bind() call

| Name | Return Type | Parameters | Return Value | Description |
| --- | --- | --- | --- | --- |
| SetAddress | Boolean | ${setaddressparamTable} | True/False |     |

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| sockAddr | Object | An roSocketAddress. |

#### Return Value

A flag indicating whether the address was successfully set.

### GetAddress() as Object

#### Description

Returns the roSocketAddress object bound to this socket.

#### Return Value

roSocketAddress Object.

### SetSendToAddress(sockAddr as Object) as Boolean

#### Description

Sets the remote address for next message to be sent.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| sockAddr | Object | An roSocketAddress. |

#### Return Value

A flag indicating whether the address was successfully stored as the first half of underlying BSD sendto() call.

### GetSendToAddress() as Object

#### Description

Returns the roSocketAddress for the remote address of the next message to be sent. This method can also be used to return the remote address on newly accepted sockets.

#### Return Value

The roSocketAddress for the remote address of the next message to be sent.

### GetReceivedFromAddress() as Object

#### Description

Returns the roSocketAddress for the remote address of the last message received via the [receive()](#receivedata-as-object-startindex-as-integer-length-as-integer-as-integer) method. This method can also be used to return the remote address on newly accepted sockets.

#### Return Value

The roSocketAddress for the remote address of the last message received.

### GetCountRcvBuf() as Integer

#### Description

Returns the number of bytes in the receive buffer.

#### Return Value

Number of bytes.

### GetCountSendBuf() as Integer

#### Description

Returns the number of bytes in the send buffer.

#### Return Value

Number of bytes.

### Status() as Integer

#### Description

Indicates whether the last operation was successful.

#### Return Value

This method returns 0 if the last operation was successful or an error number if it failed.

Runtime functions
=================

CreateObject(classname as String, \[optional parameters\]) as Object
--------------------------------------------------------------------

Creates a BrightScript Component of class _classname_ specified. Return invalid if the object creation fails. Some Objects have optional parameters in their constructor that are passed after _name_.

For example:

    app_mgr = CreateObject("roAppManager")
    section = CreateObject("roRegistrySection", "Data")
    

Type(variable, \[optional version\]) as String
----------------------------------------------

Returns the type of a variable and/or object. See the BrightScript Component specification for a list of types.

For example:

    Print type(5) 'returns a 2.1 compatible type
    Print type("my string", 3) 'return a Roku OS 3.0 type
    

GetGlobalAA() as Object
-----------------------

Each script has a global Associative Array. It can be fetched with this function.

**New in Roku OS 3.0**

Box(x as Dynamic) as Object
---------------------------

Box() will return an object version of an intrinsic type, or pass through an object if given one.

     bo = box("string")
     bo = box(bo) ' no change to bo
    

Run(filename as String \[ , Args…\]) As dynamic
-----------------------------------------------

> This function is deprecated.

Run(filenamearray as Object \[ , Args…\]) As dynamic
----------------------------------------------------

> This function is deprecated.

The run command will run a script from a script. Args may be passed to the scripts Main() function, and the called script may return arguments.

If a filename string is passed, that file compiled and run.  
If an array of files are passed instead of a single filename, then each file is compiled and they are linked together, than run.

For example:

    Sub Main()
        Run("pkg:/test.brs")
        BreakIfRunError(LINE_NUM)
        Print Run("test2.brs", "arg 1", "arg 2")
        if Run(["pkg:/file1.brs","pkg:/file2.brs"])<>4 then stop
        BreakIfRunError(LINE_NUM)     stop
    End Sub 
    
    
    Sub BreakIfRunError(ln)
        el=GetLastRunCompileError()
        if el=invalid then
            el=GetLastRunRuntimeError()
            if el=&hFC or el=&hE2 then return 
            'FC==ERR_NORMAL_END, E2=ERR_VALUE_RETURN
            print "Runtime Error (line ";ln;"): ";el
            stop
        else
            print "compile error (line ";ln;")"
            for each e in el
                for each i in e
                    print i;": ";e[i]
                end for
            end for 
            stop
       end if 
    End Sub
    

Eval(code as String) as Dynamic
-------------------------------

> Eval is deprecated effective immediately. Use of Eval() will cause compilation or runtime errors, see [Roku Manifest](/docs/developer-program/getting-started/architecture/channel-manifest.md). Use [roXMLElement.parse()](/docs/references/brightscript/components/roxmlelement.md) or [parseJSON()](/docs/references/brightscript/language/global-utility-functions.md#parsejsonjsonstring-as-string-as-object) instead of Eval() when initializing data.
> 
> To test whether a function exists, you can use this alternative method:
> 
>     if getInterface(myAA.maybeFunc, "ifFunction") <> invalid then myAA.maybeFunc()
>     

Eval can be used to run a code snippet in the context of the current function. It performs a compile, and then the bytecode execution.

If a compilation error occurs, no byte execution is performed, and Eval returns an roList with one or more compile errors. Each list entry is an roAssociativeArray with ERRNO and ERRSTR keys describing the error.

If compilation succeeds, bytecode execution is performed and the integer runtime error code is returned. These are the same error codes as returned by GetLastRunRuntimeError().

Eval() can be usefully in two cases. The first is when you need to dynamically generate code at runtime.

The other is if you need to execute a statement that could result in a runtime error, but you don't want code execution to stop.

Example:

    Print Eval("n=1/0") 
    

Outputs:

    20
    

That 20 = &h14 = ERR\_DIV\_ZERO = Divide by Zero error.

**Do not** use Eval() outside of the main() function as it can cause unexpected bugs and crashes. Use parse XML or parseJSON instead when initializing data. You can also use a downloadable component library to get the dynamic code.

GetLastRunCompileError() as Object
----------------------------------

Returns an roList of compile errors, or invalid if no errors. Each list entry is an roAssociativeArray with the keys: ERRNO, ERRSTR, FILESPEC, and LINENO.

GetLastRunRuntimeError() as Integer
-----------------------------------

Returns an error code result after the last script Run().

These two are normal:

    &hFC==ERR_NORMAL_END  
    &hE2==ERR_VALUE_RETURN   
    

**Example: Assign variables to common runtime errors**

    ERR_USE_OF_UNINIT_VAR = &hE9
    ERR_DIV_ZERO = &h14
    ERR_TM = &h18
    ERR_USE_OF_UNINIT_VAR = &hE9
    ERR_RO2 = &hF4
    ERR_RO4 = &hEC
    ERR_SYNTAX = 2
    ERR_WRONG_NUM_PARAM = &hF1

Implementing the Demand API
===========================

Publishers integrate the Demand API to create a direct automated connection with demand partners that provides real-time demand across all of the publisher's inventory. This decreases inventory waste, unifies demand from Roku and third-parties, and enables the publisher to maintain full control of their inventory allocation with their ad server. The automated supply and demand matching provided by the Demand API helps publishers monetize video ad inventory more efficiently.

> Apps in the U.S. Streaming Store that have both streamed more than an average of 100,000 hours per month and averaged more than 10,000 new installs per month over the last three months must implement the Demand API as part of their integration (this requirement is also applicable to new apps projected to reach the specified thresholds shortly after launch).
> 
> Apps outside the U.S. Streaming Store that have streamed more than an average of 200,000 hours per month over the last three months, and new apps outside the U.S. Streaming Store that are projected to reach this threshold, must also implement the Demand API.
> 
> The following table summarizes which apps must implement the Demand API and when the implementation is required:
> 
> | App criteria | In U.S Streaming Store | Outside U.S Streaming Store |
> | --- | --- | --- |
> | Inventory relationship with Roku? | YES | YES |
> | Streaming hours  <br>(average hours per month over the last three months) | 100,000 | 200,000 |
> | New installs  <br>(average new installs per month over the last three months) | 10,000 | N/A |
> | Requirement effective date | April 1, 2021 | April 1, 2022 |

Integration steps
-----------------

The Demand API integration is completed in two phases:

1.  Publisher calls the Demand API following the instructions in the integration document that will be provided to them and then verifies that their system is receiving a response. By verifying that their system can send and receive Demand API calls, the publisher is placed in a queue for completing the integration.

2.  Publisher contacts their Roku partner manager, who works with the publisher to configure the complete Demand API integration. For example, Roku Partner Management provides sample code and helps the publisher configure their ad server.

ifSocketConnectionOption
========================

Implemented by
--------------

| Name | Description |
| --- | --- |
| [roStreamSocket](/docs/references/brightscript/components/rostreamsocket.md "roStreamSocket") | The roStreamSocket component enables BrightScript apps to accept and connect to TCP streams as well as send and receive data with them |

Supported methods
-----------------

### GetKeepAlive() as Boolean

#### Description

Checks whether keep alive is set. If keep alive is set, occasional no-data packets are sent to keep the connection alive.

#### Return Value

A flag indicating whether keep alive is set.

### SetKeepAlive(enable as Boolean) as Boolean

#### Description

Sends no-data packets to keep the connection alive.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| enable | Boolean | A flag specifying whether keep alive is enabled. |

#### Return Value

A flag indicating whether keep alive was successfully set.

### GetLinger() as Integer

#### Description

Returns the max time in seconds that the socket close() blocks to allow send data to be flushed in synchronous mode.

#### Return Value

The max time in seconds.

### SetLinger(time as Integer) as Boolean

#### Description

Sets the max time in seconds that the socket close() blocks to allow send data to be flushed in synchronous mode.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| time | Integer | The max time. |

#### Return Value

A flag indicating whether the linger was successfully set.

### GetMaxSeg() as Integer

#### Description

Returns the max TCP segment size.

#### Return Value

The segment size.

### SetMaxSeg(time as Integer) as Boolean

#### Description

Sets the max TCP segment size.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| time | Integer | The max TCP segment size. |

#### Return Value

A flag indicating whether the max TCP segment size was successfully set.

### GetNoDelay() as Boolean

#### Description

Checks whether the no delay property is enabled on the socket. This means that data is sent as soon as it is available rather than once there is enough data to fill a segment.

#### Return Value

A flag indicating whether the no delay property is enabled.

### SetNoDelay(enable as Boolean) as Boolean

#### Description

Enables the no delay property on the socket. This means that data is sent as soon as it is available rather than once there is enough data to fill a segment.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| enable | Boolean | A flag specifying whether the no delay property is enabled. |

#### Return Value

A flag indicating whether the no delay property was successfully set.

StdDlgKeyboardItem
==================

Extends [StdDlgItemBase](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-item-base.md "**StdDlgItemBase**")

The **StdDlgKeyboardItem** node is used to display a keyboard or PINpad in the dialog's content area. It provides text and voice entry of strings containing alphanumeric characters and symbols or numeric digits. It should only be used as a child of a [**StdDlgContentArea**](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-content-area.md) node.

![roku815px - std-dlg-keyboard-item](https://image.roku.com/ZHZscHItMTc2/std-dlg-keyboard-item.jpg)

Fields
------

| Field | Type | Default | Access Permission | Description |
| --- | --- | --- | --- | --- |
| keyLayout | string | "unspecified" | READ\_WRITE | Specifies the type of keyboard to be displayed:  <br><br>*   "unspecified": no keyboard is displayed.<br>*   "keyboard": A [**DynamicKeyboard**](/docs/references/scenegraph/dynamic-voice-keyboard-nodes/dynamic-keyboard.md) node is displayed.<br>*   "pinpad": A [**DynamicPinPad**](/docs/references/scenegraph/dynamic-voice-keyboard-nodes/dynamic-pinpad.md) node is displayed. |
| text | string | ""  | READ\_WRITE | The default string to be displayed in the keyboard's text edit box. When the user enters the text, this field is updated with the currently entered string. |
| textEditBox | VoiceTextEditBox node | The [**VoiceTextEditBox**](/docs/references/scenegraph/dynamic-voice-keyboard-nodes/voice-text-edit-box.md) associated with the keyboard | READ | The internal [**VoiceTextEditBox** node](/docs/references/scenegraph/dynamic-voice-keyboard-nodes/voice-text-edit-box.md) used by this dialog's internal keyboard. This field should be used only to access the fields of this internal node. |

Sample app
----------

You can download and install a [sample app](https://github.com/rokudev/standard-dialog-framework) that demonstrates how to create a custom keyboard dialog that uses the keyboard item.

ifRSA
=====

Implemented by
--------------

| Name | Description |
| --- | --- |
| [roRSA](/docs/references/brightscript/components/rorsa.md "roRSA") | The RSA component provides an interface to the OpenSSL RSA library of signing algorithms |

Supported methods
-----------------

### SetPrivateKey(keyFileName as String) as Integer

#### Description

Specifies the private key to use for signing.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| keyFileName | String | Specifies the private key to be used for signing. The file name should specify a path, either in the package or a temp path. |

#### Return Value

*   1 = The key is valid.
*   0 = The file does not contain a valid key.
*   \-1 = The file was not found.

### SetPublicKey(keyFileName as String) as Integer

Specifies the public key to be used for verification.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| keyFileName | String | Specifies the public key to be used for signing. The file name should specify a path, either in the package or a temp path. |

#### Return Value

*   1 = The key is valid.
*   0 = The file does not contain a valid key.
*   \-1 = The file was not found.

### SetDigestAlgorithm(digestAlgorithm as String) as Boolean

Specifies the digest algorithm to use for signing and verification.

| Name | Type | Description |
| --- | --- | --- |
| digestAlgorithm | String | An openssl string with the digest to be used. Common digest algorithms are "sha1", "ripemd160", and "md5". |

#### Return Value

A flag indicating whether the algorithm was successfully set (true) or the string was not recognized (false).

### Sign(digest as Object) as Object

#### Description

Generates a signature based on the specified digest.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| digest | roByteArray Object | The roByteArray to be signed. Errors will be printed in the BrightScript console. If the digest algorithm is not set (using SetDigestAlgorithm) before calling Sign(), the digest is not encapsulated. This would be equivalent to simply calling the openssl function RSA\_private\_encrypt() |

#### Return Value

An roByteArray containing the signature, or invalid if an error occurred. Typical values include the following:

*   digest is empty
*   SetPrivateKey() was not yet called
*   out of memory
*   the digest could not be signed

### Verify(digest as Object, signature as Object) as Integer

#### Description

Verifies the given digest and signature. Both digest and signature should be roByteArrays. If the digest algorithm is not set (using the [SetDigestAlgorithm](#setdigestalgorithmdigestalgorithm-as-string-as-boolean) method) before calling Verify(), the digest associated with the signature is not expected to be encapsulated. This would be equivalent to simply calling the openssl function RSA\_public\_decrypt(signature) and then comparing the result with the digest

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| digest | roByteArray Object | The digest to be verified. |
| signature | roByteArray Object | The signature to be verified. |

#### Return Value

Indicates the result of the validation. This may be one of the following values:

*   1 = The signature matches.
*   \-1 = The SetPublicKey() method was not yet called.
*   \-2 = The digest is empty.
*   \-3 = There is not enough memory.
*   0 = The signature does not match.

Autoplay
========

Apps may launch video playback automatically within their apps to drive subscriptions, increase engagement, and provide a more immersive user experience. These autoplay experiences include:

*   **App launch:** Play a video or sizzle reel highlighting the app's content when the app is launched by an unauthenticated or unsubscribed user.
*   **Browsing:** Play content previews when customers browse VOD and live content within category rows and EPGs.
*   **Content details screens:** Start playback or previews on content detail screens before the customer explicitly initiates playback (via keypress or voice command).

Apps that launch directly to a full-screen playback experience and require explicit customer interaction to initiate the app navigation experience are exempt from this requirement.

Starting with Roku OS 12.5.5, users can disable these in-app autoplay experiences by toggling **Settings > Accessibility > Auto-play** **video** to "Off" on their Roku device.

> **Certification Requirement**: If autoplay is disabled on a device, apps may not begin video playback until the user navigates to a video or explicitly starts playback. Once playback begins, apps may continue playing the video until the user navigates away from it, pauses it, turns the device off, or a screensaver starts. Apps must adhere to this requirement to pass certification (Effective October 1, 2024).
> 
> Developers can use the [**roDeviceInfo.isAutoPlayEnabled()** function](/docs/references/brightscript/interfaces/ifdeviceinfo.md#isautoplayenabled-as-boolean) to check whether auto-play video is enabled or disabled on a device. This function returns a flag indicating the current state of the auto-play setting. Developers can use this function to ensure that the auto-play device setting is respected when customers browse content in their apps.

Dialog
======

> Roku OS 10.0 introduced a new [StandardDialog node](/docs/references/scenegraph/standard-dialog-framework-nodes/standard-dialog.md "**Standard Dialog**"), which features updated graphics and color palette support. This enables developers to provide a consistent user experience across the dialogs in their app. Developers should replace the legacy Dialog nodes in their app with the new [StandardDialog nodes](/docs/references/scenegraph/standard-dialog-framework-nodes/standard-dialog.md "**Standard Dialog**").

Extends [**Group**](/docs/references/scenegraph/layout-group-nodes/group.md "**Group**")

The Dialog node class defines a modal pop-up dialog used to present the user with information requiring their immediate attention.

Setting the dialog field of the current Scene node to a Dialog node causes the dialog to be displayed.

The Dialog node is configured to have up to five regions: the title, message, bullet text, graphic, and button regions. All of these are optional except for the title.

*   The title region consists of a an icon and a title label, along with a horizontal divider that visually separates the title from the rest of the dialog.
    
*   The message region consist of a string that is displayed below the title divider.
    
*   The bullet text region contains a set of zero or more bullet points. It is displayed below the message.
    
*   The graphic region consists of a single bitmap displayed center-aligned below the message and bullet text and above the button region.
    
*   The button region contains a ButtonGroup node that contains zero or more Button nodes, arranged vertically.
    

Dialogs are modal and intercept all key events except pressing the Home key. Dialogs are closed automatically when the user presses the Home key or the Back key. If the optionsDialog field is set to true, pressing the Options key also closes the dialog.

Only a single dialog may appear at any time. If a second dialog is shown, the previous dialog is closed automatically.

Fields
------

| Field | Type | Default | Access Permission | Description |
| --- | --- | --- | --- | --- |
| title | string | ""  | READ\_WRITE | Title of the dialog box |
| titleColor | color | N/A | READ\_WRITE | When set, the color of the title |
| titleFont | Font | N/A | READ\_WRITE | When set, the font of the title |
| message | string | ""  | READ\_WRITE | The string to be displayed in the message region of the dialog. Newline and carriage return characters in the string result in the message being displayed as several lines of text. In BrightScript, to include a newline in a string, use chr(10). For example: `message = "First line" + chr(10) + "Second line"` |
| messageColor | color | N/A | READ\_WRITE | When set, the color of the message text |
| messageFont | Font | N/A | READ\_WRITE | When set, the font of the message text |
| numberedBullets | Boolean | false | READ\_WRITE | If set to true, the bulletText will be displayed with numbers rather than bullets |
| bulletText | array of strings | \[ \] | READ\_WRITE | An array of strings to be displayed as a list of bullet points |
| bulletTextColor | color | N/A | READ\_WRITE | When set, the color of the bullet point text |
| bulletTextFont | Font | N/A | READ\_WRITE | When set, the font of the bullet point text |
| buttons | array of strings | \[ \] | WRITE\_ONLY | Allows a set of Button nodes to be easily created by providing an array of Button labels. Each string in the array will result in a Button node to be added to the ButtonGroup, using the string as the Button label |
| buttonGroup | ButtonGroup |     | READ\_WRITE | The dialog internal ButtonGroup node. This allows the appearance attributes of all the Button nodes in the dialog to be easily modified. Since the ButtonGroup node class is derived from the LayoutGroup node class, additional non-Button node children can also be added |
| graphicUri | uri | ""  | READ\_WRITE | Specifies a bitmap to be displayed in the dialog. The bitmap is displayed below the bullet text region and above the buttons. Only set this field to specify a custom bitmap that differs in appearance from the default bitmap |
| graphicWidth | float | 0.0 | READ\_WRITE | Specifies the width of the bitmap graphic in local coordinates. If set to 0.0, the width of the bitmap from the image file is used. If set to a value greater than 0.0, the bitmap is scaled to that width.  <br>  <br>The graphicWidth and graphicHeight fields both must be set in order to be applied, and both fields must be set before the graphicURI field. |
| graphicHeight | float | 0.0 | READ\_WRITE | Specifies the height of the bitmap graphic in local coordinates. If set to 0.0, the height of the bitmap from the image file is used. If set to a value greater than 0.0, the bitmap is scaled to that height.  <br>  <br>The graphicWidth and graphicHeight fields both must be set in order to be applied, and both fields must be set before the graphicURI field. |
| buttonSelected | integer | 0   | READ\_ONLY | Set to the index of the selected button whenever the user selects a button in the group |
| buttonFocused | integer | 0   | READ\_ONLY | Set to the index of the focused button whenever a button in the group receives the key focus |
| focusButton | integer | 0   | WRITE\_ONLY | Causes the button with the specified index to receive the focus when the ButtonGroup node has the key focus. Note that if the ButtonGroup node does not have the key focus when the focusButton field is set, the specified button will display the focus footprint as its background |
| optionsDialog | Boolean | false | READ\_WRITE | If set to true, the dialog is automatically dismissed when the Options key is pressed |
| backgroundUri | uri | ""  | READ\_WRITE | Specifies the bitmap to be displayed as the dialog background. Usually this is a 9-patch image to support dynamic resizing. Only set this field to specify a custom bitmap that differs in appearance from the default bitmap |
| iconUri | uri | ""  | READ\_WRITE | Specifies a bitmap to be displayed as a small icon next to the dialog title. Only set this field to specify a custom bitmap that differs in appearance from the default bitmap |
| dividerUri | uri | ""  | READ\_WRITE | Specifies a bitmap to be displayed as the divider between the title region and the remainder of the dialog. Usually this is a 9-patch image to support dynamic resizing. Only set this field to specify a custom bitmap that differs in appearance from the default bitmap |
| close | Boolean | false | WRITE\_ONLY | Causes the dialog to be dismissed. The dialog is dismissed whenever the close field is set, regardless of whether the field is set to true or false |
| wasClosed | Event | N/A | READ\_WRITE | Set when the dialog has been closed. The field is set when the dialog close field is set, when the Back or Home key has been pressed, when the Options key has been pressed if the optionsDialog field is set to true, and when the dialog is dismissed because another dialog was displayed |
| width | float | \-1.0 | READ\_WRITE | Specifies the width of the dialog. By default, this value is pulled from the system theme |
| maxHeight | float | \-1.0 | READ\_WRITE | Sets the maximum height of the dialog. By default, the Dialog will scale the height based on the contents but never larger than the height of the display resolution. Setting maxHeight smaller than the contents will switch to a scrollable text region |

Sample app
----------

[DialogExample](https://github.com/rokudev/samples/tree/master/ux%20components/dialogs/DialogExample) is a sample app demonstrating Dialog in action.

StdDlgCustomItem
================

Extends [StdDlgItemBase](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-item-base.md "**StdDlgItemBase**")

The **StdDlgCustomItem** node is used to display free-form dialog items in the content area that require a custom layout.

![roku400px -  - custom-item](https://image.roku.com/ZHZscHItMTc2/std-dlg-custom-item-multi-column.jpeg)

Fields
------

| Field | Type | Default | Access Permission | Description |
| --- | --- | --- | --- | --- |
| widthField | float | 0   | READ\_ONLY | The width of the custom item, which is enforced by the content area's layout algorithm. |
| fixedWidthField | float | 0   | READ\_WRITE | Specifies the desired width of the custom item, which is passed to the content area's layout algorithm. This field is typically specified when the custom item includes a [DynamicCustomKeyboard node](/docs/references/scenegraph/dynamic-voice-keyboard-nodes/dynamic-custom-keyboard.md), which has a width that is determined by the KDF file of the custom keyboard. |

> To enable a **StdDlgCustomItem** node to gain focus (for example, if it includes a custom keyboard node), set its **focusable** field to true (this field is inherited from the base [Node class](/docs/references/scenegraph/node.md)).

Sample app
----------

You can download and install a [sample app](https://github.com/rokudev/standard-dialog-framework) that demonstrates how to create a custom dialog that uses a custom item.

Authentication Overview
=======================

Roku provides mechanisms and protocols that streamline authentication for apps. These authentication methods allow customers to sign into apps with minimal input to ensure they can access and engage with content.

SVOD, TVOD, and other authenticated transactional apps use [on-device authentication](/docs/developer-program/authentication/on-device-authentication.md) with Automatic Account Link to validate subscriptions and purchases. With this mechanism, apps verify whether the customer has an active subscription through Roku Pay for the content, and then check whether there is a valid access token stored in the device registry and the Roku cloud. Based on these checks, apps either grant access to the content or do additional validations such as checking previous transactions or checking whether the customer's email address is linked to an existing subscription.

Using AAL further simplifies authentication for customers with multiple Roku devices: Once successfully authenticated on one device, customers are automatically signed in when they activate additional Roku devices linked to the same Roku account.

AVOD and non-monetized apps requiring a user account to log in can use [AAL](/docs/developer-program/authentication/universal-authentication-protocol-for-single-sign-on.md) to authenticate customers on all of the Roku devices linked to their Roku account.

TVE apps can use the ["rendezvous" linking](/docs/developer-program/authentication/authentication-and-linking.md) to validate subscriptions. With this method, apps get a registration code and display it on the Roku device. When the customers enter the registration code on the provider's external website, the provider's authentication service links the customer's device to their Roku account via an access token that is downloaded and stored on the device.

For more information on implementing these authentication methods, see their respective integration documents:

| App | Authentication Method |
| --- | --- |
| SVOD, TVOD | [On-device authentication](/docs/developer-program/authentication/on-device-authentication.md) |
| AVOD, non-monetized apps | [Automatic Account Link](/docs/developer-program/authentication/universal-authentication-protocol-for-single-sign-on.md) |
| TVE | [Rendezvous linking](/docs/developer-program/authentication/authentication-and-linking.md) |

PosterGrid
==========

Extends [**ArrayGrid**](/docs/references/scenegraph/abstract-nodes/arraygrid.md)

The PosterGrid node is a simple grid class that can be used to display two-dimensional grids of posters. In addition to the poster, each item in the grid can include up to two lines of captions.

The number of columns in the PosterGrid is fixed and the number of rows varies. The items in the grid fill each row from left to right, then top to bottom in the following order:

![roku815px - Presentation1](https://image.roku.com/ZHZscHItMTc2/Presentation1.png "Presentation1")

The layout of rows and columns in the grid is very flexible. Possible layouts include:

*   a simple layout with all posters in the grid having the same size
*   a layout with the posters in some rows having varying heights and/or the posters in some columns having varying widths
*   a layout with varying width rows and columns and items that occupy one or more rows and columns

The grid items can be organized into sections that are demarcated by labelled horizontal divider lines between the sections.

The PosterGrid node class includes the capability to automatically scale the loaded graphical images to fit within the target screen element area specified by the `basePosterSize` field value. To use this capability, select the scaling option you want as the value of the `posterDisplayMode` field.

### Example

The following screenshot is an example of the PosterGrid layout.

![roku815px - PosterGrid](https://image.roku.com/ZHZscHItMTc2/PosterGrid.png "PosterGrid")

Grid Layouts
------------

The PosterGrid class supports very flexible layouts. The philosophy is that simple layouts are easy to produce and complicated layouts are possible.

There are three general categories of layouts.

1.  Simple layouts with all grid items and spacings between items equal.To specify a simple layout:Set the `basePosterSize` field to the width and height of each of the images in the grid and set the `itemSpacing` field to spacing between posters. For example, if basePosterSize is \[300,100\] and itemSpacing is \[4, 8\], then the posters will be 300 pixels wide and 100 pixels tall. There will be 4 pixels between the columns of the grid and 8 pixels between rows of the grid.
    
2.  All the items are aligned in rows and columns, but the rows and columns (or the spacing between them) varies. To specify this type of layout, use the columnWidths, columnSpacings, rowHeights, and rowSpacings fields. Each of these fields takes an array of values, specifying the values for each row width, column height or spacing between rows and columns. If there are more rows or columns in the grid than specified in the arrays for these fields., the corresponding simple layout field values are used for the missing values (e.g. basePosterSize\[0\] for missing columnWidth, etc.)For example, suppose a grid is designed with 4 columns where each item was 80 pixels wide and had 4 pixels space between them. The grid data includes 10 rows, where the first 4 rows have items that are 120 pixel tall and the remaining 6 rows have items are 80 pixels tall. All the rows should have 6 pixels of space between them. To specify this layout, you'd set up the fields like this:
    

| Field | Example |
| --- | --- |
| basePosterSize | \[ 80, 80 \] |
| itemSpacings | \[ 4, 6 \] |
| rowHeights | \[ 120, 120, 120, 120, 80, 80, 80, 80, 80, 80 \] |

> Since the final 6 values in the rowHeights array equal basePosterSize\[1\], you can omit them, so in this case setting the rowHeights field to \[ 120, 120, 120, 120 \] would have the same result.

3.  There are clear alignments in the row/column layout, but some items can span more than one one row or column (plus the space in between).To specify this type of layout, set up the fields as in case 1 or 2 to define the sizes of the rows/columns. If any of the grid items will occupy more than one row or column, then the metadata for each grid item must contain extra metadata specifying the starting row, starting column, numbers of rows and number of columns that the item occupies. In addition, the fixedLayout field must be set to true. For example, if a grid item is supposed to span columns 2 and 3 and rows 3 through 6, then in addition to the URL for the poster, the metadata for that item would include (X = 2, Y = 3, W = 2, H = 4). W is set to 2 because the item is 2 columns wide. Similarly H is set to 4 because the item is 4 columns tall.The total pixel width of the item would be the (width of column 2) + (spacing between columns 2 & 3) + (width of column 3). Similarly, the height of the item would be the sum of the heights of columns 3, 4, 5 and 6, plus the spacings between columns 3 & 4, 4 & 5 and 5 & 6.The X and Y indices start from 0 (i.e. the first columns is X = 0).

Fields
------

FieldTypeDefaultAccess PermissionDescriptioncontentContentNodenoneREAD\_WRITESpecifies the content for the list. See [Data bindings](/docs/references/scenegraph/list-and-grid-nodes/markuplist.md#data-bindings) below for more details.  
If the data contains section markers, section dividers will be drawn between each section. These section dividers may contain an icon and/or a string.basePosterSizevector2d\[0,0\]READ\_WRITESpecifies the width and height of the posters in the grid.useAtlasBooleantrueREAD\_WRITEEnables a performance optimization when most of the poster items displayed in the grid have the same size. The field value toggles the use of a texture atlas that stores the posters in the grid. The default is true, since in many cases, most of the posters in the grid have the same size as determined by the `basePosterSize` field value. In this case, using the texture atlas can provide a rendering performance benefit. For grids that have more complicated layouts, that include several posters that have sizes that differ from the value of `basePosterSize`, or for grids where there are only a few large posters (about five to eight, or posters that are about a quarter of the screen height or width) displayed at the same time, it is best for this field to be set to `false`.posterDisplayModeoption stringnoScaleREAD\_WRITEProvides automatic scaling of posters, if `useAtlas` is set to false. If you intend to load very large graphical images, such as larger than the user interface resolution, you must set one of the scaling options other than `noScale`, otherwise the image may fail to load. The following are the possible field values:  
  

| Option | Effect |
| --- | --- |
| noScale | No scaling |
| scaleToFit | Scale the image to fit into the target screen element area, preserving the aspect ratio but "letterboxing" or "pillarboxing" the image (background-color bars at the top/bottom or left/right of the image) |
| scaleToFill | Stretch the image width and height dimensions to fill the target screen element area, distorting the image if the target screen element area has a different aspect ratio than the image |
| scaleToZoom | Scale the image to fill the target screen element area, preserving the aspect ratio but not "letterboxing" or "pillarboxing" the image, with some of the image cropped out |

itemSpacingvector2d\[0,0\]READ\_WRITEThe second value of the vector specifies the vertical spacing between items in the list. The first value of the vector is ignored.numColumnsinteger0READ\_WRITESpecifies the number of columns in the gridnumRowsinteger12READ\_WRITESpecifies the number of visible rows displayed. The actual number of rows may be more or less than the number of visible rows specified depending on the number of items in the list content.rowHeightsarray of floats\[ \]READ\_WRITEWhen specified, the rowHeights field specifies the heights of the poster for each row of the grid. This allows the height of each row of the grid to vary from row to row.  
  
The rowHeights values override the height specified in element 1 of the basePosterSize field. If the rowHeights array contains fewer elements than the number of rows needed to display all the items in the grid, element 1 of the basePosterSize field is used as the height of the excess rows.columnWidthsarray of floats\[ \]READ\_WRITEWhen specified, the columnWidths field specifies the widths of the poster for each column of the grid. This allows the width of each column of the grid to vary from column to column.  
  
The columnWidths values override the width specified in element 0 of the basePosterSize field. If the columnWidths array contains fewer elements than the number of columns specified by the numColumns field, element 0 of the basePosterSize field is used as the width of the excess columns.rowSpacingsarray of floats\[ \]READ\_WRITEWhen specified, the rowSpacings field specifies the spacing after each row of the grid. This allows the spacing between rows to vary from row to row.  
  
The rowSpacings values override the vertical spacing specified in element 1 of the itemSpacing field. If the rowSpacings array contains fewer elements than the number of rows needed to display all the items in the grid, element 1 of the itemSpacing field is used as the spacing after the excess rows.columnSpacingsarray of floats\[ \]READ\_WRITEWhen specified, the columnSpacings field specifies the spacing after each column of the grid. This allows the spacing between columns to vary from column to column.  
  
The columnSpacings values override the horizontal spacing specified in element 0 of the itemSpacing field. If the columnSpacings array contains fewer elements than the number of columns specified by the numColumns field, element 0 of the itemSpacing field is used as the spacing after the excess columns.fixedLayoutBooleanfalseREAD\_WRITEWhen fixedLayout is false, the PosterGrid assigns each item in the data model to sequential cells in the grid (or the section if the data model includes section information).  
  
When fixedLayout is true, the data models using the X, Y, W and H attributes to specify which cells of the grid each item should occupy, where X is the column number, Y is the row number, W is the number of columns the item occupies and H is the number of rows the item occupies.  
  
Fixed layout should only be set to true for cases where one or more items in the grid should span multiple rows or columns.imageWellBitmapUriuriREAD\_WRITESpecifies the bitmap file to use to suggest where images would appear for empty grids and empty sections of grids. Only set this field to specify a custom bitmap that differs in appearance from the default bitmap.loadingBitmapUriuriREAD\_WRITESpecifies a bitmap file to display while a grid item's poster is loading.  
  
To execute a seamless cross-fade transition between posters, set the **loadingBitmapUri** of the next poster to be shown to the uri of the currently displayed poster.loadingBitmapOpacityfloat1.0READ\_WRITESpecifies an opacity value used to render the loading bitmapfailedBitmapUriuriREAD\_WRITESpecifies a bitmap file to display when a grid item poster fails to loadfailedBitmapOpacityfloat1.0READ\_WRITESpecifies an opacity value used to render the failed bitmapcaption1Fontfontsystem defaultREAD\_WRITESpecifies the font for the grid item first captioncaption1Colorcolor0xddddddffREAD\_WRITESpecifies the color for the grid item first captioncaption1NumLinesinteger0READ\_WRITESpecifies the number of lines to render for the grid item first captioncaption2Fontfontsystem defaultREAD\_WRITESpecifies the font for the grid item second captioncaption2Colorcolor0xddddddffREAD\_WRITESpecifies the color for the grid item second captioncaption2NumLinesinteger0READ\_WRITESpecifies the number of lines to render for the grid item second captioncaptionBackgroundBitmapUriuriREAD\_WRITESpecifies a bitmap file to render as a background for the grid item captionscaptionHorizAlignmentstringcenterREAD\_WRITESpecifies the horizontal positioning of the grid item captions. Possible values are:  
  

| Value | Meaning |
| --- | --- |
| left | Left-justify the caption relative to the grid item poster |
| center | Center-justify the caption relative to the grid item poster |
| right | Right-justify the caption relative to the grid item poster |

  
  
Set enableCaptionScrolling to false to use captionHorizAlignmentcaptionVertAlignmentstringbelowREAD\_WRITESpecifies the vertical positioning of the grid item captions. Possible values are:  
  

| Value | Meaning |
| --- | --- |
| above | Position the caption so the bottom of the caption lies just above the grid item poster |
| top | Align the top of the caption with the top edge of the grid item poster |
| center | Align the vertical center of the caption with the vertical center of the of the grid item poster |
| bottom | Align the bottom of the caption with the bottom edge of the grid item poster |
| below | Position the caption so the top of the caption lies just below the grid item poster |

captionLineSpacingfloat0READ\_WRITESpecifies the spacing in pixels between lines of the captionshowBackgroundForEmptyCaptionsBooleantrueREAD\_WRITEIf a caption background is specified, this field specifies whether or not to display the caption background when the caption text is emptyenableCaptionScrollingBooleantrueREAD\_WRITESpecifies whether or not to scroll single line captions when it is necessary to ellipsize the caption because it is wider the column containing the grid itemdrawFocusFeedbackBooleantrueREAD\_WRITESpecifies whether or not the focus indicator bitmap is displayeddrawFocusFeedbackOnTopBooleanfalseREAD\_WRITESpecifies whether the focus indicator bitmap is drawn below or on top of the list itemsfocusBitmapUriuriREAD\_WRITESpecifies the bitmap file used for the focus indicator when the list has focus. In most cases, this should be a 9-patch image that specifies both expandable regions as well as margins. Only set this field to specify a custom bitmap that differs in appearance from the default bitmap.focusFootprintBitmapUriuriREAD\_WRITESpecifies the bitmap file used for the focus indicator when the list does not have focus. In most cases, this should be a 9-patch image that specifies both expandable regions as well as margins. Only set this field to specify a custom bitmap that differs in appearance from the default bitmap.focusBitmapBlendColorcolor0xFFFFFFFFREAD\_WRITEBlend the graphic image specified by `focusBitmapUri` with the specified color. If set to the default, 0xFFFFFFFF, no color blending will occur. Set this field to show a focus indicator graphic image with a different color than the image specified by `focusBitmapUri.`focusFootprintBlendColorcolor0xFFFFFFFFREAD\_WRITEBlend the graphic image specified by `focusFootprintBitmapUri` with the specified color. If set to the default, 0xFFFFFFFF, no color blending will occur. Set this field to show a focus footprint indicator graphic image with a different color than the image specified by `focusFootprintBitmapUri`.wrapDividerBitmapUriuri""READ\_WRITESpecifies the bitmap file to use as a visual separator between the last and first list items when the list wraps. In most case, this should be a 9-patch image that specifies both expandable regions. Only set this field to specify a custom bitmap that differs in appearance from the default bitmap.wrapDividerHeightfloat0.0READ\_WRITESpecifies the height of the wrap divider, the visual separator between the last and first list items when the list wraps. The bitmap for the wrap divider is scaled to this height. The width of the wrap divider is set to the width of the list items as specified by the `itemSize` field width value.sectionDividerBitmapUriuriREAD\_WRITEIf the ContentNode specifies sections for a list or grid, specifies a custom bitmap to use as a visual divider between the sections of the list or grid. Only set this field to use a bitmap with a different appearance than the system default. For sections that do not include an icon or a title, the system default or custom bitmap specified as the `wrapDividerBitmapUri` field value is used for the section dividers. In most cases, you will want to use a 9-patch PNG bitmap with both expandable regions, which is the type of bitmap used as the system default.sectionDividerFontfontsystem defaultREAD\_WRITESpecifies the font for section divider labelssectionDividerTextColorcolor0xddddddffREAD\_WRITESpecifies the text color for section divider labelssectionDividerSpacingfloat10READ\_WRITESpecifies the spacing between the items appearing in the section divider (e.g. the spacing between the section divider icon, the section divider label, and the section divider bitmap). Note the section divider does not always include an icon and/or a title.sectionDividerHeightfloat40READ\_WRITESpecifies the height of the section dividers. The width of the section dividers is determined by the width of the list items as specified by the itemSize field width value.sectionDividerMinWidthfloat117READ\_WRITESpecifies the minimum width of the section divider bitmap. The section divider label will be ellipsized if necessary in order to ensure that the section divider bitmap meets the minimum width.sectionDividerLeftOffsetfloat0READ\_WRITENumber of pixels to offset the left edge of the section divider relative to the left edge of the list items.itemSelectedinteger0READ\_ONLYWhen a list item is selected, itemSelected is set to the index of the selected item.itemFocusedinteger0READ\_ONLYWhen a list item gains the key focus, set to the index of the focused item.itemUnfocusedinteger0READ\_ONLYWhen a list item loses the key focus, set to the index of the unfocused item.jumpToIteminteger0WRITE\_ONLYWhen set to a valid item index, this causes the list to immediately update so that the specified index moves into the focus position.animateToIteminteger0WRITE\_ONLYWhen set to a valid item index, this causes the list to quickly scroll so that the specified index moves into the focus position.

Data bindings
-------------

A PosterGrid node should have a single ContentNode as the root node in its content field to supply the required data. The structure of the rest of the data model depends on whether or not the grid items are to be grouped into sections.

**List items not grouped into sections**

If the grid items are not to be grouped into sections, one child ContentNode should be added to the root node for each item in the grid (these child nodes can be thought of as _item nodes_). Item nodes should have their ContentNode attributes set as shown in the table below.

| Attribute | Type | Description |
| --- | --- | --- |
| HDGRIDPOSTERURL / HDPOSTERURL | uri | The image file for the item poster when the screen resolution is set to HD. HDGRIDPOSTERURL is used if non-empty. HDPOSTERURL is used otherwise. |
| SDGRIDPOSTERURL / SDPOSTERURL | uri | The image file for the item poster when the screen resolution is set to SD. SDGRIDPOSTERURL is used if non-empty. SDPOSTERURL is used otherwise. |
| SHORTDESCRIPTIONLINE1 | string | The text for the first grid item caption. |
| SHORTDESCRIPTIONLINE2 | string | The text for the second grid item caption. |
| X   | integer | When the fixedLayout field is set to true, this specifies the first row of the grid occupied by this item, where 0 refers to the first row. Note that there can be more rows in the data than visible rows, where the number of visible rows is specified by the numRows field.  <br>  <br>For example, if the data model contains enough data to fill 12 rows, X would be set to a value from 0 to 11. |
| Y   | integer | When the fixedLayout field is set to true, this specifies the first column of the grid occupied by this item, where 0 refers to the first column. Note that the number of columns is always specified by the numColumns field, regardless of how many items are in the data model.  <br>  <br>For example, if the numColumns field is set to 3, Y would be set to 0, 1 or 2. |
| W   | integer | When the fixedLayout field is set to true, this specifies how many columns the grid item occupies. If not specified, the default value of 1 is used.  <br>  <br>For example, if the numColumns field were set to 3 and a grid item is to occupy the rightmost two columns, X would be set to 1 and W would be set to 2. |
| H   | integer | When the fixedLayout field is set to true, this specifies how many rows the grid item occupies. If not specified, the default value of 1 is used.  <br>  <br>For example, if a grid item is to occupy the the third, fourth and fifth rows, Y would be set to 2 and W would be set to 3. |

**List items grouped into sections**

If the grid items are to be grouped into sections, one child ContentNode should be added to the root node for each section in the grid (these child nodes can be thought of as _section roots_). Each section root should contain one child ContentNode for each item in the section (that is, _item nodes_). Each item ContentNode uses the same attributes as the item nodes when there are no sections, as shown in the table above.

The section root ContentNodes use the following attributes:

| Attribute | Type | Description |
| --- | --- | --- |
| CONTENTTYPE | string | Must be set to `SECTION` |
| TITLE | string | Label for the section divider |
| HDGRIDPOSTERURL | uri | The image file for the icon to be displayed to the left of the section label when the screen resolution is set to HD. |
| SDGRIDPOSTERURL | uri | The image file for the icon to be displayed to the left of the section label when the screen resolution is set to SD. |
| GRIDCAPTION1NUMLINES | integer | Overrides the `caption1NumLines` field for this section of the grid, allowing different sections to display different caption layouts. If not specified, the value of the `caption1NumLines` field is used. |
| GRIDCAPTION2NUMLINES | integer | Overrides the `caption2NumLines` field for this section of the grid, allowing different sections to display different caption layouts. If not specified, the value of the `caption2NumLines` field is used. |

Example
-------

The following creates a grid of posters with two captions below each poster graphical image.

**PosterGrid Node class example**

    <?xml version="1.0" encoding="utf-8" ?>
    
    <!--********** Copyright 2015 Roku Corp.  All Rights Reserved. **********-->
    
    <component   name="postergridtest"   extends="Group"   initialFocus="testPosterGrid" >
    
    <script type="text/brightscript" >
    <![CDATA[
    sub init()
      m.testlabel = m.top.FindNode("testLabel")
      m.testpostergrid = m.top.FindNode("testPosterGrid")
      m.testpostergridcontent = createObject("roSGNode","ContentNode")
      m.readPosterGridTask = createObject("roSGNode","postergridCR")
      m.readPosterGridTask.setField("postergriduri","pkg:/server/postergrid.xml")
      m.readPosterGridTask.observeField("gotitem","buildpostergrid")
      m.readPosterGridTask.observeField("gotcontent","showpostergrid")
      m.readPosterGridTask.control = "RUN"
      m.top.setFocus(true)
    end sub
    
    sub buildpostergrid()
      gridposter = createObject("roSGNode","ContentNode")
      gridposter.hdgridposterurl = m.readPosterGridTask.hdgridposterurl
      gridposter.hdposterurl = m.readPosterGridTask.hdposterurl
      gridposter.sdgridposterurl = m.readPosterGridTask.sdgridposterurl
      gridposter.sdposterurl = m.readPosterGridTask.sdposterurl
      gridposter.shortdescriptionline1 = m.readPosterGridTask.shortdescriptionline1
      gridposter.shortdescriptionline2 = m.readPosterGridTask.shortdescriptionline2
      gridposter.x = m.readPosterGridTask.xposterpos
      gridposter.y = m.readPosterGridTask.yposterpos
      gridposter.w = m.readPosterGridTask.wnumcols
      gridposter.h = m.readPosterGridTask.hnumrows
      m.testpostergridcontent.appendChild(gridposter)
    end sub
    
    sub showpostergrid()
      m.testlabel.text = "Here's the PosterGrid: "
      m.testpostergrid.content=m.testpostergridcontent
      m.testpostergrid.visible=true
      m.testpostergrid.setFocus(true)
    end sub
    ]]>
    </script>
    
    <children>
    
    <Label
      id="testLabel"
      translation="[100,32]"
      text="Building PosterGrid... "
      />
    
    <PosterGrid
      id="testPosterGrid"
      translation="[100,100]"
      basePosterSize="[240,240]"
      itemSpacing="[32,32]"
      caption1NumLines="1"
      caption2NumLines="1"
      numColumns="4"
      numRows="3"
      />
    
    </children>
    
    </component>
    

Sample app
----------

[PosterGridExample](https://github.com/rokudev/samples/tree/master/ux%20components/lists%20and%20grids/PosterGridExample) is a sample app demonstrating PosterGrid in action.

StdDlgContentArea
=================

Extends [StdDlgAreaBase](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-area-base.md "**StdDlgAreaBase**")

The **StdDlgContentArea** node contains the main body of the dialog. It is positioned between the title area and the button area.

It contains zero or more child nodes that extend [**StdDlgItemBase**](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-item-base.md) (for example, [**StdDlgTextItem**](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-text-item.md), [**StdDlgProgressItem**](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-progress-item.md), [**StdDlgGraphicItem**](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-graphic-item.md), and other dialog building blocks). The layout and position of the [**StdDlgItemBase** nodes](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-item-base.md) are based on the dialog's width; the nodes are arranged vertically from top to bottom in the content area based on the order in which they are listed. The content area should contain only [**StdDlgItemBase** nodes](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-item-base.md); otherwise, its layout and rendering are undefined.

![roku815px - content-area](https://image.roku.com/ZHZscHItMTc2/content-area.jpg)

Fields
------

The **StdDlgContentArea** node does not have any fields.

DynamicCustomKeyboard
=====================

Extends [DynamicKeyboardBase](/docs/references/scenegraph/dynamic-voice-keyboard-nodes/dynamic-keyboard-base.md "DynamicKeyboardBase")

The **DynamicCustomKeyboard** node enables developers to create a voice-enabled keyboard that has a custom layout. As specified in its parent [DynamicKeyboardBase](/docs/references/scenegraph/dynamic-voice-keyboard-nodes/dynamic-keyboard-base.md "DynamicKeyboardBase") class, the **DynamicCustomKeyboard** node has a built-in [**VoiceTextEditBox**](/docs/references/scenegraph/dynamic-voice-keyboard-nodes/voice-text-edit-box.md) node for displaying the string of characters provided via text or voice entry, and it has a [**DynamicKeyGrid**](/docs/references/scenegraph/dynamic-voice-keyboard-nodes/dynamic-key-grid.md) node that provides keyboard functionality.

The layout of the keyboard is customized based on a JSON-formatted Key Definition File. In the Key Definition File, the developer labels the individual keys and groups them into sections and rows. The key labels support the characters in the Basic Latin, Latin 1 Supplement, Latin Extended-A, and Latin Extended-B blocks. This provides support for most Western European languages, including English, French, German, Italian, Portuguese, and Spanish.

![roku815px - address-keyboard-voice](https://image.roku.com/ZHZscHItMTc2/address-keyboard-voice.jpg)

Accessing the Key Definition File
---------------------------------

The instance of the **DynamicKeyGrid** node is accessed via the **keyGrid** field of the **DynamicCustomKeyboard** node. The **keyGrid** field includes a **keyDefinitionUri** field, which must be set to a valid Key Definition File. Typically, this is done by creating an RSG component that extends the **DynamicCustomKeyboard** and then defining an **init()** function for that component as demonstrated in the following example:

    sub init()
        m.top.keyGrid.keyDefinitionUri = "pkg:/data/coolKeyboardLayoutKDF.json"
    end sub
    

In this example, the **keyGrid** is set to the **coolKeyboardLayoutKDF.json** file, which is located in the **data** directory of the package file. The Key Definition File may be stored anywhere within the package file.

Default key selection handlers
------------------------------

It is recommended that developers create a component that extends the **DynamicCustomKeyboard** node class. This provides default key selection handling for the following use cases:

| Key | Default Handler |
| --- | --- |
| "label" specified, but not "strOut" | The "label" string is inserted in the text field's string at the current cursor position. |
| "strOut" set to "clear" ("clear" is case insensitive) | The text field is set to the empty string. |
| "strOut" set to "backspace" ("backspace" is case insensitive) | The character to the left of the cursor position is deleted from the text field's string. |
| "strOut" set to "space" ("space" is case insensitive") | A space is inserted in the text field's string at the current cursor position. |
| "strOut" set to some other string | By default, the "strOut" string is inserted in the text field's string at the current cursor position. In this case, the component typically provides a custom key selection handler (see [Custom key selection handlers](#custom-key-selection-handler) for more details). |

Custom key selection handlers
-----------------------------

For most keys defined in the Key Definition File, the [default key selection handlers](#default-key-selection-handlers) will provide the desired behavior. If custom handling is needed, the component that extends the **DynamicCustomKeyboard** node class can implement an interface function. To do this, include a function within the component's element that has the following signature:

    function keySelected(key as string) as boolean
    

The _key_ parameter is set to the key's "strOut" field, if specified; otherwise, it is set to the key's "label" string.

The function should return _true_ if it handles the key selection. Returning _false_ causes the [default key selection handler](#default-key-selection-handler) behavior to be used.

#### Example custom key select handler

The following example demonstrates a custom key handler:

1.  The Key Definition File for the component that extends **DynamicCustomKeyboard** node has a row that defines the following keys:
    
        "keys": [
            { "label": "Aa", "strOut": "ChangeCase" },
            <OTHER KEYS>
        ]
        
    
2.  When this key is selected, the keyboard's mode is changed from "UpperCase" to "LowerCase" (the Key Definition File would need to include grids for both modes). In this case, the child **DynamicCustomKeyboard** component includes a **keySelected()** function in its interface:
    
        <component name="MyCustomKeyboard" extends="DynamicCustomKeyboard>
            <interface>
                <function name="keySelected" />
            </interface>
            <OTHER COMPONENT ELEMENTS>
        </component>
        
    
3.  In the corresponding BrightScript file for the child **DynamicCustomKeyboard** component, the **keySelected()** function includes the following business logic:
    
        function keySelected(key as string) as boolean
            if key = "ChangeCase"
                if m.top.keyGrid.mode = "UpperCase"   ' m.top.keyGrid.mode would likely be initialized in the component's init()                                                
                    m.top.keyGrid.mode = "LowerCase"  ' function just after m.top.keyGrid.keyDefinitionUri is set to the Key Definition File to use
                else
                    m.top.keyGrid.mode = "UpperCase"
                end if
                return true    ' key selection is handled, return true
            end if
            ' if not handled, return false to use default DynamicCustomKeyboard keySelected handlers
            return false
        end function
        
    

#### Custom key handlers that modify the entered text string

In most cases, the default key selection handlers can be used for modifying the entered text string. However, if a custom key handler is used to do this, it must update the **cursorPosition** of the **DynamicCustomKeyboard**. The following example demonstrates a custom key handler that changes the text string:

1.  The Key Definition File includes a key definition with an action intended to duplicate the character to the left of the cursor position, positioning the cursor after the duplicated character:
    
        "keys": [
            { "icon": "pkg:/images/Duplicate.png", "strOut": "DuplicateCharacter" },
            <OTHER KEYS>
        ]
        
    
2.  The **keySelected()** function includes the following business logic:
    
        function keySelected(key as string) as boolean
            if key = "DuplicateCharacter"
                currString = m.top.text
                currStringLen = currString.Len()
                cursorPosition = m.top.textEditBox.cursorPosition
                charToDuplicate = currString.Mid(cursorPosition, 1)
             ' set the keyboard's text field to the edited string
                if cursorPosition > 0
                    m.top.text = currString.Left(cursorPosition) + charToDuplicate + currString.Right(currStringLen - cursorPosition)
                end if
                ' update the VoiceTextEditBox's cursorPosition
                m.top.TextEditBox.cursorPosition = cursorPosition + 1
                return true   ' DuplicateCharacter key selection is handled
            end if
            ' if not handled, return false to use default DynamicCustomKeyboard keySelected handlers
            return false
        end function
        
    

Fields
------

See the [DynamicKeyboardBase](/docs/references/scenegraph/dynamic-voice-keyboard-nodes/dynamic-keyboard-base.md "DynamicKeyboardBase") node and its base classes ([Group](/docs/references/scenegraph/layout-group-nodes/group.md) and [Node](/docs/references/scenegraph/node.md)) for configuring the fields inherited by the **DynamicCustomKeyboard** node.

| Field | Type | Default | Access Permission | Description |
| --- | --- | --- | --- | --- |
| keyGrid | DynamicKeyGrid node | The DynamicKeyGrid node associated with the keyboard | READ | Provides access to the internal **DynamicKeyGrid** node of this **DynamicKeyboardBase** component.  <br>  <br>Do not set this field to null or to a different DynamicKeyGrid node; this field should be used only to access the fields of this component's internal DynamicKeyGrid node.  <br><br>> The **DynamicKeyGrid**.**keyDefinitionUri** field must be set to the custom Key Definition File that defines the keyboard's layout. |

Default VoiceTextEditBox settings
---------------------------------

| Field | Type | Default | Description |
| --- | --- | --- | --- |
| voiceEntryType | string | "generic" | The type of characters accepted via voice entry. |
| voiceEnabled | boolean | true | Specifies whether voice entry is enabled for the text edit box of the dynamic keyboard. |
| maxTextLength | integer | 75  | The maximum number of characters that may be entered into the text edit box of the dynamic keyboard. |

Sample Key Definition File
--------------------------

The following sample demonstrates a Key Definition File that defines five grids for **DynamicCustomKeyboard** node. See the [Key Definition File specification](/docs/references/scenegraph/dynamic-voice-keyboard-nodes/key-definition-file.md) for more information.

    {
      "keyboardWidthFHD": 576,
      "keyboardHeightFHD": 432,
    
      "keyboardWidthHD": 384,
      "keyboardHeightHD": 288,
      "sections": [
        {
          "grids": [
            {
              "modes": "NameUpper",
              "rows": [
                {
                  "keys": [
                    { "label": "A" },
                    { "label": "B" },
                    { "label": "C" },
                    { "label": "D" },
                    { "label": "E" },
                    { "label": "F" }
                  ]
                },
                {
                  "keys": [
                    { "label": "G" },
                    { "label": "H" },
                    { "label": "I" },
                    { "label": "J" },
                    { "label": "K" },
                    { "label": "L" }
                  ]
                },
                {
                  "keys": [
                    { "label": "M" },
                    { "label": "N" },
                    { "label": "O" },
                    { "label": "P" },
                    { "label": "Q" },
                    { "label": "R" }
                  ]
                },
                {
                  "keys": [
                    { "label": "S" },
                    { "label": "T" },
                    { "label": "U" },
                    { "label": "V" },
                    { "label": "W" },
                    { "label": "X" }
                  ]
                },
                {
                  "keys": [
                    { "label": "Y" },
                    { "label": "Z" },
                    {
                      "icon": "theme:DKB_SpaceKeyBitmap",
                      "focusIcon": "theme:DKB_SpaceKeyFocusBitmap",
                      "strOut": "Space"
                    },
                    {
                      "icon": "theme:DKB_DeleteKeyBitmap",
                      "focusIcon": "theme:DKB_DeleteKeyFocusBitmap",
                      "strOut": "Delete"
                    },
                    {
                      "icon": "theme:DKB_ClearKeyBitmap",
                      "focusIcon": "theme:DKB_ClearKeyFocusBitmap",
                      "strOut": "Clear"
                    },
                    {
                      "label": "Aa",
                      "strOut": "UpperLower"
                    }
                  ]
                },
                {
                  "keys": [
                    { "label": "Prev", "disabled": 1 },
                    { "label": "Next" }
                  ]
                }
              ]
            },
            {
              "modes": "NameLower",
              "rows": [
                {
                  "keys": [
                    { "label": "a" },
                    { "label": "b" },
                    { "label": "c" },
                    { "label": "d" },
                    { "label": "e" },
                    { "label": "f" }
                  ]
                },
                {
                  "keys": [
                    { "label": "g" },
                    { "label": "h" },
                    { "label": "i" },
                    { "label": "j" },
                    { "label": "k" },
                    { "label": "l" }
                  ]
                },
                {
                  "keys": [
                    { "label": "m" },
                    { "label": "n" },
                    { "label": "o" },
                    { "label": "p" },
                    { "label": "q" },
                    { "label": "r" }
                  ]
                },
                {
                  "keys": [
                    { "label": "s" },
                    { "label": "t" },
                    { "label": "u" },
                    { "label": "v" },
                    { "label": "w" },
                    { "label": "x" }
                  ]
                },
                {
                  "keys": [
                    { "label": "y" },
                    { "label": "z" },
                    {
                      "icon": "theme:KeyboardSpaceOnBitmap",
                      "focusIcon": "theme:KeyboardSpaceOffBitmap",
                      "strOut": "Space"
                    },
                    {
                      "icon": "theme:KeyboardDeleteOnBitmap",
                      "focusIcon": "theme:KeyboardDeleteOffBitmap",
                      "strOut": "Delete"
                    },
                    {
                      "icon": "theme:KeyboardClearOnBitmap",
                      "focusIcon": "theme:KeyboardClearOffBitmap",
                      "strOut": "Clear"
                    },
                    {
                      "label": "Aa",
                      "strOut": "UpperLower"
                    }
                  ]
                },
                {
                  "keys": [
                    { "label": "Prev", "disabled": 1 },
                    { "label": "Next" }
                  ]
                }
              ]
            },
            {
              "modes": "Zip",
              "gridHeightFHD": 360,
              "gridHeightHD": 240,
              "rows": [
                {
                  "keys": [
                    { "label": "1" },
                    { "label": "2" },
                    { "label": "3" }
                  ]
                },
                {
                  "keys": [
                    { "label": "4" },
                    { "label": "5" },
                    { "label": "6" }
                  ]
                },
                {
                  "keys": [
                    { "label": "7" },
                    { "label": "8" },
                    { "label": "9" }
                  ]
                },
                {
                  "keys": [
                    {
                      "icon": "theme:KeyboardDeleteOnBitmap",
                      "focusIcon": "theme:KeyboardDeleteOffBitmap",
                      "strOut": "Delete"
                    },
                    {
    "label": "0"
    },
                    {
                      "icon": "theme:KeyboardClearOnBitmap",
                      "focusIcon": "theme:KeyboardClearOffBitmap",
                      "strOut": "Clear"
                    }
                  ]
                },
                {
                  "keys": [
                    { "label": "Prev" },
                    { "label": "Next" }
                  ]
                }
              ]
            },
            {
              "modes": "FullUpper",
              "rows": [
                {
                  "keys": [
                    { "label": "0" },
                    { "label": "1" },
                    { "label": "2" },
                    { "label": "3" },
                    { "label": "4" },
                    { "label": "5" },
                    { "label": "6" },
                    { "label": "7" }
                  ]
                },
                {
                  "keys": [
                    { "label": "8" },
                    { "label": "9" },
                    { "label": "A" },
                    { "label": "B" },
                    { "label": "C" },
                    { "label": "D" },
                    { "label": "E" },
                    { "label": "F" }
                  ]
                },
                {
                  "keys": [
                    { "label": "G" },
                    { "label": "H" },
                    { "label": "I" },
                    { "label": "J" },
                    { "label": "K" },
                    { "label": "L" },
                    { "label": "M" },
                    { "label": "N" }
                  ]
                },
                {
                  "keys": [
                    { "label": "O" },
                    { "label": "P" },
                    { "label": "Q" },
                    { "label": "R" },
                    { "label": "S" },
                    { "label": "T" },
                    { "label": "U" },
                    { "label": "V" }
                  ]
                },
                {
                  "keys": [
                    { "label": "W" },
                    { "label": "X" },
                    { "label": "Y" },
                    { "label": "Z" },
                    {
                      "icon": "theme:KeyboardSpaceOnBitmap",
                      "focusIcon": "theme:KeyboardSpaceOffBitmap",
                      "strOut": "Space"
                    },
                    {
                      "icon": "theme:KeyboardDeleteOnBitmap",
                      "focusIcon": "theme:KeyboardDeleteOffBitmap",
                      "strOut": "Delete"
                    },
                    {
                      "icon": "theme:KeyboardClearOnBitmap",
                      "focusIcon": "theme:KeyboardClearOffBitmap",
                      "strOut": "Clear"
                    },
                    {
                      "label": "Aa",
                      "strOut": "UpperLower"
                    }
                  ]
                },
                {
                  "keys": [
                    { "label": "Prev" },
                    { "label": "Next", "disabled": 1 }
                  ]
                }
              ]
            },
            {
              "modes": "FullLower",
              "rows": [
                {
                  "keys": [
                    { "label": "0" },
                    { "label": "1" },
                    { "label": "2" },
                    { "label": "3" },
                    { "label": "4" },
                    { "label": "5" },
                    { "label": "6" },
                    { "label": "7" }
                  ]
                },
                {
                  "keys": [
                    { "label": "8" },
                    { "label": "9" },
                    { "label": "a" },
                    { "label": "b" },
                    { "label": "c" },
                    { "label": "d" },
                    { "label": "e" },
                    { "label": "f" }
                  ]
                },
                {
                  "keys": [
                    { "label": "g" },
                    { "label": "h" },
                    { "label": "i" },
                    { "label": "j" },
                    { "label": "k" },
                    { "label": "l" },
                    { "label": "m" },
                    { "label": "n" }
                  ]
                },
                {
                  "keys": [
                    { "label": "o" },
                    { "label": "p" },
                    { "label": "q" },
                    { "label": "r" },
                    { "label": "s" },
                    { "label": "t" },
                    { "label": "u" },
                    { "label": "v" }
                  ]
                },
                {
                  "keys": [
                    { "label": "w" },
                    { "label": "x" },
                    { "label": "y" },
                    { "label": "z" },
                    {
                      "icon": "theme:KeyboardSpaceOnBitmap",
                      "focusIcon": "theme:KeyboardSpaceOffBitmap",
                      "strOut": "Space"
                    },
                    {
                      "icon": "theme:KeyboardDeleteOnBitmap",
                      "focusIcon": "theme:KeyboardDeleteOffBitmap",
                      "strOut": "Delete"
                    },
                    {
                      "icon": "theme:KeyboardClearOnBitmap",
                      "focusIcon": "theme:KeyboardClearOffBitmap",
                      "strOut": "Clear"
                    },
                    {
                      "label": "Aa",
                      "strOut": "UpperLower"
                    }
                  ]
                },
                {
                  "keys": [
                    { "label": "Prev" },
                    { "label": "Next", "disabled": 1 }
                  ]
                }
              ]
            }
          ]
        }
      ]
    }
    

Sample app
----------

You can download and install a [sample app](https://github.com/rokudev/dynamic-voice-enabled-keyboards) that demonstrates how to create and configure a dynamic voice-enabled custom keyboard (an address keyboard form). This sample include an example KDF file that specifies the layout of this custom keyboard.

roInputEvent
============

The roInput component sends the roInputEvent with the following predicates that indicate its valid event types:

Supported methods
-----------------

### isInput() as Boolean

Checks if an input event was received. This method returns true if an input event was received; otherwise, it returns false.

### GetInfo() as Object

Returns an roAssociativeArray describing the input event, which may be one of the following values:

| Key | Type | Value |
| --- | --- | --- |
| type | string | The type of event, which may be one of the following values:<br><br>*   **transport**. The app received a voice request to control the playback of content or select a user from a profile selection screen. |
| id  | LongInteger | The unique ID associated with the generated transport event |
| command | string | The type of command:<br><br>*   "action" (). Indicates that the app has received an utterance matching a name or word previously registered with the [roAppManager.SetVoiceActionStrings()](/docs/references/brightscript/interfaces/ifappmanager.md#setvoiceactionstringsactions-as-object-as-void) method.<br>*   "select" (). Indicates that the app has received a command for selecting an item via an ordinal number.<br>*   "forward"<br>*   "next"<br>*   "pause"<br>*   "play"<br>*   "replay"<br>*   "resume"<br>*   "rewind"<br>*   "seek"<br>*   "stop"<br>*   "startover"<br>*   "nowplaying"<br>*   "skip"<br>*   "shuffle"<br>*   "loop"<br>*   "like"<br>*   "dislike" |
| direction | string | For the "seek" transport command only. Specifies the direction of the seek command, which may be "forward" or "backward". |
| duration | string | For the "seek" transport command only. Specifies the number of seconds to skip forward or backward. |
| text | string | If the **type** is set to "transport" and the **command** is set to "action", this field contains the utterance matching the name or word previously registered for the app with the [roAppManager.SetVoiceActionStrings()](/docs/references/brightscript/interfaces/ifappmanager.md#setvoiceactionstringsactions-as-object-as-void) method. |
| ordinal | string | If the **type** is "transport" and the **command** is "select", this field includes a numerical value that corresponds to the ordinal number spoken by the user. Values may range between 1–6 (one-base indexing is used). |

Introduction to Roku development
================================

With the number #1 TV streaming platform in the United States and Mexico and 89.8 million streaming households, Roku is at the forefront of the streaming revolution. The Roku OS is built specifically for streaming, which means developers can seamlessly build intuitive, high-performance streaming apps designed especially for the TV. If you have a video catalog ready for distribution, this document will help you get started building a Roku app.

![roku600px - roku-dev-hero roku](https://image.roku.com/ZHZscHItMTc2/idk-hero.jpg)

Programming languages
---------------------

Creating a Roku app involves two programming languages: SceneGraph and BrightScript. These languages are used together similarly to how HTML and JavaScript are used for designing Web pages. SceneGraph is Roku's proprietary object-oriented XML framework. It is used to design the app UI. BrightScript is Roku's scripting language that is used to define the app behavior.

[Build your first Roku app](/docs/developer-program/getting-started/hello-world.md)

Tools
-----

Roku provides developers with a suite of tools to make developing an app fast and easy. This includes a layout editor to help design the app UI, resource monitoring and profiling tools to help improve app performance, and a test framework for automating UI tests.

The Roku developer community also provides a number of popular tools that streamline Roku development, including the [BrightScript extension for the Visual Studio Code IDE](https://marketplace.visualstudio.com/items?itemName=celsoaf.brightscript). This IDE features direct client-side validation, interactive debug sessions, automatic code formatting, in-editor telnet log, symbol navigation, and many other features that make Roku development easier.

[Explore the Roku developer tools](https://devtools.web.roku.com/)

[Get the BrightScript VSCode extension](https://rokucommunity.github.io/vscode-brightscript-language/installation.html)

Resources
---------

The journey from novice to guru may not be without challenges, but Roku is here to help you master app development. Resources to help get you started on your journey include an online video course that guides you on each step in the app development process, a vast library of sample apps that demonstrate how to build an app and integrate key features, up-to-date documentation, and a passionate, dedicated developer community that has built some of the best Roku development tools to help new Roku developers work in SceneGraph.

[Start learning how to build Roku apps with SceneGraph](/videos/courses/rsg/overview.md)

[Check out the sample apps in the Roku GitHub repository](https://github.com/rokudev/scenegraph-master-sample)

[Visit the Roku Developer forum](https://community.roku.com/t5/Roku-Developer-Program/bd-p/roku-developer-program)

Terms for development tools and apps
------------------------------------

When publishing development tools and apps for the Roku platform, observe the [developer terms](/docs/features/legal/developer-terms.md) to ensure compliance with the specified legal responsibilities, best practices, and guidelines. The developer terms includes a link to the [Roku Trademark Guidelines](https://docs.roku.com/published/trademarkguidelines), which specify rules for using Roku Marks and Roku Design Marks that must be adhered to.

\*_based on hours streamed, December 2022, Hypothesis Group_

ifSGNodeFocus
=============

The ifSGNodeFocus interface is used to query and manipulate the remote control focus of the nodes in a SceneGraph node tree.

Implemented by
--------------

| Name | Description |
| --- | --- |
| [roSGNode](/docs/references/brightscript/components/rosgnode.md "roSGNode") | The roSGNode object is the BrightScript equivalent of SceneGraph XML file node creation |

Supported methods
-----------------

### setFocus(on as Boolean) as Boolean

#### Description

Sets the current remote control focus to the subject node.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| on  | Boolean | True = Sets the current remote control focus to the subject node. This also automatically removes focus from the node on which it was previously set.  <br>False = Removes focus from the subject node if it had it. Setting the remote control focus to false is rarely necessary, and can lead to unexpected behavior. |

#### Return Value

A flag indicating whether focus on the subject node has successfully been updated.

### hasFocus() as Boolean

#### Description

Checks whether the subject node has the remote control focus.

#### Return Value

A flag indicating whether the subject node has the remote control focus.

### isInFocusChain() as Boolean

#### Description

Checks whether the subject node or any of its descendants in the SceneGraph node tree have remote control focus.

#### Return Value

A flag indicating whether the subject node or any of its descendants in the SceneGraph node tree have the remote control focus.

roRemoteInfo
============

The roRemoteInfo component provides an interface to obtain attributes about the Roku remote control that is currently connected to the Roku device. Note that a Roku remote control device that is paired with a device, may not be the one that is currently connected (a single remote is typically connected to a device at a time).

This object is created with no parameters:

`CreateObject("roRemoteInfo")`

**Example**

    remoteInfo = CreateObject("roRemoteInfo")
    print remoteInfo.GetModel(0)
    print remoteInfo.IsAwake(0)
    print remoteInfo.hasFeature("voicecapture", 0)
    

**Output**

The output from the above code could be as follows:

    538
    false
    true
    

Supported interfaces
--------------------

*   [ifRemoteInfo](/docs/references/brightscript/interfaces/ifremoteinfo.md "ifRemoteInfo")

PinPad
======

Extends [**Group**](/docs/references/scenegraph/layout-group-nodes/group.md "**Group**")

The PinPad node is a simple widget that allows you to enter a fixed length numeric string. The string that is entered is displayed in a set of boxes above the PinPad node keyboard, with each box displaying a single numeral of the entered string.

The PinPad node must have the key focus in order to work properly.

The default appearance of the PinPad node is very transparent, allowing the node to pick up most of its color from what is rendered underneath it. The appearance can be customized by changing the keyboardBitmapUri and other fields.

### PinPad Bitmap Templates

Use the links below to download the template files.

The files have opaque white lines that show the key outlines with the rest of the images fully transparent. Looking at the files in some image viewers that do not support transparency will result in the images looking all white.

When creating your own keyboard background artwork, you must maintain the size of the image and the position of the keys in order for it to align properly with the rendered key labels and icons.

#### Templates:

*   [SD PinPad Template](https://image.roku.com/ZHZscHItMTc2/pinpad---SD.png)
*   [HD PinPad Template](https://image.roku.com/ZHZscHItMTc2/pinpad---HD.png)
*   [FHD PinPad Template](https://image.roku.com/ZHZscHItMTc2/pinpad---FHD.png)

Fields
------

| Field | Type | Default | Access Permission | Description |
| --- | --- | --- | --- | --- |
| pin | string | ""  | READ\_WRITE | Contains the string of numbers that have been entered |
| pinLength | integer | 4   | READ\_WRITE | Contains the maximum number of digits that can be entered |
| secureMode | boolean | true | READ\_WRITE | When set to true, each digit entered is displayed briefly, then replaced with an asterisk. When false, the entered digits always remain visible |
| keyColor | color | 0xffffffff | READ\_WRITE | Specifies the color of the key labels and icons when the keyboard does not have the focus |
| focusedKeyColor | color | 0xffffffff | READ\_WRITE | Specifies the color of the key labels and icons when the keyboard has the focus |
| pinDisplayTextColor | color | 0xffffffff | READ\_WRITE | Specifies the color of the numbers displayed in the pin display boxes |
| keyboardBitmapUri | string | ""  | READ\_WRITE | Specifies the URI of an image file to be loaded to replace the default keyboard image drawn underneath the numeric keys and icons  <br>This image must be carefully designed so that the key positions match the default image. Template images for SD, HD and FHD resolutions are provided below. |
| pinDisplayBitmapUri | string | ""  | READ\_WRITE | Specifed the URI of an image file to be loaded to replace the default box drawn underneath each entered digit in the pin display. This should be a 9-patch image so that it can be stretched to appropriate size depending on the pinLength field |
| focusBitmapUri | string | ""  | READ\_WRITE | Specifies the URI of an image file to be loaded to replace the keyboard focus indicator. This should be a 9-patch image so that it can be stretched to the appropriate size for the double width keys |
| showPinDisplay | boolean | true | READ\_WRITE | Specifies whether or not the pin display that shows the entered digits is visible. In most cases, it is desirable to display the entered digits so that the user can see the string as it is entered.  <br>You may want to only show the keyboard part of the PinPad node. In those cases, the pin field of the node will still contain the string entered by the user, so that it can displayed in some different manner. |
| itemFocused | integer | 0   | READ\_WRITE | Specifies index of the key label that will be in focus when PinPad is created |
| focusVisible | boolean | true | READ\_WRITE | Specifies whether or not focused key is visible when PinPad is created |

Sample app
----------

[PinpadExample](https://github.com/rokudev/samples/tree/master/ux%20components/widgets/PinPadExample) is a sample app demonstrating Pinpad in action.

roFunction
==========

roFunction is the object equivalent for intrinsic type Function.

Supported interfaces
--------------------

*   [ifFunction](/docs/references/brightscript/interfaces/iffunction.md "ifFunction")
*   [ifToStr](/docs/references/brightscript/interfaces/iftostr.md "ifToStr")

roRSA
=====

The RSA component provides an interface to the OpenSSL RSA library of signing algorithms.

This component can be used to sign/verify using RSA.

Typically, you would use the roEVPDigest component to create a message digest, then use roRSA to sign it.

**Example: RSA signing using SHA1**

    ba = CreateObject("roByteArray")
    
    ' ...populate bytearray...
    
    digest = CreateObject("roEVPDigest")
    digest.Setup("sha1")
    hashString = digest.Process(ba)
    hashBA = CreateObject("roByteArray")
    hashBA.FromHexString(hashString)
    rsa = CreateObject("roRSA")
    
    ' ... save private key to tmp:/privateKey.txt
    
    rsa.SetPrivateKey("tmp:/privateKey.txt")
    rsa.SetDigestAlgorithm("sha1")
    signature = rsa.Sign(hashBA)
    

**Example: RSA verification using SHA1**

    rsa = CreateObject("roRSA")
    rsa.SetPublicKey(:tmp:/publicKey.txt")
    rsa.SetDigestAlgorithm("sha1")
    
    ' see hashBA and signature from above example
    
    result = rsa.Verify(hashBA, signature)
    if (result = 1)
        print "Verified"
    else
        print "Not verified, result = " ; result
    end if
    

Supported interfaces
--------------------

*   [ifRSA](/docs/references/brightscript/interfaces/ifrsa.md "ifRSA")

roInvalid
=========

roInvalid is the object equivalent for intrinsic type 'Invalid'.

Supported interfaces
--------------------

*   [ifToStr](/docs/references/brightscript/interfaces/iftostr.md "ifToStr")

CheckList
=========

Extends [**LabelList**](/docs/references/scenegraph/list-and-grid-nodes/labellist.md)

The CheckList node class is a simple list class that displays a list of items, some of which include checkboxes that allow the user to select or unselect that item. Each item in the list displays a text string and an optional checkbox icon positioned to the left of the text string.

If the checkbox is displayed, it is shown as either:

*   an empty box,
*   or a box with a checkmark indicator inside indicating whether the item is in the checked or unchecked state.

Example
-------

The following is a sample screenshot showing the use of CheckList:

![roku815px - CheckList](https://image.roku.com/ZHZscHItMTc2/CheckList.png "CheckList")

Fields
------

| Field | Type | Default | Access Permission | Description |
| --- | --- | --- | --- | --- |
| checkedState | array of Boolean | all false | READ\_WRITE | Specifies the checked state of each item in the list. A value of true indicates the item is in the checked state. A value of false indicates that the item is in the unchecked state. When reading the value of the field, note that the field array will always include one value for each item in the list.  <br>  <br>When writing the value of the field, if the specified array includes fewer values than items in the list, the list items that are unspecified will remain in their current state. For example, if there are 10 items in the list and the field value is set to \[ `true`, `true` \], items 0 and 1 will have their checked state set to true, and the checked state of the remaining items (items 3 to 9) will be unchanged. |
| checkOnSelect | Boolean | true | READ\_WRITE | Controls whether or not pressing the remote control OK key causes the checkedState field to automatically toggle the checked state of the currently focused list item. By default, field value is set to true, but there are use cases where other behavior may be desired. In those cases, it is up to the developer to manage the checked state of the list items by setting the `checkedState` field to the desired index. |
| checkedIconUri | uri |     | READ\_WRITE | Specifies the checkbox icon to use for list items that are in the checked state when that list item does not the key focus. Typically, the icon will include the outline of a box with a checkmark indicator inside. Only set this field to specify a custom bitmap that differs in appearance from the default bitmap. |
| uncheckedIconUri | uri |     | READ\_WRITE | Specifies the checkbox icon to use for list items that are in the unchecked state when that list item does not have the key focus. Typically, the icon will include the outline of an empty box. Only set this field to specify a custom bitmap that differs in appearance from the default bitmap. |
| focusedCheckedIconUri | uri |     | READ\_WRITE | Specifies the checkbox icon to use for list items that are in the checked state when that list item has the key focus. Typically, the icon will include the outline of a box with a checkmark indicator inside. Only set this field to specify a custom bitmap that differs in appearance from the default bitmap. |
| focusedUncheckedIconUri | uri |     | READ\_WRITE | Specifies the checkbox icon to use for list items that are in the unchecked state when that list item has the key focus. Typically, the icon will include the outline of an empty box. Only set this field to specify a custom bitmap that differs in appearance from the default bitmap. |

Data bindings
-------------

The data model for the CheckList node should have a single ContentNode as the root node in its `content` field. The structure of the rest of the data model depends on whether or not the list items are to be grouped into sections.

#### List items not grouped into sections

If the list items are not to be grouped into sections, one child ContentNode should be added to the root node for each item in the list (these child nodes can be thought of as `item nodes`). Item nodes should have their ContentNode attributes set as shown in the table below.

| Attribute | Type | Description |
| --- | --- | --- |
| TITLE | string | The label for the list item |
| HIDEICON | Boolean | When set to true, the default, the list item displays the checkbox icon, reflecting the item's current selection state. When set to false, no checkbox icon is displayed, allowing the list to contain a mix of checkbox and regular list items. |

#### List items grouped into sections

If the list items are to be grouped into sections, one child ContentNode should be added to the root node for each section in the list (these child nodes can be thought of as `section roots`). Each section root should contain one child ContentNode for each item in the section (that is, item nodes). Each item ContentNode uses the same attributes as the item nodes when there are no sections, as shown in the table above.

The section root ContentNodes use the following attributes:

| Attribute | Type | Description |
| --- | --- | --- |
| CONTENTTYPE | string | Must be set to `SECTION` |
| TITLE | string | Label for the section divider |
| HDGRIDPOSTERURL | uri | The image file for the icon to be displayed to the left of the section label when the screen resolution is set to HD. |
| SDGRIDPOSTERURL | uri | The image file for the icon to be displayed to the left of the section label when the screen resolution is set to SD. |

Sample app
----------

[CheckListExample](https://github.com/rokudev/samples/tree/master/ux%20components/lists%20and%20grids/CheckListExample) is a sample app demonstrating CheckList in action.

roChannelStoreEvent
===================

The roChannelStore sends an roChannelStoreEvent in response to a call to any of several Get\* methods in [ifChannelStore](/docs/references/brightscript/interfaces/ifchannelstore.md "ifChannelStore"). The following predicates indicate its valid event types:

Supported methods
-----------------

### isRequestSucceeded() as Boolean

Checks whether the previous GET request has completed successfully.

#### GetSourceIdentity() as Integer

Returns a unique number that can be matched with the value returned by ifChannelStore.GetIdentity() to determine which roChannelStore object this event came from

#### GetResponse() as Object

Returns an roList of roAssociativeArray items for the previous GET method invocation. The format of each roAssociativeArray item depends on which GETmethod was invoked. See [ifChannelStore](/docs/references/brightscript/interfaces/ifchannelstore.md "ifChannelStore") for more details.

In the case of a successfully completed ifChannelStore.DoOrder() initiated purchase transaction, the object returned by GetResponse() is an associative array containing the following information:

| Name | Description |
| --- | --- |
| amount | Price of each purchased item |
| code | Product code. This corresponds to the product identifier that the developer assigns to the specific in-app purchase product |
| purchaseID | Contains the unique transaction ID of the transaction. Apps often use this value to entitle users to purchased subscriptions, etc. in their back end systems |
| qty | Quantity of the specific product purchased |
| total | Total purchase amount (including taxes) in the local currency |

### isRequestFailed() as Boolean

Checks whether the previous GET request has completed failed.

#### GetSourceIdentity() as Integer

Returns a unique number that can be matched with the value returned by ifChannelStore.GetIdentity() to determine which roChannelStore object this event came from.

#### GetStatus() as Integer

Checks for the reason for failure. This method returns one of the following codes that indicate the reason for failure:

| Integer code | Failure reason |
| --- | --- |
| 2   | Interrupted |
| \-1 | HTTP timeout |
| \-2 | Other timeouts |
| \-3 | Unknown error |
| \-4 | Empty list |

#### GetStatusMessage() as String

Describes the status of the completed request. This method returns a human-readable string describing the status of the completed request.

### isRequestInterrupted() as Boolean

Checks if the previous GET request did not complete. This method returns true if the request was not complete; otherwise, it returns false.

#### GetSourceIdentity() as Integer

Returns a unique number that can be matched with the value returned by ifChannelStore.GetIdentity() to determine which roChannelStore object this event came from.

ifFunction
==========

Interface equivalent for intrinsic type Function.

Implemented by
--------------

| Name | Description |
| --- | --- |
| [roFunction](/docs/references/brightscript/components/rofunction.md "roFunction") | Object equivalent for intrinsic type Function |

Supported methods
-----------------

### GetSub() As Function

You can get a plain (non-referenced) version of the value by calling the this method.

### SetSub(value As Function) As Void

This method can be used for in/out function parameters. If you have a boxed object, you can change the value in the object via this method, without changing the variable reference itself.

    Function Main()
        f1 = Foo
        print "f1 "; Type(f1); "="; f1
    
        f2 = Box(Foo)
        print "f2 "; Type(f2); "="; f2
    
        print "adjusting f2"
        AdjustFun(f2)
    
        print "f2 "; Type(f2); "="; f2
        print "f2()"; "="; f2()
    
        f3 = f2.GetSub()
        print "f3 "; Type(f3); "="; f3
    End Function
    
    Function AdjustFun(f)
        f.SetSub(Bar)
    End Function
    
    Function Foo()
        return "--Foo--"
    End Function
    
    Function Bar()
        return "--Bar--"
    End Function
    ==>
    f1 Function=<Function: foo>
    f2 roFunction=<Function: foo>
    adjusting f2
    f2 roFunction=<Function: bar>
    f2()=--Bar--
    f3 Function=<Function: bar>

ifSGNodeDict
============

The ifSGNodeDict interface allows you access information about the nodes in a SceneGraph node tree, and find and return a node with a specific ID.

Implemented by
--------------

| Name | Description |
| --- | --- |
| [roSGNode](/docs/references/brightscript/components/rosgnode.md "roSGNode") | The roSGNode object is the BrightScript equivalent of SceneGraph XML file node creation |

Supported methods
-----------------

### findNode(name as String) as Object

#### Description

Returns the node that is a descendant of the nearest component ancestor of the subject node (possibly the subject node itself) and whose id field is set to name. The search for the descendant node is a breadth-first search that includes child nodes in nodes that are declared as custom components defined in other XML component files. These together allow finding siblings and cousins of a node within the context of a component. If a node with the specified name is not found, an invalid object is returned

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| name | String | The name of the node to be retrieved. |

#### Return Value

The node that is a descendant of the nearest component ancestor of the subject node.

### subtype() as String

#### Description

Returns the subtype of the subject node as specified when it was created.

#### Return Value

The subtype of the subject node.

### parentSubtype(nodeType as String) as String

#### Description

Returns the subtype of the parent of the nodeType in the SceneGraph node class hierarchy.

> This method does not actually reference the subject node.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| nodeType | String | The node type of the parent node. |

#### Return Value

The subtype of the parent node.

### isSubtype(nodeType as String) as Boolean

#### Description

Checks whether the subtype of the subject node is a descendant of the subtype nodeType in the SceneGraph node class hierarchy.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| nodeType | String | The node type of the subject node. |

#### Return Value

A flag indicating whether the subtype of the subject node is a descendant of the subtype nodeType.

### isSameNode(RoSGNode as Object) as Boolean

#### Description

Checks whether a specific roSGNode refers to the same SceneGraph node object as the subject node.

This can be useful when the RoSGNode objects come from two different sources, for example when one is stored in an associative array, and the other is obtained from an RoSGNode interface method that returns an RoSGNode object, like getChild(). It may be that the application needs to know whether the two RoSGNode objects are actually referring to the same underlying SceneGraph node.

NameReturn TypeParametersReturn ValueDescriptionisSameNodeBoolean

| Name | Type | Description |
| --- | --- | --- |
| RoSGNode | Object | The roSGNode to be checked. |

True/FalseReturns a Boolean value indicating whether the RoSGNode parameter refers to the same SceneGraph node object as the subject node

#### Return Value

A flag indicating whether the nodes refer to the same SceneGraph node object.

#### Example:

The following example should print "same":

    n = createObject("roSGNode", "Node")
    c = n.createChild("Node")
    if c.isSameNode(n.getChild(0)) then print "same"
    

### clone(isDeepCopy as Boolean) as Object

Returns a copy of the entire node tree or just a shallow copy.

NameReturn TypeParametersReturn ValueDescriptioncloneObject

| Name | Type | Description |
| --- | --- | --- |
| isDeepCopy | Boolean | True = return a copy of the entire node tree.  <br>False = return a shallow copy of the node tree. |

Node tree

#### Return Value

A node tree.

### callFunc(funcName as String, ...) as Dynamic

callFunc() is a synchronized interface on roSGNode. It always executes in the component's owning ScriptEngine and thread (by rendezvous if necessary), and it will always use the m and m.top of the owning component. Any context from the caller can be passed via one or more method parameters, which may be of any type (previously, callFunc() only supported a single associative array parameter).

To call the function, use the `callFunc` field with the required method signature. A return value, if any, can be an object that is similarly arbitrary. The method being called must determine how to interpret the parameters included in the `callFunc` field.

**Functional field declaration**

    <interface>
        <function name="addSomeValue" />
    </interface>
    

**Function definition**

    function addSomeValue(params as Object) as Object
        passedDataLabel = m.top.findNode("passedDataLabel")
        passedDataLabel.text = params.passedString
        result = {
            resultString : "Returned Value " + stri(params.passedInt + 4)
        }
    
        return result
    end function
    

**callFunc with parameters**

    params = {passedString:"", passedInt:12}
    result = node.callFunc("addSomeValue", params)

Content metadata
================

Content metadata describes a viewable title that will be shown to the user. Content may be any supported type of video and the metadata is used by the UI to format and display the title to the user. Some attributes (e.g. ContentType) affect how the title is displayed on screen, other attributes (e.g. SDPosterURL) specify where to fetch artwork to display with the content and other attributes (e.g. Title) are just rendered as text.

Overview
--------

The content metadata is stored in an associative array by the script and provided to the various screen objects as needed for display. In some cases an array of content metadata may be provided so that the screen can render multiple items as a list. The attribute names are critical and used as the key to look up the attribute at run time. The following table details the attributes in use. Certain attributes are recognized by particular screens, while others are more globally applicable. If the attribute is not a generally recognized attribute, the table below specifies where the attributes are recognized.

Keep in mind that there are two ways to specify stream content metadata, **data.Stream** and **data.Streams**:

*   **data.Stream**: This is used when there is one stream URL, typically an HLS or smooth streaming manifest URL.
*   **data.Streams**: This is used when you have a set of fixed bitrate streams. This is typically the case for non-adaptive MP4 streams, in which case multiple variants are specified to simulate true adaptation.

Descriptive attributes
----------------------

Descriptive metadata attributes can be used to describe the content item to the user, in a user interface element that allows the user to select the item.

AttributesTypeValuesExampleContentTypeStringAlthough ContentType accepts type String, the return value is of type [roInt](/docs/references/brightscript/components/roint.md). See table below.

| Content Type | Return Value |
| --- | --- |
| audio | 5   |
| episode | 4   |
| movie | 1   |
| not set or not supported | 0   |
| season | 3   |
| series | 2   |

"movie"TitleStringContent title: movie title for films; episode title for TV series"The Dark Knight"TitleSeasonStringSeason title for TV series"Battlestar Galactica Season 5"SecondaryTitleStringSecondary title for the video content"2022" (release year of the movie)DescriptionStringDescription of content"Batman, Gordon and Harvey Dent are forced…"SDPosterUrlStringURL for SD content artworkmysite.com/img/sd1932.jpgHDPosterUrlStringURL for HD content artworkmysite.com/img/hd1932.jpgFHDPosterUrlStringURL for FHD content artworkmysite.com/img/fhd1932.jpgReleaseDateStringFormatted Date String"3/31/2009"RatingStringSelects an icon to be displayed for the corresponding MPAA or TV rating, that is, the value will display as an icon artwork. See [Rating Attribute Icons](/docs/developer-program/getting-started/architecture/content-metadata.md#rating-attribute-icons) for a list of the acceptable values and the corresponding icon."PG-13"StarRatingIntegerSpecifies the star rating to display as red star icon artwork, as a number from 1 to 100:

*   20 displays one star
*   40 displays two stars
*   60 displays three stars
*   80 displays four stars
*   100 displays five stars

Numbers not divisible by 20 are displayed as a fractional star (A number of 30 will display one and a half stars)80UserStarRatingIntegerSpecifies the user star rating to display as yellow star icon artwork, as a number from 1 to 100:

*   20 displays one star
*   40 displays two stars
*   60 displays three stars
*   80 displays four stars
*   100 displays five stars

Does not display fractional stars for numbers not divisible by 2080ShortDescriptionLine1StringLine 1 of Poster Screen Description"The Dark Knight"ShortDescriptionLine2StringLine 2 of Poster Screen Description"Rent $1.99, Buy $14.99"EpisodeNumberStringEpisode Number"1"NumEpisodesIntegerNumber of episodes for a "season" or "series" contentType40ActorsroArrayList of Actor Names\["Brad Pitt", "Angelina Jolie"\]ActorsStringIndividual Actor Name"Brad Pitt"DirectorsroArrayList of Director Names\["Joel Coen", "Clint Eastwood"\]CategoriesroArrayList of Category/Genre Names\["Comedy", "Drama"\]CategoriesStringIndividual Category/Genre Name"Comedy"AlbumStringroSpringboard audio style uses this to display the album"Achtung"ArtistStringroSpringboard audio style uses to show artist"U2"TextOverlayULStringroSlideShow displays this string in Upper Left corner of slide"Joe's Photos"TextOverlayURStringroSlideShow displays this string in Upper Right corner of slide"3 of 20"TextOverlayBodyStringroSlideShow displays this string on the bottom part of slide"Wanda's 40'th Birthday"

Digital rights management (DRM) control attributes
--------------------------------------------------

Digital rights management (DRM) content meta-data control attributes are available in the Roku OS through the drmParams parameter of type [roAssociativeArray](/docs/references/brightscript/components/roassociativearray.md). The table below enumerates all usable attributes of drmParams.

**Note:** Not all attributes are required, and may not have the same semantic meaning when applied to different DRM systems.

| Attribute | DRM System | Type | Value | Example |
| --- | --- | --- | --- | --- |
| appData | Playready, Widevine, Verimatrix: Optional | String | Special meaning per DRM system. If supplied, expected to be a base64 encoded string. | "SGF2ZSB0byBkZWFsIHdpdGggQmFzZTY0IGZ..." |
| encodingKey | Playready: Optional | String | This field is deprecated; use the **licenseServerURL** field.  <br>  <br>Specifies the PlayReady license acquisition data, in format depending on the EncodingType attribute value specified:  <br><br>*   when encodingType="PlayReadyLicenseAcquisitionUrl", the EncodingKey attribute contains the PlayReady license acquisition URL | "[http://serverName/](http://serverName/) |
| encodingType | Playready: Optional | String | This field is deprecated; use the **licenseServerURL** field.  <br>  <br>Specifies the encoding scheme for PlayReady DRM, by setting to one of the following values:  <br><br>*   "PlayReadyLicenseAcquisitionUrl"<br>*   "PlayReadyLicenseAcquisitionAndChallenge" Note, this is the same value that used to be specified directly in Content Metadata structure | "PlayReadyLicenseAcquisitionAndChallenge" |
| KeySystem | Required for all | String | "playready" or "widevine". This value is case-insensitive. The default is an empty string.  <br>  <br><br>> As of Roku OS 9.3, support for Verimatrix DRM has been removed from the firmware. Make sure that content in your app is protected using one of the following Roku-supported DRMs: Microsoft PlayReady or Widevine. Click [here](/docs/specs/media/content-protection.md) for more information on implementing these DRMs. | "widevine" |
| licenseRenewURL | Widevine: Optional | String | A URL location for sending license renewal requests. If not specified, the Roku OS would send renewal requests to the URL specified in the licenseServerURL. | " [https://host.com/license/wideivne/renew?licenseid=090495867002](https://host.com/license/wideivne/renew?licenseid=090495867002) " |
| licenseServerURL | Playready: Required Widevine: Required | String | A URL location of a license server. This URL may include CGI parameters.  <br>  <br>If this field contains the PlayReady license acquisition URL plus additional custom license acquisition request data in format "URL%%%", the “PlayReadyLicenseAcquisitionAndChallenge" type is used. | "[https://host.com/license/playready?contentid=090495867002](https://host.com/license/playready?contentid=090495867002) " |
| serializationURL | Playready, Widevine: Optional | String | A server address used for device provisioning | "[https://host.com/provision/device?esn=090495867002](https://host.com/provision/device?esn=090495867002) " |
| serviceCert | Widevine: Optional Others: N/R (leave unset) | String | The actual certificate string for Widevine purposes, which must be obtained out-of-band (OOB) by the app. Leave this unset unless Widevine is used for DRM. | Certificate strings are too long to display here. Examples can be fetched from such sources as the Widevine test license server at "[https://proxy.uat.widevine.com/proxy](https://proxy.uat.widevine.com/proxy). " |
| lic\_acq\_window | Widevine: Optional | string | The maximum amount of time (in milliseconds) that an app waits before rotating its Widevine DRM keys. The app can generate a random wait time between 0 and the value specified in the **lic\_acq\_window** field, and use the random wait time to instruct when the Video node should make its next Widevine license request. | 1000 |

*   when encodingType="PlayReadyLicenseAcquisitionAndChallenge", the EncodingKey attribute contains the PlayReady license acquisition URL plus additional custom license acquisition request data in format "URL%%%" Note, this is the same value that used to be specified directly in Content Metadata structure The app just needs to set drmParams.licenseSererUrl.

### Passing custom HTTP headers to licensing requests

Developers looking to pass custom HTTP headers with a licensing request can now set those headers using the [ifHttpAgent](/docs/references/brightscript/interfaces/ifhttpagent.md) interface methods on the [Video](/docs/references/scenegraph/media-playback-nodes/video.md) node.

### Example of configuring a dash stream with Widevine DRM

    contMeta = {
        HDPosterUrl:"pkg:/images/BigBuckBunny.jpg"
        SDPosterUrl:"pkg:/images/BigBuckBunny.jpg"
        ShortDescriptionLine1:"Parking Wars(VOD)"
        ShortDescriptionLine2:"dash | widevine"
        Streamformat:"dash"
        SwitchingStrategy:""
        MinBandwidth:500
        VideoUrl: "http://dev.domain.com/mm/dash/vod/173850/85768039/TG_W_WIFI.mpd"
        drmParams: { ' setting up DRM config
            keySystem: "Widevine"
            licenseServerURL: "http://msfrn-ci-cp-dev.mobitv.com/widevine/get_license"
        }
    }
    

Content classification attributes
---------------------------------

_Available since Roku OS 13.0_

Developers can use the **contentClassifier** content metadata attribute to specify the genre of their content (for example, action, sports, or comedy), and the Roku OS will use this attribute to automatically adjust the sound and picture on Roku TVs (if auto mode is selected for the picture or sound settings).

###### Content classifier value

| Attribute | Type | Values | Example |
| --- | --- | --- | --- |
| contentClassifer | string | *   " "<br>*   "action"<br>*   "animated"<br>*   "black+white" (black and white)<br>*   "comedy"<br>*   "drama"<br>*   "music"<br>*   "music:lyrics"<br>*   "nature"<br>*   "news"<br>*   "podcast" (audio only)<br>*   "reality"<br>*   "sports" | "drama" |

###### Content classifier sound and picture modes

The following table details how the different **contentClassifier** attribute values are mapped to sound and picture modes on Roku TVs.

| Content Classifier | Sound Mode | Picture Mode |
| --- | --- | --- |
| " " | Standard | Standard |
| action | Movie | Movie |
| sports | Standard | Sports |
| comedy | Movie | Movie |
| drama | Movie | Movie |
| music | Music | Standard |
| music:lyrics | Music | Low Power |
| news | Dialog | Vivid |
| podcast (Audio Only ) | Dialog | Low Power |
| animated | Movie | Vivid |
| black+white | Movie | Standard |
| nature | Standard | Vivid |
| reality | Standard | Standard |

Playback configuration attributes
---------------------------------

Playback configuration meta-data attributes are used to configure the playback of the content item.

AttributeTypeValuesExampleLiveBooleanOptional flag indicating video is live. Replaces time remaining in progress bar to display "Live". Default is falseTrueUrlStringStream URL for Scene Graph Video nodemysite.com/img/vacation.jpgSDBifUrlStringBIF URL for SD trick modemysite.com/bif/sd1932.bifHDBifUrlStringBIF URL for HD trick modemysite.com/bif/hd1932.bifFHDBifUrlStringBIF URL for FHD trick modemysite.com/bif/fhd1932.bifStreamroAssociativeArraySupported by roVideoPlayer and roVideoScreen, but not the Roku Scene Graph Video node.  
For the Video node, use the top level url, streamformat, etc. attributes.  
  
The exception is cases where you don't have adaptive streams (typically MP4) and need to specify different bitrate variants separately. For this use case use the Streams attribute. roAssociativeArray that has parameters representing the stream settings that were set as individual roArrays in previous firmware revisions.  
  
The old method is still supported and descriptions of the parameters can be found under those content-meta data entries.  
  
For url please see StreamUrls, for quality it is now a Boolean that is true for HD quality.  

| Key | Type |
| --- | --- |
| url | String |
| stickyredirects | Boolean |
| quality | Boolean |
| contentid | String |
| bitrate | Integer |

{ url : "[http://me.com/big.m3u8"](http://me.com/big.m3u8%22), quality : true, contentid : "big-hls" }StreamsroArray of roAssociativeArraysUsed by roVideoPlayer and roVideoScreen to specify the content metadata for a set of fixed bitrate streams.  
  
Each array item specifies the URL, bitrate, etc. for one stream variant.  
  
Setting stream content metadata using the Streams value is recommended for non-adaptive video (such as MP4 progressive download) only.  
  
For adaptive streaming, use the Stream metadata value.  

| Key | Type |
| --- | --- |
| url | String |
| stickyredirects | Boolean |
| quality | Boolean |
| contentid | String |
| bitrate | Integer |

\[ { url : "http://me.com/x-384.mp4", bitrate : 384, quality : false, contentid : "x-384" }, { url : "http://me.com/x2500.mp4", bitrate : 2500, quality : true, contentid : "x-1500" } \]StreamBitratesroArrayArray of bitrates in kbps for content streams used.  
  
Setting stream bitrates using this value is recommended for non-adaptive video (such as MP4 progressive download) only.  
  
**Must be used in conjunction with StreamUrls and StreamQualities**\[ 384, 500, 1000, 1500 \]StreamUrlsroArrayArray of URLs for content streams.  
  
Setting stream urls using this value is recommended for non-adaptive video (such as MP4 progressive download) only.  
  
**Must be used in conjunction with StreamBitrates and StreamQualities**\[ "mysite.com/vid/1932-1.mp4", "mysite.com/vid/1932-2.mp4", "mysite.com/vid/1932-3.mp4", "mysite.com/vid/1932-4.mp4" \]StreamQualitiesroArrayArray of Strings quality indicators identifying a stream as "SD" or "HD".  
  
**Must be used in conjunction with StreamBitrates and StreamUrls**\[ "SD", "SD", "SD", "HD" \]StreamContentIDsroArrayarray of strings values logged in Roku logs to identify stream and bitrate played\[ "myco-19321-384.mp4", "myco-19321-500.mp4", "myco-19321-1000.mp4", "myco-19321-1500.mp4" \]StreamStickyHttpRedirectsroArrayArray of Boolean values indicating if the HTTP endpoint should be sticky and not subject to change on subsequent requests. Default is false\[ false, false, false, false \]StreamStartTimeOffsetIntegerOptional. Default is 0. The offset into the stream which is considered the beginning of playback. Time in seconds.3600 (one hour)StreamFormatStringType of content

*   Type of content:
    
    *   Default: H.264/AAC in .mp4 Container
*   Valid values:
    
    *   "mp4" (mp4 will also accept .mov and .m4v files)
    *   "wma" (deprecated)
    *   "mp3"
    *   "hls" -"ism" (smooth streaming)
    *   "dash" (MPEG-DASH)
    *   "mkv", "mka", "mks"
*   Deprecated:
    
    *   "wmv"

LengthFloatMovie Length in Seconds; Length zero displays at 0m, Length not set will not display3600 (one hour)PlayStartFloatPlayStart defines the start position of the content, in seconds.  
  
The player is not allowed to move to a position prior to this point. Any seek operation prior to this point will be clipped to PlayStart.  
  
Apps can use PlayStart and PlayDuration to split one content piece into multiple clips and insert these clips with other content (typically advertisements) into one content list.  
  
Starting from Roku OS 8.0, content metadata supports negative PlayStart values. This feature allows the media players to start playbacks distanced from the edge of the live stream0ClosedCaptionsBooleanBoolean indicating if CC icon should be displayedTrueHDBrandedBooleanBoolean indicating if HD branding should be displayedTrueIsHDBooleanBoolean indicating if content is HDTrueSubtitleColorStringTheme metadata attribute that specifies the color to use when rendering subtitle text"#FF0000"SubtitleConfigroAssociativeArray: {TrackName : String}Specifies the caption settings for content playback.  
  
TrackName sets the name of the caption track to render. This string is a concatenation of the track source and track id, separated by a "/".  
  
Valid track sources are: "ism", "mkv", "eia608" and "dvb".  
  
The track id must match the track identifier in the smooth or mkvmanifest. For example, if an mkvfile has a caption track called “english1” the TrackName to select this track is “mkv/english1”.  
  
When the track source is "dvb", the track id is the three-letter language code, with "\_sdh" appended for subtitles for the deaf and hard of hearing. For example, "dvb/eng\_sdh" are English subtitles for the deaf and hard of hearing and "dvb/nor" are normal Norwegian subtitles.  
  
For sideloaded caption tracks, the TrackName is the url from where the caption track can be downloaded.Sideloaded caption formats can include srt,ttml, anddfxp. Specifying eia608/1 will trigger the Roku OS to search for embedded 608/708 captions in the stream. In the 8.0 Roku OS, automatic track selection based on a preferred caption language setting is introduced. Omit setting a URL here to avoid interfering with the automatic track selection. It is sufficient to add the URLs to SubtitleTracks{ TrackName : "mkv/english1" }SubtitleTracksroArray of roAssociativeArray: \[{Language : String, Description : String, TrackName : String},...\]SubtitleTracks sets the list of available caption tracks available to the stream. This list is added to the track list in the closed caption configuration dialog that is displayed during video playback when the user presses the Roku remote control \* button. The captions from the selected track are then displayed on the screen. Language specifies the ISO 639.2B 3 character language code. This string is used to match the proper caption track with the audio language. Description specifies the text that will be shown for the corresponding track in the closed caption configuration dialog. For sideloaded caption tracks the TrackName is the URL from where the caption track can be downloaded. Sideloaded caption formats can include srt, ttml, and dfxp. The SubtitleTracks metadata is generally only used for side loaded captions. the Roku OS detects in-stream captions and thus specifying SubtitleTracks in this case is not necessarySubtitleUrlStringSpecifies the path to an SRT or TTML formatted file used to render subtitles or closed captions, respectively. This is supported on roVideoScreen only. See [Closed Caption Support](/docs/developer-program/media-playback/closed-caption.md) for additional details"mysite.com/vid/1932.srt"; "mysite.com/vid/1932.xml"VideoDisableUIBooleanIf set to true, hides the Scene Graph Video node trick play UI; If set to false (the default) shows the Scene Graph Video node trick play UIvideo = createObject("roSGNode", "Video"); video.content.VideoDisableUI = trueEncodingTypeStringSpecifies the encoding scheme for PlayReady DRM, by setting to one of the following values:

*   "PlayReadyLicenseAcquisitionUrl"
*   "PlayReadyLicenseAcquisitionAndChallenge" Note, this is the same value that used to be specified directly in Content Metadata structure

EncodingKeyStringSpecifies the PlayReady license acquisition URL, and additional custom request data, determined by the EncodingType attribute value specified:

*   when encodingType="PlayReadyLicenseAcquisitionUrl", the EncodingKey attribute contains the PlayReady license acquisition URL

SwitchingStrategyStringroVideoPlayer or roVideoScreen.  
  
Specify different stream switching algorithms to be used in HLS adaptive streaming.  
Only has an effect on HLS streams. "full-adaptation" uses measured bandwidth and buffer fullness to determine when to switch. This strategy requires that segments align across variants as the HLS spec requires. This is the new default"full-adaptation"WatchedBooleanFlag indicating if content has been watchedTrueForwardQueryStringParamsBooleanControls whether query string parameters from initial HLS stream manifest requests are forward to subsequent segment download requests. The default value is set to true for backwards compatibility.TrueForwardDashQueryStringParamsBooleanControls whether query string parameters from initial DASH stream manifest requests are forward to subsequent segment download requests. The default value is set to false for backwards compatibility.FalseIgnoreStreamErrorsBooleanWhen set to true the media player will not stop playback when it runs into a streaming related error for this content. Instead, it will skip to the next item in the content list.  
  
If this was the last item in the content list the media player will send a regular completion event (like isFullResult). Apps are still notified of any errors via an isRequestFailed notification but a new attribute in the event’s GetInfo object tells the app the error was ignored.  
  
See the changes related to isRequestFailed for more information. The default value is false.

    video_details = {
        streamFormat: "mp4"
        ignoreStreamErrors: true
        streams: [{bitrate: 537, height: 360, width: 640, url: “https://..."}]
    }

AdaptiveMinStartBitrateIntegerMinimum startup bitrate specified in kbps. Streaming will start with a variant equal to or greater than this value. If this value is not set or if it's set to zero, any minimum start bitrate will be ignored.5000AdaptiveMaxStartBitrateIntegerMaximum startup bitrate specified in kbps. Streaming will start with a variant less than or equal to this value. If this value is not set, it will default to 2500 kbps.2000filterCodecProfilesBooleanFilters out any video profile/codec level combinations that the specified hardware cannot play. The default value is false, in which case no filtering occurs. **Note that this currently only works for DASH streams.**TrueLiveBoundsPauseBehaviorStringAllows an app to customize Media Player behavior on live streams when playing in the earliest part of a DVR buffer.  
  
The stream remains paused even though it is playing in the earliest part of the buffer of a live stream when the value of the attribute is set to "pause." This enables the Roku OS to distinguish between live streams and live streams that eventually transition to video on demand.  
  
The possible values of this attribute are "resume", "stop", "pause", with resume being the default value.  
  
**Currently, this attribute will work only with Smooth and Dash streams.** (Available since Roku OS 8.1)ResumeClipStartFloatClipStart sets the clip start position of the playback. The unit of ClipStart is seconds (Available since Roku OS 8.1).00.0ClipEndFloatClipEnd sets the clip end position. The unit of ClipEnd is seconds (Available since Roku OS 8.1).00.0PreferredAudioCodecStringSpecifies the audio codec that should be used during playback. The Media Player will select and report to the app only those audio renditions that are encoded with the specified codec. Renditions that are encoded with a different codec are ignored. Possible values of this attribute are "aac", "ac3" and "eac3"."aac"AudioWhitelistStringComma-separated list of audio tracks (based on ISO 639-1 or ISO 639-2 language code) that may be selected from the **Audio track** setting for the content.  
  
"en, spa"AudioBlacklistStringComma-separated list of audio tracks (based on ISO 639-1 or 639-2 language code) that may not be selected from the **Audio track** setting for the content.  
  
(Available since Roku OS 9.4)  
  
If a language is both blacklisted and whitelisted, the blacklisting takes precedence."ita, fr"CaptionWhitelistStringComma-separated list of captioning tracks (based on ISO 639-2 language code) that may be selected from the **Accessibility>Captioning track** setting for the content.  
  
"en, spa"CaptionBlacklistStringComma-separated list of captioning tracks (based on ISO 639-2 language code) that may not be selected from the **Accessibility>Captioning track** setting for the content.  
  
(Available since Roku OS 9.4)  
  
If a language is both blacklisted and whitelisted, the blacklisting takes precedence."deu, dan"

CDN switching
-------------

Content Delivery Networks (CDNs) can be switched during playback to load balance traffic and failover to different servers in order to help optimize performance. The **CdnConfig** attribute can be used for managing load balancing and failovers.

AttributeTypeValuesDescriptioncdnConfigroArray of roAssociativeArrays

| Key | Required/ Optional | Type | Description |
| --- | --- | --- | --- |
| URLFilter | Required | String | A substring that identifies the (base)URL to which these CDN settings apply.  <br>  <br>The Roku media player matches this string against all (base)URLs listed in the manifest and applies the setting to all (base)URLs that contain this substring. |
| ContentFilter | Optional | String | For DASH streams, a substring that filters the period or asset ID to which these CDN settings apply.  <br>  <br>The Roku player only applies these CDN setting to periods with a period ID or asset ID that contains this substring.  <br>  <br>This match is used in addition to the URL filter. |
| Priority | Required | Integer | For configuring failovers, sets the priority for this (base)URL from 1 to x (a priority of 0 or less is invalid).  <br>  <br>A lower value indicates a higher priority. For example, a (base)URL with a priority of 1 is higher than another with a priority of 10.  <br>  <br>If the highest priority server fails, traffic is routed to the server with the next highest priority. If all servers are configured with the same priority, and one fails, no failover will happen. |
| Weight | Required | Integer | For configuring load balancing, sets the relative weight for all (base)URLs with the same priority. This must be a value of 1 or greater (a weight of 0 disables a CDN).  <br>  <br>The weight of a given BaseURL is its weight value divided by the sum of all weight values. This means that to spread the load equally across multiple CDNs with the same priority, set the weight for each to the same value. To configure the weights for two servers to 80% and a third server to 20%, for example, set servers one and two to 8 and server three to 4. |
| ServiceLocation | Optional | String | A blacklist of failed BaseURL locations. |

To use this field, create a child node and use a playlist (even though only one content item will be in the playlist). This field is updated only when **contentIsPlayList** is true.  
  
The **URLFilter**, **Priority**, and **Weight** attributes must be specified to apply these configurations.

**Example**

    this.cur_clip.CDNConfig = [
        {URLFilter:"http://cdn1.xyz.com/abc/", ContentFilter, “testProgram”, priority: 1, weight: 50, serviceLocation: "west"},
        {URLFilter:"http://cdn2.xyz.com/abc/", ContentFilter, “testProgram”, priority: 1, weight: 50, serviceLocation: "east"},
        {URLFilter:"http://cdn1.xyz.com/abc/", ContentFilter, “testProgram”, priority: 2, weight: 50, serviceLocation: "west"},
        {URLFilter:"http://cdn2.xyz.com/abc/", ContentFilter, “testProgram”, priority: 2, weight: 50, serviceLocation: "east"},
    ]
    

SceneGraph certificate attributes
---------------------------------

The SceneGraph certificate meta-data attributes are used to configure the use of HTTP certificates and cookies by the Audio and Video nodes. Please note that when setting any of the following four attributes on a Video or Audio node, you need to be careful that the values are set on the correct HTTPAgent. If the node does not have its own HTTPAgent, set by explicitly calling setHttpAgent() on the node, the Roku OS will traverse up the scene graph hierarchy until it finds the first node in the Video or Audio node's ancestry that has set an HTTPAgent. If none is found, the values will be set on the global HTTPAgent which is always guaranteed to exist. Therefore if you expect the header, etc. values set to only apply to your Audio and Video nodes, create a unique instance of roHttpAgent for them and assign it directly. For example, for a Video node you should do the following:

    'Assume video is a valid Video node instance
    
    httpAgent = CreateObject("roHttpAgent")
    video.setHttpAgent(httpAgent)
    

| Attribute | Type | Values |
| --- | --- | --- |
| HttpCertificatesFile | uri | If set, the Scene Graph Audio or Video node loads this public certificate bundle, to authenticate the server. The protocol must be https for this to have any effect. When used with a Scene Graph Audio or Video node, the node or global HttpAgent is found, as explained elsewhere in this documentation. When playing this content, the agent is updated in the following manner:<br><br>*   If this attribute is defined, the file URI is set into the HttpAgent instance. However, if this attribute is specified and the value is the empty string (""), then no changes will be made to the HttpAgent.<br>*   If this attribute is not defined, the behavior depends upon whether the Content Meta-Data (CMD) contains secure (https) URLs:<br>    <br>    *   If no secure URLs exist in the meta-data, then no certificates file path is set into the agent.<br>    *   If a secure URL does exist, the platform's default certificates are set into the agent. |
| HttpCookies | array of strings | If set, the Scene Graph Audio or Video node send the cookies to the server. Each cookie must have the following syntax: dom=domain;path=path;name=name;val=value; When used with a Scene Graph Audio or Video node, the node or global HttpAgent is found, as explained elsewhere in this documentation. When this Content Meta-Data is played and this attribute is set, all HTTP cookies in the agent are cleared and replaced with the cookies defined by this attribute |
| HttpHeaders | array of strings | If set, the Scene Graph Audio or Video node sends these headers to the server. Each string must be of the format "name:value". When used with a Scene Graph Audio or Video node, the node or global HttpAgent is found, as explained elsewhere in this documentation. When this Content Meta-Data is played and this attribute is set, all HTTP headers in the agent are cleared and replaced with the headers defined by this attribute |
| HttpSendClientCertificate | Boolean | If true, the Scene Graph Audio or Video node sends the client device certificate to the server, for client authentication. The protocol must be https for this to have any effect. When used with a Scene Graph Audio or Video node, the node or global HttpAgent is found, as explained elsewhere in this documentation. When this Content Meta-Data is played and this attribute exists, the value of this attribute (true or false) is set into the HttpAgent |

### drmHttpAgent for handling DRM key/license requests separately

Since Roku OS 9.3, you can create a separate agent to handle DRM key and license requests, apart from other types of requests.

Once you have created your agent, you can set the Video node's `drmHttpAgent` field directly to designate that the special agent is to supersede any currently-set agent in the case of DRM key and license requests. The `drmHttpAgent` field must be configured before setting the content in the Video node.

    ' Configure the DRM HttpAgent before setting content in the Video node
     httpAgent = CreateObject("roHttpAgent")
     httpAgent.AddHeader("DRM-Specific-1", "weqweqweqweqweqweqeqeqeqeqwe")
     httpAgent.AddHeader("DRM-Specific-2", "fgfgfgfgfgfgfgfgfg")
     httpAgent.AddHeader("DRM-Specific-3", "zxzxzxzxxzxzxzxzxzx")
     m.video.drmHttpAgent = httpAgent    
     m.video.content = videocontent
    

If `drmHttpAgent` is not set (the default), uri fetches for video involving the DRM URLs (`serializationURL`, `licenseServerURL`, `licenseRenewURL`) of ContentMetaData will use the video's regular HttpAgent. However, if the `drmHttpAgent` is set, the agent cited in the field will be used for those fetches instead.

> The "SceneGraph Certificate Attributes" mentioned above all have "Drm" versions, with names formed by the prefixing "Drm" to the "regular" names (e.g., `HttpCookies` becomes `DrmHttpCookies`, and so forth). These attributes take precedence over those of the drmHttpAgent.

Playback control attributes
---------------------------

The playback control meta-data attributes are used to control the playback parameters for the content item.

| Attribute | Type | Values | Example |
| --- | --- | --- | --- |
| MinBandwidth | Integer | roVideoPlayer or roVideoScreen: Will only select variant streams with a bandwidth higher than this minimum bandwidth. Units are kbps. By default Wowza servers set streams to 64 kbs, so you might want to set this parameter to something smaller than 64 when first testing Wowza streams. You will eventually want to specify the Wowza bitrates with a smil file (Please see the encoding guide) | 48  |
| MaxBandwidth | Integer | roVideoPlayer or roVideoScreen: Will only select variant streams with a bandwidth less than this maximum bandwidth. Units are kbps | 2500 |
| AudioPIDPref | Integer | **This attribute is deprecated**  <br>  <br>Users can select their preferred audio language on-device in the **Settings > Audio > Audio Preferred Language** screen. | 483 |
| FullHD | Boolean | roVideoPlayer or roVideoScreen: Specify that this stream was encoded at 1080p resolution | true |
| FrameRate | Integer | roVideoPlayer or roVideoScreen: Specify the 1080p stream was encoded at 24 or 30 fps | 24  |

Track ID attributes
-------------------

| Attribute | Type | Values | Example |
| --- | --- | --- | --- |
| TrackIDAudio | String | roVideoPlayer or roVideoScreen: Used in SmoothStreaming (StreamFormat = "ISM") to specify. Set the TrackIDAudio field to the desired track's StreamIndex.Name attribute from the manifest file | "Spanish" |
| TrackIDVideo | String | roVideoPlayer or roVideoScreen: Used in SmoothStreaming (StreamFormat = "ISM") to specify. Set the TrackIDVideo field to the desired track's StreamIndex.Name attribute from the manifest file | "h264video" |
| TrackIDSubtitle | String | roVideoPlayer: Used to specify a closed caption track in a video stream that supports 608/708 captions | "eia608/1" |
| AudioFormat | String | roSpringboardScreen: If set to "dolby-digital", will display a "5.1 ))" icon in the lower left of a movie style springboard screen | "dolby-digital" |
| AudioLanguageSelected | String | **This attribute was deprecated as of the Roku 9.2 OS release.**  <br>  <br>Users can select their preferred audio language on-device in the **Settings > Audio > Audio Preferred Language** screen. | "eng" |

roListScreen attributes
-----------------------

| Attribute | Type | Values | Example |
| --- | --- | --- | --- |
| SDBackgroundImageUrl | String | roListScreen: URL for the SD background image | mysite.com/images/bg1\_sd.jpg |
| HDBackgroundImageUrl | String | roListScreen: URL for the HD background image | mysite.com/images/bg1\_hd.jpg |

Rating attribute icons
----------------------

The Rating attribute contains the MPAA or TV rating stored as a string. At runtime, the ratings are shown with an icon instead of rendering the string as text. The following table shows the list of valid values for the Rating attribute, and the resulting icon that will be displayed for each value.

| Value | Icon |
| --- | --- |
| G   | ![roku815px - G rating](https://image.roku.com/ZHZscHItMTc2/g.png "g-rated") |
| NC-17 | ![roku815px - NC17 rating](https://image.roku.com/ZHZscHItMTc2/contentmetadata2.png "nc17-rated") |
| PG  | ![roku815px - PG rating](https://image.roku.com/ZHZscHItMTc2/contentmetadata3.png "pg-rated") |
| PG-13 | ![roku815px - PG-13 rating](https://image.roku.com/ZHZscHItMTc2/contentmetadata4.png "pg13-rated") |
| R   | ![roku815px - R rating](https://image.roku.com/ZHZscHItMTc2/contentmetadata5.png "r-rated") |
| UR  | ![roku815px - UR](https://image.roku.com/ZHZscHItMTc2/ur.png "ur-rated") |
| UNRATED | ![roku815px - Unrated rating](https://image.roku.com/ZHZscHItMTc2/ur.png "ur-rated") |
| NR  | ![roku815px - Not rated](https://image.roku.com/ZHZscHItMTc2/contentmetadata7.png "nr-rated") |
| TV-Y | ![roku815px - TV-Y rating](https://image.roku.com/ZHZscHItMTc2/contentmetadata8.png "tv-y-rated") |
| TV-Y7 | ![roku815px - TV-Y7 rating](https://image.roku.com/ZHZscHItMTc2/tvy7.png "tv-y7-rated") |
| TV-Y7-FV | ![roku815px - TV-Y7-FV rating](https://image.roku.com/ZHZscHItMTc2/contentmetadata10.png "tv-y7-fv-rated") |
| TV-G | ![roku815px - TV-G rating](https://image.roku.com/ZHZscHItMTc2/tvg.png "tv-g-rated") |
| TV-PG | ![roku815px - TV-PG rating](https://image.roku.com/ZHZscHItMTc2/contentmetadata12.png "tv-pg-rated") |
| TV-14 | ![roku815px - TV-14 rating](https://image.roku.com/ZHZscHItMTc2/contentmetadata13.png "tv-14-rated") |
| TV-MA | ![roku815px - TV-MA rating](https://image.roku.com/ZHZscHItMTc2/contentmetadata14.png "tv-ma-rated") |

Content feed video lesson
-------------------------

You can learn how to link the content metadata in your app's feed to a ContentNode by watching the [Creating the content feed](/videos/courses/rsg/content-feed.md) video lesson in Roku's [SceneGraph: Build a Channel online video course](https://developer.roku.com/videos/courses/rsg/overview.md).

Roku Pay web services reference
===============================

The Roku Pay APIs are RESTful web services that use standard HTTP methods for transferring billing transaction data between the Roku platform and the publisher's backend system. The Roku Pay APIs enable publishers to validate entitlements to products; refund and cancel subscriptions; issue service credits; and update customer billing cycles.

Getting started
---------------

The following table summarizes the basic information for the Roku Pay web services:

| Item | Description |
| --- | --- |
| URL | The base URL for the Roku Pay APIs is **[https://apipub.roku.com/listen/transaction-service.svc](https://apipub.roku.com/listen/transaction-service.svc)**. The resource name for the API is then appended to the URL.  <br>  <br>For example, the URL for the `validate-transaction` API is **[https://apipub.roku.com/listen/transaction-service.svc/validate-transaction](https://apipub.roku.com/listen/transaction-service.svc/validate-transaction)**. |
| Protocol | Roku Pay API calls may be sent using either HTTP or HTTPS. |
| Format | Roku Pay APIs support both JSON and XML-formatted data. Format the `accept` header as follows:<br><br>*   **JSON**: accept: application/json<br>*   **XML**: accept: application/xml |
| HTTP Methods | Roku Pay APIs support GET and POST methods for retrieving and managing transaction data:<br><br>*   **GET**: All GET requests must include the Roku Pay API key and the ID of the item being validated in the URL (transaction or refund ID).<br>*   **POST**: All POST requests require JSON or XML-formatted data in the body. The Roku Pay API key must be included in the body. |
| API Key | All Roku Pay API requests must include the developer's API key. See [Setting up Roku Pay web services](/docs/developer-program/roku-pay/quickstart/setting-up-web-services.md) for more information about getting and managing the key. For all requests, the app associated with the transaction ID or refund ID passed into the call must be owned by the developer associated with the Roku Pay API Key. |

APIs
----

The Roku Pay platform provides the following APIs for managing billing transaction data:

| Method | API | Description |
| --- | --- | --- |
| GET | [validate-transaction](#validate-transaction) | Check whether a customer is entitled to an in-app product such as a Roku Pay subscription or one-time purchase (for example, movie rental, sporting event, pay-per-view) |
| GET | [validate-refund](#validate-refund) | Check whether a refund has been issued. |
| POST | [cancel-subscription](#cancel-subscription) | Cancel a Roku Pay subscription. |
| POST | [refund-subscription](#refund-subscription) | Refund a Roku Pay subscription. |
| POST | [update-bill-cycle](#update-billing-cycle) | Change the billing cycle data for a Roku Pay subscription (for example, to provide a customer a free week of service due to a service outage, you can delay their next billing date by one week). |
| POST | [issue-service-credit](#issue-service-credit) | Give a service credit to a Roku account. (More on service credits below.) |

### Validate transaction

The `validate-transaction` API is used to validate purchases made with SceneGraph ChannelStore component. It returns an `isEntitled` flag that indicates whether a customer is entitled to an in-app product. If `isEntitled` is "true", grant the customer access to content; if it is "false", prompt them to subscribe to your app.

> As of Roku OS 10.0, the `validate-transaction` API includes **purchaseChannel** and **purchaseContext** fields that identify whether a Roku Pay subscription purchase originated from Instant Signup. For purchases made via Instant Signup, the **purchaseChannel** field is set to "web" and **purchaseContext** field is set to "isu". For on-device purchases, these fields are set to "device" and "iap", respectively.

#### Request example:

    GET https://apipub.roku.com/listen/transaction-service.svc/validate-transaction/{partnerAPIKey}/{transactionid}
    

#### Response example:

**XML**:

    <result xmlns="http://api.roku.com/transaction" xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
        <errorCode i:nil="true" xmlns=""/>
        <errorDetails i:nil="true" xmlns=""/>
        <errorMessage xmlns=""/>
        <status xmlns="">Success</status>
        <OriginalTransactionId>6ccb40bf-bd7a-49dc-9846-aafd01890ba5</OriginalTransactionId>
        <amount>1.99</amount>
        <cancelled>false</cancelled>
        <channelId>251682</channelId>
        <channelName>Pizzazzy Channel</channelName>
        <couponCode i:nil="true"/>
        <creditsApplied i:nil="true"/>
        <currency>usd</currency>
        <expirationDate>2020-02-06T23:51:02</expirationDate>
        <isEntitled>true</isEntitled>
        <originalPurchaseDate>2019-11-06T23:51:02</originalPurchaseDate>
        <partnerReferenceId i:nil="true"/>
        <productId>CAkJPWMldSfISZbs2sE3_MonthlySub</productId>
        <purchaseChannel>web</purchaseChannel>
        <purchaseContext>isu</purchaseContext>
        <productName>Pizzazzy</productName>
        <purchaseDate>2019-11-06T23:53:14</purchaseDate>
        <purchaseStatus>Active</purchaseStatus>
        <quantity>1</quantity>
        <rokuCustomerId>1f529e15cb15426be4ddb23a4933be2d</rokuCustomerId>
        <tax>0.0000</tax>
        <total>0.1300</total>
        <transactionId>09898ffd-7d2a-49bc-94b1-aafd0189a6fa</transactionId>
    </result>
    

**JSON**:

    {
        "errorCode": null,
        "errorDetails": null,
        "errorMessage": "",
        "status": 0,
        "OriginalTransactionId": "6ccb40bf-bd7a-49dc-9846-aafd01890ba5",
        "amount": 1.99,
        "cancelled": false,
        "channelId": 251682,
        "channelName": "Pizzazzy Channel",
        "couponCode": null,
        "creditsApplied": null,
        "currency": "usd",
        "expirationDate": "/Date(1581033062000+0000)/",
        "isEntitled": true,
        "originalPurchaseDate": "/Date(1573084262000+0000)/",
        "partnerReferenceId": null,
        "purchaseChannel": "web",
        "purchaseContext": "isu",
        "productId": "CAkJPWMldSfISZbs2sE3_MonthlySub",
        "productName": "Pizzazzy",
        "purchaseDate": "/Date(1573084394000+0000)/",
        "purchaseStatus": "Active",
        "quantity": 1,
        "rokuCustomerId": "1f529e15cb15426be4ddb23a4933be2d",
        "tax": 0,
        "total": 0.13,
        "transactionId": "09898ffd-7d2a-49bc-94b1-aafd0189a6fa"
    }
    

#### Managing subscription recovery

The `isEntitled` flag returned by the `validate-transaction` API is also critical for managing subscription recovery in the Roku platform. Subscription recovery is the process of handling expired Roku Pay subscriptions due to failed payments or declined credit cards. When a subscription is in recovery, Roku Pay notifies the customer once a day for multiple consecutive days (typically three) to update their method of payment in order to renew the subscription, and it attempts to charge the customer's method of payment to ensure collection of payment and continuation of service.

While Roku Pay attempts to collect payment, the publisher's entitlement service should sync with the `validate-transaction` API nightly to manage subscriptions in recovery. The API calls for this nightly sync should be spread out over an approximately 6-hour period.

A subscription is considered to be in recovery when its `expirationDate` is set to the current date or a past date but `isEntitled` is set to true. This ensures that subscriptions without entitlements are cancelled promptly, but subscriptions that are successfully renewed are still accessible on the app and across all platforms.

To execute the nightly recovery sync with the `validate-transaction` API, follow these steps:

1.  Iterate over all subscriptions that expired that day or payment is attempting to be recovered (the `expirationDate` parameter is the current date or a past date).

2.  For each subscription in recovery, call the `validate-transaction` API with the `transactionId` of the subscription.

3.  Read the `isEntitled` flag and the `expirationDate` parameter.
    
    a. If the `isEntitled` flag is "true" and the `expirationDate` has been updated to a future date, the method of payment has been updated and the subscription has been renewed. Update the entitlement service with the new `expirationDate` for the subscription, and put the account into a "subscribed" state.
    
    b. If the `isEntitled` flag is "true" but the `expirationDate` has not changed, the subscription is still in recovery and Roku is continuing payment collection.
    
    c. If the `isEntitled` flag is "false", Roku has completed the payment retry cycle and canceled the subscription. Call the `cancel subscription` API and put the account in an "unsubscribed" state in your entitlement service so it can stop calling the `validate transaction` API for that subscription.
    
    **Free trials:** When a free trial ends and the customer's method of payment fails, the `is_entitled` flag is "false". For apps using [Enhanced Subscription Recovery](/docs/developer-program/roku-pay/subscription-recovery/subscription-on-hold.md), the subscription will automatically be placed on hold; for apps using [Basic Recovery](/docs/developer-program/roku-pay/subscription-recovery/basic-recovery.md), the subscription is automatically cancelled (there is no grace period in this case).
    

The following table summarizes the action to be taken after checking the `expirationDate`:

| **expirationDate** | **isEntitled** | **Subscription state** | **Action to be taken by the app** |
| --- | --- | --- | --- |
| Future date | true | active | Entitle user |
| Current or past date | true | recovery | Entitle user and check again next day |
| Past date | false | canceled | Cancel subscription |

#### Managing upgrades/downgrades

Roku Pay supports on-device upgrades and downgrades between subscription products. Once an upgrade/downgrade has been completed, apps should call the `validate-transaction` API with the transaction ID from the `purchaseid` field of the [**doOrder** command](/docs/references/scenegraph/control-nodes/channelstore.md#doorder) to update their system. For subscription upgrades and downgrades, the `validate-transaction` API response includes the following fields to identify the transaction:

*   `purchase_type:` Indicates whether the transaction is an `UPGRADE` or `DOWNGRADE`.
    
*   `cancelled_transaction_ids`: The transaction ID of the original subscription purchase that was upgraded/downgraded.
    
*   `purchase_status`: Indicates the current state of the subscription. The following table outlines how this field relates to the `isEntitled` and `cancelled` fields:
    
    | purchase\_ status | isEntitled | cancelled | Description |
    | --- | --- | --- | --- |
    | Active | true | false |     |
    | Inactive | false | true |     |
    | Pending\_Active | false | false | The "downgrade" subscription will be activated sometime in the future (the expiration date of the original plan); therefore, the downgrade is set to `Pending_Active`. The status will be set to `valid` at the time of activation. |
    | Pending\_Inactive | true | true | When a free trial is offered with the upgrade subscription, the original subscription becomes `Pending_Inactive`. Should the user cancel the upgrade, the original subscription will be reinstated (but _will not renew_ after the entitlement period). Upon the first successful renewal of the upgraded subscription, the original subscription will be set to `Inactive`. |
    

**Upgrade Response Example (JSON)**:

      {
         "errorCode":null,
         "errorDetails":null,
         "errorMessage":"",
         "status":0,
         "OriginalTransactionId":"a800b907-55be-491d-821a-abad017d6674",
         "amount":4.99,
         "cancelled":false,
         "cancelledTransactionIds":[
            "b0f7e477-e89e-48d0-aa13-abad017d4ee9"
         ],
         "channelId":000000,
         "channelName":"ESPRIMU",
         "couponCode":null,
         "currency":"usd",
         "expirationDate":"\/Date(1588892919000+0000)\/",
         "isEntitled":true,
         "originalPurchaseDate":"\/Date(1588288117000+0000)\/",
         "partnerReferenceId":"1969",
         "productId":"Y6ZFym7Xl2agLakTcxMB_MonthlySubFreeTrial",
         "productName":"Y6ZFym7Xl2agLakTcxMB_MonthlySubFreeTrial",
         "purchaseDate":"\/Date(1588288117000+0000)\/",
         "purchaseStatus":"Active",
         "purchaseType":"UPGRADE",
         "quantity":1,
         "rokuCustomerId":"99999999999999999999999999999999",
         "tax":0.0000,
         "total":0.0000,
         "transactionId":"a800b907-55be-491d-821a-abad017d6674"
      }
    

**Downgrade Response Example (JSON)**

    {
         "errorCode":null,
         "errorDetails":null,
         "errorMessage":"",
         "status":0,
         "OriginalTransactionId":"e8515e53-8c2b-4e9e-9039-abac0165b4e1",
         "amount":2.99,
         "cancelled":false,
         "cancelledTransactionIds":[
            "03c3ac6f-5086-4601-b87a-abac0165abed"
         ],
         "channelId":000000,
         "channelName":"ESPRIMU",
         "couponCode":null,
         "currency":"usd",
         "expirationDate":"\/Date(1588801334000+0000)\/",
         "isEntitled":true,
         "originalPurchaseDate":"\/Date(1588196542000+0000)\/",
         "partnerReferenceId":"1969",
         "productId":"ZTtL0DvuGNX1sO4tJGNp_MonthlySubFreeTrial",
         "productName":"ZTtL0DvuGNX1sO4tJGNp_MonthlySubFreeTrial",
         "purchaseDate":"\/Date(1588196542000+0000)\/",
         "purchaseStatus":"PendingActive",
         "purchaseType":"DOWNGRADE",
         "quantity":1,
         "rokuCustomerId":"99999999999999999999999999999999",
         "tax":0.0000,
         "total":0.0000,
         "transactionId":"e8515e53-8c2b-4e9e-9039-abac0165b4e1"
      }
    

### Validate refund

The `validate-refund` API is used to verify that a Roku Pay purchase has been refunded.

**Request syntax:**

    GET https://apipub.roku.com/listen/transaction-service.svc/validate-refund/{partnerAPIKey}/{refundId}
    

**Response example:**

**XML**

    <result xmlns="http://api.roku.com/transaction" xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
        <errorCode i:nil="true" xmlns=""/>
        <errorDetails i:nil="true" xmlns=""/>
        <errorMessage xmlns=""/>
        <status xmlns="">Success</status>
        <OriginalTransactionId>6ccb40bf-bd7a-49dc-9846-aafd01890ba5</OriginalTransactionId>
        <amount>1.99</amount>
        <cancelled>false</cancelled>
        <channelId>251682</channelId>
        <channelName>Pizzazzy Channel</channelName>
        <couponCode i:nil="true"/>
        <creditsApplied i:nil="true"/>
        <currency>usd</currency>
        <expirationDate>2020-02-06T23:51:02</expirationDate>
        <isEntitled>true</isEntitled>
        <originalPurchaseDate>2019-11-06T23:51:02</originalPurchaseDate>
        <partnerReferenceId i:nil="true"/>
        <productId>CAkJPWMldSfISZbs2sE3_MonthlySub</productId>
        <productName>Pizzazzy</productName>
        <purchaseDate>2019-11-06T23:53:14</purchaseDate>
        <quantity>1</quantity>
        <rokuCustomerId>1f529e15cb15426be4ddb23a4933be2d</rokuCustomerId>
        <tax>0.0000</tax>
        <total>0.1300</total>
        <transactionId>09898ffd-7d2a-49bc-94b1-aafd0189a6fa</transactionId>
    </result>
    

**JSON**

    {
        "errorCode": null,
        "errorDetails": null,
        "errorMessage": "",
        "status": 0,
        "OriginalTransactionId": null,
        "amount": -1.99,
        "cancelled": false,
        "channelId": 0,
        "channelName": "Pizzazzy Channel",
        "couponCode": null,
        "creditsApplied": null,
        "currency": "usd",
        "expirationDate": null,
        "isEntitled": false,
        "originalPurchaseDate": "/Date(1578676645000+0000)/",
        "partnerReferenceId": null,
        "productId": "CAkJPWMldSfISZbs2sE3_MonthlySub",
        "productName": "Pizzazzy",
        "purchaseDate": "/Date(1578676712000+0000)/",
        "quantity": 1,
        "rokuCustomerId": "1f529e15cb15426be4ddb23a4933be2d",
        "tax": 0,
        "total": -1.99,
        "transactionId": "CBD09EA8-4C4D-4E1B-82BD-AB3E011D3E68"
    }
    

### Cancel subscription

The `cancel-subscription` API cancels the subscription corresponding to the specified `transactionId`.

**Request syntax:**

**Method/URL**

    POST https://apipub.roku.com/listen/transaction-service.svc/cancel-subscription
    

**XML body**

    <cancel>
       <cancellationDate>2020-01-10T18:34:51.380355</cancellationDate>
       <dontNotifyUser>false</dontNotifyUser>
       <partnerAPIKey>F05447A57F8DF275FC30EC835FCAD10A19B6</partnerAPIKey>
       <partnerReferenceId>3v2m4j4j9d</partnerReferenceId>
       <transactionId>c8f3e131-4dd9-4dc4-8915-ab3e013231ac</transactionId>
    </cancel>
    

**JSON body**

    {
       "cancellationDate": "2020-01-10T18:44:01.034020",
       "dontNotifyUser": false,
       "partnerAPIKey": "F05447A57F8DF275FC30EC835FCAD10A19B6",
       "partnerReferenceId": "7s9d8w0n6z",
       "transactionId": "57f45cad-113b-4fcd-8de8-ab3e0134b5cb"
    }
    

**Response example:**

**XML**

    <result xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
       <errorCode i:nil="true" />
       <errorDetails i:nil="true" />
       <errorMessage />
       <status>Success</status>
    </result>
    

**JSON**

    {
        "errorCode": null,
        "errorDetails": null,
        "errorMessage": "",
        "status": 0
    }
    

### Refund subscription

The `refund-subscription` API refunds the subscription corresponding to the specified `transactionId`.

The refund value must be:

*   specified (cannot be omitted)
*   greater than $0.00
*   less than (or equal to) the pre-tax price of the original transaction
*   tax-exclusive (must not include the tax portion of the refund).

Roku Pay automatically calculates and handles any tax that should be included in the refund.

For example, a publisher refunds 50% of a $10 subscription, for which the customer was charged $11 ($10 subscription and 10% tax \[$1.00\]). In this case, the refund amount should be $5.00 instead of $5.50. When issuing the refund, Roku adds the 10% tax ($0.50) to the $5.00 `amount` specified in the refund-subscription API call ($5.00) and refunds the customer $5.50.

The sum of all partial refunds applied against any given transaction cannot exceed the original transaction amount.

**Request syntax:**

**Method/URL**

    POST https://apipub.roku.com/listen/transaction-service.svc/refund-subscription
    

**XML body**

    <refund>
        <amount>0.99</amount>
        <comments>Customer was not impressed</comments>
        <partnerAPIKey>F05447A57F8DF275FC30EC835FCAD10A19B6</partnerAPIKey>
        <partnerReferenceId>4l2v9t0014</partnerReferenceId>
        <transactionId>35a66187-abfc-45b8-bd1e-ab3e01404134</transactionId>
    </refund>
    

**JSON body**

    {
        "amount": 0.99,
        "comments": "Customer was not impressed",
        "partnerAPIKey": "F05447A57F8DF275FC30EC835FCAD10A19B6",
        "partnerReferenceId": "4l2v9t0015",
        "transactionId": "56d72aaa-0741-4509-be69-ab3e01417803"
    }
    

**Response example:**

**XML**

    <RefundResponseData xmlns="http://schemas.datacontract.org/2004/07/ASConnect.MessageData.v2" xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
        <errorCode i:nil="true" xmlns=""/>
        <errorDetails i:nil="true" xmlns=""/>
        <errorMessage xmlns=""/>
        <status xmlns="">Success</status>
        <RefundId>f2116f00-181a-46d6-b5a3-ab3e01410986</RefundId>
    </RefundResponseData>
    

**JSON**

    {
        "errorCode": null,
        "errorDetails": null,
        "errorMessage": "",
        "status": 0,
        "RefundId": "304be6b0-ddd4-4f7b-adfc-ab3e01436cc6"
    }
    

### Update billing cycle

The `update-bill-cycle` API updates the billing cycle of the subscription corresponding to the specified `transactionId`.

Set the `newBillCycleDate` to the updated date on which the user should be billed (for example, the user can be billed on the 6th instead of the 4th). The updated date should be within the next billing period (the current expiration date plus the billing interval year or month).

**Request syntax:**

**Method/URL**

    POST https://apipub.roku.com/listen/transaction-service.svc/update-bill-cycle
    

**XML body**

    <billCycleUpdate>
        <partnerAPIKey>F05447A57F8DF275FC30EC835FCAD10A19B6</partnerAPIKey>
        <newBillCycleDate>2020-02-12T08:17:09</newBillCycleDate>
        <transactionId>de054ad8-5a45-4db3-8800-ab3e014687a6</transactionId>
    </billCycleUpdate>
    

**JSON body**

    {
        "transactionId": "fc51c9b9-ba32-4923-ae6d-ab3e01449eb5",
        "newBillCycleDate": "2020-02-12T08:17:09",
        "partnerAPIKey": "F05447A57F8DF275FC30EC835FCAD10A19B6"
    
    }
    

**Response example:**

**XML**:

    <result xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
        <errorCode i:nil="true"/>
        <errorDetails i:nil="true"/>
        <errorMessage/>
        <status>Success</status>
    </result>
    

**JSON**:

    {
        "errorCode": null,
        "errorDetails": null,
        "errorMessage": "",
        "status": 0
    }
    

### Issue service credit

The `issue-service-credit` API is used to issue a service credit to the specified Roku account. A service credit functions as the customer's method of payment until its balance reaches $0.00. Once this occurs, the method of payment on file is charged. For example, when a customer makes a purchase, the service credit is first subtracted from the product's price. Any remaining amount due is charged to the method of payment on file.

Service credits may be issued for:

*   An app. In this case, the `channelID` must be included in the request body.
*   An in-app product. In this case, the `channelID` and `productID` must be included in the request body.

The response will include a `partnerReferenceId` that can be used later to find the service credit in the Roku Pay system.

**Request example:**

    POST https://apipub.roku.com/listen/transaction-service.svc/issue-service-credit
    

**Request example:**

**XML**:

    <serviceCredit>
        <partnerAPIKey>F05447A57F8DF275FC30EC835FCAD10A19B6</partnerAPIKey>
        <amount>9.99</amount>
        <channelId>251682</channelId>
        <comments>Content Incorrect</comments>
        <partnerReferenceId>4l2v9t9104</partnerReferenceId>
        <productId>2365C2E9-D75B-D1B6-DFC0-837161653CC6</productId>
        <rokuCustomerId>1f529e15cb15426be4ddb23a4933be2d</rokuCustomerId>
    </serviceCredit>
    

**JSON**:

    {
      "partnerAPIKey":"F05447A57F8DF275FC30EC835FCAD10A19B6",
      "amount":5.00,
      "channelId":"251682",
      "comments":"Content Incorrect",
      "partnerReferenceId":"4l2v9t9101",
      "productId":"2365C2E9-D75B-D1B6-DFC0-837161653CC6",
      "rokuCustomerId":"1f529e15cb15426be4ddb23a4933be2d"
    }
    

**Response example:**

**XML**:

    <TransactionReferenceResponseData xmlns="http://schemas.datacontract.org/2004/07/ASConnect.MessageData.v2" xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
        <errorCode i:nil="true" xmlns=""/>
        <errorDetails i:nil="true" xmlns=""/>
        <errorMessage xmlns=""/>
        <status xmlns="">Success</status>
        <ReferenceId>47674</ReferenceId>
    </TransactionReferenceResponseData>
    

**JSON**:

    {
        "errorCode": null,
        "errorDetails": null,
        "errorMessage": "",
        "status": 0,
        "ReferenceId": "47674"
    }

roCompositor
============

The roCompositor allows the composition and animation of multiple roBitmaps and roRegions.

This object can create and manage roSprites in a z-ordered list. The sprites can be of arbitrary size and can be thought of as planes. The compositor can manage collision detection between the sprites, support scrolling the sprite bitmap source, and support animated sprites (multi-frame sprites with frame-flipping animation). You may have multiple roCompositor components, and they can composite onto the same or separate bitmaps. That said, the most common scenario is to have a single roCompositor.

**Example: Scrolling a bitmap**

    Library "v30/bslCore.brs"
    Function main()
            black=&hFF'RGBA
            screen=CreateObject("roScreen")
            compositor=CreateObject("roCompositor")
            compositor.SetDrawTo(screen, black)
            http = CreateObject("roUrlTransfer")
            http.SetMessagePort(CreateObject("roMessagePort"))
            http.SetUrl("http://rokudev.roku.com/rokudev/examples/scroll/VeryBigPng.png")
            http.AsyncGetToFile("tmp:/VeryBigPng.png")
            wait(0, http.GetPort())
            bigbm=CreateObject("roBitmap","tmp:/VeryBigPng.png")
            region=CreateObject("roRegion", bigbm, 0, 0, 1280, 720)
            region.SetWrap(True)
    
            view_sprite=compositor.NewSprite(0, 0, region)
            compositor.draw()
            screen.SwapBuffers()
            msgport = CreateObject("roMessagePort")
            screen.SetMessagePort(msgport)
            codes = bslUniversalControlEventCodes()
            While True
                    msg=wait(0, msgport) ' wait for a button
                    print "Msg: "; type(msg); " event: "; msg.GetInt()
                    If type(msg)="roUniversalControlEvent" Then
                            If msg.GetInt()=codes.BUTTON_UP_PRESSED Then
                                    Zip(screen, view_sprite, compositor, 0,-4) 'up
                            Else If msg.GetInt()=codes.BUTTON_DOWN_PRESSED Then
                                    Zip(screen, view_sprite, compositor, 0,+4) ' down
                            Else If msg.GetInt()=codes.BUTTON_RIGHT_PRESSED Then
                                    Zip(screen, view_sprite, compositor, +4,0) ' right
                            Else If msg.GetInt()=codes.BUTTON_LEFT_PRESSED Then
                                    Zip(screen, view_sprite, compositor, -4, 0) ' left
                            Else If msg.GetInt() = codes.BUTTON_BACK_PRESSED ' back button
                                    Exit While
                            End If
                    End If
            End While
    End Function
    Function Zip(screen, view_sprite, compositor, xd, yd)
            For x=1 To 60
                    view_sprite.OffsetRegion(xd, yd, 0, 0)
                    compositor.draw()
                    screen.SwapBuffers()
            End For
    End Function
    

Supported interfaces
--------------------

*   [ifCompositor](/docs/references/brightscript/interfaces/ifcompositor.md "ifCompositor")

OverhangPanelSetScene
=====================

Extends [**Scene**](/docs/references/scenegraph/scene.md)

The OverhangPanelSetScene node class provides a convenient way to create a Scene node that has set with default Overhang and PanelSet nodes. The layout of the Overhang and PanelSet use the default sizes for SDK2 apps. The node provides access to the PanelSet and Overhang via fields that contain the node objects.

    scene = screen.CreateScene("OverhangPanelSetScene")
    

Fields
------

| Field | Type | Default | Access Permission | Use |
| --- | --- | --- | --- | --- |
| overhang | Overhang | An Overhang node | READ\_ONLY | Provides access to the Overhang node created for this scene. Fields of the Overhang node can be set to custom the overhang. |
| panelSet | PanelSet | A PanelSet node | READ\_ONLY | Provides access to the PanelSet node created for this scene. The RoSGNode child APIs can be used to add panels to the panel set. Be careful to follow the restrictions on using the child APIs that are described in the PanelSet documentation.  <br>  <br>Fields of the PanelSet node can also be set to custom the panel set. |

Sample app
----------

[OverhangPanelSetSceneExample](https://github.com/rokudev/samples/tree/master/ux%20components/sliding%20panels/OverhangPanelSetSceneExample) is a sample app demonstrating OverhangPanelSetScene in action.

StdDlgGraphicItem
=================

Extends [StdDlgItemBase](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-item-base.md "**StdDlgItemBase**")

The **StdDlgGraphicItem** node is used to display an image in the dialog's content area with an optional text label displayed to the left, right, above, or below the image. It should only be used as a child of a [**StdDlgContentArea**](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-content-area.md) node.

![roku815px - std-dlg-graphic-item](https://image.roku.com/ZHZscHItMTc2/std-dlg-graphic-item.jpg)

Fields
------

FieldTypeDefaultAccess PermissionDescriptiontextstring""READ\_WRITESpecifies the text to be displayed next to the graphic. If the text width does not fit within the width of the content area, the text will wrap onto multiple lines.graphicUriuri""READ\_WRITEThe URI of the image to be displayed.graphicWidthfloat0READ\_WRITEThe image width to be used instead of the image's actual width.graphicHeightfloat0READ\_WRITEThe image height to be used instead of the image's actual height.graphicAlignstring"left"READ\_WRITESpecifies where to position and align the graphic and its text label, relative to the content area. This may be one of the following values:  

| Value | Text Position |
| --- | --- |
| left | The graphic is left-aligned in the content area.  <br>The text label is positioned horizontally to the right of the graphic, and centered vertically. |
| right | The graphic is right-aligned in the content area.  <br>The text label is positioned horizontally to the left of the graphic, and centered vertically. |
| center\_below | The graphic and text label are centered horizontally in the content area.  <br>The graphic is positioned below the text label. |
| center\_above | The graphic and text label are centered horizontally in the content area.  <br>The graphic is positioned above the text label. |

Direct to Play
==============

Apps participating in [Roku Search](/docs/developer-program/discovery/search/implementing-search.md) can further enhance their user experience and increase engagement by implementing Direct to Play. This feature allows customers to take advantage of the convenience and speed of voice commands to find and start watching content faster.

> Public apps must implement Direct to Play to pass [certification](/docs/developer-program/certification/certification.md#5-deep-linking).

Overview
--------

Direct to Play accelerates content delivery by supporting spoken commands to launch and play videos and audio. Customers can use their Roku voice remote, Roku Touch, or mobile app to tell their device to play a movie, TV show, song, or other content. Their Roku device will then directly launch the app where the customer is entitled to the requested content and begin playback.

For Direct to Play to directly launch content into playback on your app, the requested content must be in your app's catalog in Roku Search, your app must already be installed, your app must handle deep links to play the requested content, and your app must send the authentication status of customers to Roku.

If customers are entitled to the requested content on multiple apps, the app that is launched is based on the order specified in [Implementing Roku Search](/docs/developer-program/discovery/search/implementing-search.md). If the requested content is available on multiple apps of the same type (for example, the customer is entitled to content on two or more SVOD apps), the user selects on which app to watch the content.

Requirements
------------

To participate in Direct to Play, your app must support the following integrations:

1.  [Roku Search](/docs/developer-program/discovery/search/implementing-search.md). Enables customers to find content on your app.
    
2.  [Deep linking](/docs/developer-program/discovery/implementing-deep-linking.md). Enables the requested content to be launched directly into playback on your app.
    

> Deep linking requires that apps use [bookmarks](/docs/developer-program/media-playback/bookmarking.md) to identify the playback position of content. Therefore, apps participating in Direct to Play may not use resume/start over screens when handling voice commands to play content. When a customer tells their device to play content they have already started watching, playback must automatically resume at the stored playback position.

3.  [roInput](/docs/developer-program/discovery/implementing-deep-linking.md#implementing-deep-linking). Prevents your app from re-launching when it is handling deep link requests and is already running.
    
4.  [Authentication status events](/docs/developer-program/discovery/search/prioritizing-authenticated-channels-in-roku-search.md) (for SVOD and TVE apps). Communicates the authentication status of customers to prioritize your authenticated app above non-authenticated ones in Roku Search.
    

Video demo
----------

For a video demonstration of Direct to Play, see the [Voice overview guide](/docs/features/voice/overview.md).

ifEnum
======

Implemented by
--------------

| Name | Description |
| --- | --- |
| [roArray](/docs/references/brightscript/components/roarray.md "roArray") | An array stores an indexed collection of BrightScript objects |
| [roAssociativeArray](/docs/references/brightscript/components/roassociativearray.md "roAssociativeArray") | An associative array (also known as a map, dictionary or hash table) allows objects to be associated with string keys |
| [roByteArray](/docs/references/brightscript/components/robytearray.md "roByteArray") | The byte array component is used to contain and manipulate an arbitrary array of bytes |
| [roList](/docs/references/brightscript/components/rolist.md "roList") | The list object implements the interfaces: ifList, ifArray, ifEnum and therefore can behave like an array that can dynamically add members |
| [roMessagePort](/docs/references/brightscript/components/romessageport.md "roMessagePort") | A Message Port is the place messages (events) are sent |
| [roXMLList](/docs/references/brightscript/components/roxmllist.md "roXMLList") | Contains a list of roXML objects |

Supported methods
-----------------

### Reset() as Void

#### Description

Resets the current position to the first element of the enumeration.

### Next() as Dynamic

#### Description

Increments the position of an enumeration. If the last element of the enumeration is returned, this method sets the current position to indicate that it is now past the end.

#### Return Value

The value at the current position of the enumeration. If the current position is already past the end (that is, the last element has already been returned by a previous call to this method), "invalid" is returned.

### IsNext() as Boolean

#### Description

Checks whether the current position is not past the end of the enumeration.

#### Return Value

A flag indicating whether the current position is not past the end (true), or is past the end (false).

### IsEmpty() as Boolean

#### Description

Checks whether the enumeration contains no elements.

#### Return Value

A flag indicating whether the enumeration contains no elements (true), or contains elements (false).

Node field observers
====================

All node and component fields can have _observers_ attached to them. These observers continuously monitor the state of the specified field, and if the field changes, a specified callback function is triggered to perform an action in response to the field state change.

In most cases, the observers are only notified if the field value changes. There is also loop breaking logic to make sure that you cannot get into an infinite loop of observer callbacks. For example, suppose field A changes and calls observer function X. In function X, field B is set and calls observer function Y. If in function Y, field A is set, the setting of field A is not done, preventing an infinite loop.

See [Handling node field value changes](/docs/developer-program/core-concepts/handling-application-events.md#handling-node-field-value-changes) for information on setting up observers and writing callback functions to handle node field changes. See [Handling component <interface> field value changes](/docs/developer-program/core-concepts/handling-application-events.md#handling-component-interface-field-value-changes) for information on setting up observers and writing callback functions to handle component field changes.

roInput
=======

An roInput object can be used to receive events sent from a network client using the External Control Protocol (ECP), as described in [External Control API](/docs/developer-program/dev-tools/external-control-api.md "External Control API").

> The [supports\_input\_launch manifest flag](/docs/developer-program/getting-started/architecture/channel-manifest.md#launch-requirement-attributes) must be set for channels to accept deep linking parameters when already running. This flag enables deep linking into content without relaunching the app. See the [Deep Linking sample app](https://github.com/rokudev/deep-Linking-samples) for how to use roInput to handle deep links into content while the app is already running.

Refer to [External Control Service Commands](/docs/developer-program/dev-tools/external-control-api.md#external-control-service-commands "External Control Service Commands") for information about the ECP input command.

This object is created without any arguments:

`CreateObject("roInput")`

**Example**

The following prints information received from an external device in JSON format. If the external device sends the following input command:

    curl -d '' '<roku_target_device>:8060/input?my_event=My%20Test&x=100&y=200&action=start'
    

The following will be printed:

    {"action":"start","my_event":"My Test","x":"100","y":"200"}
    

**roInput Example**

    msgPort = CreateObject("roMessagePort")
    
    input = CreateObject("roInput")
    input.SetMessagePort(msgPort)
    
    print "Waiting for messages..."
    while true
      msg = wait(0, msgPort)
      if type(msg) = "roInputEvent"
        if msg.IsInput()
          info = msg.GetInfo()
          print "Received input: "; FormatJSON(info)
        end if
      end if
    end while
    

Supported interfaces
--------------------

*   [ifInput](/docs/references/brightscript/interfaces/ifinput.md "ifInput")

Supported events
----------------

*   [roInputEvent](/docs/references/brightscript/events/roinputevent.md "roInputEvent")

Global string functions
=======================

UCase(s as String) as String
----------------------------

Converts the string to all upper case.

     print UCase("Hello")  ' prints: HELLO
    

LCase(s as String) as String
----------------------------

Converts the string to all lower case.

     print LCase("Hello")  ' prints: hello
    

Asc(letter as String) as Integer
--------------------------------

Returns the Unicode ("ASCII") value for the first character of the specified string.

An empty string argument will return 0.

     print Asc("C") ' prints: 67
    

Chr(ch as Integer) as String
----------------------------

Performs the inverse of the Asc function: returns a one-character string whose character has the specified Unicode value.

Returns empty string if the specified value is 0 or an invalid Unicode value.

     print Chr(67) ' prints: C
    

By using Chr, you can create strings containing characters which cannot be contained in quotes, such as newline or the quote character itself.

     print (Chr(34) + "hello" + Chr(34))  ' prints: "hello"
    

Instr(start as Integer, text as String, substring as String) as Integer
-----------------------------------------------------------------------

Returns the position of the first instances of substring within text, starting at the specified start position.

Returns 0 if the substring is not found. Unlike the ifString.Instr() method, the first position is 1.

     print Instr(1, "this is a test", "t")  ' prints: 1
     print Instr(2, "this is a test", "t")  ' prints: 11
     print Instr(1, "this is a test", "is") ' prints: 3
    

Left(s as String, n as Integer) as String
-----------------------------------------

Returns the first _n_ characters of _s._

     print Left("timothy", 3) ' prints: tim
    

Len(s as String) as Integer
---------------------------

Returns the number of characters in the specified string.

     print Len("timothy") ' prints: 7
    

Mid(s as String, p as Integer\[, n as Integer\]) as String
----------------------------------------------------------

Returns a substring of _s_ with length _n_ and starting at position _p_.

n may be omitted, in which case the string starting at p and ending at the end of the string is returned.

Unlike the [ifStringOps.Mid()](/docs/references/brightscript/interfaces/ifstringops.md#midstart_index-as-integer-as-string) method, the first character in the string is position 1.

     print mid("timothy", 4, 3) ' prints: oth
    

Right(s as String, n as Integer) as String
------------------------------------------

Returns the last n characters of s.

     print right("timothy", 3) ' prints: thy
    

Str(value as Float) as String
-----------------------------

StrI(value as Integer) as String
--------------------------------

Converts a _value_ to a string. Str(A), for example, returns a string equal to the decimal representation of the numeric value of A.

For example, if A# = 58.5 then Str(A#) equals the string " 58.5". If A# = -58.5 then Str(A#) equals the string "-58.5".

For **non-negative numbers**, a leading blank is inserted before the value string as a sign placeholder.

(For integer values, _value_.ToStr() may be used instead if a leading blank for non-negative numbers is not desired. See [ifIntOpts](/docs/references/brightscript/interfaces/ifintops.md) in [roInt](/docs/references/brightscript/components/roint.md)).

See the [ifStringOps](/docs/references/brightscript/interfaces/ifstringops.md) interface in [roString](/docs/references/brightscript/components/rostring.md) for the corresponding inverse / string-to-value functions ToInt() and ToFloat().

StrI(value as Integer, radix as Integer) as String
--------------------------------------------------

Converts the integer value into a string representation using the given radix.

If radix is not 2 .. 36 then an empty string is returned.

Note that the returned string does not include a base prefix and uses lowercase letters to represent those digits in bases greater than 10.

For example:

    print StrI(255, 16) '= "ff"
    
    print StrI(9, 2) '= "1001"
    

String(n as Integer, str as String ) as String
----------------------------------------------

Returns a string composed of n copies of the second argument concatenated together.

For example,

     print String(4, "ab") ' prints: abababab
    

StringI(n as Integer, ch as Integer) as String
----------------------------------------------

Returns a string composed of n copies of the character whose Unicode value is the second argument.

For example,

     print StringI(5, 67) ' prints: CCCCC
    

Val(s as String) as Float
-------------------------

Performs the inverse of the STR function: returns the number represented by the characters in a string argument.

For example, if A$="12" and B$="34" then VAL(A$+ "."+B$) returns the number 12.34.

Val(str as String, radix as Integer) as Integer
-----------------------------------------------

Returns the integer value from parsing the string with the specified radix.

Radix should be 2 .. 36 or the special value 0 (which automatically identified hexadecimal or octal numbers based on 0x or 0 prefixes respectively).

Leading whitespace is ignored then as much of the rest of the string will be parsed as valid.

For example:

    print Val("0x80", 0) '= 128
    
    print Val("FF", 16) '= 255
    
    print Val("1001", 2) '= 9
    

Substitute(str as String, arg0 as String, arg1 = "" as String, arg2 = "" as String, arg3 = "" as String) as String
------------------------------------------------------------------------------------------------------------------

Replaces all instances of {0} or ^0 in a string with arg0. Similarly, replaces all instances of {1} or ^1 with arg1, {2} or ^2 with arg2, and {3} or ^3 with arg3.

**Example**

    thing = "book"
    color = "red"
    print Substitute("My {0} is {1}.", thing, color) ' prints "My book is red."

Defining SceneGraph components
==============================

A Roku SceneGraph application consists of one or more SceneGraph components. These SceneGraph components are defined in XML files, which consist of a required **<component>** XML element, that contains the other possible XML elements to fully define the component. The Roku SceneGraph application can then create an object instance of any defined SceneGraph component as needed.

<component> XML element
-----------------------

The component XML files consist of a [**<component>**](/docs/references/scenegraph/xml-elements/component.md) XML element, which contains the other XML elements that can further define the component. The **<component>** element has two required attributes:

*   `name`  
    A unique name for the component
*   `extends`  
    The name of the built-in node class, or extended component, that the component _extends_

All components in a SceneGraph application are defined by extending the component from a built-in node class or extended component, and setting the field values of the nodes included in the component, which may be built-in node classes or extended components. When you extend a component, the extended component includes all of the previously declared or defined characteristics of the original component, plus the new characteristics you declare and define for the new component.

<interface> XML Element
-----------------------

Roku SceneGraph components allow (but do not enforce), encapsulation of internal component behavior, by providing an [**<interface>**](/docs/references/scenegraph/xml-elements/interface.md) XML element. The **<interface>** element can contain several **<field>** elements, which define custom fields for the components. These custom fields can be written and read by the application in the same way as the fields of the built-in node classes. This allows the application to set a field value to control the component operation, and read a field value to get the results of the component operation, without writing and reading the internal fields of the component.

<script> XML Element
--------------------

Component behavior is controlled using BrightScript in a [**<script>**](/docs/references/scenegraph/xml-elements/script.md) XML element. The **<script>** element provides two methods of including BrightScript code in the component:

*   directly, using a `CDATA` element section
*   by reference, using the `uri` attribute of the **<script>** element to specify the location of the BrightScript code to be included

<children> XML Element
----------------------

You can create the component SceneGraph nodes entirely in BrightScript in the [**<script>**](/docs/references/scenegraph/xml-elements/script.md) element. But Roku SceneGraph also supplies a [**<children>**](/docs/references/scenegraph/xml-elements/children.md) XML element to allow nodes to be defined in XML markup. These SceneGraph nodes are then created automatically when the component is created (see [**Component Initialization Order**](/docs/developer-program/core-concepts/xml-components/component-initialization-order.md) for important details on this process).

Defining SceneGraph nodes in the **<children>** element is particularly useful when the component will have a relatively fixed number and types of nodes, rather than a number of different node types that may be created (and removed) dynamically as part of component operation. Field values of the nodes declared and defined in the **<children>** element can still be set dynamically in the [**<script>**](/docs/references/scenegraph/xml-elements/script.md) element, by first using the **ifSGNodeDict** **`findNode()`** method to find the object reference.

There are some limitations in defining node field values in the **<children>** element. You cannot use expressions and otherwise manipulate variables and object references in the XML markup to set field values. You are restricted to fixed values that can be expressed only as strings assigned to the field. And you should not start or stop or otherwise control the operation of certain nodes, such as media playback or animation nodes, by setting the values of those types of fields in the XML markup definition of the node in the **<children>** element. Rather you should find the object reference using the **ifSGNodeDict** **`findNode()`** method in the [**<script>**](/docs/references/scenegraph/xml-elements/script.md) element, then set those fields there, as part of your scripting to control component behavior.

Node Definition Examples
------------------------

A typical XML file will include one or more SceneGraph node elements inside the [**<component>**](/docs/references/scenegraph/xml-elements/component.md) element. These nodes are instantiated when the XML is parsed, and added as children of the XML **<component>** element top-level node.

Nodes are defined using an XML element that matches the node type. Field values of the node are specified as attributes of the node element. The following example shows how to define a [**<Poster>**](/docs/references/scenegraph/renderable-nodes/poster.md) node, and set its `id`, `uri` and `translation` fields.

**Defining a Node in XML**

    <Poster 
      id = "myPoster" 
      uri = "pkg:/images/myPoster.jpg" 
      translation = "[ 200, 100 ]" />
    

Nodes can include children by simply including them in the body of a node XML element. The follow example shows how to declare a **Poster** node that includes a **Label** draw on top of it.

**Adding a Child Node in XML**

    <Poster 
      id = "myPoster" 
      uri = "pkg:/images/myPoster.jpg" 
      translation = "[ 200, 100 ]" >
    
      <Label 
        id = "FirstName" 
        text = "John" />
    
    </Poster>
    

By default, if a node includes one or more node elements in the body of its XML definition, the nodes defined in the body are added as children of the node. In a few cases, nodes defined in the body of another node serve a special purpose, and should not be added as children. In that case, the nodes defined in the body should have an XML `role` attribute specified to indicate which field of the parent node should be set to their value. For example, a [**<Label>**](/docs/references/scenegraph/label-nodes/label.md) node could have a [**<Font>**](/docs/references/scenegraph/typographic-nodes/font.md) node defined in its body. If you specify the role attribute as `font` for the **<Font>** node, it causes the parent **<Label>** node `font` field to be set to the **<Font>** node.

**Defining the role Attribute of a Node**

    <Label text = "John Doe" >
      <Font 
        id = "TypewriterFont" 
        role = "font" 
        uri = "pkg:/fonts/BohemianTypewriter.ttf" 
        size = "36" />
    </Label>
    

An instance of a node can be used in more than place in the scene, using a field attribute value that begins with `dictionary:`. For example, if the **<Label>** node is defined as above in an XML file, another **<Label>** node can be defined that uses the same **<Font>** node as follows:

**Using dictionary to Set an Attribute Value**

    <Label 
      text = "John Doe"
      font = "dictionary:TypewriterFont" />
    

Extending Built-In Node Classes
-------------------------------

Roku SceneGraph includes a wide variety of node classes that are built into the SceneGraph API. These built-in node classes are described in the [**SceneGraph XML Reference**](/docs/developer-program/core-concepts/scenegraph-xml/overview.md).

But Roku SceneGraph allows you to extend these built-in node classes with your own custom node classes, with unique fields, appearance, behaviors, and interfaces. The key to writing SceneGraph applications is to define your own custom node classes, then create and use them as needed for your application.

For example, the starting point of any SceneGraph application is a custom node class extended from one of the built-in **Scene** node classes, such as [**Scene**](/docs/references/scenegraph/scene.md) or [**OverhangPanelSetScene**](/docs/references/scenegraph/sliding-panels-nodes/overhangpanelsetscene.md). These **Scene** node classes are _abstract_ node classes, you _must_ extend them in order to use them. So every SceneGraph application _must_ include an XML component file in the following format:

    <?xml version="1.0" encoding="utf-8" ?>
    <component name = "MyApplicationScene" extends = "Scene" >
    
    customized_scene_definitions
    
    </component>
    

The built-in abstract **Scene** node is extended by setting the `name` and `extends` attributes of the [**<component>**](/docs/references/scenegraph/xml-elements/component.md) XML element. After this custom extended **Scene** node is defined in an XML component file in the `pkg:/components` directory, you can then start the application by creating the custom **Scene** node component in the `pkg:/source` /`main.brs` file using the **Scene** node component name as the `CreateScene()` argument for a BrightScript `roSGScreen` object:

`scene = screen.CreateScene("MyApplicationScene")`

Likewise, you define custom components for your entire application that are created and added to your SceneGraph node tree as needed. For example, you could add a custom scrollable row list component to your application by extending the built-in [**RowList**](/docs/references/scenegraph/list-and-grid-nodes/rowlist.md) node class component in an XML component file:

    <?xml version = "1.0" encoding = "utf-8" ?>
    
    <component name = "MyCustomRowList" extends = "RowList" >
    customized_rowlist_definitions
    </component>
    

Once this XML component file is created, you can now add the custom row list component to your **Scene** component, or any other SceneGraph component in your application. For example, the following adds the custom row list to the application **Scene** component using the `createChild()` function using BrightScript in a **<script>** element:

    <?xml version = "1.0" encoding = "utf-8" ?>
    
    <component name = "MyApplicationScene" extends = "Scene" >
    
        <script type="text/brightscript" >
          <![CDATA[
    
          sub init()
            rowlist = m.top.createChild("MyCustomRowList")
          end sub
    
          ]]>
        </script>
    
    </component>
    

Or you can add the custom component using XML markup in the [**<children>**](/docs/references/scenegraph/xml-elements/children.md) element of the XML component file:

    <?xml version = "1.0" encoding = "utf-8" ?>
    
    <component name = "MyApplicationScene" extends = "Scene" >
      <children>   
    
        <MyCustomRowList/>
      </children>
    </component>
    

In either case, you have added your custom component to the SceneGraph node tree as a child node of the Scene node, by specifying the component name from your custom XML component file.

Rendezvous linking
==================

> All apps, except TVE apps, must complete authentication entirely on-device to pass certification. See [On-device authentication](/docs/developer-program/authentication/on-device-authentication.md) for how to implement the required authentication method.
> 
> Only TVE apps may use rendezvous linking to authenticate Roku customers. A TVE app is defined as an app that is accessed with credentials from a cable/satellite subscription.

This overview describes the typical flow and API used for registering and linking a device to an authentication service. The primary and recommended method for linking a device involves 3 main steps:

1.  Display a short on-screen registration code (generated on the server) on the Roku device.
    
2.  The user links the device by entering the registration code on the provider's website/service.
    
3.  The service confirms the code is correct and issues a token to the Roku device. Once the device downloads the token, the app displays a congratulations screen and allows the user access to the video service. The next time the app is launched, the service will check if the token matches.
    

This is known as the "rendezvous" style of registration.

* * *

Authentication flow
-------------------

Several transactions between the device and the provider server make this work. The steps are as follows:

**1\. Pre-registration:**

*   First, the device makes a "pre-registration" request to the server.
*   The server generates a short registration code and sets up an entry in a database associating the code with a temporary request for linking.
*   The device receives this response and displays the code to the user.

**2\. Device linking:**

*   The device begins making a sequence of "link" requests to the server.
*   The server responds to the link request with a "not completed" code until the user successfully enters the code into the web site, or the code expires.

**3\. Linking success:**

*   When the user has successfully entered the code plus any other necessary credentials on the provider web site, the server re-associates the code with the user's real account.
*   The next time the device makes a "link" query, the server responds with a permanent token that can be used to access the user's account.

All subsequent API requests use this token to uniquely identify the customer and device. A request can be made as HTTP GET with values in parameters, or HTTP POST with values in the body of the request, for example, as XML or JSON.

### Step 1: Pre-registration

![roku815px - authenticationandlinking1](https://image.roku.com/ZHZscHItMTc2/authenticationandlinking1.jpg "authenticationandlinking1")

This transaction is used to retrieve a registration code from the server for device registration. The code is displayed on screen by the device and the user is requested to go to the website and enter this code. It is desirable to make the code as short as possible to make it easy for the user to enter, yet ensure uniqueness during the retry interval. The device will poll at a specified frequency (`retryInterval`) during registration until the device has been registered or the maximum time has expired (`retryDuration`).

**Pre-registration request:**

    <preRegistration>
      <deviceID>(unique id/serial number for the device)</deviceID>
      <deviceTypeID>(optional opaque string identifying device type)</deviceTypeID>
      <firmwareVersion>(optional major.minor.build)</firmwareVersion>
    </preRegistration>
    

**Response:**

    <result>
      <status>success/failure</status>
      <regCode>(small ~5 character code customer will enter onto web site)</regCode>
      <retryInterval>(polling interval in secs to detect completion (e.g. 30)</retryInterval>
      <retryDuration>(max duration in secs for retries (e.g. 900) )</retryDuration>
    </result>
    

### Step 2: Device linking

This transaction is used to check the registration progress to see if the user has successfully entered their registration code on the website to link their device. This method is polled continuously at the specified interval (`retryInterval`) from the time the pre-registration request is made until a `success` response is received or until the max retry time (`retryDuration`) has elapsed. An example of the request/response is shown below in XML format:

**Link request:**

    <linkAccount>
      <regCode>(current registration code from PreRegistration request)</regCode>
      <deviceID>(unique id/serial number for the device)</deviceID>
      <deviceTypeID>(opaque string identifying device type)</deviceTypeID>
    </linkAccount>
    

> Note: The device ID **should not** be used as the authentication token as is. You can however hash the device ID to create an auth token as long as it generates a unique value each time.

**Intermediate response:**

![roku815px - authenticationandlinking2](https://image.roku.com/ZHZscHItMTc2/authenticationandlinking2.jpg "authenticationandlinking2")

    <result>
      <status>incomplete</status>
    </result>
    

The device linking request may fail for several reasons, such as:

*   Missing or invalid registration code
*   Expired registration code
*   Customer account issue (e.g. not registered, hold, etc.)

The app is expected to handle these types of responses gracefully.

### Step 3: Linking success

![roku815px - authenticationandlinking3](https://image.roku.com/ZHZscHItMTc2/authenticationandlinking3.jpg "authenticationandlinking3")

The final response after successfully linking the device should send a token (opaque string) back to the Roku device and be written to the app's registry. This token can then be used by the client to perform further operations on the server, such as play media. The next time the app is launched, the service should check to see that the token matches.

**This token, and not the device serial number, should be used to identify an account on the server.** This allows a user to disassociate (unlink) a device from an account by simply removing the app or when doing a factory reset which causes the stored device token to be discarded.

**Final response:**

    <result>
      <status>success/failure</status>
      <deviceToken>(opaque string to identify account for future requests)</deviceToken>
      <customerId>(optional customer ID if required by partner)</customerId>
      <creationTime>(optional ISO8601 date/time value)</creationTime>
    </result>

Testing a Roku Pay app
======================

Testing the purchase and entitlement workflows in your Roku Pay workflow entails three major steps:

1.  Verifying that content cannot be accessed without a subscription.
2.  A subscription can be purchased.
3.  Access to content is granted with a valid subscription.

These steps are based on the Roku Pay workflows specified in the [On-device authentication guide](/docs/developer-program/authentication/on-device-authentication.md).

> Before running any Roku Pay tests on an app, make sure to add one or more in-app products to the app, enable the app for billing testing, add yourself as a Test User to the app, and then [sideload the app](/docs/developer-program/getting-started/developer-setup.md).
> 
> *   **In-app products**: Developers must [add one or more in-app products](/docs/developer-program/roku-pay/quickstart/in-channel-products.md) to the app being tested. If the app has one or more sets of mutually exclusive products, [create product groups](/docs/developer-program/roku-pay/quickstart/in-channel-products.md#adding-product-groups) for each set. To test entitlements after a free trial expires, create a product that includes a 1-day [free trial](/docs/developer-program/roku-pay/quickstart/in-channel-products.md#adding-product-groups#trials-and-offers).
>     
> *   **Billing Testing**: Developers can [designate an app for "billing testing"](/docs/developer-program/roku-pay/testing/billing-testing.md) to observe output from the SceneGraph ChannelStore node in the debug console when the app is sideloaded. The billing testing feature provides developers with visibility into the confirmations, error codes, and other transactional metadata related to purchases made with Roku Pay.
>     
> *   **Test Users**. Developers can [add themselves as a Test User](/docs/developer-program/roku-pay/quickstart/test-users.md) to the app being tested in order to execute ChannelStore purchases without being billed for the transactions.
>     

Verifying no entitlement without a Roku Pay subscription
--------------------------------------------------------

To verify that a customer cannot be entitled to content without a subscription purchased through Roku Pay, follow these steps:

1.  Launch app and select content behind paywall.

2.  Send the [**getAllPurchases** command](/docs/references/scenegraph/control-nodes/channelstore.md#getpurchases). Verify that it does not return any active subscription products.

3.  Call the **[roRegistrySection.read()](/docs/references/brightscript/interfaces/ifregistrysection.md#readkey-as-string-as-string)** function on the device registry section for the app. Verify that it does not return an access token from device registry.

4.  Send the [**getChannelCred** command](/docs/references/scenegraph/control-nodes/channelstore.md#getchannelcred). Verify that it does not return an access token from Roku cloud.

Verifying Roku Pay purchase workflow
------------------------------------

To verify that a customer can purchase a subscription product and upgrade/downgrade their plan through Roku Pay, follow these steps:

1.  Send the [**getCatalog** command](/docs/references/scenegraph/control-nodes/channelstore.md#getcatalog). Verify that the SceneGraph components used to display in-app products are populated with product metadata.

2.  Select a subscription product. Verify that the [**getUserData** command](/docs/references/scenegraph/control-nodes/channelstore.md#getuserdata) is sent and the request for information (RFI) screen is displayed.

3.  Press **Continue** on the RFI screen. Verify that the [order is created](/docs/references/scenegraph/control-nodes/channelstore.md#creating-an-order) and the [**doOrder** command](/docs/references/scenegraph/control-nodes/channelstore.md#doorder) is executed.

4.  Verify that the order confirmation screen displays any free trial offers or discounts included with the subscription product.

5.  Confirm the order of the subscription product. Verify that the `orderStatus` field confirms that the order was successfully completed.

6.  Verify that an access token is generated in the publisher's backend system and passed into:
    
    a. The [**storeChannelCredData** command](/docs/references/scenegraph/control-nodes/channelstore.md#storechannelcreddata) to store the access token in the Roku cloud.
    
    b. The **[roRegistrySection.write()](/docs/references/brightscript/interfaces/ifregistrysection.md#writekey-as-string-value-as-string-as-boolean)** function to store the access token in the device registry.
    
7.  If your app includes a [product group](/docs/developer-program/roku-pay/quickstart/monetization-in-developer-dashboard.md#product-groups), select another in-app product that is in the same product group as the previously ordered one. Verify that the "You're already subscribed" dialog is displayed.
    

8.  Call the [**validate-transaction** API](/docs/developer-program/roku-pay/implementation/roku-web-service.md#validate-transaction) with purchase ID included in the `orderStatus` field. Verify that the `isEntitled` flag is set to "true".

9.  If your app includes multiple subscription plans, upgrade or downgrade the subscription plan, and then do the following:
    
    a. Verify that the `order.action` field is set to the correct string.
    
    b. Call the `validate-transaction` API with purchase ID included in the `orderStatus` field. Confirm the following:
    
    *   The `purchase_type` is set to `UPGRADE` or `DOWNGRADE`.
        
    *   The `cancelled_transaction_ids` field is set to the transaction ID of the original subscription purchase.
        
    *   The `purchase_status` field is set to `active`.
        

10.  Close the app.

Verifying Roku Pay entitlement workflow
---------------------------------------

To verify that a customer is entitled to content after purchasing a subscription through Roku Pay, follow these steps:

1.  Re-launch app.

2.  Send the [**getAllPurchases** command](/docs/references/scenegraph/control-nodes/channelstore.md#getpurchases). Verify that it returns the purchased subscription product.

3.  Call the [**validate-transaction** API](/docs/developer-program/roku-pay/implementation/roku-web-service.md#validate-transaction) with purchase ID included in the `purchases` field. Verify that the `isEntitled` flag is set to "true".

4.  Call the **[roRegistrySection.read()](/docs/references/brightscript/interfaces/ifregistrysection.md#readkey-as-string-as-string)** function on the device registry section for the app. Verify that it returns an access token from the device registry.

5.  Send the [**getChannelCred** command](/docs/references/scenegraph/control-nodes/channelstore.md#getchannelcred). Verify that it returns an access token from Roku cloud.

6.  To test that customers are not entitled to subscription products after a free trial ends, do the following:
    
    a. Order a subscription product that has a 1-day free trial.
    
    b. After the trial expires the next day, cancel the subscription.
    
    c. Complete steps 1-3. Verify that the `isEntitled` flag is set to "false".

Manifest file
=============

Root level
----------

The root level of all Roku apps must contain a `manifest` file (`pkg:/manifest`) containing important attributes for the application. These attributes include but are not limited to the following:

*   Name and version number of the application
*   App icon
*   Splash screen image

Manifest guidelines
-------------------

*   Each attribute is on a separate line, and has the form `name=value`
*   Each `name=value` pair must end with a newline character, or it may not be parsed by the Roku OS
*   The last line must end with a newline character
*   Empty lines are ignored
*   Lines beginning with a '#' (number sign) are comment lines and are ignored
*   All graphics files specified in the manifest file should be included in the `images` directory
*   The URI to set the path to the files should use the `pkg:` resource prefix, such as `pkg:/images/splash-screen.png`

Example manifest file
---------------------

    # Channel Details
    title=HeroGridChannel
    major_version=1
    minor_version=1
    build_version=1
    
    # Channel Assets
    mm_icon_focus_hd=pkg:/images/channel-poster_hd.png
    mm_icon_focus_sd=pkg:/images/channel-poster_sd.png
    
    # Splash Screen + Loading Screen Artwork
    splash_screen_sd=pkg:/images/splash-screen_sd.jpg
    splash_screen_hd=pkg:/images/splash-screen_hd.jpg
    splash_screen_fhd=pkg:/images/splash-screen_fhd.jpg
    splash_color=#808080
    splash_min_time=0
    # Resolution
    ui_resolutions=fhd
    
    confirm_partner_button=1
    

Required attributes
-------------------

These are the minimum attributes required for every Roku app:

| Attribute | Type | Description | Sample manifest entry | Specification |
| --- | --- | --- | --- | --- |
| `title` | string | name of the app | `title=Roku Media Player` |     |
| `major_version` | integer | major portion of the app version | `major_version=1` |     |
| `minor_version` | integer | minor portion of the app version | `minor_version=2` |     |
| `build_version` | integer | build number | `build_version=00150` |     |
| `mm_icon_focus_hd` | string | local URI for the HD app icon.  <br>  <br>**NOTE:** The app will not appear on devices or be accessible after publication without this attribute pointing to a valid image. The image's file name and file type must also match. | `mm_icon_focus_hd=pkg:/images/channel-icon_HD.png` | 290x218 |
| `mm_icon_focus_sd` | string | local URI for the SD app icon.  <br>  <br>**NOTE:** The app will not appear on devices or be accessible after publication without this attribute pointing to a valid image. The image's file name and file type must also match. | `mm_icon_focus_sd=pkg:/images/channel-icon_SD.png` | 246x140 |
| `splash_screen_hd` | string | local URI for the HD splash screen displayed when the app is launched | `splash_screen_hd=pkg:/images/splash-screen_HD.jpg` | 1280x720 |
| `splash_screen_sd` | string | local URI for the SD splash screen displayed when the app is launched | `splash_screen_hd=pkg:/images/splash-screen_SD.jpg` | 720x480 |

Optional attributes
-------------------

The following categories of attributes are optional:

### Voice control attributes

| Attribute | Type | Description | Sample manifest entry |
| --- | --- | --- | --- |
| `supports_etc_seek` | integer | Enables handling of "seek" and "start over" voice commands.  <br>  <br>If this flag is not enabled, an error message is displayed when an app receives a "seek" or "start over" command. | `supports_etc_seek=1` |
| `supports_etc_next` | integer | Enables handling of "next" voice commands.  <br>  <br>If this flag is not enabled, an error message is displayed when an app receives a "next" command. | `supports_etc_next=1` |
| `supports_voice_roinput` | integer | Specifies that the app supports voice controls. | `supports_voice_roinput=1` |
| `voice_action_launch_screen` | integer | Specifies that the app displays a hands-free voice profile selection screen upon launch. | `voice_action_launch_screen=1` |

### Splash screen attributes

| Attribute | Type | Description | Sample manifest entry | Specification |
| --- | --- | --- | --- | --- |
| `splash_color` | hex value | background color to use if the splash screen image is not full screen | `splash_color=#121212` |     |
| `splash_min_time` | integer | minimum amount of time (in milliseconds) to display the splash screen  <br>  <br>If no value is specified, then 1600 (1.6 seconds) is used. If 0 is specified, then there is no default time, so the splash screen disappears as soon as the application displays its first screen. (This may result in the appearance of flashing, if your application shows its first screen quickly). | `splash_min_time=1500` |     |
| `splash_screen_fhd` | string | local URI for the FHD splash screen  <br>  <br>The FHD splash screen image is scaled down for HD display mode but this attribute can be used to specify a resolution-specific splash screen image. | `splash_screen_fhd=pkg:/images/splash-screen_FHD.png` | 1920x1080 |
| `splash_rsg_optimization` | integer | Roku recommends that you do not use this attribute at this time as it may deplete your app's available memory resources. Set this attribute to remove the black screen flash in SceneGraph apps. This is only applicable for SceneGraph apps and only if the first screen is a SceneGraph component. | `splash_rsg_optimization=1` |     |

### Graphics scaling attributes

| Attribute | Type | Description | Sample manifest entry |
| --- | --- | --- | --- |
| `ui_resolutions` | comma separated values | A comma-separated list of up to three strings that identify the UI resolutions the application has been designed to support. | `ui_resolutions=sd,hd,fhd` |
| `uri_resolution_autosub` | comma separated values | Provides a flexible way to specify graphical image URIs that are automatically modified to replace a specified string with a string that gets a resolution-specific graphical image.  <br>  <br>The attribute value is a comma-separated list of four strings that specify the string to be replaced along with the replacement strings for SD, HD and FHD resolutions. For example, suppose the manifest includes this line: `uri_resolution_autosub=$$RES$$,SD,720p,1080p` And the Roku player supports full high-definition resolution. Then if the application specifies a URI of: [http://www.roku.com/testChannel/assets/$$RES$$/rokuTV.jpg](http://www.roku.com/testChannel/assets/$$RES$$/rokuTV.jpg). At runtime that URI will be modified to: [http://www.roku.com/testChannel/assets/1080p/rokuTV.jpg](http://www.roku.com/testChannel/assets/1080p/rokuTV.jpg) and the application will get the full-high definition version of the graphical image in the specified directory. | `uri_resolution_autosub=$$RES$$,SD,720p,1080p` |

1.  The default setting for `ui_resolutions` is `ui_resolutions=sd,hd`
    
    *   `sd` Applications designed for standard definition 720x480
    *   `hd` Applications designed for high definition 1280x720
    *   `fhd`Applications designed for full high definition 1920x1080

### Launch requirement attributes

| Attribute | Type | Description | Sample manifest entry |
| --- | --- | --- | --- |
| `supports_input_launch` | integer | The [roInputEvent](/docs/references/brightscript/events/roinputevent.md) is used to check whether a deep link has been passed into the application while your app is running. This enables your application to deep link into content without re-launching your app. This attribute must be added to the manifest for this functionality to work. | `supports_input_launch=1` |
| `requires_gaming_remote` | integer | Specifies that a gaming remote must be linked to the Roku Player to launch the application. If not, a dialog box is presented to the user. | `requires_gaming_remote=1` |
| `requires_mkv` | integer | Playing MKV files requires the use of a dynamically loaded library that is not part of the initially booted image. Therefore, an entry must be added to the manifest of any applications that require MKV support so that support is enabled when the app is launched. | `requires_mkv=1` |
| `network_not_required` | integer | Set to 1 to specify the application does not require the network (such as the USB Media Player). This lets the user launch an application even if there is no network connection. | `network_not_required=1` |
| `bs_libs_required` | string | Specifies the BrightScript libraries required for the application. | `bs_libs_required=roku_ads_lib` |
| `usb_media_handler` | integer | Set to 1 to specify if the app can be auto-launched when a USB device is inserted. | `usb_media_handler=1` |

### DRM attributes

| Attribute | Type | Description | Sample manifest entry |
| --- | --- | --- | --- |
| `requires_verimatrix_drm` | integer | Downloads the required library to use Verimatrix DRM. | `requires_verimatrix_drm=1` |
| `requires_verimatrix_version` | value | Specifies the version of Verimatrix DRM to use. Roku currently supports version 1.0. | `requires_verimatrix_version=1.0<br />`  <br>  <br><br>> As of Roku OS 9.3, support for Verimatrix DRM has been removed from the firmware. Make sure that content in your app is protected using one of the following Roku-supported DRMs: Microsoft PlayReady or Widevine. Click [here](/docs/specs/media/content-protection.md) for more information on implementing these DRMs. |

> See [Content Protection](/docs/specs/media/content-protection.md) for implementation details.

### Special purpose attributes

| Attribute | Type | Description | Sample manifest entry |
| --- | --- | --- | --- |
| `hidden` | integer | The hidden property tells the Roku OS to not display the app on the home screen. Hidden apps can still be launched over the network via the [External Control API](/docs/developer-program/dev-tools/external-control-api.md). | `hidden=1` |
| `playonly_aware` | integer | Attribute to specify the application responds to the PlayOnly remote control button event. If not set, the application will receive the Play event instead when the user selects the button. | `playonly_aware=1` |
| `pause_aware` | integer | Attribute to specify the application responds to the pause remote control button event.  <br>  <br>When this attribute is not set (the default), the application will not respond to the pause event and will toggle between "play" and "pause" modes when it receives the play event.  <br>  <br>When the attribute is set to `1`, the play event strictly indicates play-mode (no toggling), and a pause event is necessary to invoke pause-mode. | `pause_aware=1` |
| `channel_token` |     | Token string used to grant access for specific Roku platform features (for example, Continue Watching) | `ewogICJpc3MiOiAidXJuOnJva3UuY29tOnRva2VubWludDpjaGFubmVsdG9rZW4iLAogICJhdWQiOiAidXJuOnJva3UuY29tOnN0Yi9jaGFubmVsIiwKICAic3ViIjogInVybjpyb2t1LmNvbTpzdGIvNzAzMDM0IiwKICAianRpIjogInVybjo4ZjNhN2FiNi1mMWJkLTQ1MTYtOTRiNS0wYTc3ZjNmMDY2OGEiLAogICJpYXQiOiAxNzA1NTI3NzE4LAogICJleHAiOiAyMDIwODg3NzE4LAogICJuYmYiOiAxNDU2NzkwNDAwLAogICJyb2t1LXRmdiI6ICIxIiwKICAicm9rdS1wZXJtIjogWwogICAgImp3dF9oZWFkZXIiCiAgXSwKICAicm9rdS1jaGFubmVsLWlkIjogWwogICAgIjEiCiAgXQp9` |
| `run_as_process` (**deprecated as of Roku OS 12.5**) | Integer | Enables the Roku OS to run the [chanperf debug command](/docs/developer-program/debugging/debugging-channels.md#scenegraph-debug-server-port-8080-commands) in the SceneGraph debug console (port 8080) order to print the current memory and CPU utilization of an app. | `run_as_process=1` |
| `rsg_version` | value | Sets the SceneGraph [observer callback model](/docs/developer-program/core-concepts/handling-application-events.md).  <br>  <br>If using Roku OS 9.0 or above, use `rsg_version=1.2`. This enables a new internal mechanism for processing component <script> tags that optimizes the resulting compiled script code resulting in a reduced initial startup time and lesser memory usage while preserving compatibility.  <br>  <br>If using a [Roku component library node](/docs/references/scenegraph/control-nodes/componentlibrary.md), the `rsg_version` flag needs to be declared in the component library's manifest as well.  <br>  <br>[Eval()](/docs/references/brightscript/language/runtime-functions.md#evalcode-as-string-as-dynamic) is deprecated. Eval() cannot be used with `rsg_version=1.2`.  <br>  <br>The manifest entry defaults to 1.2 as of Roku OS 9.3 if it's not specified in the manifest.  <br>  <br>Note that support for the “rsg\_version=1.0” manifest flag is deprecated as of Roku OS 8. | `rsg_version=1.2` |
| `automatic_audio_guide_disabled` | integer | Set to 1 to disable screen reader within an app. | `automatic_audio_guide_disabled=1` |
| `disable_audio_guide_shortcut` | integer | Disables the shortcut for activating the screen reader (pressing the options key \[\*\] four times ). | disable\_audio\_guide\_shortcut=1\` |
| `bs_prof_enabled` | boolean | Enable [BrightScript profiling](/docs/developer-program/dev-tools/brightscript-profiler.md) | `bs_prof_enabled=true` |
| `confirm_partner_button` | integer | This new feature has been added that launches a confirmation dialogue before launching an app when the user presses one of the four app-specific buttons on the Roku remote. This minimizes the number of unintended app launches after accidentally hitting a button while fast forwarding or rewinding content in a different app. When this manifest flag is set to “1” (confirm\_partner\_button=1), the OS will display a confirmation HUD (Head Up Display) any time the user presses a partner app button while in that app. By default, the OS will always display this confirmation HUD when a partner button is pressed during video playback, regardless of if the manifest flag has been set. ![roku815px - confirm partner button](https://image.roku.com/ZHZscHItMTc2/confirmpartnerbutton.jpg) | `confirm_partner_button=1` |
| `suppress_unconnected_hud` | integer | Manifest entry for overriding network connectivity HUD. This attribute is used to override the system level display that indicates when media playback is interrupted due to network connection failures. _For more information on the connectivity HUD, please read the related [support article](https://support.roku.com/article/208755728-what-to-do-if-you-can)_ | `suppress_unconnected_hud=[1\|0]`  <br>  <br>(1 suppresses, 0 enables). |
| `dial_title` | string | The name of the title used by the Roku [DIAL](/docs/developer-program/dev-tools/external-control-api.md#dial-discovery-and-launch) server to identify the app. | `dial_title=2Dvideo` |
| `game` | integer | All game apps must add the game manifest entry to their manifest file. This flag prevents the app from having audio/sound effects delays in the game. | `game=1` |

Screensaver attributes
----------------------

For an overview and guide on screensavers, see [Screensavers on Roku](/docs/developer-program/media-playback/screensavers.md).

### Required screensaver attributes

For stand-alone screensavers, only the following attributes are required:

| Attribute | Type | Description | Sample manifest entry |
| --- | --- | --- | --- |
| `screensaver_title` | string | name of the screensaver displayed in Settings | `screensaver_title=Dog Screensaver` |
| `major_version` | integer | major portion of the screensaver version | `major_version=1` |
| `minor_version` | integer | minor portion of the screensaver version | `minor_version=2` |
| `build_version` | integer | build number | `build_version=150` |

Legacy attributes (Deprecated)
------------------------------

The following attributes are no longer required or used by Roku devices:

| Attribute | Type | Description | Sample manifest entry |
| --- | --- | --- | --- |
| `subtitle` | string | Short promotional description of your application for display beneath the title | `subtitle=providing the latest in cool videos` |
| `mm_icon_side_hd` | string | Local URI for side unfocused image for HD | `mm_icon_side_hd=pkg:/images/side-hd.png` |
| `mm_icon_side_sd` | string | Local URI for side unfocused image for SD | `mm_icon_side_sd=pkg:/images/side-sd.png` |
| `requires_audiometadata` | integer | The [roAudioMetadata](/docs/references/brightscript/components/roaudiometadata.md) component requires the use of a dynamically loaded library that is not part of the initially booted image. Therefore, an entry must be added to the manifest of any applications that use the roAudioMetadata component so that it can be loaded when the app is launched. | `requires_audiometadata=1` |
| `requires_bluetooth` | integer | Specifies that a Bluetooth remote must be linked to the box to launch the app. If not, a dialog box is presented to the user. This attribute has been superseded by `requires_gaming_remote`. | `requires_bluetooth=1` |

Component architecture
======================

The BrightScript Component architecture and library are separate from BrightScript, but BrightScript requires them.

*   All APIs exposed to BrightScript are exposed as BrightScript components. In other words, if a platform wants to expose APIs to be scripted, the platform must register a new BrightScript component.
*   BrightScript has language features that are designed to work with BrightScript component Interfaces. These include: for each, print, the array operator, dot operator, and intrinsic objects.
*   Fundamental BrightScript building blocks are implemented as BrightScript components. For example: Lists, Vector Arrays, Associative Arrays, and Objects.

* * *

Brief summary of BrightScript Components
----------------------------------------

BrightScript Components are robust against version changes. In other words, scripts are generally backwards compatible with Objects that have undergone version improvements.

BrightScript Components keep a reference count and delete themselves when the reference count goes to zero.

A key BrightScript Component concept is the Interface. The term Interface is used here as it is in Java or Microsoft COM. An Interface is a known set of member functions that implement a set of logic. In some ways an Interface is like a virtual base class in C++. Any script or C-compatible program can use an object's interface without regard to what type of object it is a part of, as long as it is familiar with a particular interface. For example, the roUrlTransfer component implements four interfaces: ifUrlTransfer, ifHttpAgent, ifSetMessagePort and ifGetMessagePort.

BrightScript statements that work with BrightScript Component Interfaces
------------------------------------------------------------------------

**For each**  
The for-each statement works on any object that has an [ifEnum](/docs/references/brightscript/interfaces/ifenum.md) interface. These include: Array, Associative Array, List, ByteArray, and MessagePort.

**Print**  
If the expression being printed evaluates to an object that has an [ifEnum](/docs/references/brightscript/interfaces/ifenum.md) interface, print will print every item that can be enumerated.  
In addition to printing the values of intrinsic types, PRINT will also print any object that exposes one of these interfaces: [ifString](/docs/references/brightscript/interfaces/ifstring.md), [ifInt](/docs/references/brightscript/interfaces/ifint.md), [ifFloat](/docs/references/brightscript/interfaces/iffloat.md).

**Wait**  
The wait function will work on any object that has an [ifMessagePort](/docs/references/brightscript/interfaces/ifmessageport.md) interface.

**Array operator –"\[\]"**  
The array operator works on any object that has an [ifArrayGet](/docs/references/brightscript/interfaces/ifarrayget.md) or [ifArraySet](/docs/references/brightscript/interfaces/ifarrayset.md) interface. This includes Array, AssociativeArray, ByteArray, and Lists.

**Member access operator "."**  
The "." Operator works on any object that has an [ifAssociativeArray](/docs/references/brightscript/interfaces/ifassociativearray.md) interface (as well as on any BrightScript Component (when calling a member function)). It also has special meaning when used on [roXMLElement](/docs/references/brightscript/components/roxmlelement.md) or [roXMLList](/docs/references/brightscript/components/roxmllist.md).

**Expression parsing**  
Any expression that is expecting an Integer, Float, Double, Boolean or String, can take an object with the [ifInt](/docs/references/brightscript/interfaces/ifint.md), [ifFloat](/docs/references/brightscript/interfaces/iffloat.md), [ifDouble](/docs/references/brightscript/interfaces/ifdouble.md), [ifBoolean](/docs/references/brightscript/interfaces/ifboolean.md), or [ifString](/docs/references/brightscript/interfaces/ifstring.md) interface.

Intrinsic types and object types
--------------------------------

A variable may hold either an "intrinsic type" or an "object type". An intrinsic type is one of Integer, Float, Double, String, Invalid, Boolean or Function. An object type is one of Array, Associative Array or BrightScript Component. The most important difference is a variable containing an intrinsic type contains the value itself; that is, the Integer, Float, Double, etc. is contained within the variable. On the other hand, a variable containing an object type contains merely a pointer or reference to the actual object. Assigning an object type results in two pointers to the same object, while assigning an intrinsic type results in two copies of the same value, which can be modified independently of each other.

    a = 42  ' a contains an intrinsic Integer
    b = a   ' b contains a copy of a
    a = 43  ' does not modify b
    b = 44  ' does not modify a
    
    a = [ 1,2,3 ]   ' a contains a reference to an array
    b = a           ' b contains another reference to the same array
    a[0] = 5        ' now both a[0] and b[0] equal 5
    b[1] = 6        ' now both a[1] and b[1] equal 6
    

The same thing holds true when variables are passed as function parameters. If the variable is intrinsic, the function parameter is a copy of the original. But if the variable is object, the function parameter is merely an additional reference to the same object. That is, intrinsic variables are "passed by value", while object variables are "passed by reference".

**Example**

    function Modify(a as Integer, b as Object) as Void
        a = 43
        b.first = 6
    end function
    
    .....
    
        x = 42
        y = { first: 1, second: 2 }
        Modify(x, y)
        ' now x is still 42 but y.first is 6
    

Each object maintains a "reference count", which is the number of variables which refer to the object. The reference count is set to 1 when the object is created and a reference to it is saved in a variable. When an object's reference count drops to zero, the object is destroyed.

**Example**

    a = CreateObject("roArray")   ' array has a ref count of 1
    b = a                         ' array has a ref count of 2
    a = invalid                   ' array has a ref count of 1 (a no longer refers to it)
    c = b                         ' array has a ref count of 2
    b = 100                       ' array has a ref count of 1 (b no longer refers to it)
    c = invalid                   ' array has a ref count of 0 and is destroyed
    

Note that after the last statement, since no variables refer to the object any longer, it would be impossible to use the object even if it were not destroyed.

Use of wrapper functions on intrinsic types
-------------------------------------------

If an intrinsic types is passed to a function that expects an Object, a "wrapper" object will be created, assigned the correct value, and passed to the function. Wrapper objects are objects which behave like the intrinsic entities that they represent. For example, an integer may be converted to an roInt object, which can be used much like an ordinary integer, but it has object semantics. This automatic conversion to an object is sometimes referred to as "autoboxing".

**Example**

    Function Main()
        MyFunA(4)
        MyFunB(4)
    End Function
    
    Function MyFunA(p as Object) as Void
        print "A",p,type(p)
    End Function
    
    Function MyFunB(p as Integer) as Void
        print "B",p,type(p)
    End Function
    

**Will Print:**

      A 4 roInt  
      B 4
    Integer
    

**Example**

    Print 5.tostr()+"th"   ' prints 5th
    Print "5".toint()+5    ' prints 10
    If type(5.tostr())<> "String" Then Stop
    If (-5).tostr()<>"-5" Then Stop
    If (1+2).tostr()<>"3" Then Stop
    If 5.tostr()<>"5" Then Stop
    i=-55
    If i.tostr()<>"-55" Then Stop
    If 100%.tostr()<>"100" Then Stop
    If (-100%).tostr()<>"-100" Then Stop
    y%=10
    If y%.tostr()<>"10" Then Stop
    If "5".toint()<>5 Or type("5".toint())<>"Integer" Then Stop
    If "5".tofloat()<>5.0 Or type("5".tofloat())<>"Float" Then Stop
    fs="-1.1"
    If fs.tofloat()<>-1.1 Or fs.toint()<>-1 Then Stop
    If "01234567".left(3)<>"012" Then Stop
    If "01234567".right(4)<>"4567" Then Stop
    If "01234567".mid(3)<>"34567" Then Stop
    If "01234567".mid(3,1)<>"3" Then Stop
    If "01234567".instr("56")<>5 Then Stop
    If "01234567".instr(6,"56")<>-1 Then Stop
    If "01234567".instr(0,"0")<>0 Then Stop
    

Note that `-5.tostr()` will cause an error since the dot operator binds tighter than unary negation.

Use: `(-5).tostr()`

BrightScript XML support
------------------------

BrightScript supports XML via two BrightScript Components, and some dedicated language features. The BrightScript Component roXMLElement provides support for parsing, generating, and containing XML. In addition, the roXMLList object is often used to hold lists of roXMLElement, and implements the BrightScript standard ifList interface as well as the ifXMLList interface. Language features are provided via the dot operator, and the @ operator. BrightScript XML support is limited to UTF-8 encoded content.

### Dot operator

*   When applied to an roXMLElement, the dot operator returns an roXMLList of children that match the dot operand. If no tags match, an empty list is returned.
*   When applied to an roXMLList, the dot operator aggregates the results of performing the dot operator on each roXMLElement in the list.
*   When used on XML, which is technically case sensitive, the dot operator is still case insensitive. If you wish to do a case sensitive XML operation, don't use the dot operator. Use the XML member functions.

### Attribute operator

The @ operator can be used on an roXMLElement to return a named attribute. It is always case insensitive (despite the fact that XML is technically case sensitive). When used on an roXMLList, the @ operator will return a value only if the list contains exactly one element.

For example, if the file "example.xml" contains the following:

    <?xml version="1.0" encoding="utf-8" ?>
    <rsp stat="ok">
      <photos page="1" pages="5" perpage="100" total="500">
        <photo id="3131875696" owner="21963906@N06" secret="f248c84625" server="3125" farm="4" title="VNY 16R" ispublic="1" isfriend="0" isfamily="0" />
        <photo id="3131137552" owner="8979045@N07" secret="b22cfde7c4" server="3078" farm="4" title="hoot" ispublic="1" isfriend="0" isfamily="0" />
        <photo id="3131040291" owner="27651538@N06" secret="ae25ff3942" server="3286" farm="4" title="172 • 365 :: Someone once told me..." ispublic="1" isfriend="0"
      </photos>
    </rsp>
    

Then

     rsp=CreateObject("roXMLElement")
     rsp.Parse(ReadAsciiFile("tmp:/example.xml"))
    

? rsp.photos.photo will return an roXMLList with three entries.

? rsp.photos.photo\[0\] will return an roXMLElement reference to the first photo (id="3131875696").

? rsp.photos will return an roXMLList reference containing the photos tag.

rsp.photos@perpage will return the string 100.

Use the GetText() method to return an element's text.  
For example, if the variable booklist contains this roXMLElement:

     <booklist>
     <book lang=eng>The Dawn of Man</book>
     </booklist>
    

then

     print booklist.book.gettext()
    

Will print "The Dawn of Man", and

     print booklist.book@lang
    

will print

    "eng"
    

**Example: flikr**

    REM
    REM Interestingness
    REM pass an (optional) page of value 1 - 5 to get 100 photos
    REM starting at 0/100/200/300/400
    REM
    REM returns a list of "Interestingness" photos with 100 entries
    REM
    Function GetInterestingnessPhotoList(http as Object, page=1 as Integer) as Object
        print "page=";page
        http.SetUrl("http://api.flickr.com/services/rest/?method=flickr.interestingness.getList&api_key=YOURKEYGOESHERE&page="+mid(stri(page),2))
        xml=http.GetToString()
        rsp=CreateObject("roXMLElement")
        If Not rsp.Parse(xml) Then Stop
        Return helperPhotoListFromXML(http, rsp.photos.photo) 'rsp.GetBody().Peek().GetBody())  
    End Function
    
    Function helperPhotoListFromXML(http as Object, xmllist as Object,
        owner=invalid as dynamic) as Object
        photolist=CreateObject("roList")
        For Each photo In xmllist
            photolist.Push(newPhotoFromXML(http, photo, owner))
        End For
        Return photolist
    End Function
    
    REM
    REM newPhotoFromXML
    REM
    REM Takes an roXMLElement Object that is an <photo> ... </photo>
    REM Returns an brs object of type Photo
    REM photo.GetTitle()
    REM photo.GetID()
    REM photo.GetURL()
    REM photo.GetOwner()
    REM
    Function newPhotoFromXML(http as Object, xml as Object, owner as dynamic) as Object
        photo = CreateObject("roAssociativeArray")
        photo.http=http
        photo.xml=xml
        photo.owner=owner
        photo.GetTitle=function():return m.xml@title:end function
        photo.GetID=function():return m.xml@id:end function
        photo.GetOwner=pGetOwner
        photo.GetURL=pGetURL
        Return photo
    End Function
    
    
    Function pGetOwner() as String
        If m.owner <> Invalid Return m.owner
            Return m.xml@owner
    End Function
    
    Function pGetURL() as String
        a=m.xml.GetAttributes()
        url="http://farm"a.farm".static.flickr.com/"a.server"/"a.id"_"a.secret".jpg"
        Return url
    End Function
    

#### Parsing colons in namespace element and attribute tags

For elements and attributes with namespaces, you can use the [roXMLElement interface](/docs/references/brightscript/interfaces/ifxmlelement.md#getattributes-as-object) to parse the colons in their tags. Consider the following XML:

    <media:thumbnail xmlns:media='http://something.something.com/mrss/' url='http://blahblablah.com' width='72' height='72' />
    

To parse these tags, do the following

*   Element with namespace: use `elementArray = GetNamedElements("media:thumbnail")`.
*   Attributes with namespace: use `element.GetAttributes()["xmlns:media"]`.
*   Attributes without namespace: use the @ operator (`element@url`).

Garbage collection
------------------

BrightScript will automatically free strings when they are no longer used, and it will free objects when their reference count goes to zero. This is done at the time the object or string is no longer used; there is no background garbage collection task. This results in very predictable "garbage collection" – there are no unexpected stalls in execution.

A "mark and sweep" garbage collection is run after a script executes, or can be manually forced to run via the debug console. A script can force the Garbage collector to run via the RunGarbageCollector() function. The Garbage collector's purpose is to clean up objects that refer to themselves or have other circular references (which are not managed by the normal reference counting garbage collection).

**Example**

    i=roCreateObject("roInt")
    j=i ' reference incremented
    i=invalid ' reference decremented
    j=0 ' roInt just free'd.
    

Events
------

Events in BrightScript center around an event loop and the roMessagePort BrightScript Component. Any BrightScript Component can be posted to a message port. Typically these will be Objects that are designed to represent an events. For example, the roFilesystem class posts events of type roFilesystemEvent.

**Example**

    fs = CreateObject("roFilesystem")
    port = CreateObject("roMessagePort")
    fs.SetMessagePort(port)
    while true
        msg = wait(0, port)
        if type(msg)="roFileSystemEvent" then
            if msg.isStorageDeviceAdded() then print "device added"
        end if
    End While
    

Threading model
---------------

A BrightScript script runs in a single thread. Multiple threads cannot be created in a BrightScript program. The general rule of thumb is that BrightScript Component calls are synchronous if they return quickly, or asynchronous if they take a long time to complete. For example, class roArray methods are all synchronous. But if "roVideoPlayer" is used to play a video, the Play() method returns immediately while video continues to play (it is asynchronous). As the video plays, it will post events to a message port. Typical events would be "media finished" or "time x reached". Some components have a choice of synchronous or asynchronous methods; for example roUrlTransfer has methods GetToString() which is synchronous (returns only after the transfer is complete) and AsyncGetToString() which is asynchronous (returns immediately and the transfer continues in the background).

This threading model means that the script writer does not have to deal with mutexes, condition variables, and other synchronization objects. The script merely receives and processes messages to handle events happening in the background.

Scope
-----

BrightScript uses the following scoping rules:

*   BrightScript does not support global variables. Except, there is one hard-coded global variable "global" that is an interface to the global BrightScript Component. The global component contains all global library functions. There is also a global context that can be accessed via the [GetGlobalAA()](/docs/references/brightscript/language/runtime-functions.md#getglobalaa-as-object). If in function scope and that function is not a method in an object, "m." also references the global associative array accessed with [GetGlobalAA()](/docs/references/brightscript/language/runtime-functions.md#getglobalaa-as-object).
*   Functions declared with the FUNCTION statement are at global scope, unless they are anonymous, in which case they are local scope.
*   Local variables exist with function Scope. If a function calls another function, that new function has its own scope.
*   Labels exist in function scope.
*   Block Statements (like FOR-END FOR or WHILE-END WHILE) do not create a separate scope.

Creating and using intrinsic objects
------------------------------------

In most of this manual we use the term "object" to refer to a "BrightScript Component". These are C or C++ components with interfaces and member functions that BrightScript uses directly. Other than a few core objects that BrightScript relies upon (roArray, roAssociativeArray, roInt, etc.) BrightScript Components are platform specific.

You can also create "intrinsic" objects in BrightScript itself to use in your scripts. These act in some ways like Components; for example, the syntax to invoke a method in a Component or in an intrinsic object is identical: "object.function()". However, to be clear, these are not BrightScript Components. There is currently no way to create a BrightScript Component in BrightScript, or to create intrinsic objects that have interfaces (they only contain member functions, properties, or other objects).

An intrinsic object is simply an roAssociativeArray which contains function references. When a function is called "from" an Associative Array, a special pointer named "m" is accessible inside the function, which refers to the Associative Array. A "constructor" in BrightScript is a normal function at global scope that creates the Associative Array and fills in its member functions and properties.

"m" the BrightScript "this pointer"
-----------------------------------

A BrightScript object is an roAssociativeArray which contains function pointers. When a member function is called "from" an AssociativeArray, the special variable "m" is set to point to that AssociativeArray. "m" is accessible inside the called function to access other data in the AssociativeArray object.

**Example**

    function Main()
         obj = ConstructMyObject()
         obj.Set("hi!")
         print obj.Get()
         print "--------"
         print obj
         stop
    end function
    
    function ConstructMyObject()
         obj = {
             Set       : function(x) : m.Value = x : end function
             Get       : function() : return m.Value : end function
             Value     : 0
         }
         return obj
    end function
    

Output:

hi!  
\--------  
value: hi!  
get: <bsTypedValue: Function>  
set: <bsTypedValue: Function>

Script libraries
----------------

In addition to the platform BrightScript components discussed in [Brief summary of BrightScript Components](/docs/references/brightscript/language/component-architecture.md#brief-summary-of-brightscript-components), BrightScript enables platform BrightScript libraries to be used in your scripts.  
BrightScript libraries are .brs files that are provided by the platform and compiled into your application when directed via the "Library" keyword to make additional functions available.  
The Roku OS provides some common libraries under the system library directory "common:/LibCore".  
Additional libraries may be provided by the platform for specific usage purposes.

**Example**

Library "v30/bslCore.brs"

The common library file sources can be viewed from the debug console:

    BrightScript> bslCore =
    ReadAsciiFile("common:/LibCore/v30/bslCore.brs")  
    BrightScript> print bslCore
    

### v30/bslCore.brs

This library provides platform constant definitions as well as some common utility functions.

#### bslBrightScriptErrorCodes() as Object

*   Returns an roAssociativeArray with name value pairs of the error name and corresponding integer value, for example ERR\_OKAY = &hFF.

#### bslGeneralConstants() as Object

*   Returns an roAssociativeArray with name value pairs of system constants, for example MAX\_INT = 2147483647.

#### bslUniversalControlEventCodes() as Object

*   Returns an roAssociativeArray with name value pairs of the remote key code (buttons) constants, for example BUTTON\_SELECT\_PRESSED = 6.

#### AsciiToHex(ascii as String) as String

*   Returns the hex encoded string, for example AsciiToHex("Hi!") = "486921".

#### HexToAscii(hex as String) as String

*   Returns a string that is the hex decoded string, for example HexToAscii("486921") = "Hi!".

#### HexToInteger(hex as String) as Integer

*   Returns the integer value of the passed in hex string.

This library includes 2D graphics helper functions on top of the native components.

#### Object dfNewBitmapSet(String filename)

The goal is to enable simple xml descriptions of graphics resources like bitmaps, regions, sprites, animations, and layouts to be used in your games. The library handles parsing, loading, rendering, and animation of sprites sheets (multiple images in a single png file).

*   Filename is the path to an XML file that contains info about bitmap regions, animation frames, and ExtraInfo metadata (any fields you would like) about resources used in 2d games.
*   Returns an roAssociativeArray with the following name value pairs:
    
    *   ExtraInfo: roAssociativeArray
        
        *   Contains any name value pairs the designer desires.
    *   Regions: roAssociativeArray of name, roRegions pairs
        
        *   The roAssociative array returns a set of Regions from Region tag information from the xml.
        *   Used to describe regions of a bitmap
        *   Bitmap contains parameters: name, filename where filename is a .png, .gif, or .jpg file
        *   Region contains parameters: name, x, y, w, h and is a subtag of a bitmap
    *   Animations: roAssociativeArray of name, roArray of roRegion pairs.
        
        *   The top level roAssociativeArray is the animation name with a value of an array of frames that represent the animation
        *   Each frame is an roRegion that is represented in the xml by the "use" parameter. The use parameter refers to a previously defined Bitmap.Region returned in the Regions info.
        *   Animation frame descriptions can be used by the roSprite and roCompositor components.
    *   Backgrounds: roAssociativeArray of name, path pairs.
        
        *   Backgrounds do not create bitmaps at this point
        *   Use in conjunction with dfSetBackground() to manage backgrounds

#### dfDrawMessage(dest as Object, region as Object) as Void

*   dest is an roScreen/roBitmap/roRegion and region is an roRegion
*   greys the entire dest region and draws it the region centered on the drawable dest.

#### dfDrawImage(dest as Object, path as String, x as Integer, y as Integer) as Boolean

*   Returns True if successful
*   Creates a bitmap out of the image stored in the filename "path" and draws it at position (x,y) of the drawable dest.

#### dfSetupDisplayRegions(screen as Object, topx as Integer, topy as Integer, width as Integer, height as Integer) as Object

*   Helper function to setup screen scaling with supplied pillar box or letterbox images to fill the entire screen.
    
*   screen is an roScreen
    
*   topx and topy are the coordinates of the upper left hand corner of the main drawing region
    
*   Width and height is the size of the main drawing region
    
*   Returns an associative array containing the following roRegions
    
    Main: main drawable region  
    Left: left region if there is pillar box area on the left  
    Right: right region if there is a pillar box area on the right  
    Upper: upper region if there is a letterbox area at thetop  
    Lower: lower region if there is a letterbox area at the bottom  
    When using these regions as drawables, your graphics will be translated and clipped to these regions.
    

#### Object dfSetBackground(String backgroundName, Object backgrounds)

*   dfSetBackground helps manage the limited video memory. The video memory does not currently run a defragmenter, and is very limited. These constraints make it important that large bitmaps (like backgrounds that fill the entire screen) are only allocated when needed. It is also helpful if you set your first initial background very early in your program, and then immediately replace the background after it is no longer in use. This helper function supports this background management for your application.
*   backgroundName is a key for the Backgrounds roAssociative array of backgrounds.
*   Backgrounds is an roAssociative array of background name keys and file path string values
*   This function creates an roBitmap out of the background image file and returns a region the size of the entire roBitmap.

###### Example: bslDefender.brs

If spriteMap.xml contains the following:

    <DefenderBitmapSet>
    <ExtraInfo cellsize="40"/>
    <Bitmap name="Background" filespec="pkg:/images/background.png" />
    <Bitmap name="game-over" filespec="pkg:/images/gameover.png" />
    <Bitmap name="title-screen" filespec="pkg:/images/Splash.gif" />
    <Bitmap name="water_strip" filespec="pkg:/images/water_sprite.png">
    <Region name="a" x="0" y="" w="40" h="40" t="225" />
    <Region name="b" x="40" y="0" w="40" h="40" t="225" />
    </Bitmap>
    <Animation name="water">
    <frame use="water_strip.a" />
    <frame use="water_strip.b" />
    </Animation>
    </DefenderBitmapSet>
    

Then

     BrightScript> xml = ReadAsciiFile("pkg:/images/map.xml")
     BrightScript> bitmapset = dfNewBitmapSet(xml)
     BrightScript> cellwidth=app.bitmapset.extrainfo.cellsize.toint()
     BrightScript> print bitmapset.regions
     Background: <Component: roRegion>
     game-over: <Component: roRegion>
     title-screen: <Component: roRegion>
     water_strip.a: <Component: roRegion>
     water_strip.b: <Component: roRegion>
     water_strip: <Component: roRegion>
     BrightScript> print bitmapset.animations.water
     <Component: roRegion>
     <Component: roRegion>
     BrightScript> dfDrawMessage(screen, bitmapset.regions["game-over"])
     BrightScript> REM screen now shows gameover.png image centered on screen

MiniKeyboard
============

Extends [**Group**](/docs/references/scenegraph/layout-group-nodes/group.md "**Group**")

The MiniKeyboard node class allows a user to enter a string of letters and numerals. The string entered is displayed in a [TextEditBox](/docs/references/scenegraph/widget-nodes/texteditbox.md "TextEditBox") node that is part of the MiniKeyboard node.

The MiniKeyboard node is intended for users to enter a simple case-insensitive string consisting of the letters A-Z and the numerals 0-9. It is intended for use in functions such as "Search", where the entered string need not support general case-sensitive text entry. For general text entry, use a [Keyboard](/docs/references/scenegraph/widget-nodes/keyboard.md "Keyboard") node instead.

The MiniKeyboard node must have the key focus in order to work properly.

The default appearance of the MiniKeyboard node is very transparent, allowing the keyboard to pick up most of its color from what is rendered underneath it. The appearance can be customized by changing the keyboardBitmapUri and other fields.

### Keyboard Bitmap Templates

*   Use the links below to download the template files.
*   The files have opaque white lines that show the key outlines with the rest of the images fully transparent. Looking at the files in some image viewers that do not support transparency will result in the images looking all white.
*   When creating your own keyboard background artwork, you must maintain the size of the image and the position of the keys in order for it to align properly with the rendered key labels and icons.

#### Templates

*   [SD MiniKeyboard Template](https://image.roku.com/ZHZscHItMTc2/SDMiniKeyboardTemplate.png "SD MiniKeyboard Template")
*   [HD MiniKeyboard Template](https://image.roku.com/ZHZscHItMTc2/HDMiniKeyboardTemplate.png "HD MiniKeyboard Template")
*   [FHD MiniKeyboard Template](https://image.roku.com/ZHZscHItMTc2/FHDMiniKeyboardTemplate.png "FHD MiniKeyboard Template")

Fields
------

| Field | Type | Default | Access Permission | Description |
| --- | --- | --- | --- | --- |
| text | string | ""  | READ\_WRITE | Contains the string of characters that has been entered |
| keyColor | color | 0xffffffff | READ\_WRITE | Specifies the color of the key labels and icons when the Keyboard node does not have the focus |
| focusedKeyColor | color | 0xffffffff | READ\_WRITE | Specifies the color of the key labels and icons when the Keyboard node has the focus |
| keyboardBitmapUri | string | ""  | READ\_WRITE | Specifies the URI of an image file to be loaded to replace the default keyboard image drawn underneath the key label and icons.  <br>This image must be carefully designed so that the key positions match the default image. Template images for SD, HD and FHD resolutions are provided below. |
| focusBitmapUri | string | ""  | READ\_WRITE | Specifies the URI of an image file to be loaded to replace the keyboard focus indicator. This should be a 9-patch image so that it can be stretched to the appropriate size for the double width keys |
| textEditBox | TextEditBox node | system default | READ\_ONLY | This provides access to the Keyboard node internal TextEditBox node so that its appearance can be modified. You should not set this field, but you can set the fields of the TextEditBox node (such as, myKeyboard.textEditBox.textColor = "0xFF0000FF") |
| showTextEditBox | boolean | true | READ\_WRITE | Specifies whether or not the Keyboard node internal TextEditBox node is displayed. In most cases, it is desirable to display the TextEditBox node so that the user can see the string as it is entered. In some cases though, you might want to show only the keyboard part of the Keyboard node. In those cases, the text field of the node will still contain the string entered by the user, so it can displayed in some different manner |
| lowerCase | boolean | true | READ\_WRITE | Specifies whether the 26 letter keys are displayed as lowercase or uppercase |

Sample app
----------

[MiniKeyboardExample](https://github.com/rokudev/samples/tree/master/ux%20components/widgets/MiniKeyboardExample) is a sample app demonstrating MiniKeyboard in action.

ifHMAC
======

Implemented by
--------------

| Name | Description |
| --- | --- |
| [roHMAC](/docs/references/brightscript/components/rohmac.md "roHMAC") | The HMAC component provides an interface to the OpenSSL HMAC functions |

Supported methods
-----------------

### Setup(digestType as String, key as Object) as Integer

#### Description

Initializes new HMAC context.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| digestType | String | Selects one of the supported digest algorithms, as documented in [roEVPDigest](/docs/references/brightscript/components/roevpdigest.md "roEVPDigest"). |
| key | Object | An roByteArray containing the key for the MAC. |

#### Return Value

An integer indicating whether the function succeeded (0) or failed (1).

### Reinit() as Integer

#### Description

Re-initializes an existing HMAC context. This can be called to reuse an existing roHMAC object to authenticate new data.

#### Return Value

An integer indicating whether the function succeeded (0) or failed (1).

### Process(message as Object) as Object

#### Description

Digests the data in an array generates a MAC. Calling this method is the same as making the following calls:

    hmac.Reinit()
    hmac.Update(message)
    mac = hmac.Final()
    

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| message | Object | An [roByteArray](/docs/references/brightscript/components/robytearray.md "roByteArray") with the data to be digested. |

#### Return Value

An [roByteArray](/docs/references/brightscript/components/robytearray.md "roByteArray") containing the generated MAC.

### Update(partialMesssage as Object) as Void

#### Description

Adds more data to be digested. The data in the array is added to the current digest.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| partialMesssage | Object | An [roByteArray](/docs/references/brightscript/components/robytearray.md "roByteArray") with the additional data to be digested. |

### Final() as Object

#### Description

Returns an [roByteArray](/docs/references/brightscript/components/robytearray.md "roByteArray") containing the final MAC.

#### Return Value

The final MAC.

roSprite
========

The roSprite object cannot be created directly with a CreateObject() call. It must be associated with a managing roCompositor object. This association is implicitly created by creating an roSprite object with the roCompositor methods NewSprite() or NewAnimatedSprite().

Supported interfaces
--------------------

*   [ifSprite](/docs/references/brightscript/interfaces/ifsprite.md "ifSprite")

roAppInfo
=========

roAppInfo retrieves the developer ID, which can be useful during development. It also retrieves manifest values, such as the title and version number, avoiding the need to parse the manifest file from BrightScript. This object is created with no parameters.

#### Example

**Implementation**

    brush: vb; gutter: false; theme: Confluence
    appInfo = CreateObject("roAppInfo")
    
    print "     ID: " ; appInfo.GetID()
    print "  IsDev: " ; appInfo.IsDev()
    print "  DevID: " ; appInfo.GetDevID()
    print "  Title: " ; appInfo.GetTitle()
    print "Version: " ; appInfo.GetVersion()
    print "MajVers: " ; appInfo.GetValue("major_version")
    

**Output**

    brush: plain; gutter: false; theme: Confluence
    '      ID: 41089_bd3a
    '   IsDev: false
    '   DevID: 990df3584920876b7e74fe7b29e1f505f148373b
    '   Title: BrightScript Test
    ' Version: 1.0.0
    ' MajVers: 1 
    

Supported interfaces
--------------------

*   [ifAppInfo](/docs/references/brightscript/interfaces/ifappinfo.md "ifAppInfo")

ifSocketOption
==============

Implemented by
--------------

| Name | Description |
| --- | --- |
| [roDataGramSocket](/docs/references/brightscript/components/rodatagramsocket.md "roDataGramSocket") | The roDataGramSocket component enables Brightscript apps to send and receive UDP packets |
| [roStreamSocket](/docs/references/brightscript/components/rostreamsocket.md "roStreamSocket") | The roStreamSocket component enables BrightScript apps to accept and connect to TCP streams as well as send and receive data with them |

Supported methods
-----------------

### GetTTL() as Integer

#### Description

Returns the TTL (Time To Live) value for all IP packets on the socket.

#### Return Value

The TTL value.

### SetTTL(ttl as Integer) as Boolean

#### Description

Sets the TTL value for all IP packets on the socket.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| ttl | Integer | The TTL value to be used for IP packets on the socket. |

#### Return Value

A flag indicating whether the TTL was successfully set.

### GetReuseAddr() as Boolean

#### Description

Checks whether an address that has been previously assigned can be immediately reassigned.

#### Return Value

A flag indicating whether the previously assigned address can be reassigned.

### SetReuseAddr(reuse as Boolean) as Dynamic

#### Description

Enables a previously assigned address to be immediately reassigned.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| Reuse | Boolean | A flag specifying whether the address can be reused. |

#### Return Value

A flag indicating whether the reuse address feature was successfully set.

### GetOOBInline() as Boolean

#### Description

Checks whether Out Of Bounds (OOB) data is read inline with regular data.

#### Return Value

A flag indicating whether OOB data is read inline with regular data.

### SetOOBInline(inline as Boolean) as Boolean

#### Description

Enables Out Of Bounds (OOB) data to be read inline with regular data.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| inline | Boolean | A flag specifying whether OOB data is read inline. |

#### Return Value

A flag indicating whether the OOB inline data feature was successfully set.

### GetSendBuf() as Integer

#### Description

Returns the current send buffer size.

#### Return Value

The buffer size.

### SetSendBuf(size as Integer) as Boolean

#### Description

Sets the current send buffer size.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| size | Integer | The send buffer size to be used. |

#### Description

A flag indicating whether the send buffer size was successfully set.

### GetRcvBuf() as Integer

#### Description

Returns the current receive buffer size.

#### Return Value

The buffer size.

### SetRcvBuf(size as Integer) as Boolean

#### Description

Sets the current receive buffer size.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| size | Integer | The receive buffer size to be used. |

#### Description

A flag indicating whether the receive buffer size was successfully set.

### GetSendTimeout() as Integer

#### Description

Returns the current send timeout.

#### Return Value

The number of seconds for the send timeout.

### SetSendTimeout(timeout as Integer) as Boolean

#### Description

Sets the current send timeout (in seconds).

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| timeout | Integer | The number of seconds for the send timeout. |

#### Return Value

A flag indicating whether the send timeout was successfully set.

### GetReceiveTimeout() as Integer

#### Description

Returns the current receive timeout.

#### Return Value

The number of seconds for the receive timeout.

### SetReceiveTimeout(timeout as Integer) as Boolean

#### Description

Sets the current receive timeout (in seconds).

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| timeout | Integer | The number of seconds for the receive timeout. |

#### Return Value

A flag indicating whether the receive timeout was successfully set.

Activating developer mode
=========================

Once you [get a Roku device](https://www.roku.com/products/players) and [enroll in the Roku developer program](https://developer.roku.com/enrollment/standard), you can put your device in developer mode, sideload apps using the Roku web plug-in, and then [run sample apps](https://github.com/rokudev/) and test and debug your app application.

To activate developer mode on your Roku device, follow these steps:

1.  Use your Roku remote or Roku remote app and press home three times, up twice, and then right, left, right, left, right.
    
    ![roku400px dev-mode](https://image.roku.com/ZHZscHItMTc2/dev-startup1.png)
    

2.  Write down the URL of your Roku device that is displayed on the screen and then enable the Development Application Installer.

3.  Read and accept the [Developer Tools License Agreement](https://docs.roku.com/published/developersdk/en/us), which enables you to build apps with the Roku SDK and other developer tools.

4.  Enter a password for your Roku device (note that passwords are case sensitive). Once you submit the password, your Roku device reboots. When the device finishes rebooting, it is activated in developer mode and ready for sideloading apps.

Sideloading apps
----------------

Sideloading is how you install apps on your Roku device outside of adding them from the Streaming Store. To sideload an app on a Roku device that is in developer mode, follow these steps:

1.  In your web browser, enter the URL of your Roku device.

2.  Log in to your Roku device. In the **User Name** field, enter "rokudev", and then enter the password you created when you enabled developer mode.

3.  The Development Application Installer in the Roku plug-in opens. You use this tool to sideload apps on your Roku device. See [Roku plug-in tools](https://confluence.portal.roku.com:8443/display/DR/Activating+developer+mode#Activatingdevelopermode-plug-in-tools) for more information on the other utilities available in the Roku plug-in.
    
    ![roku600px dev-app-installer](https://image.roku.com/ZHZscHItMTc2/dev-app-installer-squashfs-v3.png)
    

4.  [Download the Roku Hello World sample app](https://github.com/rokudev/hello-world/archive/refs/heads/master.zip), and then extract the archive.

5.  In the Development Application Installer, click **Upload**, and then select the **hello-world-master/dist/apps/hello-world.zip** file. Select the type of compression you want to use for loading the app: **squashfs** or **zip**. Select **squashfs** for faster sideloading.
    
    ![roku600px dev-app-installer](https://image.roku.com/ZHZscHItMTc2/dev-app-installer-squashfs-selected-v2.png)
    

6.  The Hello World app launches on your Roku device and displays "Hello World" on the screen. The sideloaded app is displayed in the bottom row of apps on the Roku home screen by default. In the next section, you will build this app from scratch.
    
    ![roku600px hello-world](https://image.roku.com/ZHZscHItMTc2/hello-world.jpg)
    

> Only one app can be sideloaded at a time. If you sideload another app, the new app replaces the older app on your Roku device.
> 
> If you reinstall an identical version of an app that is already sideloaded on your Roku device, you will receive an error. You can always delete and then re-install an app at any time.

Video demo
----------

[Watch this video](https://image.roku.com/ZHZscHItMTc2/RokuDeveloperMode.mp4) to learn how to activate developer mode on your Roku device and sideload apps.

Roku plug-in tools
------------------

In addition to the Development Application Installer, the Roku plug-in includes **Utilities** and **Packager** tabs.

### Package Utilities

The **Utilities** tab contains several tools essential for Roku app development:

![roku600px package-utilities](https://image.roku.com/ZHZscHItMTc2/package-utilities.png)

*   **Inspect**. Examine the details of a package file such as the developer ID used and the creation date.

*   **Rekey**. Replace the signing key on the current Roku device with a key from an existing package.

*   **Screenshot**. Take HD screenshots highlighting the UI of your sideloaded app.

*   **Profiling data**: Collect app performance statistics such as CPU and memory usage, "wall-clock" time, and function call counts. You can then use the [BrightScript Profiler](https://developer.roku.com/docs/developer-program/dev-tools/brightscript-profiler.md) to analyze the collected data and optimize your app.

#### Package inspector

The package inspector is a utility to inspect the details of the package such as the developer ID used and the creation date. This is helpful for verifying the same developer ID is used when updating a package to ensure any registry data remains intact. The app registry data will be lost when using a different developer ID to update a published app.

#### Rekey utility

The rekey utility allows you to replace the signing key on the current Roku device with a key from an existing package. This utility is most useful when developing multiple apps on the same Roku device. See [Packaging apps](https://developer.roku.com/docs/developer-program/publishing/packaging-channels.md#packaging-with-the-development-application-installer) for how to rekey a Roku device.

#### Screenshot utility

The screenshot utility enables you to take an HD screenshot (1280 X 720) of your sideloaded app's UI (you cannot take a screenshot of any content playback). FHD (1920x1080) screenshots require a 4K-capable Roku set to 1080p or 4K UHD display type. This is useful for generating images that highlight your app in the Streaming Store. See [App Publishing](https://developer.roku.com/docs/developer-program/publishing/channel-publishing-guide.md#screenshots-window) for more information on uploading the screenshots when submitting your app for publishing to the Streaming Store.

#### Profiling data utility

The profiling data utility enables you to capture app performance statistics. You can then use the [BrightScript Profiler](https://developer.roku.com/docs/developer-program/dev-tools/brightscript-profiler.md) to analyze the collected data and determine where performance improvements and efficiencies can be made in the app. See the [BrightScript Profiler documentation](https://developer.roku.com/docs/developer-program/dev-tools/brightscript-profiler.md#collecting-the-data) for more information on collecting data with this tool.

### Application Packager

The Application Packager takes the sideloaded app, signs it, and then generates an encrypted package for publication. This enables developers to securely publish apps while keeping all intellectual property safely encrypted. The process of packaging an app uses cryptographic hardware built into Roku devices and creates an encrypted package that can be easily and securely distributed on Roku devices. For more information, see [Packaging Roku apps](https://developer.roku.com/docs/developer-program/publishing/packaging-channels.md).

![roku600px application-packager](https://image.roku.com/ZHZscHItMTc2/application-packager.png)

ifDeviceInfo
============

Implemented by
--------------

| Name | Description |
| --- | --- |
| [roDeviceInfo](/docs/references/brightscript/components/rodeviceinfo.md) | The roDeviceInfo component provides an interface to obtain attributes about the device |

Supported methods
-----------------

#### Device properties

### GetModel() as String

#### Description

Returns the model name of the Roku device. See the [Hardware Specification](/docs/specs/hardware.md) for the list of the current, updatable, and legacy Roku models.

#### Return Values

A five-character alphanumeric string (for example, "3050X") .

### GetModelDisplayName() as String

#### Description

Returns the model display name of the Roku device.

#### Return Values

The model display name (for example, "Roku 2 XD")

### GetModelType() as String

#### Description

Returns a string describing the type of device. For future compatibility, the caller should by default assume "STB" when anything other than described value is returned

#### Return Values

The device type, which may be one of the following values:

*   "STB": Set-top box.
*   "TV": Roku TV.

### GetModelDetails() as Object

#### Description

Returns detailed information about the device model.

#### Return Values

An associative array containing the following information about the device model:

| Name | Type | Description |
| --- | --- | --- |
| VendorName | String | The model vendor. |
| ModelNumber | String | The model number. |
| VendorUSBName | String | The USB vendor. |
| ScreenSize | String | The size of the Roku TV. |

### GetFriendlyName() as String

#### Description

Returns a string describing the device that may be used for network device selection. The string is subject to change and should not be used as a persistent key or ID

#### Return Values

A user-assigned device name or a description of the device such as model name and/or serial number.

### GetOSVersion() As Object

#### Description

Returns an roAssociativeArray containing the **major**, **minor**, **revision**, and **build** numbers of the Roku OS running on the device.

#### Return Values

An roAssociativeArray containing the following fields:

| Name | Type | Description |
| --- | --- | --- |
| major | string | The major version number (for example, 9) |
| minor | string | The minor version number (for example, 2) |
| revision | string | The firmware revision number (for example, 6) |
| build | string | The build number (for example, 4127) |

### GetVersion() as String

> **This method is deprecated**.
> 
> Developers must update their apps to use [GetOSVersion()](/docs/references/brightscript/interfaces/ifdeviceinfo.md#getosversion-as-object) method to get the current Roku OS version running on a device.

#### Description

Returns the version number of the device.

#### Return Values

A 13-character string (for example "034.08E01185A"). The third through sixth characters are the major/minor version number ("4.08") and the ninth through twelfth are the build number ("1185")

### GetDeviceUniqueId() as String

> **This method is deprecated**.
> 
> Developers must update their apps to use the 32-character alphanumeric unique identifier returned by [GetChannelClientId()](/docs/references/brightscript/interfaces/ifdeviceinfo.md#getchannelclientid-as-string).

#### Description

Returns a string of 12 zeroes (it no longer returns the unique identifier for the app on a device).

#### Return Values

A string of 12 zeros ("000000000000")

### GetAdvertisingId() as String

> **This method is deprecated**.
> 
> Developers must update their apps to use the [GetRIDA()](/docs/references/brightscript/interfaces/ifdeviceinfo.md#getrida-as-string) method to get the unique identifier.

#### Description

Returns a unique identifier for the device. This identifier is persistent but can be reset by the user from the device's Settings menu or by performing a factory reset on the device.

If the user has disabled Ad ID tracking from the settings menu, then this identifier should not be used for targeted advertising. IsAdIdTrackingDisabled() should be called to check if the user has disabled Ad ID tracking

#### Return Values

A Universally Unique Identifier (UUID) as specified in IETF-RFC 4122 with 36 characters (32 alphanumeric characters and four hyphens). The characters are grouped in the form 8-4-4-4-12, for example "123e4567-e89b-12d3-a456-426655440000"

### GetRIDA() as String

#### Description

Returns a unique identifier for the device.

If the user has set "Limit ad tracking" from the **Settings** menu (the user has opted out of targeted advertising), the RIDA is set to a temporary ID. This temporary ID is different than the UUID returned if the user has not opted out, and it expires after 30 days. Apps must still pass this temporary ID on ad server requests to support frequency capping.

> If the user’s country is an EU member country, any data collection must be compliant with the [EU General Data Protection Regulation (GDPR)](/docs/features/legal/compliance.md#gdpr).

#### Return Values

A Universally Unique Identifier (UUID). This identifier is persistent, but it can be reset by the user from the device's **Settings** menu or by performing a factory reset on the device

### IsAdIdTrackingDisabled() as Boolean

> **This method is deprecated**.
> 
> Developers must update their apps to use [IsRIDADisabled()](/docs/references/brightscript/interfaces/ifdeviceinfo.md#isridadisabled-as-boolean) to get the Ad Id tracking status.

#### Description

If Ad Id tracking is disabled, the identifier returned by GetAdvertisingId() should not be used for Ad targeting

#### Return Values

Returns true if the user has disabled Ad Id tracking by selecting "Limit ad tracking" from the Roku Settings menu, false otherwise.

### IsRIDADisabled() as Boolean

#### Description

Indicates whether tracking via Roku's ID for Advertisers (RIDA) is disabled on the device.

#### Return Values

A flag indicating whether RIDA tracking is disabled on the device (RIDA tracking can be disabled by selecting "Limit ad tracking" from the **Settings>Privacy>Advertising** menu). If RIDA tracking is disabled, this returns true; false otherwise.

### GetClientTrackingId() as String

> **This method is deprecated**.
> 
> Developers must update their apps to use the [GetChannelClientId](/docs/references/brightscript/interfaces/ifdeviceinfo.md#getchannelclientid-as-string) method to get the unique identifier.

#### Description

Returns a unique identifier for the device.

#### Return Values

A unique identifier. This identifier is different across apps so each app will get a different identifier when calling this function

### GetChannelClientId() as String

#### Description

Returns a unique identifier for the device. The ID is persistent and cannot be reset. This value can be used to manage or identify devices linked to the app’s content services.

#### Return Values

A unique identifier. This identifier is different across apps so each app will get a different identifier when calling this function

### GetUserCountryCode() as String

Returns the ISO 3166-1 (2-letter) country code associated with the user's Roku account.

#### Return Values

An ISO 3166-1 (2-letter) country code.

> If the app owner entered into an additional agreement to have the app published to a curated [Roku Powered Streaming Store](https://www.roku.com/roku-powered) instead of the user country, a Roku Powered Streaming Store Identifier will instead be returned:

| Roku Powered Streaming Store | Roku Powered Streaming Store Identifier | Country |
| --- | --- | --- |
| Econet | Econet | ZW  |
| Globe | globe | PH  |
| PLDT | PLDT | PH  |
| Sky Germany | skyde | DE  |
| Sky Spain | skyes | ES  |
| Sky Ireland | skyie | IE  |
| Sky Italy | skyit | IT  |
| Sky UK | skyuk | UK  |
| Telstra | Telstra | AU  |

> A future enhancement to GetUserCountryCode() will return the 2-letter country code instead of the Roku Powered Streaming Store Identifier. It is therefore recommended that apps use both to avoid having to update later.

### GetRandomUUID() as String

#### Description

Returns a randomly generated unique identifier. Each time this function is called, a different identifier is returned

#### Return Values

A Universally Unique Identifier (UUID) version 4 as specified in IETF-RFC 4122 with 36 characters (32 alphanumeric characters and four hyphens). The characters are grouped in the form 8-4-4-4-12, for example "123e4567-e89b-12d3-a456-426655440000"

### GetTimeZone() as String

#### Description

Checks for the user's current system time zone setting.

#### Return Values

A string representing the user's current system time zone setting. For example, this method may return values such as:

*   "US/Puerto Rico-Virgin Islands"
*   "US/Guam"
*   "US/Samoa"
*   "US/Hawaii"
*   "US/Aleutian"
*   "US/Alaska"
*   "US/Pacific"
*   "US/Arizona"
*   "US/Mountain"
*   "US/Central"
*   "US/Eastern"
*   "Canada/Pacific"
*   "Canada/Mountain"
*   "Canada/Central Standard"
*   "Canada/Central"
*   "Canada/Eastern"
*   "Canada/Atlantic"
*   "Canada/Newfoundland"
*   "Europe/Germany"
*   "Europe/Iceland"
*   "Europe/Ireland"
*   "Europe/United Kingdom"
*   "Europe/Portugal"
*   "Europe/Central European Time"
*   "Europe/Greece/Finland"

> Click [here](/docs/references/brightscript/interfaces/time-zones.md) for the complete list of time zones returned by this method.

### HasFeature(feature as String) as Boolean

#### Description

Checks if the current device/firmware supports the passed in feature string.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| feature | String | The feature to be checked, which may be one of the following values:<br><br>*   "5.1\_surround\_sound"<br>*   "can\_output\_5.1\_surround\_sound"<br>*   "sd\_only\_hardware"<br>*   "usb\_hardware"<br>*   "sdcard\_hardware"<br>*   "ethernet\_hardware"<br>*   "gaming\_hardware"<br>*   "energy\_star\_compliant"<br>*   "soundbar\_hardware". Check whether the device has soundbar hardware (for example, speakers).<br>*   "voice\_remote" (). Checks whether a Roku device is paired with a Roku voice remote. This enables developers to tailor the in-app user experience for viewers with Roku voice remote controls.<br>*   "handsfree\_voice" (). Checks whether a Roku device is paired with a hands-free Roku remote control such as the Roku Voice Remote Pro. This enables developers to tailor the in-app user experience for viewers with hands-free Roku remote controls (for example, displaying voice tips and tricks in the UI). |

> The "1080p\_hardware" argument is deprecated. Apps should use the GetVideoMode() and CanDecodeVideo() functions instead

#### Return Values

A flag indicating whether the current device/firmware supports the passed in feature string.

### GetCurrentLocale() as String

#### Description

Gets the current locale value based on the user's language setting.

#### Return Values

A string representing the current locale based on the user's language setting. The string is an ISO 639-1 (2-letter) language code followed by an underscore and a ISO 3166-1 (2-letter) country code. This may be one of the following values:

| String | Locale |
| --- | --- |
| "en\_US" | US English |
| "en\_GB" | British English |
| "en\_AU" | Australian English |
| "fr\_CA" | Canadian French |
| "es\_ES" | International Spanish |
| "es\_MX" | Mexican Spanish |
| "de\_DE" | German |
| "it\_IT" | Italian |
| "pt\_BR" | Brazilian Portuguese |

### GetCountryCode() as String

#### Description

Checks for the country code of the app.

#### Return Values

A value that indicates the Streaming Store associated with a user’s Roku account. Typically, the value returned will be an ISO 3166-1 (2-letter) country code representing the country. Alternatively, if the app owner entered into an additional agreement to have the app published to a curated [Roku Powered Streaming Store](https://www.roku.com/roku-powered) instead of the user country, then a Roku Powered Streaming Store Identifier will instead be returned. This may be one of the following values:

| Value | Country | Roku Powered Streaming Store (if applicable) |
| --- | --- | --- |
| "AR" | Argentina |     |
| "AU" | Australia |     |
| "BR" | Brazil |     |
| "CA" | Canada |     |
| "CL" | Chile |     |
| "CO" | Colombia |     |
| "CR" | Costa Rica |     |
| "DE" | Germany |     |
| "Econet" | Zimbabwe | Econet |
| "FR" | France |     |
| "GB" | Great Britain and Northern Ireland |     |
| "globe" | Philippines | Globe |
| "GT" | Guatemala |     |
| "HN" | Honduras |     |
| "IE" | Republic of Ireland |     |
| "MX" | Mexico |     |
| "OT" | Rest of World |     |
| "PA" | Panama |     |
| "PE" | Peru |     |
| "PLDT" | Philippines | PLDT |
| "Telstra" | Australia | Telstra |
| "skyde" | Germany | Sky Germany |
| "skyes" | Spain | Sky Spain |
| "skyie" | Ireland | Sky Ireland |
| "skyit" | Italy | Sky Italy |
| "skyuk" | United Kingdom | Sky UK |
| "SV" | El Salvador |     |
| "US" | United States |     |

> This does not necessarily match the physical location of the device, nor does it necessarily match the last two letters of the current locale string.

### GetPreferredCaptionLanguage() as String

#### Description

Checks the two-letter ISO 639-1 language terminology code of the preferred caption language set on the Roku device.

#### Return Values

The two-letter ISO 639-1 language terminology code, which may be one of the following values:

| Language | Code |
| --- | --- |
| English | en  |
| Spanish | sp  |
| French | fr  |
| German | de  |
| Italian | it  |
| Portuguese | Pt  |
| Russian | ru  |
| Turkish | tr  |
| Polish | Pl  |
| Ukranian | uk  |
| Romanian | Rm  |
| Dutch | nl  |
| Croatian | hr  |
| Hungarian | hu  |
| Greek | el  |
| Czech | cs  |
| Swedish | sv  |

### TimeSinceLastKeypress() as Integer

#### Description

Checks for the number of seconds passed since the last remote keypress.

#### Return Values

The number of seconds since the last remote keypress was received.

### GetDrmInfo() as Object

> **This method is deprecated**.
> 
> Developers must update their apps to use the replacement API [GetDrmInfoEx()](/docs/references/brightscript/interfaces/ifdeviceinfo.md#getdrminfoex-as-object) to return the supported DRM system and features.

#### Description

Checks for the supported DRM system and its features.

#### Return Values

An associative array with the supported DRM system and features. For example, a device that supports PlayReady inside a trusted environment with secure stop returns:

`{"playready": "tee;ss"}`

The values for the PlayReady key above are:

*   **tee** indicates the core DRM system runs in a Trusted Execution Environment
*   **ss** indicates the DRM system supports secure stop

### GetDrmInfoEx() as Object

**Description**

Checks for the DRM system used by the app.

**Return Values**

An associative array with the supported DRM system and features:

**Example**

    PlayReady : {
        multikey: false
        securestop: true
        tee: false
        version: "2.5"
        securityLevel: "3000"
    }
    Widevine : {
        multikey: true
        securestop: false
        tee: false
        version: "widevine 16.4.0"
        securityLevel: "1"
    }
    

> tee indicates the core DRM system runs in a Trusted Execution Environment.

### GetCaptionsMode() as String

#### Description

Determines whether global captions are turned on or off, or are in instant replay mode.

#### Return Values

The current global setting for the Mode property, which may be one of the following values:

*   On
*   Off
*   Instant replay

> On a Roku TV, when the user selects "On Mute", this function will return "On" when the TV is muted and "Off" when it is not muted.

### SetCaptionsMode(mode as String) as Boolean

#### Description

Sets the current global setting for the Mode property.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| mode | String | The current global setting for the Mode property, which may be one of the following values:<br><br>*   On<br>*   Off<br>*   Instant replay<br>*   When mute (Roku TVs only) |

#### Return Values

A flag indicating whether the Mode property was successfully set.

### GetCaptionsOption(option as String) as String

#### Description

Checks the current value of the specified global setting property.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| Option | String | The global setting property to be checked, which may be one of the following values:<br><br>*   Mode<br>*   Text/Font<br>*   Text/Effect<br>*   Text/Size<br>*   Text/Color<br>*   Text/Opacity<br>*   Background/Color<br>*   Background/Opacity<br>*   Window/Color<br>*   Window/Opacity<br>*   Track<br>*   Track\_Composite<br>*   Track\_Analog<br>*   Muted |

#### Return Values

The value of the specified global setting property, which may be as follows:

| Queried Property | Possible Values |
| --- | --- |
| Mode | *   On<br>*   Off<br>*   Instant replay<br>*   When mute (Roku TVs only) |
| Text style | *   Default<br>*   Serif Fixed Width<br>*   Serif Proportional<br>*   Sans Serif Fixed Width<br>*   Sans Serif Proportional<br>*   Casual<br>*   Cursive<br>*   Small Caps |
| Text edge effect | *   Default<br>*   None<br>*   Raised<br>*   Depressed<br>*   Uniform<br>*   Drop shadow (left)<br>*   Drop shadow (right) |
| Text size | *   Default<br>*   Extra large<br>*   Large<br>*   Medium<br>*   Small<br>*   Extra small |
| Text color | *   Default<br>*   White<br>*   Black<br>*   Red<br>*   Green<br>*   Blue<br>*   Yellow<br>*   Magenta<br>*   Cyan |
| Text opacity | *   Default<br>*   25%<br>*   75%<br>*   100% |
| Background Color | *   Default<br>*   White<br>*   Black<br>*   Red<br>*   Green<br>*   Blue<br>*   Yellow<br>*   Magenta<br>*   Cyan |
| Background Opacity | *   Default<br>*   Off<br>*   25%<br>*   75%<br>*   100% |
| Window Color | *   Default<br>*   White<br>*   Black<br>*   Red<br>*   Green<br>*   Blue<br>*   Yellow<br>*   Magenta<br>*   Cyan |
| Window Opacity | *   Default<br>*   Off<br>*   25%<br>*   75%<br>*   100% |

#### Example

    di = CreateObject("roDeviceInfo")
    mode = di.GetCaptionsMode()
    
    print "Font=";di.GetCaptionsOption("Text/Font")
    print "Color=";di.GetCaptionsOption("Text/Color")
    print "Size=";di.GetCaptionsOption("Text/Size")
    print "Effect=";di.GetCaptionsOption("Text/Effect")
    print "Opacity=";di.GetCaptionsOption("Text/Opacity")
    print "Background Color=";di.GetCaptionsOption("Background/Color")
    print "Background Opacity=";di.GetCaptionsOption("Background/Opacity")
    print "Window Color=";di.GetCaptionsOption("Window/Color")
    print "Window Opacity=";di.GetCaptionsOption("Window/Opacity")
    

### GetClockFormat() as String

#### Description

Checks whether the system settings for Time (**Setting > System > Time**) is set to a 12 or 24-hour format.

#### Return Values

The time format:

*   "12h": 12-hour AM/PM format
*   "24h": 24-hour format
*   "": error

### IsClockValid() as Dynamic

#### Description

Checks if the device's system clock is valid.

#### Return Values

A flag indicating whether the system clock on the device is valid.

### EnableValidClockEvent(enable as Boolean) as Dynamic

_Available since Roku OS 13.0_

#### Description

Notifies the app when the device's system clock becomes valid.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| enable | Boolean | A flag specifying whether to enable valid system clock events. |

#### Return Values

A flag indicating whether valid system clock events are enabled (true) or disabled (false).

### EnableAppFocusEvent(enable as Boolean) as Dynamic

#### Description

Notifies the app when a system overlay event (such as the [confirm partner button HUD](/docs/developer-program/getting-started/architecture/channel-manifest.md#special-purpose-attributes) or the caption control overlay) is displayed. This notification gives the app the opportunity to do any processing they may want to when the app loses or regains focus.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| enable | Boolean | A flag specifying whether to enable/disable system overlay event notifications. |

#### Return Values

A flag indicating whether the system overlay event notifications are enabled (true) or disabled (false).

### EnableScreensaverExitedEvent(enable as Boolean) as Dynamic

#### Description

Notifies the app when a screensaver exit event occurs. This function enables the sending of an [roDeviceInfoEvent](/docs/references/brightscript/events/rodeviceinfoevent.md) when a user has exited the screensaver.

To receive events, you must have first called [SetMessagePort](/docs/references/brightscript/interfaces/ifsetmessageport.md) on the roDeviceInfo object specifying the message port that is to receive the events

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| enable | Boolean | A flag specifying whether to enable/disable screensaver exit event notifications. |

#### Return Values

A flag indicating whether screensaver exit event notifications are enabled (true) or disabled (false).

### IsHDMIConnected() as Boolean

> **This method is deprecated**.
> 
> Developers must use the [ifHdmiStatus](/docs/references/brightscript/interfaces/ifhdmistatus.md) interface functions instead.

#### Description

Checks for an HDMI connection.

#### Return Values

A flag indicating whether an HDMI connection to a TV has been detected.

### EnableLowGeneralMemoryEvent(enabled as Boolean) as Dynamic

#### Description

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| enable | Boolean | A flag specifying whether to enable/disable lowGeneralMemoryLevel event notifications. |

#### Return Values

A flag indicating whether lowGeneralMemoryLevel event notifications are enabled (true) or disabled (false).

### GetGeneralMemoryLevel() as String

#### Description

Checks the general memory levels of the device.

#### Return Values

Returns the general memory levels of the app, which may be one of the following values:

*   "normal"
*   "low"
*   "critical"

### IsStoreDemoMode() as Boolean

#### Description

Checks whether the device is in demo mode.

#### Return Values

A flag indicating whether the device is in demo mode.

#### Network info

### GetLinkStatus() as Boolean

#### Description

Checks if the device has an active connection.

#### Return Values

A flag indicating whether the device has an active connection.

### EnableLinkStatusEvent(enable as Boolean) as Boolean

#### Description

Notifies the app when a network connection status event occurs. This function enables the sending of an [roDeviceInfoEvent](/docs/references/brightscript/events/rodeviceinfoevent.md) when the network connection status changes. To receive events, you must have first called [SetMessagePort](/docs/references/brightscript/interfaces/ifsetmessageport.md) on the roDeviceInfo object specifying the message port that is to receive the events

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| enable | Boolean | A flag specifying whether to enable/disable network connection status event notifications. |

#### Return Values

A flag indicating whether network connection status event notifications are enabled (true) or disabled (false).

### GetConnectionType() as String

#### Description

Checks whether the device has a WiFi or wired connection, or if it is not connected through any type of network.

#### Return Values

The type of internet connection the device is using. This may be one of the following values:

*   "WiFiConnection"
*   "WiredConnection"
*   "" (the device does not have an Internet connection)

### EnableInternetStatusEvent(enable as Boolean) as Boolean

#### Description

Notifies the app when an internet connection status event occurs. This function enables the sending of an [roDeviceInfoEvent](/docs/references/brightscript/events/rodeviceinfoevent.md) when the network connection status changes, as indicated by `roDeviceInfoEvent.internetStatus`. To receive events, the app must have first called [SetMessagePort](/docs/references/brightscript/interfaces/ifsetmessageport.md) on the roDeviceInfo object specifying the message port that is to receive the events.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| enable | Boolean | A flag specifying whether to enable/disable network connection status event notifications. |

#### Return Values

A flag indicating whether network connection status event notifications are enabled (true) or disabled (false).

### GetInternetStatus() as Boolean

#### Description

Checks the internet connection status of the device.

#### Return Value

True if the cached internet status shows a connection; false, otherwise.

### ForceInternetStatusCheck() as Boolean

#### Description

Forces a new internet connection check. A new check will only be initiated if the cached internet status is older than 10 seconds.

#### Return Value

True indicates only that a new internet check has been initiated; otherwise, false. To get the actual internet connection status, use the [**GetInternetStatus()**](getinternetstatus-as-boolean) method.

### GetExternalIp() as String

#### Description

Checks the IP address assigned to the device by your internet service provider (ISP). This IP address is visible to the internet and all other computers outside your local network.

#### Return Values

The external IP address assigned to the device.

### GetIPAddrs() as Object

#### Description

Checks the local IP address of the device.

#### Return Values

An associative array, where each key is the name of a network interface and the value is the IP-address of the interface. Typically, the associative array only contains a single interface.

### GetConnectionInfo() as Object

#### Description

Checks for the information associated with the hardware's connection

#### Return Values

An associative array with the following key-value pairs:

| Key | Value |
| --- | --- |
| type | Same as the value returned from GetConnectionType(). Indicated whether the device is using a WiFiConnection or WiredConnection. |
| name | Name of the connection interface. |
| ip  | IP address used by the connection. |
| ipv6  <br>  <br>_Available since Roku OS 12.0_ | A list of IPv6 addresses used by the connection. |
| mac | _This field is deprecated_  <br>  <br>The device's MAC address is no longer returned (a string of zeros is returned in this field). Developers can use the [roDeviceInfo.GetChannelClientId](/docs/references/brightscript/interfaces/ifdeviceinfo.md#getchannelclientid-as-string) method to uniquely identify devices. |
| ssid | The SSID of the Access Point (present only if type = "WiFiConnection"). |
| gateway | IP Address of the connection gateway (usually the router). |
| dns.0 | IP Address of first DNS server associated with the connection. |
| dns.1 | IP Address of the second DNS server, if any (Similarly for any subsequent DNS servers). |
| dns.2 | IP Address of the third DNS server, if any (Similarly for any subsequent DNS servers). |
| dns.3 | IP Address of the fourth DNS server, if any (Similarly for any subsequent DNS servers). |
| active | A flag indicating the network status. |
| default | A flag indicating whether the default WiFi connection is being used. |
| expectedThroughput | The actual speed of the connection. This rate may be significantly lower than the theoretical maximum because of interference, distance, network overhead, and other factors. In ideal conditions, a single client might achieve approximately 65-70% of the physical rate. |
| protocol | The Wifi protocol name (IEEE 802.11g). |
| signal | The received signal strength indicator (RSSI). Values closer to 0 indicate a stronger signal; values closer to -100 indicate a weaker signal. |
| ssid | The service set identifier (SSID). The name of the WiFi network to which the device is connected. |
| txFailed | The number of dropped frames. |
| txRetries | The number of retries to send frames. |

#### Video info

### GetDisplayType() as String

#### Description

Gets the text corresponding to the button selection in the Player Info Settings/Display Type page.

#### Return Values

The display type, which may be one of the following values:

*   "HDTV"
*   "4:3 standard"
*   "16:9 anamorphic"

### GetDisplayMode() as String

#### Description

Checks the UI resolution of the device.

#### Return Values

The configured graphics layer resolution, which may be one of the following values:

*   "480i" or "480p" (the **ui\_resolutions** manifest entry includes **sd** as a supported resolution).
*   "720p"
*   "1080p" (the **ui\_resolutions** manifest file entry includes **fhd** as a supported resolution)

### GetDisplayAspectRatio() as String

#### Description

Checks the aspect ratio for the display screen.

#### Return Values

The aspect ratio, which may be one of the following values:

*   "4x3"
*   "16x9"

### GetDisplaySize() as Object

#### Description

Checks the display size of a screen.

#### Return Values

An associative array with the screen width and height. Specifically, the keys "w" and "h" contain the values for the screen width and height respectively. This may be one of the following:

*   720 and 480
*   1280 and 720
*   1920 and 1080

### GetVideoMode() as String

#### Description

Checks the video playback resolution.

#### Return Values

The video playback resolution, which maybe one of the following values:

| String | Resolution | Aspect Ratio | Refresh Rate | Bit Depth |
| --- | --- | --- | --- | --- |
| "480i" | 720x480 | 4:3 | 60 Hz | 8 Bit |
| "480p" | 720x480 | 4:3 | 60 Hz | 8 Bit |
| "576i25" | 720x576 | 4:3 | 25 Hz | 8 Bit |
| "576p50" | 720x576 | 4:3 | 50 Hz | 8 Bit |
| "576p60" | 720x576 | 4:3 | 60 Hz | 8 Bit |
| "720p50" | 1280x720 | 16:9 | 50 Hz | 8 Bit |
| "720p" | 1280x720 | 16:9 | 60 Hz | 8 Bit |
| "1080i50" | 1920x1080 | 16:9 | 50 Hz | 8 Bit |
| "1080i" | 1920x1080 | 16:9 | 60 Hz | 8 Bit |
| "1080p24" | 1920x1080 | 16:9 | 24 Hz | 8 Bit |
| "1080p25" | 1920x1080 | 16:9 | 25 Hz | 8 Bit |
| "1080p30" | 1920x1080 | 16:9 | 30 Hz | 8 Bit |
| "1080p50" | 1920x1080 | 16:9 | 50 Hz | 8 Bit |
| "1080p60b10" | 1920x1080 | 16:9 | 60 Hz | 8 Bit |
| "1080p60Dv" | 1920x1080 | 16:9 | 60 Hz | 8 Bit |
| "1080p" | 1920x1080 | 16:9 | 60 Hz | 8 Bit |
| "2160p24" | 3840x2160 | 16:9 | 24 Hz | 8 Bit |
| "2160p25" | 3840x2160 | 16:9 | 25 Hz | 8 Bit |
| "2160p30" | 3840x2160 | 16:9 | 30 Hz | 8 Bit |
| "2160p30Dv" | 3840x2160 | 16:9 | 30 Hz | 8 Bit |
| "2160p50" | 3840x2160 | 16:9 | 50 Hz | 8 Bit |
| "2160p60" | 3840x2160 | 16:9 | 60 Hz | 8 Bit |
| "2160p60Dv" | 3840x2160 | 16:9 | 60 Hz | 8 Bit |
| "2160p24b10" | 3840x2160 | 16:9 | 24 Hz | 10 Bit |
| "2160p25b10" | 3840x2160 | 16:9 | 25 Hz | 10 Bit |
| "2160p30b10" | 3840x2160 | 16:9 | 30 Hz | 10 Bit |
| "2160p50b10" | 3840x2160 | 16:9 | 50 Hz | 10 Bit |
| "2160p60b10" | 3840x2160 | 16:9 | 60 Hz | 10 Bit |
| "4320p60" | 7680 x 4320 | 16:9 | 60 Hz | 12 Bit |
| "4320p60b10" | 7680 x 4320 | 16:9 | 60 Hz | 12 Bit |

### GetDisplayProperties() as Object

#### Description

Checks for the display properties of the screen.

#### Return Values

An associative array with the following key/value pairs for the display properties of the screen:

| Key | Type | Value |
| --- | --- | --- |
| Width | Integer | Physical width of the attached display in centimeters |
| Height | Integer | Physical height of the attached display in centimeters |
| Internal | Boolean | Set to true if the display is part of the Roku Player (such as a Roku TV), false otherwise |
| Hdr10 | Boolean | Set to true if the attached display supports HDR10, false otherwise |
| Hdr10Plus | Boolean | Set to true if the attached display supports HDR10+, false otherwise |
| HdrSeamless | Boolean | Set to true if the attached display supports any type of HDR, such as HDR10, HLG, or  <br>Dolby Vision, false otherwise. |
| Headless | Boolean | Set to true if the attached display supports being powered off while audio continues to play |
| HLG | Boolean | Set to true if the attached display supports HLG, false otherwise |
| DolbyVision | Boolean | Set to true if the attached display supports Dolby Vision, false otherwise |
| visible | boolean | For Roku TVs only. Indicates whether the TV screen is on/off while the Roku device is actively streaming content. This is useful for checking whether customers have muted their TV screen while streaming video in order to continue listening to the audio (for example, when playing music videos, conferences, or podcasts). |

### GetSupportedGraphicsResolutions() as Object

#### Description

Checks the supported graphics resolutions.

#### Return Values

A list of associative arrays. Each associative array contains the following key/value pairs for the graphics resolutions:

| Key | Type | Value |
| --- | --- | --- |
| width | integer | The pixel width of the supported resolution |
| height | integer | The pixel height of the supported resolution |
| name | string | Either SD, HD, or FHD |
| ui  | boolean | True if this resolution is the current Roku UI resolution |
| preferred | boolean | True if this is the preferred UI resolution, i.e., if this is the optimal resolution for the device |

### CanDecodeVideo(video\_format as Object) as Object

#### Description

Checks whether the device can decode and play the specified video format.

#### Parameters

NameTypeDescriptionvideo\_formatObjectAn associative array with the following key/value pairs specifying the video format to be checked.  
  
As of Roku OS 14.1, the keys in the associative array are fully case-insensitive. For older OS versions, use lower-case letters for the keys when specified within double quotes ("").  
  
KeyTypeValueRequirementCodecstringSpecifies the video codec:

| Codec | Profile | Level |
| --- | --- | --- |
| "mpeg2" | n/a | "main", "high" |
| "mpeg4 avc" 1 | "main", "high" | "4.1", "4.2" |
| "hevc" 1 | "main", "main 10" | "4.1", "5.0", "5.1" |
| "vp9" 1 | "profile 0", "profile 2" | "4.1", "5.0", "5.1" |

RequiredProfilestringSpecifies the profileOptionalLevelstringSpecifies the levelOptionalContainerstringSpecifies the container format: “mp4”, “hls”, “mkv”, “ism”, “dash”, “ts”Optional

> All the codecs, except "mpeg2", can provide additional display info (bit depth, refresh rate, display width, display height) if the codec, profile, and level are passed as parameters.
> 
> For example, if the application wants to check if the Roku Player can play an AVC stream at high profile and level 4.2, it calls [CanDecodeVideo()](/docs/references/brightscript/interfaces/ifdeviceinfo.md#candecodevideovideo_format-as-object-as-object) with the following video\_format:
> 
> `{Codec: "mpeg4 avc", Profile: "high", Level: "4.2"}`
> 
> Format keys that are not provided by the caller are not taken into account and not updated. For example, calling [CanDecodeVideo()](/docs/references/brightscript/interfaces/ifdeviceinfo.md#candecodevideovideo_format-as-object-as-object) with a format description that has only a codec key (such as `{"codec": "vp9"}`) will return that same format if the device can decode and play that codec at all, even if the decode capability is limited to one specific container, profile, and level.
> 
> For Roku streaming players, an HDMI connection or television setting may affect whether the device actually supports a video format, regardless of the values returned by this function. It is therefore recommended that the application also call the [GetVideoMode() function](#getvideomode-as-string), which reports the current video playback resolution.

#### Return Values

An associative array that includes a flag indicating whether the video format can be played, and the closest video format supported by the device.

If the Roku Player cannot play that video format, it will return false, and return the closest video format it can play, with the changed fields, such as:

`{"codec":["hevc","mpeg1","mpeg2","h263","mpeg4 avc","vp9"],"result":false,"updated":"codec"}`

The return value shows the Roku Player cannot play requested video format, shows the updated keys of the requested video format (level and profile) that it can support, and the all the key values of the requested video format supported by the Roku Player.

### GetUIResolution() as Object

#### Description

Checks for the UI resolution of the screen.

#### Return Values

An associative array with the following key-value pairs describing the current UI resolution:

KeyValuenameThe possible values are:

| Value | Meaning |
| --- | --- |
| SD  | standard definition (720x480 screen pixel dimensions) |
| HD  | high-definition (1280x720 screen pixel dimensions) |
| FHD | full high-definition (1920x1080 screen pixel dimensions) |

widthThe possible values are:

| Value | Meaning |
| --- | --- |
| 720 | standard definition screen pixel width |
| 1280 | high-definition screen pixel width |
| 1920 | full high-definition screen pixel width |

heightThe possible values are:

| Value | Meaning |
| --- | --- |
| 480 | standard definition screen pixel height |
| 720 | high-definition screen pixel height |
| 1080 | full high-definition screen pixel height |

### GetGraphicsPlatform() as String

#### Description

Checks the graphics platform of the device.

#### Return Values

The device's graphics platform, which may be one of the following values:

*   "opengl"
*   "directfb"

### GetVideoDecodeInfo() as Object

> **This method is deprecated**.
> 
> Developers should use the [CanDecodeVideo()](#candecodevideovideo_format-as-object-as-object) function instead.

#### Description

See [http://en.wikipedia.org/wiki/Extended\_display\_identification\_data#EIA.2FCEA-861\_extension\_block](http://en.wikipedia.org/wiki/Extended_display_identification_data#EIA.2FCEA-861_extension_block) for an explanation of the information returned.

#### Return Values

An associative array with the EDID (EIA.2FCEA-861) information describing the video display

### EnableCodecCapChangedEvent(enable As Boolean)

#### Description

Notifies the app when the audio or video codec changes. This function enables the sending of an [roDeviceInfoEvent](/docs/references/brightscript/events/rodeviceinfoevent.md) when the codec changes. To receive events, you must have first called [SetMessagePort](/docs/references/brightscript/interfaces/ifsetmessageport.md) on the roDeviceInfo object specifying the message port that is to receive the events

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| enable | Boolean | A flag indicating whether to enable/disable codec change event notifications. |

#### Return Values

A flag indicating whether codec change event notifications are enabled (true) or disabled (false).

#### Audio info

### GetAudioOutputChannel() as String

#### Description

Checks for the type of audio output.

#### Return Values

The selected audio output, which may be one of the following values:

*   "Stereo"
*   "5.1 surround"

### GetAudioDecodeInfo() as Object

> **This method is deprecated**.
> 
> Developers should use the [CanDecodeAudio()](#candecodeaudioaudio_format-as-object-as-object) function instead.

#### Description

Lists each audio decoder supported by the device, with up to four numbers describing the decoder from the EDID SAD (Short Audio Descriptor). Each value is of the form "::::"

#### Return Values

An associative array with EDID (EIA.2FCEA-861) audio decoder information for the device connected to the HDMI port (or the device itself for a Roku TV).

For example, the name "DD+" may have the value "8:6:0:1" where there are 8 independent audio tracks (7.1 audio), 6 is the SAD1 byte, 0 is the SAD2 byte, and 1 is the binary value that indicates this is a pass-through audio device (not a Roku TV). The SAD1 and SAD2 bytes are interpreted differently for different codecs and more information about their values can be found here: [http://en.wikipedia.org/wiki/Extended\_display\_identification\_data#CEA\_EDID\_Timing\_Extension\_Version\_3\_data\_format](http://en.wikipedia.org/wiki/Extended_display_identification_data#CEA_EDID_Timing_Extension_Version_3_data_format)

#### Example

The following example demonstrates how to determine if the attached device supports Dolby Digital Plus audio:

    di = CreateObject("roDeviceInfo")
    audioDecoders = di.GetAudioDecodeInfo()
    
    REM Check for surround sound codecs:
    hasDolbyDigital = audioDecoders.doesexist("AC3")
    hasDTS = audioDecoders.doesexist("DTS")
    hasDDPlus = audioDecoders.doesexist("DD+")
    

> The definition of hasFeature (“5.1\_surround\_sound”) has changed in Roku OS 6.1. In previous firmware revisions it returned true when the user set the system audio format to "Surround Sound". In Roku OS6.1 and above, it returns true when any of the codecs in the GetAudioDecodeInfo() AA has more than 2 audio channels. Users devices will also be default to the "Auto Detect" system HDMI audio setting in v6.1.

### CanDecodeAudio(audio\_format as Object) as Object

#### Description

Checks if the device can decode and play the specified audio format.

> Use this method to query the codecs every time before starting playback on content (do not cache and use the results from a previous call). In addition, use the [**roDeviceInfo.audioCodecCapabilityChanged()**](/docs/references/brightscript/events/rodeviceinfoevent.md) event to identify any codec changes that may occur when the audio output destination is switched. This will help your app to perform well with the Roku mobile app and and private listening.

#### Parameters

NameTypeDescriptionaudio\_formatObjectAn associative array with the audio format to be checked. The general format of the associative arrays for CanDecodeAudio() is similar to the parameter and return associative arrays used in [CanDecodeVideo()](#candecodevideovideo_format-as-object-as-object).  
  
As of Roku OS 14.1, the keys in the associative array are fully case-insensitive. For older OS versions, use lower-case letters for the keys when specified within double quotes ("").  
  
KeyTypeValueRequirementCodecstringSpecifies the audio codec: “aac”, “ac3”, “eac3”, "alac", "flac", “mp2”, “mp3”, “vorbis”, “wma” (sunset as of Roku OS 12.5), “wma pro” (sunset as of Roku OS 12.5), “dts”, "ac4"RequiredProfilestringSpecifies the codec profile:

| Codec | Profile |
| --- | --- |
| "h.265/h.265" | "main", "high", "main 10" |
| "vp9" | "profile 0", "profile 2" |
| "AAC codec profiles" | "mp2 lc", "mp4 he" |

OptionalLevelStringSpecifies the codec level:

| Codec | Level |
| --- | --- |
| "h.265/h.265" | 4.1, 4.2, 5.0, 5.1 |
| "vp9" | 3.0, 3.1, 4.0, 4.1, 5.0, 5.1 |

OptionalChCntintegerSpecifies the required number of audio channelsOptionalPassThruintegerSpecifies whether the bitstream needs to be decoded on the device. By default, this reports the codec properties of both the Roku device and the attached HDMI device.  
  
You can filter the values returned by including one of the following options:

*   **0** - Reports only codecs that are supported on the Roku device itself.
*   **1** - Reports only codecs of the attached HDMI device (for example, an audio receiver).

OptionalAtmosIntegerSpecifies whether Atmos presence is to be validated. Include 'atmos=1' to check for the presence of Atmos. Starting with Roku OS 14.1,'atmos=0' can be used to specifically check for the absence of Atmos.OptionalSampleRateintegerSpecifies the sample rateOptionalBitRateintegerSpecifies the bit rate in Kbit/secOptionalContainerstringSpecifies the container formatOptional

#### Return Values

An associative array that includes a flag indicating whether the audio format can be played, and the closest audio format supported by the device.

### IsPassthruCodecActive() as Boolean

#### Description

Indicates whether a passthrough device that owns the codec (a TV, audio receiver, or soundbar connected to a Roku device via HDMI) is rendering audio.

Apps can call the [CanDecodeAudio()](#candecodevideovideo_format-as-object-as-object) function with the **audioFormat.passthru** field set to 1 to check whether the passthrough device can decode and play the specified audio format, and then call this function to determine whether the passthrough device is actually rendering the audio.

If the app receives a [**roDeviceInfoEvent.audioCodecCapabilityChanged**](/docs/references/brightscript/events/rodeviceinfoevent.md#isstatusmessage-as-boolean) event, it can call this function again to determine whether the audio output has changed (for example, check whether a different set of codecs are now relevant). The app can also re-query the [CanDecodeAudio()](#candecodevideovideo_format-as-object-as-object) function to determine whether the codecs themselves have changed (for example, an audio receiver has been disconnected).

#### Return Values

A flag indicating whether the passthrough device is rendering audio.

### GetSoundEffectsVolume() as Integer

#### Description

Checks for the user interface sound effects volume level.

#### Return Values

The UI sounds effects volume as a percentage. A return value of 0 indicates that UI sound effects are muted, and a value of 100 indicates that they are set to the maximum volume level

### IsAudioGuideEnabled() as Dynamic

> The screen reader is available on the following devices: Roku Streaming Stick (3600X), Roku Express (3700X) and Express+ (3710X), Roku Premiere (4620X) and Premiere+ (4630X), Roku Ultra (4640X), and any Roku TV running Roku OS version 7.5 and later.

#### Description

Checks if the screen reader is enabled.

#### Return Values

A flag indicating whether the screen reader is enabled.

### EnableAudioGuideChangedEvent(enable as Boolean) as Dynamic

> The screen reader is available on: Roku Streaming Stick (3600X), Roku Express (3700X) and Express+ (3710X), Roku Premiere (4620X) and Premiere+ (4630X), Roku Ultra (4640X), and any Roku TV running Roku OS version 7.5 and above

#### Description

Notifies the app when the screen reader changes. This function enables the sending of an [roDeviceInfoEvent](/docs/references/brightscript/events/rodeviceinfoevent.md) when the screen reader changes. To receive events, you must have first called [SetMessagePort](/docs/references/brightscript/interfaces/ifsetmessageport.md) on the roDeviceInfo object specifying the message port that is to receive the events

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| enable | Boolean | A flag indicating whether to enable/disable screen reader change event notifications. |

#### Return Values

A flag indicating whether screen reader change event notifications are enabled (true) or disabled (false).

### IsAutoplayEnabled() as Boolean

_Available since Roku OS 13.0_

**Description**

Returns a flag indicating whether autoplay is enabled on a device. Developers can use this function to ensure that the autoplay device setting is respected when customers browse content in their apps.

If autoplay is disabled on a device, apps may not begin any video playback until the customer expressly requests it. Once a user navigates to a video or otherwise explicitly requests the playback of the video to begin, the app may continue playing that video until the user navigates away from it, pauses it, turns the device off, or a screensaver starts.

Apps must adhere to [Roku’s autoplay policy](/docs/developer-program/media-playback/autoplay.md) to pass certification (Effective after October 1, 2024).

**Return Value**

A boolean indicating whether autoplay is enabled on a device.

roMicrophone
============

The roMicrophone API allows apps to receive audio data from the user’s microphone-supported remote control device or mobile phone. When a user initiates recording on their remote control device or mobile phone (via the Roku Mobile App) for the first time within the application, the application will request the user’s permission for the application to access the microphone by displaying a UI dialog box.

The application will only receive microphone access if the permission is granted by the user.

![roku815px - microphone-access](https://image.roku.com/ZHZscHItMTc2/microphone-access.jpg "microphone-access")

After the permission is granted, whenever a user activates the microphone, the application will display a notice informing the user that the microphone is currently being used by the application.

From the settings menu (Settings > Privacy > Microphone), the user can revoke microphone permissions from individual applications, at which time the particular application will not be able to access the microphone unless the user re-enables microphone permissions.

From the settings menu, the user may also:

*   (a) enable universal microphone access permissions for all applications (thereby eliminating the need to request microphone permission on an application by application basis), and
*   (b) prohibit all applications from accessing the microphone.

![roku815px - microphone-setting](https://image.roku.com/ZHZscHItMTc2/microphone-setting.jpg "microphone-setting")

When integrating the roMicrophone API, you acknowledge and agree to the following:

*   (i) that you will notify your users of your collection, use, and disclosure of any voice recordings or other derived data that you receive through the roMicrophone API;
*   (ii) you will not modify, circumvent, obscure, or otherwise diminish the notices provided by the roMicrophone API to users when they activate or enable microphone recording from their remote control device or mobile phone;
*   (iii) you will not collect any information from, or otherwise activate, the microphone on any remote control device or mobile phone using the roMicrophone API feature without receiving the requisite permissions from the user;
*   (iv) you have and will maintain a legally adequate privacy policy;
*   (v) you have and will maintain all necessary rights and consents from users to use the roMicrophone API features; and
*   (vi) your use of the roMicrophone API features will comply with all applicable laws, rules, and regulations.

YOU FURTHER AGREE YOU WILL NOT USE THE roMicrophone API AND FEATURES IN CONNECTION WITH CONTENT OR APPS DIRECTED TOWARD CHILDREN OR IN CONNECTION WITH USERS KNOWN TO BE CHILDREN. If Roku discovers or determines that you are using the roMicrophone API and features in connection with content or apps directed toward children or with users known to be children, Roku reserves the right to disable or otherwise limit your access to the roMicrophone API feature and related functionality.

YOU MAY NOT ENABLE THE roMicrophone API FEATURES IF YOU DO NOT AGREE TO ABOVE. PLEASE CONTACT ROKU FOR FURTHER INFORMATION. Implementation

The application should display a focusable button or indicator in the UI that the user selects by pressing and holding the OK button. In response to the OK press event, the application can call:

*   [StartRecording()](/docs/references/brightscript/interfaces/ifmicrophone.md "StartRecording") - to receive streamed audio data from the microphone asynchronously or
*   [RecordToFile()](/docs/references/brightscript/interfaces/ifmicrophone.md "RecordToFile()") - to have the audio data directly captured to a WAV format output file.

> Roku OS will display a HUD to let the user initially consent to be recorded and to subsequently be informed when the microphone is being used. Recording is performed as long as the user holds down the OK button, or until a limit is reached or if an error should occur.

Supported interfaces
--------------------

*   [ifMicrophone](/docs/references/brightscript/interfaces/ifmicrophone.md "ifMicrophone")
*   [ifSetMessagePort](/docs/references/brightscript/interfaces/ifsetmessageport.md "ifSetMessagePort")
*   [ifGetMessagePort](/docs/references/brightscript/interfaces/ifgetmessageport.md "ifGetMessagePort")

Supported events
----------------

*   [roMicrophoneEvent](/docs/references/brightscript/events/romicrophoneevent.md "roMicrophoneEvent")

ifSystemLog
===========

Implemented by
--------------

| Name | Description |
| --- | --- |
| [roSystemLog](/docs/references/brightscript/components/rosystemlog.md "roSystemLog") | The roSystemLog component enables the application to receive events from the Roku Streaming Player that are intended for reporting errors and trends, rather than trigger a response to a user action |

Supported methods
-----------------

### EnableType(logType as String) as Void

#### Description

Enables log message of type logType. When a log type is enabled, system log messages of that type are sent to the message port that was set using SetMessagePort().

All system log events are disabled by default and must be explicitly enabled by the application.

#### Parameters

NameTypeDescriptionlogTypeStringThe logType to be enabled, which may be one of the following values:Valid logTypesDescription"http.connect"Sent whenever a successful HTTP connection is made. This means that the server responded to the HTTP request with a success (2xx) status code. However, this does not necessarily mean that all of the body of the request has been received successfully"http.error"Sent whenever an error occurs while executing an HTTP request. This may be sent during the time of the initial connection for two possible reasons:

*   because the server responded with an error code, or
*   data is being read from the body after the initial connection takes place

"bandwidth.minute"Sent every minute to report the current measured bandwidth“http.complete”

| Property/Key | Type | Description |
| --- | --- | --- |
| LogType | String | When enabled, the “http.complete” events will be sent to Roku after an http transfer is completed for adaptive streams. This event consolidates information related to:<br><br>*   a cURL transfer such as DNS look up time,<br>*   connection latency,<br>*   transfer speed,<br>*   and number of bytes. |
| DateTime | roDateTime | The GMT time of the event, with a resolution of one millisecond |
| Url | String | The URL that was requested |
| OrigUrl | String | The original URL. If the original URL was redirected, then Url represents the new redirected URL and OrigURL the original. OrigURL is included so that it's easy to correlate between events and URLs passed to components |
| Method | String | The HTTP method. "GET", "POST", or "HEAD" |
| Status | String | For LogType “http.complete”, this will be “ok” |
| TargetIp | String | The IP address of the target server |
| HttpCode | Integer | The HTTP response code if available |
| ContentType | String | Content type or MIME type |
| DNSLookupTime | Double | DNS name resolution time in seconds with double precision |
| ConnectTime | Double | Time taken to connect to the server (seconds) |
| FirstByteTime | Double | Time taken to receive the first byte from the server (seconds) |
| TransferTime | Double | Total data transfer time (seconds) |
| DownloadSpeed | Double | Transfer download speed in bytes per second |
| BytesDownloaded | Integer | Number of bytes downloaded from the server |
| UploadSpeed | Double | Transfer upload speed in bytes per second |
| BytesUploaded | Integer | Number of bytes uploaded to the server |

See [roSystemLogEvent](/docs/references/brightscript/events/rosystemlogevent.md "roSystemLogEvent") for details on the information reported for each log type.

Taking the online video course
==============================

Developers can learn how to build a Roku app from the ground up through the [SceneGraph: Build an app online video course](/videos/courses/rsg/overview.md). This course features a set of 13 video lessons and a comprehensive [sample app](https://github.com/rokudev/scenegraph-master-sample) that walks developers through each step in building a basic, high-performance Roku app that passes certification. This course is ideal for developers that are new to the Roku platform and want a simple, streamlined path for quickly understanding Roku development.

The **SceneGraph: Build an app** online video course is available on [YouTube](https://go.roku.com/rsg-course-youtube), the [Roku developers video portal](/videos/courses/rsg/intro.md), and the [Roku Developers app](https://go.roku.com/-VkGoU0ve) on your Roku device.

ifAssociativeArray
==================

Implemented by
--------------

| Name | Description |
| --- | --- |
| [roAssociativeArray](/docs/references/brightscript/components/roassociativearray.md "roAssociativeArray") | An associative array allows objects to be associated with string keys |
| [roSGNode](/docs/references/brightscript/components/rosgnode.md "roSGNode") | The roSGNode object is the BrightScript equivalent of SceneGraph XML file node creation |

Supported methods
-----------------

### AddReplace(key as String, value as Dynamic) as Void

#### Description

Adds a new entry to the array associating the supplied value with the supplied key string. Only one value may be associated with a key. If the key is already associated with a value, the existing value is discarded.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| value | Dynamic | The value of the key to be added to the associative array. |
| key | String | The key to be added to the associative array. |

### Lookup(key as String) as Dynamic

#### Description

Returns the value in the array associated with the specified key. The key comparison is case-insensitive, unless the **SetModeCaseSensitive()** method has been called.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| key | String | The key associated with the value to be retrieved from the associative array. |

#### Return Value

Returns the value in the array associated with the specified key. If there is no value associated with the key, the type "invalid" is returned.

### LookupCI(key as String) as Dynamic

#### Description

Same as the [Lookup()](#lookupkey-as-string-as-dynamic) method except that the key comparison is always case insensitive, regardless of the case mode.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| key | String | The key (case-insensitive) associated with the value to be retrieved from the associative array. |

#### Return Value

Returns the value in the array associated with the specified key. If there is no value associated with the key, the type "invalid" is returned.

### DoesExist(key as String) as Boolean

#### Description

Looks for an entry in the associative array associated with the specified key.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| key | String | The key associated with the entry to be checked. |

#### Return Value

A flag indicating whether an entry is associated with the specified key exists. If there is no associated object then false is returned. If there is such an object then true is returned.

### Delete(key as String) as Boolean

#### Description

Deletes an entry from an associative array based on the key.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| key | String | The key associated with the entry to be deleted. |

#### Return Value

A flag indicating whether an entry is associated with the specified key exists. If there is no associated object then false is returned. If there is such an object then true is returned.

### Clear() as Void

#### Description

Remove all key/values from the associative array.

### Keys() as Object

#### Description

Returns an array containing the associative array keys in lexicographical order.

#### Return Value

An array of associative array keys.

### Items() as Object

#### Description

Returns an array containing the associative array key/value pairs in lexicographical order of key.

#### Return Value

An array of associative array keys/value pairs.

#### Example

        aa = {one:1, two:2, three:3}
        for each item in aa.Items()
            print item.key, item.value
        end for
        REM prints "one  1", "three  3", "two  2"
    

### SetModeCaseSensitive() as Void

#### Description

Makes all subsequent associative array lookups case sensitive (by default, lookups are case insensitive).

### Append(aa as Object) as Object

#### Description

Appends an associative array to this calling object. If any key in the **aa** parameter is already associated with a value in the calling object, the current value is discarded and is replaced with the value provided in the **aa** parameter.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| aa  | Object | The associative array to be appended to the calling object. |

#### Return Value

The function returns `invalid`.

### Count() As Integer

#### Description

Returns the number of keys in the associative array.

#### Return Value

The number of keys in the associative array.

Roku Pay integration requirements
=================================

All channels with transactional content or in-channel purchases (SVOD, TVOD, and other subscription services) must integrate and enable Roku Pay services. This document lists the requirements for integrating Roku Pay services in an channel. Channels must adhere to all of these requirements to pass certification.

RP 1 Channel setup requirements
-------------------------------

| Requirement | Name | Description | Documentation |
| --- | --- | --- | --- |
| RP 1.1 | Channel name | Channels must provide a name, description, and poster (a 540x405 JPEG or PNG image) in each language supported by the channel.  <br>  <br>The channel name must clearly identify the company associated with the service, and the publisher must have full legal rights or consent for their channel names and the rights to all trademarks and copyright expressions associated with the name.  <br>  <br>The channel name may not include the name "Roku", and it may not contain any profanity, or derogatory or misleading language. | [Channel publishing](/docs/developer-program/publishing/channel-publishing-guide.md#create-a-channel) |

RP 2 Sign-up and sign-in requirements
-------------------------------------

| Requirement | Name | Description | Documentation |
| --- | --- | --- | --- |
| RP 2.1 | RFI screen | All authenticated transactional channels (SVOD, TVOD, and other subscription services) must use the [getUserData](/docs/references/scenegraph/control-nodes/channelstore.md#getuserdata) command to display a Request For Information (RFI) screen during the sign-up and sign-in workflows to enable customers to share their Roku account information with the channel.  <br>  <br>Only if the user declines the request, may channels require the customer to manually enter information other than a password. | *   [Signup requirements and best practices](/docs/developer-program/roku-pay/signup-best-practices.md)<br>*   [Sign-in requirements and best practices](/docs/developer-program/roku-pay/signin-best-practices.md) |

RP 3 Payment requirements
-------------------------

| Requirement | Name | Description | Documentation |
| --- | --- | --- | --- |
| RP 3.1 | Product groups | Subscription services must create product groups in the [Developer Dashboard](https://developer.roku.com/developer) for any set of subscription products that the consumer should not be able to be subscribed to simultaneously.  <br>  <br>For example, if an channel has two in-channel products for the same monthly subscription but with different free trial durations, these two products must be added to the same product group to prevent the customer from paying for two separate monthly subscriptions | [In-channel purchases - Product groups](/docs/developer-program/roku-pay/quickstart/in-channel-products.md#adding-product-groups) |
| RP 3.2 | Multiple purchase protection | Channels must protect against multiple purchases of content or subscriptions through Roku Pay before passing new orders to the Streaming Store service.  <br>  <br>The Streaming Store service inherently protects against purchasing the same subscription code multiple times, but preventing, for example, the purchase of a free trial subscription and a non-free trial subscription must be done in the channel. | [In-channel purchases -Product Groups](/docs/developer-program/roku-pay/quickstart/in-channel-products.md#adding-product-groups) |
| RP 3.3 | Price changes | SVOD channels must provide 30-days notice to existing customers before changing the price of their service. | [In-channel purchases - Product pricing](/docs/developer-program/roku-pay/quickstart/in-channel-products.md#product-pricing) |
| RP 3.4 | In-channel product naming | Channels must name in-channel products so that the service being offered is clearly identifiable. The publisher must have full legal rights or consent for their in-channel product names and the rights to all trademarks and copyright expressions associated with the names. The in-channel product names may not include the name "Roku", text related to a trial or discount offer**,** or any profane, derogatory, or misleading language. | [In-channel purchases - Product basics](/docs/developer-program/roku-pay/quickstart/in-channel-products.md#product-basics) |

RP 4 Authentication and entitlement requirements
------------------------------------------------

| Requirement | Name | Description | Documentation |
| --- | --- | --- | --- |
| RP 4.1 | On-device authentication | Channels that include authentication must complete account sign-ups and sign-ins on the device using [On-device authentication](/docs/developer-program/authentication/on-device-authentication.md).  <br>  <br>Sign-up and sign-in workflows are prohibited from including external webpages, links to off-device promotional or marketing materials, or utilizing off-device sign-up or sign-in mechanisms such as rendezvous linking. | [On-device authentication](/docs/developer-program/authentication/on-device-authentication.md) |
| RP 4.2 | On-device upgrades and downgrades | Channels must complete upgrades and downgrades on the device using [On-device upgrade and downgrade](/docs/developer-program/roku-pay/implementation/on-device-upgrade-downgrade.md). The upgrade/downgrade workflows are prohibited from including external webpages. | [On-device upgrade and downgrade](/docs/developer-program/roku-pay/implementation/on-device-upgrade-downgrade.md) |
| RP 4.3 | Account-based entitlements | Channels must automatically entitle content or subscriptions purchased through Roku Pay across all devices tied to the purchasing Roku account.  <br>  <br>Channels can use the [getAllPurchases](/docs/references/scenegraph/control-nodes/channelstore.md#getallpurchases) API can upon launch to return the transactionID for an active subscription, and they can use an entitlement server to look up an account via a call to the [validate-transaction API](/docs/developer-program/roku-pay/implementation/roku-web-service.md#validate-transaction). | *   [getPurchases ChannelStore API](/docs/references/scenegraph/control-nodes/channelstore.md#getuserdata)<br>*   [validate-transaction Roku Pay Web service API](/docs/developer-program/roku-pay/implementation/roku-web-service.md#validate-transaction) |
| RP 4.4 | Abandonment tracking | All subscription services that have streamed more than an average of 5 million hours per month over the last three months (and new subscription services projected to reach the specified streaming hour threshold shortly after launch) must implement Roku Event Dispatcher (RED) in the signup workflow.  <br>  <br>Channels must fire a RED event upon loading each page within the signup flow and submission of the final page to help track where users are abandoning the process. This includes, but is not limited to, the following pages: landing, sign up, registration, device activation, subscription selection, payment, purchase confirmation, and cancellation.  <br>  <br>If the channel's sign-up flow is contained within a form that covers one or more pages, channels must fire a RED event when each element in the form is completed. Streaming hours per month information is available in the Developer Dashboard. | [Tracking signup abandonment](/docs/developer-program/roku-pay/implementation/tracking-signup-abandonment.md). |
| RP 4.5 | Enhanced Subscription Recovery (churn mitigation) | All apps offering subscriptions must implement Enhanced Subscription Recovery to pass [certification](/docs/developer-program/roku-pay/roku-pay-requirements.md#rp-4-authentication-and-entitlement-requirements) | [Enhanced Subscription Recovery](/docs/developer-program/roku-pay/subscription-recovery/subscription-on-hold.md) |

roSGScreenEvent
===============

**roSGScreenEvents** are events sent to a scene graph **roSGScreen** by the framework. Other than when notifying the app's main BrightScript thread that the screen is being closed, and thus that the app should be terminated, apps do not generally handle these events.

Supported methods
-----------------

### isScreenClosed() as Boolean

Checks whether the screen has been closed and is no longer displayed to the user. This method returns true if the screen was closed; otherwise, it returns false.

Apps respond to this event by exiting the main BrightScript thread to exit the application.

#### Example: Handling the isScreenClosed event to terminate an app in source/main.brs

    sub Main()
        showChannelSGScreen()
    end sub
    
    sub showChannelSGScreen()
        screen = CreateObject("roSGScreen")
        m.port = CreateObject("roMessagePort")
        screen.setMessagePort(m.port)
        m.scene = screen.CreateScene("SimpleCaptionsScene")
        screen.show()
        while(true)
            msg = wait(0, m.port)
            msgType = type(msg)
            if msgType = "roSGScreenEvent"
                if msg.isScreenClosed() then return
            end if
        end while
    end sub

ifFloat
=======

Interface equivalent for intrinsic type Float

Implemented by
--------------

| Name | Description |
| --- | --- |
| [roFloat](/docs/references/brightscript/components/rofloat.md "roFloat") | Object equivalent for intrinsic type 'Float' |

Supported methods
-----------------

### GetFloat() As Float

#### Description

Gets the float value stored in the calling Float object.

#### Return Value

The float value stored in the calling Float object.

### SetFloat(value As Float) As Void

#### Description

Sets the calling Float object to the specified float value.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| value | Float | The float value to be set on the calling Float object. |

ifAppMemoryMonitor
==================

Implemented by
--------------

| Name | Description |
| --- | --- |
| [roAppMemoryMonitor](/docs/references/brightscript/components/roappmemorymonitor.md "roAppMemoryMonitor") | Subscribes channels to low-memory notifications. When an app is subscribed, it receives a [roAppMemoryNotificationEvent](/docs/references/brightscript/events/roappmemorynotificationevent.md) when it reaches a specific percentage of the per-app memory limit (80%). |

> The roAppMemoryMonitor functions are supported on all [current and updatable device models](/docs/specs/hardware.md), except for Liberty, Austin, Mustang and Littlefield.

Supported methods
-----------------

### EnableMemoryWarningEvent(enable as Boolean) as Boolean

#### Description

Enables an app to be alerted when it has reached 80% of its memory usage limit.

#### Parameter

| Name | Type | Description |
| --- | --- | --- |
| enable | Boolean | A flag that enables or disables memory alerts on the app. |

#### Return Values

A flag indicating whether memory alerts have been enabled.

### GetMemoryLimitPercent() as Int

#### Description

Returns the usage percentage of memory limit for the app.

#### Return Values

The usage percentage of memory limit for the app.

#### Example

    m.port = CreateObject("roMessagePort")
    deviceInfo = CreateObject("roAppMemoryMonitor")
    deviceInfo.setMessagePort(m.port)
    ret = deviceInfo.EnableMemoryWarningEvent(true)
    if ret = true
        m.global.forCgroup="true"
    else
        m.global.forCgroup="false"
        deviceInfo = CreateObject("roDeviceInfo")
        deviceInfo.setMessagePort(m.port)
        deviceInfo.enableLowGeneralMemoryEvent(true)
    end if
    print "showChannelSGScreen forCgroup= " m.global.forCgroup
    while(true)
        msg = wait(0, m.port)
        msgType = type(msg)
        if msgType = "roSGScreenEvent"
            if msg.isScreenClosed() then return
        else if msgType = "roAppMemoryNotificationEvent"
            print "Event MemoryUsagePercent = "            
            msg.getInfo().lookup("MemoryUsagePercent")
            m.global.getEvent="true"
        else if msgType = "roDeviceInfoEvent"
            print "Event generalMemoryLevel = " msg.getInfo().lookup("generalMemoryLevel")
            m.global.getEvent="true"
        end if
    end while
    

### GetChannelAvailableMemory() as Int

_Available since Roku OS 12.5_

#### Description

Returns the estimated kilobytes (Kb) of memory available for the app. This can be used to determine when to release memory when an app receives low-memory warnings.

#### Return Value

An integer indicating the estimated available memory remaining for the app or the available memory for the device, whichever is lower.

### GetChannelMemoryLimit() as Object

_Available since Roku OS 13.0_

**Description**

Returns the amount of foreground and background memory the app may use and the maximum amount of memory that the RokuOS may allocate on behalf of the app (the memory that shows up in the app's heap memory statistics). This helps developers debug memory issues and find out the maximum available memory for scenarios such as when their app has been suspended and is in the background, is playing a video, and so on.

**Return Value**

An roAssociativeArray that contains the following fields:

| Field | Kind | Description |
| --- | --- | --- |
| maxForegroundMemory | Integer | The maximum amount of memory that app could have when it is running in the foreground. |
| maxBackgroundMemory | Integer | The maximum amount of memory that app could have when it is running in the background. |
| maxRokuManagedHeapMemory | Integer | The maximum amount of memory that the RokuOS may allocate on behalf of the app that shows up in the app's heap memory stats. |

ifSGNodeChildren
================

The ifSGNodeChildren interface allows querying and manipulation of nodes in a SceneGraph node tree, such as creating new nodes, placing them at certain positions in the tree, and removing them.

Implemented by
--------------

| Name | Description |
| --- | --- |
| [roSGNode](/docs/references/brightscript/components/rosgnode.md "roSGNode") | The roSGNode object is the BrightScript equivalent of SceneGraph XML file node creation |

To use the methods in this interface to manipulate child nodes at the scene level, the subject nodes must be wrapped in another element, typically a Group node. For example:

    <?xml version="1.0" encoding="utf-8" ?>
    <component name = "myScene" extends = "Scene" >
      <script type = "text/brightscript" >
        <![CDATA[
        sub init()
          m.myGroup = m.top.FindNode("myGroup")
          m.label = m.myGroup.getChild(0)
        end sub
        ]]>
      </script>
    
      <children>
        <Group id = "myGroup">
          <Label id = "myLabel" ... />
        </Group>
      </children>
    </component>
    

In the example above, m.label will contain the roSGNode corresponding to the Label node after the getChild() call. On the other hand, the following will not work:

    <?xml version="1.0" encoding="utf-8" ?>
    <component name = "myScene" extends = "Scene" >
      <script type = "text/brightscript" >
        <![CDATA[
        sub init()
          m.label = m.top.getChild(0)
        end sub
        ]]>
      </script>
    
      <children>
        <Label id = "myLabel" ... />
      </children>
    </component>
    

The Scene node children are hidden elements used by the SceneGraph framework. Thus, despite the fact that the Label node is in the scene element, it will not be retrieved by getChild() .

> Removing or replacing a node in a SceneGraph node tree can cause that node to be destroyed entirely if there are no more references to it.

Supported methods
-----------------

### appendChild(child as roSGNode) as Boolean

#### Description

Adds a child node to the end of the subject node list of children so that it is traversed last (of those children) during render.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| child | roSGNode | The child node to be appended to the end of the list. |

#### Return Value

A flag indicating whether the child node was successfully appended.

### createChild(nodeType as String) as Object

#### Description

Creates a child node of type nodeType, and adds the new node to the end of the subject node list of children.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| nodeType | String | The node class to be created. |

#### Return Value

The child node that was created.

### insertChild(child as roSGNode, index as Integer) as Boolean

#### Description

Inserts a previously-created child node at the position index in the subject node list of children, so that this is the position that the new child node is traversed during render.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| child | roSGNode | The child node to be added to the child tree. |
| index | Integer | The postion index where the child node is to be inserted. |

#### Return Value

A flag indicating whether the child node that was successfully inserted.

### removeChild(child as roSGNode) as Boolean

#### Description

Finds a child node in the subject node list of children, and if found, remove it from the list of children. The match is made on the basis of actual object identity, that is, the value of the pointer to the child node.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| child | roSGNode | The child node to be removed from the child tree. |

#### Return Value

A flag indicating whether the child node that was successfully removed.

### removeChildIndex(index as Integer) as Boolean

#### Description

If the subject node has a child node in the index position, removes that child node from the subject node list of children.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| index | Integer | The position in the tree of the child node to be removed. |

#### Return Value

A flag indicating whether the child node that was successfully removed.

### replaceChild(newChild as roSGNode, index as Integer) as Boolean

#### Description

If the subject node has a child node in the index position, replace that child node with the newChild node in the subject node list of children, otherwise do nothing.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| newChild | roSGNode | The child node to replace the one specified by the index. |
| index | Integer | The index of the child node to be replaced. |

#### Return Value

A flag indicating whether the child node that was successfully replaced.

### getChild(index as Integer) as Dynamic

#### Description

Returns the child node specified by the index.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| index | Integer | The index of the child node to be retrieved. |

#### Return Value

The child node at the index position; otherwise, "invalid".

### getParent() as roSGNode

#### Description

Returns the parent node of a node has been added to a list of children.

#### Return Value

The parent node; otherwise, "invalid".

### getChildCount() as Integer

#### Description

Returns the current number of children in the subject node list of children. This is always a non-negative number.

#### Return Value

The number of child nodes in the tree.

### reparent(newParent as roSGNode, adjustTransform as Boolean) as Boolean

#### Description

Moves the subject node to another parent node.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| newParent | roSGNode | The new parent node where the child node is to be moved. |
| adjustTransform | Boolean | Specifies whether the translation, rotation, and scale of the node are adjusted so that the node has the same transformation factors relative to the screen as it previously did.  <br>  <br>If **adjustTransform** is true, the subject node transformation factor fields (translation/rotation/scale) are adjusted so that the node has the same transformation factors relative to the screen as it previously did.  <br>  <br>If **adjustTransform** is false, the subject node is simply parented to the new node without adjusting its transformation factor fields, in which case, the reparenting operation could cause the node to jump to a new position on the screen. |

#### Return Value

A flag indicating whether the node that was successfully moved to another parent node.

### appendChildren(child\_nodes as Object) as Boolean

#### Description

Appends an array of children nodes to the subject node.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| child\_nodes | Object | An roArray of child nodes to be appended to the subject node. |

#### Return Value

A flag indicating whether the children nodes were successfully appended.

### insertChildren(child\_nodes as Object, index as Integer) as Boolean

#### Description

Inserts an array of child nodes to the subject node, starting at a specific position.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| child\_nodes | Object | An roArray of child nodes to be inserted in the tree. |
| index | Integer | The position in the tree where to insert the child nodes. |

#### Return Value

A flag indicating whether the children nodes were successfully inserted.

### removeChildren(child\_nodes as Object) as Boolean

#### Description

Removes an array of child nodes from the subject node.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| child\_nodes | Object | An roArray of child nodes to removed from the tree |

#### Return Value

A flag indicating whether the children nodes were successfully removed.

### removeChildrenIndex(num\_children as Integer, index as Integer ) as Boolean

#### Description

Removes a specific number of child nodes from the subject node starting at a specific position.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| num\_children | Integer | The number of child nodes to be removed. |
| index | Integer | The starting position in the child node tree where the specified number of nodes are to be removed. |

#### Return Value

A flag indicating whether the children nodes were successfully removed.

### update(fields as roAssociativeArray\[, addFields as Boolean\]) as Void

#### Description

Takes the key-value pairs in an roAssociativeArray and maps the values to the respective field name in the calling node.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| fields | roAssociativeArray | Contains key-value pairs corresponding to the fields in the subject node to be updated. |
| addFields | Boolean | optional (default = false). If true, and a specified key is not yet present, add it and value to the node. |

#### Example

The following example demonstrates how to use this method:

    aa = {"a":"1", "b":"2", "c":"3", "d":"4"}
    cn = createObject("roSGNode", "contentNode")
    cn.addfield("a","string",false)
    cn.addfield("b","string",false)
    cn.addfield("c","string",false)
    cn.update(aa,false)
    'At this point, cn would contain the following:
    <Component: roSGNode> =
    {
        change: <Component: roAssociativeArray>
        focusable: false
        focusedChild: <Component: roInvalid>
        id: ""
        a: "1"
        b: "2"
        c: "3"
    }
    

### replaceChildren(child\_nodes as Object, index as Integer) as Boolean

#### Description

Replaces the child nodes in the subject node, starting at the position specified by index, with new child nodes specified by child\_nodes

> Starting from Roku OS 8.1, when using this method to update the content of each item in a markupGrid, if more items are supplied than there are in the original list (going from 4 items to 5), the 'extra' items are ignored and not added as children. The [appendChildren()](#appendchildchild-as-rosgnode-as-boolean) function can be used to add the extra items.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| child\_nodes | Object | An roArray of child nodes to replace the nodes in the tree. |
| index | Integer | The starting position in the tree from where to replace the child nodes. |

#### Return Value

A flag indicating whether the children nodes were successfully replaced.

### getChildren(num\_children as Integer, index as Integer) as Object

#### Description

Retrieves a specific number of child nodes from the subject node, starting at a specific position.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| num\_children | Integer | The number of child nodes to be retrieved. |
| index | Integer | The starting position in the child node tree where the specified number of nodes are to be retrieved. |

#### Return Value

An roArray containing the child nodes retrieved. If num\_children is -1, all the child nodes are returned.

### createChildren(num\_children as Integer, subtype as String ) as Object

#### Description

Creates a specific number of new child nodes of a specific type or extended type.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| num\_children | Integer | Number of new child nodes to be created. |
| subtype | String | Node type or extended type of the new child nodes to be created. |

#### Return Value

An roArray containing the new child nodes created.

### getScene() as roSGNode

#### Description

Returns the node's root Scene. This returns a valid Scene even if the node is not parented.

#### Return Value

The node's root Scene.

Debugging-only Methods
----------------------

The following methods can be called on any subject node and return the same global results. They can be used in a development app for debugging purposes, but should not be used in a production app.

> These methods are similar to the debugger sgnodes commands. See [Special SceneGraph Debugging Commands](/docs/developer-program/debugging/debugging-channels.md#special-scenegraph-debugging-commands) for information on the debugger sgnodes commands. Also please note that calling these functions from code should only be done for debugging purposes. Any calls to [getAll()](#getall-as-object), [getRoots()](#getroots-as-object), [getRootsMeta()](#getrootsmeta-as-object) and [getAllMeta()](#getallmeta-as-object) should be removed from your production channels. |

### getAll() as Object

#### Description

Returns an array with every existing node created by the currently running app.

#### Return Value

An roArray with the all the existing nodes created by the app.

### getRoots() as Object

#### Description

Returns an array with every existing node without a parent created by the currently running app.

The existence of these unparented nodes means they are being kept alive by direct BrightScript references. These could be in variables local to a function, arrays, or associative arrays, including a component global m or an associative array field of a node.

#### Return Type

An roArray with every existing node without a parent created by the currently running app

### getRootsMeta() as Object

#### Description

Returns a string with every existing node without a parent created by the currently running app.

The existence of these unparented nodes means they are being kept alive by direct BrightScript references. These could be in variables local to a function, arrays, or associative arrays, including a component global m or an associative array field of a node. These unparented nodes are organized as an XML forest of trees.

#### Return Value

A string with every existing node without a parent created by the currently running app.

### getAllMeta() as Object

#### Description

Returns a string with every existing node created by the currently running app (similar to the [getAll()](#getall-as-object) method) organized as an XML forest of trees according to the usual parent-child node relationship. Cycles are handled with a reference entry in the tree rather than indefinite recursion.

#### Return Value

A string with the all the existing nodes created by the app.

roMicrophoneEvent
=================

The [roMicrophone](/docs/references/brightscript/components/romicrophone.md "roMicrophone") component sends the `roMicrophoneEvent` with the following predicates that indicate its valid event types:

Supported methods
-----------------

### IsRecordingDone() as Boolean

Checks if the microphone recording session has been closed. This method returns true if the recording session is closed; otherwise, it returns false.

### IsRecordingInfo() as Boolean

Checks whether the microphone is open. This method returns true when the microphone is open; otherwise, it returns false.

#### GetInfo() as Object

Returns the information regarding a particular microphone recording session. This method returns an roAssociativeArray containing the following information:

| Key | Type | Value |
| --- | --- | --- |
| format | string | The audio data format (ex. pcm-s16-le) |
| num\_channels | integer | The number of channels (ex. 1 for mono) |
| sample\_rate | integer | The audio sample rate (ex. 16000 for 16kHz) |
| sample\_data | roByteArray | Signed 16-bit integer containing audio data as PCM (little-endian format) |
| level | integer | Value displaying a calculated volume level between 0 (silence) and 100 (maximum) |

Task
====

Extends [**Node**](/docs/references/scenegraph/node.md)

The Task node class allows you to specify a function to be spawned in a different thread, and run asynchronously with respect to both the scene rendering thread and the main application thread. A Task node also allows you to run functions that cannot be run in SceneGraph node or component, typically BrightScript code functions involving operations such as reading data from servers and file system manipulation. (You also cannot, and should not, run functions in a SceneGraph application for operations that are functionally the same as SceneGraph nodes and components, such as playing videos.) A list of all the BrightScript functions and components that cannot be used in SceneGraph applications or can only be used in a Task node can be found in [BrightScript Support](/docs/developer-program/core-concepts/scenegraph-brightscript/brightscript-support.md "BrightScript Support").

A Task node is typically used to read data from a server to create a ContentNode to configure a SceneGraph node or component (see [ContentNode](/docs/references/scenegraph/control-nodes/contentnode.md "ContentNode")). A Task node used for this purpose can be thought of as a content reader. Since ContentNodes are required to configure many components rendered in a scene, such as lists, panels, and grids, and you will generally want to read the data for those types of nodes from your server, you should create a Task node as a content reader for each of those components that you use in your scene.

The Task node class was designed with three general development use cases:

*   A new Task node object is created for each asynchronous operation. The input data needed for the operation is set in the Task node object [<interface>](/docs/references/scenegraph/xml-elements/interface.md "<interface>") fields in the render thread, along with an observer of the output `<interface>` field data, and the Task node control field is set to RUN. After the output data is returned to the render thread, the Task node object is not used again.
*   A Task node object is used multiple times for several identical asynchronous operations. In this case, the input data for each operation is set in the existing Task node object, with another observer for the output `<interface>` field data, and the Task node control field is again set to RUN. This may be more efficient than creating a new Task node object for each of the identical operations.
*   A Task node observes its input `<interface>` fields using the port form of the ifSGNodeField [observeField()](/docs/references/brightscript/interfaces/ifsgnodefield.md#observefieldfieldname-as-string-functionname-as-string-as-boolean "observeField()") method, and returns output data with each field change. In this case, the Task node acts like a continuous server.

Since Task nodes launch asynchronous threads, and have no provisions for locks and mutexes, you must be careful to avoid race, deadlock, and other asynchronous thread errors. Here are a few tips for using Task nodes:

*   Avoid accessing files which must be persistent before thread completion, to avoid a subsequent Task node or other thread access of the same file before the thread completes. It is easier and safer to use a dynamically-created string or other data object to hold temporary thread data to avoid having a subsequent or existing thread overwrite and corrupt the data.
*   Be very careful if you access any object in a Task node that may exist in another thread. It is better to completely separate all objects in any other possible thread from the Task node thread by setting the `<interface>` fields of the Task node with copies of the minimum amount of data needed to run the thread.
*   In the Task node init() function, perform the minimum required amount of initialization of the Task node and any included thread functions. If you intend to trigger an asynchronous task based on a Task node input`<interface>` field change, in many cases, you should only set up the observer for the field in init().
*   Use the port form of the ifSGNodeField [observeField()](/docs/references/brightscript/interfaces/ifsgnodefield.md#observefieldfieldname-as-string-functionname-as-string-as-boolean "observeField()") rather than the onChange attribute. This will avoid triggering the thread in response to a render thread event before the Task node observers are set up.
*   It is more efficient to use a persistent Task node that is triggered by an `<interface>` field change than to create a new Task node every time a particular asynchronous thread is required. If needed, you can communicate that the particular asynchronous thread is no longer required through an `<interface>` field as well, either through the triggering field, or a special field used for control of the Task node.
*   You can use a single Task node object to run any number of different asynchronous threads by setting the functionName field to the Task node function you want before setting the control field to RUN. If you do not use the input data `<interface>` fields to trigger running the thread, this is equivalent to calling an asynchronous function, and passing the input data fields as arguments to the function. The output data `<interface>` fields can likewise be considered as the return value of a asynchronous function call, but to avoid blocking you must observe the fields, or the state field, as a callback event to handle the results in the calling thread.

Also review "[SceneGraph threads](/docs/developer-program/core-concepts/threads.md "SceneGraph")" for in-depth information on using Task nodes most efficiently.

### Example

The following reads attributes from an XML file on a server containing the content for a PosterGrid node into a ContentNode, which can then be assigned to the content field of the PosterGrid node to configure and populate the grid.

#### Task Node Example

    <?xml version="1.0" encoding="utf-8" ?>
    
    <!--********** Copyright 2016 Roku Corp.  All Rights Reserved. **********-->
    
    <component name = "postergridCR" extends = "Task" >
    
      <interface>
        <field id = "postergriduri" type = "string" />
        <field id = "postergridcontent" type = "node" />
      </interface>
    
      <script type = "text/brightscript" >
        <![CDATA[
    
        sub init()
          m.top.functionName = "getContent"
        end sub
    
        sub getContent()
          postergridcontent = createObject("RoSGNode","ContentNode")
    
          postergridxml = createObject("roXMLElement")
    
          readInternet = createObject("roUrlTransfer")
          readInternet.setUrl(m.top.postergriduri)
          postergridxml.parse(readInternet.GetToString())
    
          if postergridxml.getName()="PosterGrid"
            for each poster in postergridxml.GetNamedElements("poster")
              postercontent = postergridcontent.createChild("ContentNode")
              postercontent.setFields(poster.getAttributes())
            end for
          end if
    
          m.top.postergridcontent = postergridcontent
        end sub
    
        ]]>
      </script>
    
    </component>
    

In addition to this example, a much simpler, complete example, including the scene that creates the Task node, can be found here: [SimpleTask example](https://github.com/rokudev/samples/tree/master/ux%20components/control). That example simply uses a Task node to increment a counter and display the current counter value on the screen.

Fields
------

| Field | Type | Default | Access Permission | Description |
| --- | --- | --- | --- | --- |
| functionName | string | ""  | READ\_WRITE | The name of the function in the Task node component to be executed when the state field changes to RUN. The function must be declared within the scope of the Task node component |
| control | option string | init | WRITE\_ONLY | Requests a change in the run state of the spawned task. The valid options are the same as for the state field, but case-insensitive (i.e. can set "RUN" or "run") |
| state | value string | init | READ\_ONLY | Inquires about the run state of the spawned task. Note that the values are in lowercase: "init", "stop", "run", "done" |

Sample app
----------

[TaskExample](https://github.com/rokudev/samples/tree/master/ux%20components/control/TaskExample) is a sample app demonstrating Task in action.

ifUrlTransfer
=============

Implemented by
--------------

| Name | Description |
| --- | --- |
| [roUrlTransfer](/docs/references/brightscript/components/rourltransfer.md "roUrlTransfer") | A roUrlTransfer object transfers data to or from remote servers specified by URLs. It can perform mutual authentication with a web server |

Supported methods
-----------------

> Each roUrlTransfer object can perform only one asynchronous operation at one time. After starting an asynchronous operation, you cannot perform any other data transfer operations using that object until the asynchronous operation has completed, as indicated by receiving an roUrlEvent message whose GetSourceIdentity value matches the GetIdentity value of the roUrlTransfer.
> 
> Furthermore, the roUrlTransfer object must remain referenced until the transfer has completed. That means that there must be at least one variable containing a reference to the object during the transfer. Allowing the variable to go out of scope (for example, by returning from a function where the variable is declared, or reusing the variable to hold a different value) will stop the asynchronous transfer.

### GetIdentity() as Integer

#### Description

Returns a unique number for this object that can be used to identify whether events originated from this object. The value can be any arbitrary value as assigned by the Roku OS, and should only be used for comparison purposes. For example, the value should not be used as an array index. For use as a look-up key, one option would be to use `GetIdentity().ToStr()` as an associative array key.

#### Return Value

A unique number for the object.

#### Example

    Function Setup()
        m.pendingXfers = {}
    End Function
    
    Function GetAsync(url as String)
        newXfer = CreateObject("roUrlTransfer")
        newXfer.SetUrl(url)
        newXfer.AsyncGetToString()
        requestId = newXfer.GetIdentity().ToStr()
        m.pendingXfers[requestId] = newXfer
    End Function
    
    Function HandleUrlEvent(event as Object)
        requestId = event.GetSourceIdentity().ToStr()
        xfer = m.pendingXfers[requestId]
        if xfer <> invalid then
            ' process it
            m.pendingXfers.Delete(requestId)
        end if
    End Function
    

### SetUrl(url as String) as Void

#### Description

Sets the URL to use for the transfer request.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| url | String | The URL to be used for the transfer request |

### GetUrl() as String

#### Description

Returns the current URL.

#### Return Value

The URL.

### SetRequest(req as String)

#### Description

Changes the request method from the normal GET, HEAD or POST to the value passed as a string.

> Use this function cautiously because it can generate invalid HTTP requests.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| req | String | The request method to be used |

### GetRequest() as String

#### Description

Returns the current request method.

#### Return Value

The request method.

### GetToString() as String

#### Description

Connects to the remote service as specified in the URL and returns the response body as a string. This function waits for the transfer to complete and it may block for a long time. This calls discards the headers and response codes. If that information is required, use the [AsyncGetToString()](#asyncgettostring-as-boolean) method.

#### Return Value

The response body.

### GetToFile(filename as String) as Integer

#### Description

Connect to the remote service as specified in the URL and write the response body to a file on the Roku device's filesystem. This function does not return until the exchange is complete and may block for a long time. The HTTP response code from the server is returned. It is not possible to access any of the response headers. If this information is required use the [AsyncGetToFile()](#asyncgettofilefilename-as-string-as-boolean) method instead.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| filename | String | The file on the Roku device's filesystem to which the response body is to be written |

#### Return Value

The HTTP response code.

### AsyncGetToString() as Boolean

#### Description

Starts a GET request to a server, but does not wait for the transfer to complete.

When the GET request completes, a [roUrlEvent](/docs/references/brightscript/events/rourlevent.md "roUrlEvent") will be sent to the message port associated with the object. The event will contain a roString with the body of the response. If false is returned then the request could not be issued and no events will be delivered.

#### Return Value

A flag indicating whether the request was issued.

### AsyncGetToFile(filename as String) as Boolean

#### Description

Starts a transfer without waiting for it to complete, similar to the [AsyncGetToString()](#asyncgettostring-as-boolean) method. However, the response body will be written to a file on the device's filesystem instead of being returned in a String object.

When the GET request completes, an [roUrlEvent](/docs/references/brightscript/events/rourlevent.md "roUrlEvent") will be sent to the message port associated with the object. If false is returned then the request could not be issued and no events will be delivered.

| Name | Type | Description |
| --- | --- | --- |
| filename | String | The file on the Roku device's filesystem to which the response body is to be written |

#### Return Value

A flag indicating whether the request was issued.

### Head() as Dynamic

#### Description

Synchronously performs an HTTP HEAD request and returns an [roUrlTransfer](/docs/references/brightscript/interfaces/ifurltransfer.md "roUrlTransfer") object.

#### Return Value

An [roUrlTransfer](/docs/references/brightscript/interfaces/ifurltransfer.md "roUrlTransfer") object. If a catastrophic failure occurs (for example, an asynchronous operation is already active), invalid is returned

### AsyncHead() as Boolean

#### Description

Begins an HTTP HEAD request without waiting for it to complete. When the HEAD completes, an [roUrlEvent](/docs/references/brightscript/events/rourlevent.md "roUrlEvent") will be sent to the message port associated with the object. If false is returned then the request could not be issued and no events will be delivered.

#### Return Value

A flag indicating whether the request was issued.

### PostFromString(request as String) as Integer

#### Description

Uses the HTTP POST method to send the supplied string to the current URL. The HTTP response code is returned. Any response body is discarded

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| request | String | The POST request to be sent |

#### Return Value

The HTTP response code.

### PostFromFile(filename as String) as Integer

#### Description

Uses the HTTP POST method to send the contents of the specified file to the current URL. The HTTP response code is returned. Any response body is discarded

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| filename | String | The file containing the POST request to be sent |

#### Return Value

The HTTP response code.

### AsyncPostFromString(request as String) as Boolean

#### Description

Uses the HTTP POST method to send the supplied string to the current URL. When the POST request completes, an [roUrlTransfer](/docs/references/brightscript/interfaces/ifurltransfer.md "roUrlTransfer") will be sent to the message port associated with the object. If false is returned then the request could not be issued and no events will be delivered.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| request | String | The POST request to be sent asynchronously |

#### Return Value

A flag indicating whether the request was issued.

### AsyncPostFromFile(filename as String) as Boolean

#### Description

Uses the HTTP POST method to send the contents of the specified file to the current URL. When the POST request completes, an [roUrlTransfer](/docs/references/brightscript/interfaces/ifurltransfer.md "roUrlTransfer") will be sent to the message port associated with the object. If false is returned then the request could not be issued and no events will be delivered.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| filename | String | The file containing the POST request to be sent asynchronously |

#### Return Value

A flag indicating whether the request was issued.

### AsyncPostFromFileToFile(fromFile as String, toFile as String) as Boolean

#### Description

Uses the HTTP POST method to send the contents of the specified file (fromFile) to the current URL. When the POST request completes successfully, an [roUrlTransfer](/docs/references/brightscript/interfaces/ifurltransfer.md "roUrlTransfer") will be sent to the message port associated with the object. If false is returned then the request could not be issued and no events will be delivered. This function is the same as AsyncPostFromFile, except that the HTTP response is written to the file specified by the toFile parameter.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| fromFile | String | The file containing the POST request to be sent asynchronously |
| toFile | String | The file on the Roku device's filesystem to which the response body is to be written |

#### Return Value

A flag indicating whether the request was issued.

### AsyncCancel() as Boolean

| Name | Type | Possible Value | Description |
| --- | --- | --- | --- |
| AsyncCancel | Boolean | True/False | Cancel any outstanding async requests on the roUrlEvent object |

### RetainBodyOnError(retain as Boolean) as Boolean

#### Description

Returns the body of the response even if the HTTP status code indicates that an error occurred.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| retain | Boolean | A flag specifying whether to return the response body when there is an HTTP error response code. |

#### Return Value

A flag indicating whether the operation was successful.

### SetUserAndPassword(user as String, password as String) as Boolean

#### Description

Enables HTTP authentication using the specified user name and password.

> HTTP basic authentication is intentionally disabled because it is inherently insecure. [HTTP digest authentication](https://tools.ietf.org/html/rfc2617 "HTTP digest authentication") is supported.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| user | String | The user name to be authenticated |
| password | String | The password to be authenticated |

#### Return Value

A flag indicating whether the operation was successful.

### SetMinimumTransferRate(bytes\_per\_second as Integer, period\_in\_seconds as Integer) as Boolean

#### Description

Terminates the transfer automatically if the transfer rate drops below the specified rate (bytes\_per\_second) over a specific interval (period\_in\_seconds).

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| bytes\_per\_second | Integer | The minimum transfer rate required to transfer data. |
| period\_in\_seconds | Integer | The interval to be used for averaging bytes\_per\_second.  <br>  <br>For large file transfers and a small bytes\_per\_second, averaging over fifteen minutes or even longer might be appropriate.  <br>  <br>If the transfer is being done over the internet, setting this to a small number because it may cause temporary drops in performance if network problems occur. |

#### Return Value

A flag indicating whether the operation was successful.

### GetFailureReason() as String

#### Description

If any of the `roUrlEvent` functions indicate failure then this function may provide more information regarding the failure.

#### Return Value

Failure reason.

### EnableEncodings(enable as Boolean) as Boolean

#### Description

Enables gzip encoding of transfers

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| retain | Boolean | A flag specifying whether to enable gzip encoding of transfers |

#### Return Value

A flag indicating whether this operation was successful.

### Escape(text as String) as String

#### Description

URL encodes the specified string per [RFC 3986](https://www.ietf.org/rfc/rfc3986.txt "RFC 3986") and return the encoded string

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| text | String | The string to be URL-encoded |

#### Return Value

The URL-encoded string.

### Unescape(text as String) as String

#### Description

Decodes the specified string per [RFC 3986](https://www.ietf.org/rfc/rfc3986.txt "RFC 3986") and returns the unencoded string.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| text | String | The string to be URL-decoded |

#### Return Value

The decoded string.

### UrlEncode(url as String) as String

> This method is deprecated. Use the [Escape()](/docs/references/brightscript/interfaces/ifurltransfer.md#escapetext-as-string-as-string) method.

#### Description

URL encodes the specified string per RFC 3986 and return the encoded string

| Name | Return Type | Parameters | Return Value | Description |
| --- | --- | --- | --- | --- |
| UrlEncode | String | ${UrlEncodeParameters} | URL-encoded String |     |

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| text | String | The string to be URL-encoded |

#### Return Value

The encoded string.

### EnableResume(enable as Boolean) as Boolean

#### Description

Enables automatic resumption of `AsyncGetToFile` and `GetToFile` requests

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| enable | Boolean | A flag specifying whether to automatically resume `AsyncGetToFile` and `GetToFile` requests |

#### Return Value

A flag indicating whether the operation was successful.

### EnablePeerVerification(enable as Boolean) as Boolean

#### Description

Verifies that the certificate has a chain of trust up to a valid root certificate using CURLOPT\_SSL\_VERIFYPEER.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| enable | Boolean | A flag specifying whether to verify a certificate has a chain-of-trust up to a valid root certificate |

#### Return Value

A flag indicating whether the operation was successful.

### EnableHostVerification(enable as Boolean) as Boolean

#### Description

Verifies that the certificate belongs to the host using CURLOPT\_SSL\_VERIFYHOST.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| enable | Boolean | A flag specifying whether to verify a certificate belonging to the host. |

#### Return Value

A flag indicating whether the operation was successful.

### EnableFreshConnection(enable as Boolean) as Boolean

> The Roku OS no longer supports this function. Channels should always reuse connections because it is more efficient (new connections impact app performance by increasing latency and consuming more CPU).

#### Description

Enables a fresh connection using CURLOPT\_FRESH\_CONNECT.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| enable | Boolean | A flag specifying whether to enable fresh connections. |

#### Return Value

A flag indicating whether the operation was successful.

### SetHttpVersion(version as String) as Void

#### Description

An optional function that enables HTTP/2 support. If version is set to `"http2"`, HTTP/2 will be used for all underlying transfers.

This must be set on a roUrlTransfer instance prior to any data transfer. The HTTP version used by an instance cannot be changed after the instance's first use.

For the HTTP/2 connection sharing feature, all roUrlTransfers should be made from the same thread.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| version | String | The http version to be used (for example, "http2" for HTTP/2). `"AUTO"` is the default value, which causes the roUrlTransfer connection to auto-negotiate HTTP/1.x or HTTP/2, depending on the agreement reached by client and server. |

> SetHttpVersion does not impact the connection made by the Roku Media player, which will always use HTTP/1.x.

### GetUserAgent() as String

_Available since Roku OS 12.5_

#### Description

Returns the user agent of the device, which can then be passed into server-side ad requests.

#### Return Value

The device user agent, which has the following syntax: "Roku/DVP-major.minor (major.minor.revision.build-plid)". For example, Roku/DVP‑12.0 (12.0.0.4171‑29).

TextEditBox
===========

Extends [**Group**](/docs/references/scenegraph/layout-group-nodes/group.md "**Group**")

The **TextEditBox** node class is intended to display a string of characters as they are typed. When focused, it displays a flashing cursor to indicate the text insertion position.

**TextEditBox** nodes are automatically included in the [**Keyboard**](/docs/references/scenegraph/widget-nodes/keyboard.md "**Keyboard**") and [**MiniKeyboard**](/docs/references/scenegraph/widget-nodes/minikeyboard.md "**MiniKeyboard**") node classes.

The default appearance of the **TextEditBox** is very transparent, allowing it to pick up most of its color from what is rendered underneath it. The appearance can be customized by changing the backgroundUri and other fields.

Fields
------

| Field | Type | Default | Access Permission | Description |
| --- | --- | --- | --- | --- |
| text | string | ""  | Read-Write | Contains the string of characters being displayed. |
| hintText | string | ""  | Read-Write | Specifies a string to be displayed if the length of the text field string is zero. The typical usage of this field is to prompt the user about what to enter (such as, "Enter your WiFi password"). |
| maxTextLength | integer | 15  | Read-Write | Specifies the maximum length of the string that can be displayed. When used internal to the **Keyboard** node, maxTextLength is initialized to 75. When used in the **MiniKeyboard** node, maxTextLength is initialized to 25. |
| cursorPosition | integer | 0   | Read-Write | By default, this is set to the length of the text field, indicating that the next character to be entered should be appended at the end of the string. When used internal to the **Keyboard** and **MiniKeyboard** nodes, those nodes use this field to move the text insertion point. |
| clearOnDownKey | boolean | true | Read-Write | When clearOnDownKey is set to true, the textEditBox erases all the characters when down key is pressed (focus does not move down). When set to false, the characters are not erased and focus moves down. |
| active | boolean | false | Read-Write | When active is set to true, the cursor is displayed. When set to false, the cursor is hidden. When used internal to the **Keyboard** and **MiniKeyboard** nodes, those nodes set this field to true when the keyboard has focus, and false when it does not. |
| secureMode | boolean | false | Read-Write | When set to true, the characters entered are briefly displayed, then replaced with an asterisk. When set to false, the characters entered are always displayed. When used internal to the **Keyboard** and **MiniKeyboard** nodes, you can access the keyboard **textEditBox** field to set its secureMode field. For example: `myKeyboard.textEditBox.secureMode = true` |
| textColor | color | 0xffffffff | Read-Write | Specifies the color of the text string displayed. |
| hintTextColor | color | 0xffffffff | Read-Write | Specifies the color of the hint text string. |
| width | float | \-1.0 | Read-Write | Specifies the width of the **TextEditBox** node. When used internal to the **Keyboard** and **MiniKeyboard** nodes, those nodes set this field to match the width of the keyboard. |
| backgroundUri | string | ""  | Read-Write | Specifies the URI of the image rendered as the background of the **TextEditBox** node. |
| leadingEllipsis | Boolean | false | READ\_WRITE | Specifies whether to display the end or beginning of text that overflows its available width:  <br><br>*   **true**. The end of the text is shown. For example, "the quick brown fox jumps over the lazy dog" would be truncated to "...jumps over the lazy dog".<br>*   **false**. The start of the text is shown (for example, "the quick brown fox jumps..."). |

Sample app
----------

[TextEditBoxExample](https://github.com/rokudev/samples/tree/master/ux%20components/widgets/TextEditBoxExample) is a sample app demonstrating TextEditBox in action.

Program statements
==================

DIM name (dim1, dim2, …, dimK)
------------------------------

DIM ("dimension") is a statement that provides a short cut to creating roArray objects. It sets variable _name_ to type "roArray", and creates Arrays of Arrays as needed for multi-dimensional arrays. The dimension passed to Dim is the index of the maximum entry to be allocated (the array initial size = dimension+1); the array will be resized larger automatically if needed.

    Dim array[5]
    

Is the same as:

    array=CreateObject("roArray",6,true)
    

Note that x\[a,b\] is the same as x\[a\]\[b\].

     Dim c[5, 4, 6]
     For x = 1 To 5
        For y = 1 To 4
            For z = 1 To 6
                c[x, y, z] = k
                k = k + 1
            End for
        End for
     End for
    
    
     k=0
     For x = 1 To 5
        For y = 1 To 4
            For z = 1 To 6
                If c[x, y, z] <> k Then print"error" : Stop
                If c[x][y][z] <> k Then print "error": Stop
                k = k + 1
            End for
        End for
     End for
    

variable = expression
---------------------

Assigns a variable to a new value.

**Example**

    a$="a rose is a rose"
    b1=1.23
    x=x-z1
    

In each case, the variable on the left side of the equals sign is assigned the value of the constant or expression on the right side.

END
---

Terminates execution normally.

STOP
----

Interrupts execution return a STOP error. Invokes the debugger. Use "cont" at the debug prompt to continue execution, or "step" to single step.

GOTO label
----------

Transfers program control to the specified line number. GOTO _label_ results in an branch. A label is an identifier terminated with a colon, on a line by itself.

For example:

    mylabel:
    print "Anthony was here!"
    Goto mylabel
    

RETURN \[expression\]
---------------------

Used to return from a function back to the caller. If the function is not of type Void, return can return a value to the caller.

FOR counter = exp TO exp \[STEP exp\] / END FOR
-----------------------------------------------

Creates an iterative (repetitive) loop so that a sequence of program statements may be executed over and over a specified number of times. The general form is (brackets indicate optional material):  
FOR _counter-variable = initial value_ TO _final value_ \[STEP _increment_\]  
\[_program statements_\]  
END FOR  
In the FOR statement, _initial value, final value_ and _increment_ can be any expression. The first time the FOR statement is executed, these three are evaluated and the values are saved; if the variables are changed by the loop, it will have no effect on the loop's operation. However, the counter variable must not be changed or the loop will not operate normally. The first time the FOR statement is executed the counter is set to the "initial value" and to the type of "initial value".  
At the top of the loop, the counter is compared with the _final value_ specified in the FOR statement. If the counter is greater than the _final value_, the loop is completed and execution continues with the statement following the END FOR statement. (If _increment_ was a negative number, loop ends when counter is less than _final value_.) If the counter has not yet exceeded the _final value_, control passes to the first statement after the FOR statement.  
When program flow reaches the END FOR statement, the counter is incremented by the amount specified in the STEP _increment_. (If the _increment_ has a negative value, then the counter is actually decremented.) If STEP _increment_ is not used, an increment of 1 is assumed.

For example:

    For i=10 To 1 Step -1
        print i
    End For
    

"EXIT FOR" is used to exit a FOR block prematurely.

FOR EACH item IN object
-----------------------

The FOR EACH statement iterates through each item in any object that has an "ifEnum" interface (enumerator). The For block is terminated with a END FOR statement. The variable _item_ is set at the top of the loop to the next item in the object. Objects that are intrinsically ordered (like a List) are enumerated in order. Objects that have no intrinsic order (like AssociativeArray) are enumerated in apparent random order. It is okay to delete entries as you enumerate them.

"EXIT FOR" is used to exit a FOR block prematurely.  
The following objects can be enumerated: roList, roArray, roAssociativeArray, roMessagePort.

For example:

    aa = { joe: 10, fred: 11, sue:9 }
    
    For Each n In aa
        Print n;aa[n]
        aa.delete(n)
    End For
    

WHILE expression / EXIT WHILE / END WHILE
-----------------------------------------

The While loop executes until expression is false. The "exit while" statement can be used to terminate a while loop prematurely.

For example:

    k = 0
    while k = 0
        k = 1
        print "loop once".
    end while
    
    while true
        print "loop once"
        if k <> 0 then exit while
    end while
    

CONTINUE FOR / CONTINUE WHILE
-----------------------------

The "continue" statement terminates the execution of the statements in the current iteration of the loop, and continues execution of the loop with the next iteration

For example:

    fruits = ["orange", "lemon", "lime"]
    for each fruit in fruits
        if fruit = "lemon" then continue for
        ? fruit
    end for
    ...
    counter = 0
    while counter < 3
        if counter = 1 then
            counter++
            continue while
        end if
        ? counter
        counter++
    end while
    

TRY / CATCH variable / END TRY
------------------------------

Use to trap exceptions, which enables the implementation of error handling in BrightScript programs. Schematically, the syntax is as follows:

    TRY
        ' Zero or more statements ("TRY block")
    CATCH exception_object_variable_name
        ' Zero or more statements ("CATCH block")
    END TRY
    

> END TRY and ENDTRY are equivalent

The TRY block of statements is executed. If and only if an error occurs, the CATCH block of statements is executed, and the named variable is assigned the information about the triggering exception. If no error occurs during execution of the TRY block, the CATCH block is skipped.

> It is illegal to put a GOTO label within a TRY block (i.e., between TRY and CATCH). A GOTO label may exist exist between CATCH and END TRY, however.

The variable name specified as the _exception object_ in the CATCH clause must refer to a _simple variable_. It cannot be an array element, for example. The following are **not** legal as exception object references in the CATCH clause:

    CATCH                ' no object variable at all -- an object must always be specified
    CATCH someArray[23]  ' array element is bad exception object
    CATCH bill.ted       ' object field is bad exception object
    CATCH 22             ' literal constant is bad exception object
    CATCH a+wave         ' expression is bad exception object
    

Information about the exception is contained within an exception object that is assigned to the CATCH-clause variable. This exception object can contain the following elements:

| Name | Type | Meaning |
| --- | --- | --- |
| number | Integer | The classic BrightScript error number |
| message | String | A textual interpretation of the error number |
| backtrace | roArray | A backtrace, normally, to the location (origin) of the problem, even if the exception is subsequently caught and "re-thrown." |
| rethrown | boolean | False: This is the first time that this exception has been caught. True: The exception has been caught and re-thrown; the backtrace is therefore _not_ to the location of the most recent THROW. |
| rethrow\_backtrace | roArray | A second backtrace, to the location of a re-thrown exception. |

A backtrace is an array of associative arrays, each of which includes at least the following elements:

| Name | Type | Meaning |
| --- | --- | --- |
| filename | String | The URI-formatted filename |
| line\_number | Integer | The line number within that file |
| function | String | The prototype/signature (name, arguments, return type) of the function |

**Example code**

The following example sends an error message, including the contents of the exception record, to the debug console.

    TRY
        PRINT 1/0
    CATCH e
        PRINT "Division failed: ", e
    END TRY
    

> TRY and CATCH are _not_ keywords in BrightScript. Programmers should treat them as reserved identifiers and avoid using them. In particular, legacy code that may already employ them as ordinary identifiers should be rewritten to use different identifiers instead.
> 
> TRY and CATCH were introduced into BrightScript with Roku OS version 9.4, and any app that uses them must declare a minimum OS version of 9.4 in the Package Upload Developer Dashboard page during app submission.

### Nested TRY/CATCH statements

TRY/CATCH statements can be nested within TRY or CATCH blocks, as needed. Here is an example:

    PRINT "Starting"
    x = "I'm not an array"
    TRY
        PRINT "x[0]*2=";x[0]*2
    CATCH e
        TRY
            PRINT "I think that failed because ";x[0];" isn't a number"
        CATCH e
            PRINT "Nope, I guessed wrong: ";e.message
        END TRY
    END TRY
    PRINT "Ending"
    

> The STOP statement produces an uncatchable error, consistent with its intended use in debugging.

THROW expression
----------------

Use the THROW statement to propagate an exception back to the caller of the present code.

The expression given in the THROW statement should evaluate to an exception object (or the equivalent associative array), as defined for TRY/CATCH. A single String is also acceptable as operand, however. In that case, BrightScript creates a default exception object, fills the `message` field with the supplied String, and sets the error number to `ERR_USER` (`&h28`).

> THROW is a keyword in BrightScript.
> 
> THROW was introduced into BrightScript with Roku OS version 9.4, and any app that uses it must declare a minimum OS version of 9.4 in the Package Upload Developer Dashboard page during app submission.

**Example code**

    FUNCTION reciprocal(x)
        RETURN 1/x
    END FUNCTION
    
    FUNCTION factorial(n)
        IF n < 0 THEN
            THROW "Cannot calculate negative factorial."
        ELSE IF n = 0 THEN
            RETURN 1
        ELSE
            RETURN n * factorial(n-1)
        END IF
    END FUNCTION
    
    SUB main()
        TRY
            PRINT reciprocal(0)
        CATCH e
            PRINT "reciprocal() failed: ", e.message
        END TRY
    
        PRINT factorial(-2) ' Error will be reported by BrightScript runtime/debugger
    END SUB
    

REM
---

Instructs the compiler to ignore the rest of the program line. This allows you to insert comments (REMarks) into your program for documentation. An ' (apostrophe) may be used instead of REM.

For example:

    Rem ** this remark introduces the program **
    ' this too is a remark
    

IF expression THEN statements \[ELSE statements\]
-------------------------------------------------

There are two forms of the IF THEN ELSE statement. The single line form (this one), and the multi-line or block form (see next section). The IF instructs the Interpreter to test the following _expression_. If the _expression_ is true, control will proceed to the statements immediately following the expression. If the expression is False, control will jump to the matching ELSE statement (if there is one) or down to the next program line.

For example:

    if x > 127 then print "out of range"
    If caveman = "fred" then print "flintstone" else print "rubble"
    

THEN is optional in the above and similar statements.

Block IF, ELSEIF, THEN, ENDIF
-----------------------------

The multi-line or block form of IF THEN ELSE is more flexible. It has the form:

     if BooleanExpression then
       statements
     elseif BooleanExpression then
       statements
     else
       statements
     end if
    

There may be any number of elseif statements, or there may be none. The else statement may also be omitted. "elseif" can also be written as two words: "else if".

For example:

    msg = wait(0, p)
    if type(msg) = "roVideoPlayerEvent" then
        if debug then print "video event"
        if msg.isFullResult()
            if debug then print "video finished"
            return 9
        end if
    else if type(msg) = "roUniversalControlEvent" then
        if debug then print "button press "; msg.GetInt()
        HandleButton(msg.GetInt())
    elseif msg = invalid then
        if debug print "timeout"
        return 6
    end if
    

PRINT item list
---------------

Prints an item or a list of items on the console. The items may be either strings, number, variables, or expressions. Objects that have an ifInt, ifFloat, or ifString interface may also be printed.

The items to be PRINTed may be separated by commas or semi-colons. If commas are used, the cursor automatically advances to the next print zone before printing the next item. If semi-colons are used, no space is inserted between the items printed.

Positive numbers are printed with a leading blank (instead of a plus sign); floating point numbers are printed with a trailing blank; and no blanks are inserted before or after strings.

For example:

    x=5:print 25; " is equal to"; x^2
     25 is equal to 25
    
    a$="string":print a$;a$,a$;" ";a$
    stringstring    string string
    
    print "zone 1","zone 2","zone 3","zone 4"
    zone 1          zone 2          zone 3          zone 4
    

> `?` is a short cut for the `print` statement. For example:
> 
>     x=5:? 25; " is equal to"; x^2
>     

Each print zone is 16 char wide. The cursor moves to the next print zone each time a comma is encountered.

    print "print statement #1 "; "print statement #2"
    
    Output: print statement #1 print statement #2
    

Semi-colons can be dropped in some cases. For example, this is legal:

    Print "this is a five " 5 "!!"
    

A trailing semi-colon over-rides the cursor-return so that the next PRINT begins where the last one left off. If no trailing punctuation is used with print, the cursor drops down to the beginning of the next line.

A few examples of printing enumerable objects:

**Printing Enumerable Objects**

    Print {}
    ' this will print: <Component: roAssociativeArray> =  { }
    
    Print {a:1}
    ' this will print: <Component: roAssociativeArray> =  { a: 1 }
    
    Print []
    ' this will print: <Component: roArray> = [ ]
    
    Print [5]
    ' this will print: <Component: roArray> = [ 5 ]
    

**TAB (expression)**  
Moves the cursor to the specified position on the current line (modulo the width of your console if you specify TAB positions greater than the console width). TAB may be used several times in a PRINT list.

    print tab(5)"tabbed 5";tab(25)"tabbed 25"
    

No punctuation is required after a TAB modifier. Numerical expressions may be used to specify a TAB position. TAB cannot be used to move the cursor to the left. If the cursor is beyond the specified position, the TAB is ignored.

**POS ( x )**  
Returns a number from 0 to window width, indicating the current cursor position on the cursor. Requires a "dummy argument" (any numeric expression).

    print tab(40) pos(0) 'prints 40 at position 40
    print "these" tab(pos(0)+5)"words" tab(pos(0)+5)"are"; tab(pos(0)+5)"evenly" tab(pos(0)+5)"spaced"
    

FUNCTION(\[parameter \[= default\] AS type, …\]) AS type / END FUNCTION
-----------------------------------------------------------------------

A function is declared using the function statement. In parentheses, one or more optional parameters to be passed may be declared. The return type of the function may also be declared. If the parameter or return type are not declared, they are assumed to be "dynamic" Intrinsic types are passed by value (a copy is made). Objects are passed by reference. Parameters can be of type:

*   Integer
*   Float
*   Double
*   Boolean
*   String
*   Object
*   Dynamic
*   Function

In addition to the above types, the return type can be:

*   Void

Each parameter can have a default value, which is used if the parameter is not included in the call. The default parameter is declared by following the parameter name with an equal sign and the default value. If any parameter has a default value, then each following parameter must also have a default value. In the following examples, the functions add2 and add3 can be called with either one or two parameters.

For example:

    Function cat(a, b)
        Return a+b 'a, b could be numbers or strings
    End Function
    
    Function five() as Integer
        Return 5
    End function
    
    Function add(a as Integer, b as Integer) As Integer
        Return a+b
    End function
    
    
    Function add2(a as Integer, b=5 as Integer) As Integer
        Return a+b
    End Function
    
    
    Function add3(a as Integer, b=a+5 as Integer) as Integer
        Return a+b
    End Function
    

Functions have their own scope.

The statement "Sub" can be used instead of "function" as a shortcut to a function of Void return Type.

If a function is called from an associative array, then a local variable "m" is set to the AssociativeArray that the function is stored in.

For example:

    Sub main()
        obj={
            add: add
            a: 5
            b: 10
        }
    
        obj.add()
        print obj.result
    End Sub
    
    
    Function add() as void
        m.result = m.a + m.b
    End Function
    

If a function is not called from an AssociativeArray, then its "m" is set to an AssociativeArray that is global to the module, and persists across calls.

Anonymous functions
-------------------

A function is anonymous if it does not have a name. Note that Anonymous Functions do not currently create closures. An Anonymous Function can be declared like this:

    myfunc = Function (a, b)
        Return a+b
    End Function
    
    print myfunc(1,2)
    

They can be used with associative array literals like this:

    q = {
        starring : Function(o, e)
            str = e.GetBody()
            print "Starring: " + str
            toks = box(str).tokenize(",")
            For Each act In tok
                actx = box(act).trim()
                If actx <> "" Then
                    print "Actor: [" + actx + "]"
                    o.Actors.Push(actx)
                End If
            End For
            Return 0
        End Function
    }
    
    q.starring(myobj, myxml)

roVideoPlayerEvent
==================

The roVideoPlayer sends the roVideoPlayerEvent with the following predicates that indicate its valid event types:

Supported methods
-----------------

### isPaused() as Boolean

Checks whether video playback was paused by the user. This method returns true if video playback was paused; otherwise, it returns false.

### isListItemSelected() as Boolean

Checks whether the video player is about to start playing a new item in the content list. This method returns true if a new item in the content list was selected; otherwise, it returns false.

#### GetIndex() as Integer

Returns the index of the item that is about to start playing.

### isFormatDetected() as Boolean

Checks whether an event has been fired when the format of all tracks in the media stream have been identified.

Specific information about the event can be obtained by calling the GetMessages() and GetInfo() methods on the event.

#### GetMessage() as String

Returns a description of the message (for exampe, "Format Detected").

#### GetInfo() as Object

Returns information about the video player event. This method returns an roAssociativeArray that contains the following keys:

| Key | Value |
| --- | --- |
| audio | The format of the audio stream, if any |
| captions | The format of the captioning data, if any |
| video | The format of the video stream, if any |

### isRequestFailed() as Boolean

Checks whether video playback has failed. This method returns true if video playback failed; otherwise, it returns false.

Specific information about the event can be obtained by calling the GetMessage(), GetIndex(), and GetInfo() methods on the event.

#### GetMessage() as String

Returns a description of the message (for example, "Segment download started").

#### GetIndex() as Integer

Returns the error ID, which may be one of the following values:

| Value | Description |
| --- | --- |
| 0   | Network error : server down or unresponsive, server is unreachable, network setup problem on the client. |
| \-1 | HTTP error: malformed headers or HTTP error result. |
| \-2 | Connection timed out |
| \-3 | Unknown error |
| \-4 | Empty list; no streams were specified to play |
| \-5 | Media error; the media format is unknown or unsupported |
| \-6 | DRM error |

#### GetInfo() as Object

Returns an associative array containing information about the event failure. The associative array contains the following key-value pairs:

| Key | Type | Value |
| --- | --- | --- |
| ClipIdx | Integer | The zero starting index of the item in the content list this event is related to. |
| Ignored | Boolean | True if the error was ignored and the player skipped to the next item in the content list. |

### isSegmentDownloadStarted() as Boolean

Checks whether the individual segments in an HLS or smooth stream are about to be downloaded. This method returns true if segments in the stream are going to be downloaded; otherwise, it returns false.

Specific information about the event can be obtained by calling the GetMessages() and GetInfo() methods on the event.

#### GetMessage() as String

Returns a description of the message (for example, "Segment download started").

#### GetInfo() as Object

Returns an associative array containing the following information about the segment download event:

| Key | Value |
| --- | --- |
| Sequence | Stream segment sequence number |
| SegBitrate | Bitrate of the segment, in kilobits per second |
| StartTime | Timestamp of the start of the segment data |
| EndTime | Timestamp of the end of the segment data |

### isStreamStarted() as Boolean

Checks whether the video stream has started playing. This method returns true if the video stream has started playing; otherwise, it returns false. Specific information about the event can be obtained by calling the GetIndex() and GetInfo() methods on the event.

#### GetIndex() as Integer

Returns the segment sequence number.

#### GetInfo() as Object

Returns an associative array containing the following information about the stream started event:

| Key | Type | Value |
| --- | --- | --- |
| Url | String | URL of video stream |
| StreamBitrate | Integer | average bitrate of stream, in bits per second |
| MeasuredBitrate | Integer | measured network bandwidth in kibibits per second, used to select stream |
| IsUnderrun | Boolean | true if this is a rebuffer due to an underrun |

### isStatusMessage() as Boolean

Checks whether status information or other diagnostic message is available. This method returns true if status information or diagnostic message is available; otherwise, it returns false. Specific information about the event can be obtained by calling the GetMessage() method on the event.

#### GetMessage() as String

Returns status information or other diagnostic message, which may be one of the following:

*   "startup progress"
*   "start of play"
*   "playback stopped"
*   "end of stream" (deprecated)
*   "end of playlist" (deprecated)

### isFullResult() as Boolean

Checks whether video playback has completed at the end of the content list. This method returns true if video playback has completed at the end of the content list; otherwise, it returns false.

### isResumed() as Boolean

Checks whether video playback has resumed. This method returns true if video playback has resumed; otherwise, it returns false.

### isCaptionModeChanged() as Boolean

Checks whether closed caption mode or track has been changed by the user. This method returns true if closed caption mode or track has been changed by the user; otherwise, it returns false. Specific information about the event can be obtained by calling the GetMessage(), GetIndex(), and GetInfo() methods on the event.

#### GetMessage() as String

Returns a caption track name, such as: "eia608/1" ,"eia608/3", and so on.

#### GetIndex() as Integer

Returns the index of the captions mode, which may be one of the following values:

| Index | Mode |
| --- | --- |
| 0   | Off |
| 1   | On  |
| 2   | Instant replay |

#### GetInfo() as Object

| Name | Return Type | Return Value | Description |
| --- | --- | --- | --- |
| GetInfo | Object | Invalid | This method always returns invalid. |

#### Example: isCaptionModeChanged() Event

    Function showVideoScreen(episode As Object)
      port = CreateObject("roMessagePort")
      screen = CreateObject("roVideoScreen")
      'some video stream
      '...
      'etc...
      episode.SubtitleConfig : {
        TrackName : "eia608/1"
        }
      screen.SetContent(episode)
      screen.SetMessagePort(port)
      screen.Show()
      while true
        msg = wait(0, port)
        if type(msg) = "roVideoScreenEvent" then
          if msg.isCaptionModeChanged()
            print "Caption Mode Changed"
            print "Caption Mode: "; msg.GetIndex()
            print "Caption track: "; msg.GetMessage()
          end if
        end if
      end while
    End Function
    

### isTimedMetaData() as Boolean

Checks whether an ID3 timecode has passed with an event that includes key-value pairs for timed metadata that the BrightScript app is interested in.

All timed metadata is released after it is delivered to the BrightScript app. It is also released without delivery if the BrightScript app did not indicate its interest in the data with a [SetTimedMetaDataForKeys()](/docs/references/brightscript/interfaces/ifvideoplayer.md#settimedmetadataforkeyskeys-as-dynamic-as-void) method call.

This method returns true if an ID3 timecode has passed; otherwise, it returns false. Specific information about the event can be obtained by calling the GetMessage(), GetIndex(), and GetInfo() methods on the event.

#### GetMessage() as String

Returns the string "Timed Metadata".

#### GetIndex() as Integer

Returns the PTS timecode.

| Name | Return Type | Return Value | Description |
| --- | --- | --- | --- |
| GetIndex | Integer | PTS timecode. |     |

#### GetInfo() as Object

Returns an associative array with timedMetadata at the PTS timecode specified in the index.

### isPlaybackPosition() as Boolean

Checks whether the current position in the video stream has changed. This event is sent periodically while playing, as determined by the last call to [ifVideoPlayer.SetPositionNotificationPeriod](/docs/references/brightscript/interfaces/ifvideoplayer.md#setpositionnotificationperiodperiod-as-integer-as-void "ifVideoPlayer.SetPositionNotificationPeriod"). This method returns true if the current position in the video stream has changed; otherwise, it returns false. Specific information about the event can be obtained by calling the GetIndex() and GetInfo() methods on the event.

### GetIndex() as Integer

Returns current position in the stream (in seconds) from the beginning.

### GetInfo() as Object

Returns an roAssociativeArray array with the following key-value pairs:

| Member | Type | Value |
| --- | --- | --- |
| ClipIdx | Integer | The zero starting index of the item in the content list this event is related to |
| ClipPos | Integer | The player position relative to the start of the clip in milliseconds |

### isStreamSegmentInfo() as Boolean

Checks whether playback has begun of a segment in an HLS, DASH, or smooth stream. This method returns true if the playback of a segment in an HLS, DASH, or smooth stream has begun; otherwise, it returns false. Specific information about the event can be obtained by calling the GetMessage(), GetIndex() and GetInfo() methods on the event.

#### GetMessage() as String

Returns a description of the message (for example, "Stream segment info").

#### GetIndex() as Integer

Returns the segment start time in seconds.

#### GetInfo() as Object

Returns an associative array with the following information about the stream segment:

| Key | Value |
| --- | --- |
| StreamBandwidth | Bandwidth of the stream being played in kbps |
| SegStartTime | Segment start time (offset from start of stream) in milliseconds |
| Sequence | Stream segment sequence number |
| SegUrl | Stream segment URL (i.e., .ts file for HLS, stream fragment URL for smooth) |
| HdrMode | Indicates the HDR format of the content, which may be one of the following values:<br><br>*   0: UNKNOWN<br>*   1: NONE (SDR)<br>*   2: HDR10<br>*   3: DOLBY\_VISION<br>*   4: HLG10<br>*   5: HDR10\_PLUS<br>*   6: SL\_HDR2 |

### isDownloadSegmentInfo() as Boolean

Checks whether a segment in an adaptive stream (HLS, Smooth, or DASH) has been downloaded. This method returns true if a segment in an adaptive stream (HLS, Smooth, or DASH) has been downloaded; otherwise, it returns false. Specific information about the event can be obtained by calling the GetMessage(), GetIndex() and GetInfo() methods on the event.

#### GetMessage() as String

Returns a description of the message (for example, "Download segment info").

#### GetIndex() as Integer

Returns the segment sequence number.

#### GetInfo() as Object

Returns an associative array containing the following information about the segment download:

| Key | Value |
| --- | --- |
| Status | Status of the download: 0 = success, nonzero = error |
| Sequence | Stream segment sequence number (same as returned by GetIndex) |
| SegUrl | Stream segment URL (i.e., .ts file for HLS, stream fragment URL for smooth) |
| DownloadDuration | Amount of time spent downloading the segment, in milliseconds |
| SegSize | Segment size, in bytes |
| SegType | Type of data in the segment: 1=audio, 2=video, 3=captions, 0=mux |
| Bitrate | Bitrate of the segment, in bits per second |
| SegBitrate | Bitrate of the segment, in kilobits per second (equal to Bitrate / 1000) |

### isRequestSucceeded() as Boolean

Checks whether the player has finished playing an item in the content list. This method returns true if the player has finished playing a content list item; otherwise, it returns false. Specific information about the event can be obtained by calling the GetIndex() method on the event.

#### GetIndex() as Integer

Returns the index of the item in the content list that finished playing.

Automatic Account Link
======================

Automatic account link enables apps to authenticate customers using an access token or authentication artifact stored in the Roku cloud. This simplifies authentication for customers with multiple Roku devices: Once successfully authenticated on one device, customers are automatically signed in when they activate additional Roku devices linked to the same Roku account.

> **Certification requirement**: Apps requiring a user account to log in that have streamed more than average of 1 million hours per month over the last three months (and new Apps expected to reach the threshold shortly after launch) must implement Automatic Account Link to pass [certification](/docs/developer-program/certification/certification.md#4-app-operation). This requirement is applicable for TVE apps that use Adobe Primetime Authentication.

Overview
--------

To implement Automatic Account Link, you first check whether there is a valid access token stored in the device registry. If the device registry contains an access token, grant the customer access to your content.

If the device registry does not contain a valid access token, you check whether one is stored in the Roku cloud. If there is an access token in the Roku cloud, store it in the device registry and then grant the customer access to your content; otherwise, display your app UI and have the customer sign in or sign up and then grant access.

The following table summarizes the logic to be used for Automatic Account Link; the subsequent flow chart illustrates this workflow.

| Valid Access Token in Device Registry ? | Valid Access Token in Roku Cloud? | Next Steps |
| --- | --- | --- |
| YES | —   | Get a refresh token from your entitlement server and store it in the device registry and Roku cloud. Grant access to content. |
| NO  | YES | Store the access token in the device registry. Grant access to content. |
| NO  | NO  | Display your app UI, get the customer's email address, and have them sign up or sign back in. Once the customer has successfully authenticated, generate a new access token from your entitlement server and store it in the device registry and Roku cloud. Grant access to content. |

![roku815px - automatic account link flow chart](https://image.roku.com/ZHZscHItMTc2/AAL.jpg)

Checking for a valid access token in the device registry
--------------------------------------------------------

To check for a valid access token in the device registry, follow these steps:

1.  Create an [**roRegistrySection**](/docs/references/brightscript/components/roregistrysection.md) object. This provides access to your section within the device registry to get and read your keys. When creating the registry section, pass in the name of your registry. This must be the same name used when the registry section was created.

       reg_sec = CreateObject("roRegistrySection", <your_registry_section>")
    

> To get a list of the keys in the registry section in order to find the one linked to the access token, call the [**roRegistrySection.getKeyList()**](/docs/references/brightscript/interfaces/ifregistrysection.md#getkeylist-as-object) method.

2.  Use the **roRegistrySection.read()** method to retrieve the access token. This method takes the name of the key to get the value associated with it.

       access_token_value = reg_sec.read("access_token_key_name")
    

3.  Check the access token in your entitlement server to verify whether it is still valid.
    
    *   If the access token is valid, get a refresh token from your entitlement server and store it in the device registry. Call the [**roRegistrySection.write()**](/docs/references/brightscript/interfaces/ifregistrysection.md#writekey-as-string-value-as-string-as-boolean) and [**roRegistrySection.flush()**](/docs/references/brightscript/interfaces/ifregistrysection.md#deletekey-as-string-value-as-string-as-boolean) methods to permanently store the refresh token on the device:

         reg_sec.write("access_token_key_name", "access_token_value")
         reg_sec.flush()
    

*   Store the access token in the Roku cloud. Grant access to content. In this case, no additional steps are required and authentication is complete.

*   If the access token is invalid or there is no access token, [check for an access token in the Roku cloud](#checking-for-a-valid-access-token-in-the-roku-cloud). Use the [**roRegistrySection.delete()**](/docs/references/brightscript/interfaces/ifregistrysection.md#deletekey-as-string-as-boolean) method to delete an invalid access token from the device registry:

         reg_sec.delete("access_token_key_name")
    

Checking for a valid access token in the Roku cloud
---------------------------------------------------

To check for a valid access token in the Roku cloud, follow these steps:

1.  Call the [**ChannelStore.getChannelCred**](/docs/references/scenegraph/control-nodes/channelstore.md#getchannelcred) command. This causes the **channelCred** field to be set to a **ContentNode** that includes a **json.channel\_data** field.

       myChannelStore.command = "getChannelCred"
       accessToken = myChannelStore.channelCred.json.channel_data
    

2.  If the **json.channel\_data** field contains your access token, check whether the customer is currently signed in using a flag in the device registry. This is a publisher-specific key-value pair that you have previously added to your registry section to track the login status of customers. The value should be toggled when customers sign in and out.

3.  If the customer is signed in, store the access token retrieved from the Roku cloud in the device registry, and then grant the customer access to the content. In this case, no additional steps are required and authentication is complete.

4.  If the customer is signed out (or is signing up), display your app UI and have them [sign in](#signing-users-in).

Signing users in
----------------

If both the device registry and Roku cloud do not contain a valid access token, open your app UI to have the customer sign in (or sign up) following these steps:

1.  Set the [**ChannelStore.requestedUserData**](/docs/references/scenegraph/control-nodes/channelstore.md#fields) field to "email, firstName, lastName" to ask the customer to share their email address and name from their account, and then call the [**ChannelStore.getUserData**](/docs/references/scenegraph/control-nodes/channelstore.md#getuserdata) command to get the email address and name.

       myChannelStore.requestedUserData("email, firstName, lastName")
       myChannelStore.command = "getUserData"
    

2.  When you call the the **ChannelStore.getUserData** command, a "Request for information" screen is displayed automatically. It asks the customer whether your app can access the account information linked to their email address and name.

3.  If the customer clicks **Allow**, the `userData` field is automatically set to a **ContentNode** that contains a string field with the customer's email address and name. If the customer is signing up, you will send all the information stored in this ContentNode to your system after they submit their account information.

       email = myChannelStore.userData.email
       firstName = myChannelStore.userData.firstName
       lastName = myChannelStore.userData.lastName
    

4.  Optionally, display a [keyboard dialog](/docs/references/scenegraph/standard-dialog-framework-nodes/standard-keyboard-dialog.md) pre-populated with the customer's email address so that they can verify their email address or enter a different one. If the customer clicks **Cancel**, the `userData` field is set to "invalid". In this case, display an empty [keyboard dialog](/docs/references/scenegraph/standard-dialog-framework-nodes/standard-keyboard-dialog.md) so the customer can enter their email address for your app.

5.  Display a keyboard for the customer to enter their password. If the customer is signing up and has allowed access to their Roku account information, pre-populate the keyboard with an auto-generated secure password, which the customer can accept or edit. If the customer is signing in or does not allow access, display an empty [keyboard dialog](/docs/references/scenegraph/dialog-nodes/keyboarddialog.md) so the customer can enter their password for your app.

6.  After the customer submits their password, validate their credentials in your system. If the credentials are valid, obtain an access token from your entitlement server, and store it in the device registry and in the Roku cloud. In the device registry, also update the login status flag.
    
    To store an access token in the Roku cloud, call the [**ChannelStore.storeChannelCredData**](/docs/references/scenegraph/control-nodes/channelstore.md#storechannelcreddata) command. You can use the **status** and **response** fields of the **storeChannelCredDataStatus** content node to verify that the command was successful and that the access token stored in the Roku cloud has the specified value.
    

> Any metadata within the access token related to its validity must be managed entirely by the publisher.

        myChannelStore.channelCredData = "your access token"
        myChannelStore.command = "storeChannelCredData"
    
        'check if command was successful
        status = myChannelStore.storeChannelCredDataStatus.status
        if status = 0
           ...
        end if
    
        'check if access token stored in Roku cloud has specifed value
        response = myChannelStore.storeChannelCredDataStatus.response
        if response.json.channel_data = myChannelStore.channelCredData
            ...
        end if
    

7.  If the customer is signing up, create a new account for them in your system. Use the `userData` field to send the customer's email address and name to your system.

8.  Grant the customer access to the content. No additional steps are required and authentication is complete.

Signing users out
-----------------

When a user signs out of the partner application, it is up to the application to enforce the partner's preferred protocol: The app could sign out the user account on all devices, for example, or sign out just the user on a particular device.

Roku does not recommend any one approach to addressing sign out situations, and leaves such decisions to individual partners, so that they can have the flexibility to do what is appropriate for their own business requirements.

Testing Automatic Account Link
------------------------------

You can test Automatic Account Link by sideloading your app and using the [billing test feature in the Developer Dashboard](/docs/developer-program/roku-pay/testing/billing-testing.md).

ifListToArray
=============

Implemented by
--------------

| Name | Description |
| --- | --- |
| [roList](/docs/references/brightscript/components/rolist.md "roList") | The list object implements the interfaces: ifList, ifArray, ifEnum and therefore can behave like an array that can dynamically add members |
| [roXMLList](/docs/references/brightscript/components/roxmllist.md "roXMLList") | Contains a list of roXML objects |

Supported methods
-----------------

### ToArray() As Object

> This function is available in Roku OS 8.0 or later

#### Description

Returns an roArray containing the same elements as the list.

#### Return Value

An element list as an array.

Transitioning to SceneGraph
===========================

The following summarizes how to transition from the older Roku API to SceneGraph applications. In general, SceneGraph handles events without requiring you to write custom event loops, and allows you easily add custom event handlers by observing virtually any of the fields used in your SceneGraph application. Also, SceneGraph supplies built-in node classes that are very similar to some BrightScript UI screen components, but also gives you much greater flexibility to build your own custom screens. Because SceneGraph is more dynamic, flexible, and object-oriented than the older Roku API for building UI elements, you cannot write an equivalent SceneGraph application by simply substituting different function names and argument lists for UI elements.

However, much of your existing BrightScript code that handles other aspects of your application can probably be used in the new context of a SceneGraph application. For example, calls to your existing BrightScript functions can be added to any SceneGraph XML component file, by specifying the location of the BrightScript file in the package components directory in the **<script>** element. For example, if you had a set of functions to manipulate URLs, you could add the following **<script>** element to allow a SceneGraph component to call the functions:

    <script type = "text/brightscript" uri = "pkg:/components/uriutils.brs"/>
    

If these calls relied on application global data, you would have to set up a _global node_ as described in [Data scoping](/docs/developer-program/core-concepts/data-scoping.md) for this data.

There is a simplifying assumption you can make when transitioning an older Roku API application to SceneGraph. In many cases, SceneGraph replaces a series of BrightScript component interface function calls with setting and reading of node class fields of the equivalent parameters. For example, the SetNumPinEntryFields() interface function call for the roPinEntryDialog component is replaced by setting the `pinLength` field of the internal **PinPad** node object of a [PinDialog](/docs/references/scenegraph/standard-dialog-framework-nodes/standard-pinpad-dialog.md) node. But note that for many of the older Roku API screen components, you must develop your own custom screen component equivalent from more fundamental SceneGraph node classes. For example, you must develop an equivalent of the roSearchScreen component using the [MiniKeyboard](/docs/references/scenegraph/widget-nodes/minikeyboard.md) node class as the user input basis of a custom SceneGraph search screen component. You must then write additional BrightScript code to replicate the function of the roSearchScreen component.

| BrightScript Component | SceneGraph Equivalent | Implementation Notes |
| --- | --- | --- |
| roAudioPlayer | [Audio](/docs/references/scenegraph/media-playback-nodes/audio.md) node | The roSpringboardScreen component for user selection of audio files can be created using SceneGraph list and grid node classes. |
| roFont, roFontRegistry | [Font](/docs/references/scenegraph/typographic-nodes/font.md) node | The Font node simplifies specifying different fonts. |
| roListScreen | [LabelList](/docs/references/scenegraph/list-and-grid-nodes/labellist.md), [MarkupList](/docs/references/scenegraph/list-and-grid-nodes/markuplist.md), [RowList](/docs/references/scenegraph/list-and-grid-nodes/rowlist.md), [CheckList](/docs/references/scenegraph/list-and-grid-nodes/checklist.md), [RadioButtonList](/docs/references/scenegraph/list-and-grid-nodes/radiobuttonlist.md) nodes | SceneGraph gives you many more options and flexibility for list screens. |
| roSearchScreen | [MiniKeyboard](/docs/references/scenegraph/widget-nodes/minikeyboard.md) node | The MiniKeyboard node class can be used as the user input basis of a custom SceneGraph component equivalent to the roSearchScreen component. |
| roKeyboardScreen | [MiniKeyboard](/docs/references/scenegraph/widget-nodes/minikeyboard.md), [Keyboard](/docs/references/scenegraph/widget-nodes/keyboard.md) nodes | The keyboard screens and SceneGraph keyboard node classes are very similar in appearance and operation. |
| roUniversalControlEvent | [onKeyEvent()](/docs/developer-program/core-concepts/handling-application-events.md) | SceneGraph supplies a single function that replaces the need to write a remote control input event handling loop. |
| roPinEntryDialog | [PinDialog](/docs/references/scenegraph/dialog-nodes/pindialog.md) node | The function of the PinDialog node is almost identical to the roPinEntryDialog component. |
| roGridScreen | [PosterGrid](/docs/references/scenegraph/list-and-grid-nodes/postergrid.md), [MarkupGrid](/docs/references/scenegraph/list-and-grid-nodes/markupgrid.md), [RowList](/docs/references/scenegraph/list-and-grid-nodes/rowlist.md) nodes | The built-in SceneGraph poster grid node classes are simpler, but much more flexible. You can use SceneGraph to create a custom grid screen identical to the older Roku API, but even better, you can create a completely original grid screen of your own design. |
| roImageCanvas, roScreen | SceneGraph | SceneGraph starts with the ability to draw your own custom screen elements, then use them as objects throughout your application. |
| roSpringboardScreen | SceneGraph | The roSpringboardScreen component for user selection of audio/video files can be created using SceneGraph list and grid node classes. |
| BrightScript Component Events | SceneGraph events | You can observe changes in virtually all aspects of SceneGraph operation using the [<interface>](/docs/references/scenegraph/xml-elements/interface.md) field onChange attribute event, or adding an observer to a field of a SceneGraph node. |
| roTextScreen | [ScrollableText](/docs/references/scenegraph/typographic-nodes/scrollabletext.md) node | These two are very similar in appearance and operation. |
| roTimespan | [Timer](/docs/references/scenegraph/control-nodes/timer.md) node | Adding a Timer node, observing the fire field, and writing an event handler that scripts some aspect of another node is the equivalent of writing a loop including roTimespan. |
| roVideoScreen, roVideoPlayer | [Video](/docs/references/scenegraph/media-playback-nodes/video.md) node | The SceneGraph Video node class encompasses all the functionality of the roVideoScreen and roVideoPlayer components. The roSpringboardScreen component for user selection of video files can be created using SceneGraph list and grid node classes. |

ifSprite
========

Implemented by
--------------

| Name | Description |
| --- | --- |
| [roSprite](/docs/references/brightscript/components/rosprite.md "roSprite") | This component is associated with a managing roCompositor object |

Supported methods
-----------------

### MoveTo(x as Integer, y as Integer) as Void

#### Description

Move the sprite to a new set of coordinates.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| x   | Integer | The x-coordinate to which the sprite is to be moved. |
| y   | Integer | The y-coordinate to which the sprite is to be moved. |

### MoveOffset(xOffset as Integer, yOffset as Integer) as Void

#### Description

Move the sprite to a new position based on offsets to the current position.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| xOffset | Integer | The offset from the current x-coordinate to be used. |
| yOffset | Integer | The offset from the current y-coordinate to be used. |

### GetX() as Integer

#### Description

Returns the x-coordinate of the sprite.

#### Return Value

The x-coordinate of the sprite.

### GetY() as Integer

#### Description

Returns the y-coordinate of the sprite.

#### Return Value

The y-coordinate of the sprite.

### SetZ(z as Integer) as Void

#### Description

Sets the z value of the sprite. The z value defines the order in which sprites are drawn. Sprites with higher z values are drawn after (in front of) sprites with lower z values. The default z value is 0.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| z   | Integer | The z value to be used for the sprite. |

### GetZ() as Integer

#### Description

Returns the z value of the sprite.

#### Return Value

The z value of the sprite.

### SetDrawableFlag(enable as Boolean) as Void

#### Description

Sets whether this sprite is drawable or just used for collision tests. An undrawable sprite can be used to define a region in the background that needs collision testing. It can also be used as an auxiliary collision region for a more complex sprite defined in another sprite.

The default value is true, and it is set when a sprite is created.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| enable | Boolean | A flag specifying whether the sprite is drawable:  <br>  <br>True = The sprite is drawable.  <br>  <br>False = The sprite may only be used for collision tests. |

### GetDrawableFlag() as Boolean

#### Description

Checks whether the sprite is drawable.

#### Return Value

A flag indicating whether the sprite is drawable.

### SetMemberFlags(flags as Integer) as Void

#### Description

Defines the sprite membership though flags. The flags are used with CollidableFlags to define which sprites are allowed to collide.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| flags | Integer | Enables "levels" of collision detection, as only sprites with a member flag bit that matches a collidable flag bit will be checked for collisions. The default value is 1. |

### GetMemberFlags() as Integer

#### Description

Returns the value of member flags variable.

#### Return Value

The value of the member flag variable.

### SetCollidableFlags(flags as Integer) as Void

#### Description

Sets bits to determine which sprites will be checked for collisions. The sprites that are checked must have the corresponding bits sets in their MemberFlags.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| flags | Integer | The bits to be set for determining which sprites to check for collisions. The default value is 1. |

### GetCollidableFlags() as Integer

#### Description

Returns the value of collidable flags variable.

#### Return Value

The value of the flag variable.

### SetRegion(region as Object) as Void

#### Description

Sets the region of the sprite to the passed roRegion object. If one already is set, it is replaced.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| region | Object | The roRegion object to be used as the region for the sprite. |

### GetRegion() as Object

#### Description

Returns an roRegion object that specifies the region of a bitmap that is the sprite's display graphic.

#### Return Value

roRegion object.

### OffsetRegion(x as Integer, y as Integer, width as Integer, height as Integer) as Void

#### Description

Adjusts the part of an [roRegion](/docs/references/brightscript/components/roregion.md "roRegion")'s bitmap that is being displayed as the sprite. Wrap is taken into consideration.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| x   | Integer | The x-coordinate for the bitmap. |
| y   | Integer | The y-coordinate for the bitmap. |
| width | Integer | The width of the bitmap. |
| height | Integer | The height of the bitmap. |

### SetData(data as Dynamic) as Void

#### Description

Associates user-defined data with the sprite. The data can be any type including intrinsic types or objects.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| data | Dynamic | The user-defined data to be associated with the sprite. |

### GetData() as Dynamic

#### Description

Returns any user data associated with the sprite previously set via the [SetData()](#setdatadata-as-dynamic-as-void) method.

#### Return Value

Any user-defined data associated with the sprite. Returns invalid if there is no user data associated with this sprite.

### CheckCollision() as Object

#### Description

Returns the first [roSprite](/docs/references/brightscript/components/rosprite.md "roSprite") that this sprite collides with.

#### Return Value

An roSprite object. If there are no collisions, this method returns invalid.

### CheckMultipleCollisions() as Object

#### Description

Returns an roArray of all roSprite objects this sprite collides sprites. The collision area is the entire sprite's bounding box, and the sprites must actually be overlapped to detect a collision. That is, if a fast moving sprite moves "through" another sprite without actually overlapping when this call is made, no collision is detected.

#### Return Value

roArray of colliding sprites. If there are no collisions, this method returns invalid.

### Remove() as Void

#### Description

Removes the sprite from the managing roComposite object and deletes the sprite.

Selecting user profiles with Roku Voice
=======================================

Apps with a profile selection screen can audibly and visually prompt the viewer to select a user profile and then handle a voice request with the name or position of the selected profile.

![roku815px - profile-selector](https://image.roku.com/ZHZscHItMTc2/profile-selector-800.jpg)

Updating the manifest
---------------------

To identify that your app supports a hands-free voice profile selection screen, add the following flag to the [manifest](/docs/developer-program/getting-started/architecture/channel-manifest.md): `voice_action_launch_screen=1`.

Implementing profile selector APIs
----------------------------------

To implement voice support for a profile selection screen, integrate the following APIs:

*   **Voice request trigger**. Upon launch, apps can call the [roAppManager.StartVoiceActionSelectionRequest()](/docs/references/brightscript/interfaces/ifappmanager.md#startvoiceactionselectionrequest-as-void) function to trigger a voice request for the viewer to select a user profile on devices that are paired with a hands-free Roku Voice remote control, such as the Roku Voice Remote Pro.
    
    Before calling the **StartVoiceActionSelectionRequest()** function, developers can call the [roDeviceInfo.HasFeature("handsfree\_voice")](/docs/references/brightscript/interfaces/ifdeviceinfo.md#hasfeaturefeature-as-string-as-boolean) function to check whether a Roku device is paired with a hands-free Roku remote control.
    
          appMgr = CreateObject("roAppManager")
          deviceInfo = CreateObject("roDeviceInfo")
          ' channel is launched and profile selection screen is displayed
          if deviceInfo.HasFeature("handsfree_voice")
              appMgr.StartVoiceActionSelectionRequest()
          end if
        
    

*   **Profile selection via registered/matched text strings**. Apps can call the [roAppManager.SetVoiceActionStrings()](/docs/references/brightscript/interfaces/ifappmanager.md#setvoiceactionstringsactions-as-object-as-void) function to register a list of text strings, such as user profile names, that can be matched to voice requests.
    
          appMgr = CreateObject("roAppManager")
          profile1 = { text: "kids", link: "d46ge-i8Y5-192"}
          profile2 = { text: "Jane", link: "2a2Nu-u1D4-555"}
          profile3 = { text: "John", link: "6Nu70-N37x-901"}
        
          actions = [profile1, profile2, profile3]
        
          appMgr.SetVoiceActionStrings(actions)
        
    
    When the name uttered by the user matches the registered text string, the matched text string is provided to the app via the [roInput voice command handler](/docs/references/brightscript/interfaces/ifinput.md#eventresponseroassociativearray-aa-as-boolean). Specifically, if the **command** received by the handler is "action", the associative array returned by the [**roInputEvent.GetInfo()**](/docs/references/brightscript/events/roinputevent.md#getinfo-as-object) method includes a **text** field that is set to the matched text string.
    
          function handleTransport(evt)
              cmd = evt.command
              ret = {status: "unhandled"}
              if cmd = "action"
                  print "profile name uttered by user"
                  print evt.text ' prints "kids", "Jane", or "John"
              end if
              return ret
          end function
        
    

*   **Profile selection via ordinal numbers**. The [roInput voice command handler](/docs/references/brightscript/interfaces/ifinput.md#eventresponseroassociativearray-aa-as-boolean) also supports profile selection via ordinal numbers. For example, when a user says "first", "number one", "pick the first", "select the first", "choose the first", and so on to select a user profile within a row, the app will receive a value of "1".
    
    Specifically, if the **command** received by the handler is "select", the associative array returned by the [**roInputEvent.GetInfo()**](/docs/references/brightscript/events/roinputevent.md#getinfo-as-object) method includes a **ordinal** field that is set to a numerical value corresponding to the ordinal number spoken by the user. Values may range between 1–6 (one-based indexing is used).
    
          function handleTransport(evt)
              cmd = evt.command
              ret = {status: "unhandled"}
              if cmd = "select"
                  print "Voice ordinal event"
                  print evt.ordinal ' prints 1
              end if
              return ret
          end function
        
    

Sample app
----------

The [custom UI voice control sample (**Transport\_Control\_CustomUI**)](https://github.com/rokudev/transport-control) demonstrates how to add voice support to a profile selection screen.

ifToStr
=======

Implemented by
--------------

| Name | Description |
| --- | --- |
| [roBoolean](/docs/references/brightscript/components/roboolean.md "roBoolean") | Object equivalent for intrinsic type Boolean |
| [roDouble](/docs/references/brightscript/components/rodouble.md "roDouble") | Object equivalent for intrinsic type 'Double' |
| [roFloat](/docs/references/brightscript/components/rofloat.md "roFloat") | Object equivalent for intrinsic type 'Float' |
| [roFunction](/docs/references/brightscript/components/rofunction.md "roFunction") | Object equivalent for intrinsic type Function |
| [roInt](/docs/references/brightscript/components/roint.md "roInt") | Object equivalent for intrinsic type Integer |
| [roInvalid](/docs/references/brightscript/components/roinvalid.md "roInvalid") | Object equivalent for intrinsic type 'Invalid' |
| [roLongInteger](/docs/references/brightscript/components/rolonginteger.md "roLongInteger") | Object equivalent for intrinsic type LongInteger |
| [roString](/docs/references/brightscript/components/rostring.md "roString") | Object equivalent for intrinsic type 'String' |

Supported methods
-----------------

### ToStr() As String

#### Description

Returns the value as a string.

#### Return Value

The string.

### ToStr(format As String) As String

#### Description

Returns the object's value formatted as a string according to the specified printf-like [format string](/docs/references/brightscript/language/global-string-functions.md#format-strings).

The object's value can be considered as an implicit parameter to be converted in the formatting for each placeholder parameter.

The format specifier must match the value's data type (for example, _"%d"_ would be valid for an integer value, but not for a string value).

#### Return Value

The formatted string.

#### Support

Format-string support (the `ifToStr` interface) is implemented by the following types:

*   Integer (roInt)
*   LongInteger (roLongInteger)
*   Float (roFloat)
*   Double (roDouble)
*   String (roString)
*   Boolean (roBoolean)

#### Examples

##### Integer (Decimal)

    print 123.ToStr("%d")
    '=> "123"
    
    n = 300 + 45
    print n.ToStr("The value is %d.")
    '=> "The value is 345."
    
    month = 7
    print month.ToStr("%2d")
    '=> " 7"
    
    month = 8
    print month.ToStr("%02d")
    '=> "08"
    
    month = 9
    print month.ToStr("%-4d")
    '=> "9   "
    

##### Integer (Hexadecimal)

    hexy = 32767 - 1
    print hexy.ToStr("%08X")
    '=> "00007FFE"
    
    print hexy.ToStr("%06x")
    '=> "007ffe"
    
    big_num = &H100000000&
    print big_num.ToStr("%d = 0x%0X")
    '=> "4294967296 = 0x100000000"
    

##### Float

    f = 3.141592
    print f.ToStr("%f")
    '=> "3.141592"
    
    print f.ToStr("%.3f")
    '=> "3.142"
    
    print f.ToStr("%4.2f")
    '=> "3.14"
    

##### String

    s = "123"
    print s.ToStr("[%s]")
    '=> "[123]"
    
    print s.ToStr("<%5s>")
    '=> "<  123>"  
    
    print s.ToStr("<%-5s>")
    '=> "<123  >"

Scene
=====

Extends [**Group**](/docs/references/scenegraph/layout-group-nodes/group.md "**Group**")

The **Scene** node class serves as the root of a SceneGraph node tree. Every **roSGScreen** object must have a **Scene** node, or a node that derives from the **Scene** node class as its root, including an XML markup component that extends the Scene node class or subclass. That node must be created using the **roSGScreen** createScene() function, with an argument that is a string of the name of the **Scene** node object created. For example:

    screen = CreateObject("roSGScreen")
    scene = screen.CreateScene("Scene")
    

While it is technically possible to have more than one scene per app, we recommend you only have one **roSGScreen** and one **Scene** node. Child nodes of the scene can be treated as different "scenes" where you can then implement transitions between them.

Fields
------

FieldTypeDefaultAccess PermissionDescriptionbackgroundURIuriinvalidREAD\_WRITESpecifies a graphic image file to be used for the Scene node background.limitBackgroundToUIResolutionbooleantrueREAD\_WRITEIf the scene background URI is overridden with a non-theme value and this field is set to true, the **backgroundURI** image is limited to the current screen size after being loaded.  
  
if this field is set to false, the **backgroundURI** image is loaded without any scaling applied.backgroundColorcolor0x000000FFREAD\_WRITELoads an image using the provided background URI as-is and does not apply any scaling whatsoever when "limitBackgroundToUIResolution" is false. Specifies a background color for the scene. This color is only used if the backgroundURI field is set to an empty string. For example:  
  
scene.backgroundColor="0xEB1010FF"  
scene.backgroundUri = ""backExitsSceneBooleantrueREAD\_WRITEIf true, a Back key press causes the scene to exit, back to the last user-focused item. If false, a Back key press does not cause the scene to exit. In order for the Back key to cause the scene to exit, the remote control focus must be explicitly set on the scene, or a child of the scene, using the [ifSGNodeFocus](/docs/references/brightscript/interfaces/ifsgnodefocus.md "ifSGNodeFocus") interface setFocus(true) function. A Home key press always causes the scene to exit.dialogNodeinvalidSetting this field to a node extended from a **Dialog** node causes the dialog to be displayedcurrentDesignResolutionassocarrayREAD\_WRITEThis read-only field is set when the Scene is initialized. It indicates which of an app's design resolutions (per manifest's ui\_resolutions value) is being used, based on the player model and connected display type. Previously, a developer could deduct the same information by using both [roDeviceInfo.GetUIResolution](/docs/references/brightscript/interfaces/ifdeviceinfo.md#getuiresolution-as-object\(\) "roDeviceInfo.GetUIResolution") and [roAppInfo.getValue](/docs/references/brightscript/interfaces/ifappinfo.md#getvaluekey-as-string-as-string "roAppInfo.getValue")("ui\_resolutions"). This new field simplifies the process.  
  
The field is set to an AA with two numeric-valued keys — width and height — as well as a string value indicating the current design resolution ("HD", "FHD" or "SD").  
  

    Brightscript Debugger> ? myNode.getScene().currentDesignResolution
    <Component: roAssociativeArray> =
    {
        height: 720
        resolution: "HD"
        width: 1280
    }
    

paletteRSGPalette nodenot setREAD\_WRITEDefines the default color palette used by those nodes that have a **palette** field (for example, the **Scene** node, [standard dialogs](/docs/references/scenegraph/standard-dialog-framework-nodes/standard-dialog.md), [dynamic custom voice keyboards](/docs/references/scenegraph/dynamic-voice-keyboard-nodes/dynamic-keyboard-base.md), and so on).  
  
Apps typically set the **Scene.palette** field to consistently color the standard dialogs and keyboards in the app.  
  
Nodes that include a **palette** field can be set to an **RSGPalette** node to override the default colors specified in the **Scene** node.  
  
If a node that supports a palette does not set its **palette** filed, the node looks up the scene graph until it finds a node with its **palette** field set.  
  
If no ancestor node is found with its palette field set, the default color palette is used (grey with white text).  
  
The RSGPalette color values used by the Scene node are as follows:  

| Palette Color Name | Usages |
| --- | --- |
| PrimaryTextColor | The text color used for the entered text displayed in the VoiceTextEditBox node. |
| SecondaryTextColor | The text color used for the hints displayed in the VoiceTextEditBox. |
| InputFieldColor | The blend color applied to the VoiceTextEditBox background |
| DialogBackgroundColor | Blend color for dialog's background bitmap. |
| DialogItemColor | Blend color for the following items:  <br><br>*   [StdDlgProgressItem's](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-progress-item.md) spinner bitmap<br>*   [StdDlgDeterminateProgressItem's](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-determinate-progress-item.md) graphic |
| DialogTextColor | Color for the text in the following items:  <br><br>*   [StdDlgTextItem](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-text-item.md) and [StdDlgGraphicItem](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-graphic-item.md) if the **namedTextStyle** field is set to "normal" or "bold".<br>*   All [content area items](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-item-base.md), except for [StdDlgTextItem](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-text-item.md) and [StdDlgGraphicItem](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-graphic-item.md).<br>*   [Title area](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-title-area.md#fields). Unfocused button. |
| DialogFocusColor | Blend color for the following:  <br><br>*   The [button area](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-button-area.md#fields) focus bitmap.<br>*   The focused scrollbar thumb. |
| DialogFocusItemColor | Color for the text of the focused button. |
| DialogSecondaryTextColor | Color for the text of in the following items:  <br><br>*   [StdDlgTextItem](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-text-item.md) and [StdDlgGraphicItem](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-graphic-item.md) if the **namedTextStyle** field is set to "secondary".<br>*   Disabled button. |
| DialogSecondaryItemColor | Color for the following items:  <br><br>*   The divider displayed below the title area.<br>*   The unfilled portion of the [StdDlgDeterminateProgressItem's](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-determinate-progress-item.md) graphic. |
| DialogInputFieldColor | The blend color for the text edit box background bitmap for keyboards used inside dialogs. |
| DialogKeyboardColor | The blend color for the keyboard background bitmap for keyboards used inside dialogs |
| DialogFootprintColor | The blend color for the following items:  <br><br>*   The button focus footprint bitmap that is displayed when the [button area](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-button-area.md#fields) does not have focus.<br>*   Unfocused scrollbar thumb and scrollbar track. |

On-device authentication
========================

Apps implement on-device authentications so that customers can complete sign-ups and sign-ins entirely on their Roku devices—without having to visit an external webpage. Additionally, once a customer authenticates on one device, they can automatically be signed in when they activate additional Roku devices linked to their same Roku account.

> All authenticated apps must implement on-device authentication to pass [certification](/docs/developer-program/certification/certification.md#2-purchases). Account sign-ups and sign-ins must be completed on-device, without visiting an external webpage. The sign-up and sign-in workflows may not include links to off-device promotional or marketing materials, nor may they utilize off-device sign-up or sign-in mechanisms such as rendezvous linking.
> 
> In addition, apps requiring a user account to log in that have streamed more than average of 1 million hours per month over the last three months must implement [Automatic Account Link](/docs/developer-program/authentication/universal-authentication-protocol-for-single-sign-on.md) to pass [certification](/docs/developer-program/certification/certification.md#2-purchases).

Overview
--------

To implement on-device authentication, you first verify whether a customer should have access to your content. To do this, you check whether the customer has an active Roku subscription for the content, and then check whether there is a valid access token stored in their device registry. If the device registry does not contain a valid access token, you check whether one is stored in the Roku cloud. The next steps depend on the results of these checks. The following table lists the next steps for each possible outcome; the subsequent flow chart illustrates the logic used in this authentication workflow.

| Active Subscription through Roku Pay? | Valid Access Token in Device Registry and Entitlement? | Valid Access Token in Roku Cloud? | Next Steps |
| --- | --- | --- | --- |
| YES | YES | —   | Get a refresh token from your entitlement server and store it in the device registry and Roku cloud. Grant access to content. |
| YES | NO  | YES | Store an access token in the device registry. Grant access to content. |
| YES | NO  | NO  | The next steps depend on whether the customer originally created their account through Roku Pay or your own service ("publisher service)":  <br><br>*   **Created through Roku Pay**: Validate the previous transaction. Get a new access token from your entitlement server and store in device registry and Roku cloud. Grant access to content.<br>*   **Created through publisher service**: Check whether the Roku cloud has an access token. If it does and the customer is signed in, store the access token in the device registry, and then grant access to content. |
| NO  | YES | —   | Grant access to content. |
| NO  | NO  | YES | If the customer is signed in, store the access token in the device registry, and grant access to content. If the customer is signing up (or has signed out), have them re-authenticate. |
| NO  | NO  | NO  | Create a new subscription through Roku Pay. |

If the customer is not signed up or is signed out, display your app UI, get the customer's email address, and have them sign up or sign back in. Once the customer has successfully authenticated, generate a new access token from your entitlement server and store it in the device registry and Roku cloud. Grant access to content.

If the Roku cloud does not have an access token, display your app UI and then get the customer's email address. Use the email address to check whether the customer is linked to an active subscription in your system. If there is already an active subscription, generate a new access token from your entitlement server and store it in the device registry and Roku cloud. Grant access to content.

![roku815px - on-device-authenticaton with automatic account link flow chart](https://image.roku.com/ZHZscHItMTc2/on-device-authentication-aal-v11.jpeg)

> For SVOD and TVOD apps (and other subscription services), on-device authentication deprecates the ["rendezvous" registration method](/docs/developer-program/authentication/authentication-and-linking.md). With this method, a customer was shown a registration code on their device and had to enter it on an external website. An authentication service then linked the customer's device to their account via an access token that was downloaded and stored on the device.
> 
> Authentication via a third-party oAuth provider such as Google or Facebook is not supported.

Verifying access to content
---------------------------

The first step for implementing on-device authentication entails checking whether a customer has access to content. To do this, use the [**ChannelStore node**](/docs/references/scenegraph/control-nodes/channelstore.md) and [**Roku Pay Web Service API**](/docs/developer-program/roku-pay/implementation/roku-web-service.md) to check for an active subscription created through Roku Pay. Next, use the [**roRegistrySection()**](/docs/references/brightscript/components/roregistrysection.md) method to find an access token in the device registry and then check your entitlement server to see if it is still valid. If the device registry does not contain a valid access token, use the [**ChannelStore node**](/docs/references/scenegraph/control-nodes/channelstore.md#getchannelcred) to see if an access token is stored in the Roku cloud.

### Check for an active Roku subscription

To check for an active Roku subscription with the **ChannelStore API**, follow these steps:

1.  Call the [**ChannelStore.getAllPurchases**](/docs/references/scenegraph/control-nodes/channelstore.md#getallpurchases) command. This command returns all of the historical subscription and one-time purchases made by the customer on the app. It causes the **purchases** field to be set to a **ContentNode** containing the results of the command. The **purchases** contentNode contains a child content node for each purchase.
    
        myChannelStore.command = "getAllPurchases"
        
    

2.  Get the transaction ID from the **purchaseId** field of the child content node. Find the subscription to be validated using the **code** or **productType** fields of the child content node.
    
        if (myChannelStore.purchases <> invalid)
            count = myChannelStore.purchases.GetChildCount()
            for x = 0 to count - 1
                if (myChannelStore.purchases.getChild(x).code = "monthlySubscription")
                   transactionId = myChannelStore.purchases.getChild(x).purchaseId
                end if
            end for
        endif
        
    

3.  Pass the transaction ID into a [**validate-transaction**](/docs/developer-program/roku-pay/implementation/roku-web-service.md#validate-transaction) Roku Pay web service GET API call.
    
        https://apipub.roku.com/listen/transaction-service.svc/validate-transaction/{partnerAPIKey}/transactionid
        
    

4.  Check the **isEntitled** field in the response to verify that the user is entitled to the content.
    
        <result>
            <transactionId>{transactionId}</transactionId>
            ...
            <isEntitled>true</isEntitled>
            ...
            <rokuCustomerId>abcdefghijklmnop</rokuCustomerId>
            <expirationDate>2020-08-22T14:59:50</expirationDate>
        </result>
        
    

5.  Proceed to the [next section](#check-for-a-valid-access-token-in-the-device-registry) to verify that the customer's device has a valid access token. This is still necessary even if **isEntitled** is true to handle scenarios where the customer has an active subscription but is using a new device or has factory reset their existing device. If **isEntitled** is false, cancel the subscription and remove the entitlement.

### Check for a valid access token in the device registry

To check for a valid access token in the device registry, follow these steps:

1.  Create an [**roRegistrySection**](/docs/references/brightscript/components/roregistrysection.md) object. This provides access to your section within the device registry to get and read your keys. When creating the registry section, pass in the name of your registry. This must be the same name used when the registry section was created.
    
        reg_sec = CreateObject("roRegistrySection", <your_registry_section>")
        
    

> To get a list of the keys in the registry section in order to find the one linked to the access token, call the [**roRegistrySection.getKeyList()**](/docs/references/brightscript/interfaces/ifregistrysection.md#getkeylist-as-object) method.

2.  Use the **roRegistrySection.read()** method to retrieve the access token. This method takes the name of the key to get the value associated with it.
    
        access_token_value = reg_sec.read("access_token_key_name")
        
    

3.  Check the access token in your entitlement server to verify whether it is still valid.
    
    a. If the access token is valid, check your system to verify that the subscription is valid. If the subscription is valid, generate a refresh token in your system and store it in the device registry and in the Roku cloud, and then grant the customer access to the content. In this case, no additional steps are required and authentication is complete.
    
    *   Call the [**roRegistrySection.write()**](/docs/references/brightscript/interfaces/ifregistrysection.md#writekey-as-string-value-as-string-as-boolean) and [**roRegistrySection.flush()**](/docs/references/brightscript/interfaces/ifregistrysection.md#deletekey-as-string-value-as-string-as-boolean) methods to permanently store the refresh token on the device:
        
                   reg_sec.write("access_token_key_name", "access_token_value")
                   reg_sec.flush()
            
        
    *   Call the [**ChannelStore.storeChannelCredData**](/docs/references/scenegraph/control-nodes/channelstore.md#storechannelcreddata) command to store an access token in the Roku cloud. You can use the **status** and **response** fields of the **storeChannelCredDataStatus** content node to verify that the command was successful and that the access token stored in the Roku cloud has the specified value.
        
                   myChannelStore.channelCredData = "your access token"
                   myChannelStore.command = "storeChannelCredData "
            
                   'check if command was successful
                   status = myChannelStore.storeChannelCredDataStatus.status
                   if status = 0
                      ...
                   end if
            
                   'check if access token stored in Roku cloud has specifed value
                   response = myChannelStore.storeChannelCredDataStatus.response
                   if response.json.channel_data = myChannelStore.channelCredData
                      ...
                   end if
            
        
    
    b. If the access token is valid, but the subscription cannot be verified in your system, delete the access token using the [**roRegistrySection.delete()**](/docs/references/brightscript/interfaces/ifregistrysection.md#deletekey-as-string-as-boolean) method.
    
             reg_sec.delete("access_token_key_name")
        
    
    c. If the access token is invalid and the customer has an active subscription billed through Roku Pay, validate the subscription using the [**validate-transaction**](/docs/developer-program/roku-pay/implementation/roku-web-service.md#validate-transaction) Roku Pay Web Service API and [business logic](/docs/developer-program/roku-pay/roku-pay-best-practices.md#payment-retry-checks). Once the subscription is validated, generate a new access token in your system and store it in the device registry and in the Roku cloud (as described in step a), and then grant the customer to access the content.
    
    d. If the subscription cannot be validated, [get the customer's credentials](#get-and-check-account-credentials) in your app UI and check whether the customer already has an active subscription in your system.
    
    e. If the access token is invalid and billing is managed through your services, [get the customer's credentials](#get-and-check-account-credentials) in your app UI and check whether the customer already has an active subscription in your system.
    
    f. If the access token is invalid and the customer does not have an active subscription through Roku Pay, display your app's landing page, which should include entry points for signing-up and signing-in, so the customer can sign up and \[create a new subscription\](#signing-up-new-subscribers-through-Roku Pay).
    

### Check for a valid access token in the Roku cloud

To check for a valid access token in the Roku cloud, follow these steps:

1.  Call the [**ChannelStore.getChannelCred**](/docs/references/scenegraph/control-nodes/channelstore.md#getchannelcred) command. This causes the **channelCred** field to be set to a **ContentNode** that includes a **json.channel\_data** field.
    
        myChannelStore.command = "getChannelCred"
        accessToken = myChannelStore.channelCred.json.channel_data
        
    

2.  If the **json.channel\_data** field contains your access token, check whether the customer is currently signed in using a flag in the device registry. This is a publisher-specific key-value pair that you have previously added to your registry section to track the login status of customers. The value should be toggled when customers sign in and out.

3.  If the customer is signed in, get the access token from the device registry and store it in the Roku cloud, and then grant the customer access to the content. In this case, no additional steps are required and authentication is complete. To store an access token in the Roku cloud, call the [**ChannelStore.storeChannelCredData**](/docs/references/scenegraph/control-nodes/channelstore.md#storechannelcreddata) command.
    
        myChannelStore.channelCredData = "your access token"
        myChannelStore.command = "storeChannelCredData "
        
    

4.  If the customer is not signed in, display your app's landing page, which should include entry points for \[signing-up\](#signing-up-new-subscribers-through-Roku Pay) and [signing-in](#signing-in-existing-subscribers).

Signing up new subscribers through Roku Pay
-------------------------------------------

To enable customers to purchase a new subscription from your app UI, you first get their email address and use it to check whether they already have a subscription. If they already have one, have them re-authenticate their account and then store a new access token on their device. Otherwise, complete and validate an order for the new subscription and create a new customer account in your system following the steps in this section.

### Get and check account credentials

To obtain and validate the customers' account credentials, follow these steps:

1.  Set the [**ChannelStore.requestedUserData**](/docs/references/scenegraph/control-nodes/channelstore.md#fields) field to "email, firstName, lastName" to ask the customer to share their email address and name from their account, and then call the [**ChannelStore.getUserData**](/docs/references/scenegraph/control-nodes/channelstore.md#getuserdata) command to get the email address and name.
    
        myChannelStore.requestedUserData("email, firstName, lastName")
        myChannelStore.command = "getUserData"
        
    

2.  When you call the the **ChannelStore.getUserData** command, a "Request for information" (RFI) screen is displayed automatically. It guides the customer to create an account in your system using their Roku account information.
    
    ![roku815px - signup-2-rfi](https://image.roku.com/ZHZscHItMTc2/signup-rfi-getuserdata-v2.jpg)
    

3.  If the customer clicks **Continue**, the `userData` field is automatically set to a **ContentNode** that contains a string field with the customer's email address and name. In step 5, you will use the email address to verify whether the customer already has an active subscription that is billed through your services. You will send all the information stored in this ContentNode to your system when the order is completed.
    
        email = myChannelStore.userData.email
        firstName = myChannelStore.userData.firstName
        lastName = myChannelStore.userData.lastName
        
    

4.  Display a [keyboard dialog](/docs/references/scenegraph/standard-dialog-framework-nodes/standard-keyboard-dialog.md) pre-populated with the customer's email address so that they can verify their email address or enter a different one. If the customer clicks **Cancel**, the `userData` field is set to "invalid". In this case, display an empty [keyboard dialog](/docs/references/scenegraph/dialog-nodes/keyboarddialog.md) so the customer can enter their email address for your app.

5.  Use the customer's email address from the **userData**.**email** field to check whether that email address is already linked to an active subscription for which your service is handling billing.
    
    a. If the email address is linked to an active subscription, display a keyboard for the customer to enter their password.
    
    b. After the user submits their password, validate their credentials in your system. If the credentials are valid, obtain an access token from your entitlement server, store it in the device registry, and update the login status flag in the device registry. Grant the customer access to the content. No additional steps are required and authentication is complete.
    

6.  If the customer's email address is not linked to an active subscription in your system and they allowed access to their Roku account information, pre-populate the keyboard with an auto-generated secure password, which the customer can accept or edit. If the customer did not allow access, display an empty [keyboard dialog](/docs/references/scenegraph/standard-dialog-framework-nodes/standard-keyboard-dialog.md) so the customer can enter their own password for your app. Complete and validate a new subscription following the next section.

### Complete and validate new subscription

To complete and validate the new subscription, follow these steps:

1.  Call the **ChannelStore** [**getCatalog**](/docs/references/scenegraph/control-nodes/channelstore.md#getcatalog) command to display the list of products that are available for purchase.
    
        myChannelStore.command = getCatalog
        
    

2.  Once the customer selects a product, [create an order](/docs/references/scenegraph/control-nodes/channelstore.md#creating-an-order) that contains the product the customer is purchasing. To do this, you set the [**ChannelStore.order**](/docs/references/scenegraph/control-nodes/channelstore.md#order) field to a **ContentNode** that has one child **ContentNode** for the item the customer is purchasing.
    
        myOrder = CreateObject("roSGNode", "ContentNode")
        itemPurchased = myOrder.createChild("ContentNode")
        itemPurchased.addFields({ "code": "UPC3L5A", "qty": 1})
        myChannelStore.order = myOrder
        
    

3.  Call the **ChannelStore** [**doOrder**](/docs/references/scenegraph/control-nodes/channelstore.md#doorder) command to display the Roku Pay order confirmation dialog, which is pre-populated with an order summary.
    
         myChannelStore.command = "doOrder"
        
    
    ![roku815px - signup-3-order-confirmation](https://image.roku.com/ZHZscHItMTc2/signup-order-confirmation-do-order.jpg)
    

4.  Once the customer approves the purchase, the **ChannelStore.orderStatus** field is set to a **ContentNode** containing information about the completed order. The **ContentNode** will have a child **ContentNode** for the item purchased. Get the transaction ID from the **orderStatus** ContentNode.
    
        transactionId = myChannelStore.orderStatus.getChild(0).purchaseId
        
    

5.  Validate the transaction ID via a [**validate-transaction**](/docs/developer-program/roku-pay/implementation/roku-web-service.md#validate-transaction) Roku Pay Web Service API call from your server. Check the **isEntitled** field in the response to verify that the user is entitled to the content. If **isEntitled** is true, allow the customer to access the content. If **isEntitled** is false, exit the order flow and return the user to your app's home page.

6.  Create a new account for the customer in your system. Store the validated transaction ID, and the customer's email address, name, and user ID in your system.
    
7.  Generate a new access token in your system and store it in the device registry and in the Roku cloud. To store an access token in the Roku cloud, call the [**ChannelStore.storeChannelCredData**](/docs/references/scenegraph/control-nodes/channelstore.md#storechannelcreddata) command.
    
        myChannelStore.channelCredData = "your access token"
        myChannelStore.command = "storeChannelCredData "
        
    

8.  You should also generate a secure temporary password and store it in the customer's account, and then send the customer a "Welcome" email with information on how to reset the temporary password.

Signing in existing subscribers
-------------------------------

If a customer is signing in, have them authenticate themselves in your app UI following these steps:

1.  After the user enters the sign-in flow, set the [**ChannelStore.requestedUserData**](/docs/references/scenegraph/control-nodes/channelstore.md#requesteduserdata) field to "email" to ask the customer to share their email address, and set the [**ChannelStore.requestedUserDataInfo**](/docs/references/scenegraph/control-nodes/channelstore.md#requesteduserdatainfo) field to a ContentNode that has a **context** field set to "signin".
    
        myChannelStore.requestedUserData("email")
        info = CreateObject(“roSGNode”, “ContentNode”)
        info.addFields({context: “signin”})
        myChannelStore.requestedUserDataInfo = info
        
    

2.  Call the [**ChannelStore.getUserData**](/docs/references/scenegraph/control-nodes/channelstore.md#getuserdata) command to get the email address.
    
        myChannelStore.command = "getUserData"
        
    

3.  When you call the the **ChannelStore.getUserData** command, a "Request for information" (RFI) screen is displayed automatically. It guides the customer to share the email address and/or phone number in their Roku customer account with the app in order to sign in.
    
    ![roku815px - signin-2-rfi-splash](https://image.roku.com/ZHZscHItMTc2/signin-2-rfi-splash-v2.jpg)
    

4.  If the customer clicks **Continue**, the `userData` field is automatically set to a **ContentNode** that contains **email** and/or **phone** fields, which are strings set to the customer's email address and phone number.
    
         email = myChannelStore.userData.email
        
    
    If the customer clicks **Cancel**, the `userData` field is set to "invalid". In this case, display an empty [keyboard dialog](/docs/references/scenegraph/standard-dialog-framework-nodes/standard-keyboard-dialog.md) so the customer can enter their email address or phone number for signing into your app.
    

5.  Display an empty [keyboard dialog](/docs/references/scenegraph/standard-dialog-framework-nodes/standard-keyboard-dialog.md) so the customer can enter their password for your app.

6.  After the customer submits their password, validate their credentials in your system. If the credentials are valid, obtain an access token from your entitlement server, store it in the device registry, and update the login status flag in the device registry. Grant the customer access to the content. No additional steps are required and authentication is complete.

Sample app
----------

You can download and install a [sample app](https://github.com/rokudev/on-device-authentication) that demonstrates how to implement on-device authentication. This sample shows how to use the [**ChannelStore node**](/docs/references/scenegraph/control-nodes/channelstore.md) and [**Roku Web Service API**](/docs/developer-program/roku-pay/roku-web-service.md) to check for an active Roku subscription, and how to use the [**roRegistrySection()**](/docs/references/brightscript/components/roregistrysection) object and [**ChannelStore node**](/docs/references/scenegraph/control-nodes/channelstore.md) to check for access tokens in the device registry and Roku Cloud, respectively. If the customer does not have an active subscription or their subscription cannot be validated (because it was purchased on a different platform), the sample shows how to use the Roku Pay [Request for Information (RFI) screen](/docs/references/scenegraph/control-nodes/channelstore.md#getuserdata) to sign customers up for a new Roku subscription and sign them in to their existing subscription..

Setting up Roku Pay web services
================================

Roku Pay includes [web services](/docs/developer-program/roku-pay/implementation/roku-web-service.md#apis) that developers integrate into their backend system for validating, refunding, and canceling transactions related to subscriptions and one-time purchases. In addition to pulling transactions via the [Roku Pay web services](/docs/developer-program/roku-pay/implementation/roku-web-service.md#apis), publishers can receive the transactions in real-time via [push notifications](/docs/developer-program/roku-pay/implementation/push-notifications.md). These features enable publishers to implement an entitlement service for checking whether to grant users access, issue refunds or service credits, and cancel subscriptions.

The **Roku Pay Web Services** page lets developers manage their Roku Pay API key, whitelist IP addresses that may send requests using the key, and enter the URL for receiving push notifications. You can access this page from the Developer Dashboard, by selecting **Roku Pay Web Services**. You can also select **Roku Pay Web Services** from the drop-down list on the left side of the pages within the Developer Dashboard.

![roku815px - web-api-settings-dashboard-v2](https://image.roku.com/ZHZscHItMTc2/web-api-settings-dashboard-v2.jpg)

Roku Pay API Key
----------------

Your Roku Pay API key enables you to send Roku Pay web service API calls and receive push notifications. Record and secure your key.

![roku815px - roku-pay-api-key](https://image.roku.com/ZHZscHItMTc2/roku-pay-api-key-v4.png)

### Rotating API keys

Developers can periodically rotate their Roku Pay API Key as a security best practice or reset it immediately if it becomes compromised. The **Roku Pay API Key** settings include an **Invalidate** button that generates a new Roku Pay API Key and lets developers either immediately invalidate their old one (in case it has been compromised) or schedule its invalidation for a later date (for regular security maintenance). Scheduling the invalidation of the old API key provides developers with a grace period to implement the new one and thus avoid any downtime.

> Developers may only have a maximum of two Roku Pay API Keys at a time: one active and one expired or expiring.

To generate a new Roku Pay API Key, follow these steps:

1.  On the current active API key, click **Invalidate**. An API key cannot be invalidated if there is already another one in the expired/expiring state.

2.  Select whether to invalidate the API key immediately or at a later date.
    
    *   Click **Invalidate Immediately** to generate a new API key and expire the current one. An expired key cannot be used for making Roku Pay Web Service API calls.
        
    *   Click **Invalidate in Days** to generate a new API key and schedule the expiration of the current one in 1–30 days. The default is **1** day.
        
        ![roku400px - invalidate-key](https://image.roku.com/ZHZscHItMTc2/invalidate-key-v2.png)
        

3.  Click **Submit**.

4.  The new API key is generated and has a status of **Active**. The status of the current API key changes to **Expired** (if invalidated immediately) or **Expiring on \*timestamp\*** (if invalidation is scheduled for a later date).
    
    ![roku600px - rotate-roku-pay-api-key](https://image.roku.com/ZHZscHItMTc2/rotate-roku-pay-api-key-v5.png)
    

#### Changing the grace period for an expiring API key

To change the grace period for invalidating an expiring API key, click **Edit** on the Expiring API key, change the number of days in which it will be invalidated, and then click **Submit**.

#### Reactivating an expired API key

To reactivate an expired API key, click **Edit** on the Expired API key, schedule its expiration in 1–365 days, and then click **Submit**.

#### Deleting an expired or expiring API key

To permanently delete an expired or expiring API key, click **Delete** on the Expired/Expiring API key and then click **Delete** in the confirmation dialog. Once an API key has been deleted, it can no longer be retrieved or used again.

Allowed IP address range
------------------------

Developers can whitelist one or more ranges of IPv4 addresses from where Roku Pay API calls using their API key may originate. This prevents the Roku Pay web services from accepting requests with the developer's API key outside the specified range. If an IP address range is set, a request is only valid if it comes from the specified range. If no range is specified, any request with the developer's API key from any IP address is accepted.

![roku600px - allowed-ip-address-range-blank](https://image.roku.com/ZHZscHItMTc2/allowed-ip-address-range-blank-v3a.png)

To set a range of allowed IP address, follow these steps:

1.  Click **Add Allowed IP Address Range**.

2.  In the **Starting IP** field, enter the starting IPv4 address of the range.

3.  In the **Ending IP**, enter the ending IP address of your IP address range. To only allow requests to be sent from the starting IP address, leave this field empty.

4.  Click **Add**. The starting IP address, ending IP address (if any), and number of IP addresses in the specified range are listed. Repeat steps 1–4 to add another range of IP addresses.
    
    ![roku815px - allowed-ip-address-range](https://image.roku.com/ZHZscHItMTc2/allowed-ip-address-range-v2.jpg)
    

5.  To edit an IP address range, click **Edit**, update the starting and/or ending IP addresses, and then click **Update**. To delete an IP address range, click **Delete** and then click **Delete** in the confirmation dialog.

Push notifications
------------------

Publishers can subscribe to [transaction notification messages from Roku Pay](https://developer.roku.com/docs/developer-program/roku-pay/implementation/push-notifications.md). This enables the publisher to receive purchases, cancellations, and refund/service credit requests in real-time and update their backend system accordingly.

Roku sends push notification messages using [JWT signature authentication](https://datatracker.ietf.org/doc/html/rfc7515#section-3). This enables publishers to verify that the push notification messages received by their endpoint originated from Roku.

> As of February 1, 2024, all developer accounts must use [JWT signature authentication](https://datatracker.ietf.org/doc/html/rfc7515#section-3) to receive Roku Pay push notifications. Apps cannot revert to receiving unauthenticated messages.

To receive JWT/JWS-secured push notifications, follow these steps:

1.  Read the [Roku Pay Push Notification JWT authentication guide](/docs/developer-program/roku-pay/implementation/push-notifications-jwt.md). This document explains how to configure and test your endpoint for receiving JWT/JWS-secured messages.

> The payload for JWT/JWS-secured messages is significantly different than the one used for unauthenticated messages; therefore, you must configure your push notification endpoint properly to avoid disrupting your system

2.  Configure a test endpoint and verify whether it can receive and process the JWT/JWS-secured messages. To do this, go to the [**Test Push Notification URL** settings](#test-push-notification-url) and then provide an HTTPS test notification URL and test end date. JWT/JWS-secured messages will automatically start being sent to the specified test endpoint.
    
3.  Optionally, you can manually send test payloads to your test endpoint in the [**On-demand Test Message** settings](#on-demand-test-message).
    
4.  Enter the URL for your production push notification endpoint.
    

### Test push notification URL

Publishers can automatically send JWT/JWS-secured Roku Pay push notification messages to a test endpoint until a specific end date. This enables publishers to verify that they can receive and process the JWT/JWS-secured Roku Pay push notification messages before sending them to their production endpoint.

![roku815px - img](https://image.roku.com/ZHZscHItMTc2/push-notification-test-url.png)

To automatically send JWT/JWS-secured Roku Pay push notification messages to a test endpoint, follow these steps:

1.  In the **Notification URL** field, enter your test push notification endpoint. The endpoint must use HTTPS.

2.  In the **End Date** field, enter when test notifications are stopped being sent to the test push notification URL.

3.  Click **Save Changes**.

### On-demand test message

Publishers can manually send a test JWT/JWS-secured message with a generic payload to the test push notification endpoint configured in the [**Test Configuration For Push Notification** settings](#test-configuration-for-push-notification). This enables publishers to verify that their test endpoint can receive a JWT/JWS-secured message without generating Roku Pay transactions.

![roku815px - img](https://image.roku.com/ZHZscHItMTc2/push-notification-on-demand-test-message.png)

To manually send a test JWT/JWS-secured notification message to a test endpoint, follow these steps:

1.  In the **Test Message Type** field, enter any non-empty text.

2.  In the **Test Message Payload** field, enter any non-empty text.

3.  Click **Send Test Message**.

### Push notification URL

Once you have configured and tested your push notification integration, you can provide the URL of your push notification production endpoint.

![roku600px - push-notification-endpoint](https://image.roku.com/ZHZscHItMTc2/push-notification-prod-url.png)

To provide the endpoint to receive Roku Pay push notifications, follow these steps:

1.  Enter the secure URL for your production push notification endpoint.
2.  Click **Save Changes**.

> See the [Roku Pay push notifications reference](https://developer.roku.com/docs/developer-program/roku-pay/implementation/push-notifications.md) for more information on the contents of the Roku Pay push notification messages.
> 
> If the endpoint fails for a specific message for three consecutive days (72 hours), Roku stops sending that notification. If the endpoint fails to acknowledge 100 notifications within 10 days, the endpoint is considered invalid and placed on a deny list.

### Replay notifications

Publishers can resend Roku Pay push notification messages for a specific 14-day timeframe within the past 90 days. This enables publishers to receive messages that may have been missed because their endpoint had a misconfiguration, service outage, or other error.

![roku600px - push-notification-endpoint](https://image.roku.com/ZHZscHItMTc2/push-notification-replay-messages.png)

To resend Roku Pay push notifications, follow the steps:

1.  In the **Start Date** and **End Date** boxes select the timeframe for which you want push notification replays to be send to your endpoint.
2.  Click **Replay Notifications**.

> Check the timestamp of replayed messages to ensure they are processed in the correct order. Processing replayed messages out of order can result in entitlement errors (for example, the replayed messages for a subscription placed on hold and then subsequently recovered must be processed in that order or the customer may be denied access to content).

ifFileSystem
============

Implemented by
--------------

| Name | Description |
| --- | --- |
| [roFileSystem](/docs/references/brightscript/components/rofilesystem.md "roFile System") | The roFilesystem component implements common filesystem inspection and modification routines |

Supported methods
-----------------

The format of file and directory pathnames is described on the [File System](/docs/developer-program/getting-started/architecture/file-system.md "File System") page.

### GetVolumeList() as Object

#### Description

Returns the available volumes on the device.

#### Return Value

An [roList](/docs/references/brightscript/components/rolist.md "roList") containing strings representing the available volumes.

### GetDirectoryListing(dirPath as String) as Object

#### Description

Returns the file names in the specified directory path.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| dirPath | String | The directory path from which to get a list of file names. |

#### Return Value

An [roList](/docs/references/brightscript/components/rolist.md "roList") of strings representing the directory listing of names in dirPath.

### Find(dirPath as String, regEx as String) as Object

#### Description

Returns the file names in the specified directory path matching the provided regex.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| dirPath | String | The directory path from which to get a list of file names. |
| regex | String | The regex to be used to search for files. |

#### Return Value

An [roList](/docs/references/brightscript/components/rolist.md "roList") of Strings representing the directory listing of names in dirPath that match the regex.

### FindRecurse(dirPath as String, regEx as String) as Object

#### Description

Returns the file names in the specified directory path and any sudirectories matching the provided regex.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| dirPath | String | The directory path from which to get a list of file names. |
| regex | String | The regex to be used to search for files. |

#### Return Value

An [roList](/docs/references/brightscript/components/rolist.md "roList") of Strings representing the directory listing of names in dirPath that match the regex. Each item in the list is the name of the file relative to dirPath.

### Match(path as String, pattern as String) as Object

#### Description

Returns the file names in the specified directory path matching the provided shell-like pattern. This method is similar to the [Find()](#finddirpath-as-string-regex-as-string-as-object) method except that it uses shell-like pattern matching rather than regular expression matching.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| path | String | The directory path from which to get a list of file names. |
| pattern | String | The shell-like pattern to be used to search for files. The pattern may contain wildcards such as `*`and `?`. |

#### Return Value

An [roList](/docs/references/brightscript/components/rolist.md "roList") of Strings representing the directory listing of names in dirPath that match the shell-like pattern.

### Exists(path as String) as Boolean

#### Description

Checks if the specified directory path exists on the device.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| path | String | The directory path to be checked. |

#### Return Value

A flag indicating whether the specified path directory exists on the device.

### Stat(path as String) as Object

#### Description

Returns the keys in the specified directory path.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| path | String | The directory path to be checked. |

#### Return Value

An [roAssociativeArray](/docs/references/brightscript/components/roassociativearray.md "roAssociativeArray") containing the following key-value pairs for the specified path:

| Name | Type | Values |
| --- | --- | --- |
| type | String | *   "file"<br>*   "directory" |
| size | Integer | Number of bytes in the file. Only relevant for type "file". |
| permissions | String | *   "rw": read/write<br>*   "r": read-only |

### GetVolumeInfo(path as String) as Object

#### Description

Returns information about the specified volume. The function can only be called on external volumes; internal volumes do not return meaningful information.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| path | String | The external volume for which to get information. This should be specified as the volume name plus a directory separator (for example, "ext1:/"). |

#### Return Value

An roAssociativeArray containing the following key-value pairs about the specified external volume:

| Name | Type | Values |
| --- | --- | --- |
| blocksize | Integer | The size of the filesystem blocks in bytes. |
| blocks | Integer | The number of blocks in the filesystem. |
| free-blocks | Integer | The number of unused blocks in the filesystem. |
| usedblocks | Integer | The number of used blocks in the filesystem. |
| label | String | The volume label, if any. |
| mounttime | Integer | The time (in UTC format) when the volume specified in the path was last mounted. This field will be set to 0 if the drive is unknown or unmounted. |

### CreateDirectory(path as String) as Boolean

#### Description

Creates the directory specified by the path parameter. All directories in path except the last one must already exist; that is, only one directory can be created.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| path | String | The path of the directory to be created. |

#### Return Value

A flag indicating whether the path was successfully created.

### Delete(path as String) as Boolean

#### Description

Permanently removes the file or directory specified by the path parameter. If path is a directory, its contents are recursively removed.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| path | String | The path of the directory to be deleted. |

#### Return Value

A flag indicating whether the path was successfully deleted.

### CopyFile(fromPath as String, toPath as String) as Boolean

#### Description

Copies the files from one directory to another.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| fromPath | String | The source path containing the files to be copied. |
| toPath | String | The target path to which files are to be copied. |

#### Return Value

A flag indicating whether the files were successfully copied.

### Rename(fromPath as String, toPath as String) as Boolean

#### Description

Renames the directory.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| fromPath | String | The current name of the path to be renamed. |
| toPath | String | The new name of the path. |

#### Return Value

A flag indicating whether the directory was successfully renamed. If the provided target directory (**toPath**) exists, it is not overwritten; instead the operation fails and this method returns false

ifTimeSpan
==========

Implemented by
--------------

| Name | Description |
| --- | --- |
| [roTimespan](/docs/references/brightscript/components/rotimespan.md "roTimespan") | The Timespan object provides an interface to a simple timer for tracking the duration of activities |

Supported methods
-----------------

### Mark() as Void

#### Description

Sets the "Mark" point to the current time. The Mark point is also automatically set to the current time when an roTimespan object is created.

### TotalMilliseconds() as Integer

#### Description

Returns the total number of milliseconds from the "Mark" point to the current time.

#### Return Value

The number of milliseconds.

### TotalSeconds() as Integer

#### Description

Returns the total number of seconds from the "Mark" point to the current time.

#### Return Value

The number of seconds.

#### Example

    x = timespan.TotalSeconds()
    

is equivalent to

    x = Int(timespan.TotalMilliseconds() / 1000)
    

### GetSecondsToISO8601Date(date as String) as Integer

#### Description

Parses the ISO8601 date (e.g. 2008-11-29T14:54:02.171) and returns the number of seconds from now (not the "Mark" point) until the specified date/time.

The date provided and the current time calculations are all done assuming UTC. The "Z" timezone part of the ISO8601 string is ignored.

#### Parameters

| Parameters | Type | Description |
| --- | --- | --- |
| date | String | The ISO8601date to be parsed. |

#### Return Value

The number of seconds.

StandardPinPadDialog
====================

Extends [StandardDialog](/docs/references/scenegraph/standard-dialog-framework-nodes/standard-dialog.md "**Standard Dialog**")

The **StandardPinPadDialog** node enables text and voice entry of numeric characters—typically, short numeric PIN codes. It is similar to the legacy [PinDialog](/docs/references/scenegraph/dialog-nodes/pindialog.md) node, but includes additional voice entry of the numeric digits. This additional functionality is provided through the node's internal DynamicPinPad and VoiceTextEditBox nodes.

![roku815px - pin-pad-dialog](https://image.roku.com/ZHZscHItMTc2/pin-pad-dialog.jpg)

Structure
---------

The StandardKeyboardDialog is comprised of the following areas and building block nodes:

*   StdDlgTitleArea.
*   StdDlgContentArea, which may contain the following items:
    
    *   Zero or more StdDlgTextItem nodes.
    *   One StdDlgKeyboardItem containing a DynamicPinPad node
*   StdDlgButtonArea, which may contain zero or more StdDlgButton nodes.

Fields
------

| Field | Type | Default | Access Permission | Description |
| --- | --- | --- | --- | --- |
| title | string | ""  | READ\_WRITE | The title to be displayed at the top of the dialog. |
| message | array of strings | \[ \] | READ\_WRITE | One or more blocks of text, which are typically used to describe information about the data to be entered. Each string in the array is displayed as a separate block of text with the standard amount of space left between the blocks.  <br><br>> Minimize the message length to avoid having a scrollbar automatically added to the content area. If multiple strings are specified or any string is too long, the dialog may not be able to fit within the height of the display. |
| buttons | array of strings | \[ \] | READ\_WRITE | List of buttons to be displayed in the button area at the bottom of the dialog. Each string in the buttons array adds a new button to the button area.  <br><br>> Minimize the number of buttons in the dialog to ensure that all buttons are visible without the user having to scroll up and down. |
| textEditBox | VoiceTextEditBox node | The keyboard item's VoiceTextEditBox node | READ | The internal VoiceTextEditBox node used by this dialog's internal keyboard. This field should be used only to access the fields of this internal node  <br><br>> Use the **textEditBox.maxTextLength** field to limit the length of the pin to be entered. |
| pin | string | ""  | READ\_WRITE | Displays the entered PIN number in the text edit box. As the user enters each numeric digit, this field is updated with the currently entered value. |

Sample app
----------

You can download and install a [sample app](https://github.com/rokudev/standard-dialog-framework) that demonstrates how to create a standard PINPad dialog.

Bookmarking
===========

Bookmarking refers to saving a user's playback position in the content on your app so that they can continue watching later on from precisely where they left off.

It is recommended that all services with content longer than 15 minutes build bookmarking functionality into their service, as it will enhance the end-user's experience — not just on Roku, but across all interactions they have with your service on any platform. For example, if your service implements bookmarks, then users who begin watching a television show on Roku before switching over to their mobile device can pick up where they left off. In addition, bookmarks must be saved for a minimum of 30 days.

> Channels must implement bookmarking in VOD content that is longer that 15 minutes to pass [certification](/docs/developer-program/certification/certification.md#4-channel-operation).

This guide provides simple instructions on two different ways to bookmark media content, either in your service's backend or locally in the device's registry.

Retrieving playback position
----------------------------

It is important to know that video playback position (or "timestamp") can be retrieved via the position field in the video node.

      m.video = m.top.findNode("MyVideo")
      TimeStamp = m.video.position
    

Storing timestamps for cross-platform retrieval
-----------------------------------------------

It is best practice to store the timestamp of a user's bookmark position in the service's backend, so that it can be retrieved on any platform, not just Roku.

To do this, the app must first retrieve the timestamp as outlined above, then make a request to store the timestamp on the service's backend. This ensures that when starting media playback on other platforms, the developer can load the previously-saved timestamp.

It is recommended that the app makes the request to store this timestamp on the backend once every 30 seconds, but the frequency can be increased on devices with more memory. This concept is very similar to beacons fired by the Roku Ad Framework. The best way to approach this is through roUrlTransfer.

      url = ('url with timestamp to send to developer end')
      curl = createObject("roUrlTransfer")
      curl.setUrl(url)
      curl.postFromString(TimeStamp as String)
    

This should be done on a 30 second timer to ensure functionality across all devices.

Storing timestamps on-device for local retrieval
------------------------------------------------

While it is ideal to store timestamps in your backend service, it is also possible to store it locally on a Roku device's registry. With this approach, a user will only be able to resume watching from their last playback position if they use the same Roku device. The timestamp won't be accessible on other platforms.

To write to the registry, use the [roRegistrySection](/docs/references/brightscript/components/roregistrysection.md) component.

      sec = createObject("roRegistrySection", "MySection")
      if sec.Exists("PlaybackBookmark")
        BookmarkTime =  sec.Read("PlaybackBookmark")
      end if
    

If the roku device has a previously stored value that matches the PlaybackBookmark key, then it will return the value stored inside the registry. The function below shows how to create a key value pair to store the timestamp of a bookmark. The timestamp must be done in seconds.

      TimeStamp = 360
      sec = createObject("roRegistrySection", "MySection")
      sec.Write("PlaybackBookmark", TimeStamp)
      sec.Flush()
    

This will save the media playback position inside the registry and the Flush() method will save it to persistent storage in the case of a reboot. Note that if you are running this multiple times on a timer, it will overwrite any previous value associated with the same key. Once this is done, all that's left is to find run the seek() function from the video node to resume playback from the last point.

      m.video = m.top.findNode("MyVideo")
      m.video.content = videoContent
      m.video.control = "play"
      m.video.seek = BookmarkTime

onKeyEvent()
============

The `onKeyEvent()` function receives remote control key events from the Roku OS, and allows the writing of event handlers for a node or component in response to the events. The function returns a message to the Roku OS to indicate that a particular event has been handled by the node or component, preventing the event from moving up the focus chain, to possibly be handled by parent nodes in the SceneGraph node tree, or by default firmware handlers.

> Several node classes handle certain remote control key events automatically, so the `onKeyEvent()` function is not required to handle those events, and should not be used for those events in those nodes. As an example of node classes that automatically handle certain remote control key events, grid node classes such as [PosterGrid](/docs/references/scenegraph/list-and-grid-nodes/postergrid.md) automatically handle **Up**, **Down**, **Right**, and **Left** key presses when the poster grid has focus. Typically, you should use the ifSGNodeField `observeField()` method to handle changes in the subject node fields caused by automatic key event handling of the node.

#### Syntax

    function onKeyEvent(_key_ as String, _press_ as Boolean) as Boolean  
        ...  
    end function
    

Key event handling is easy to set up in XML by including an `onKeyEvent()` function in the <script> element. When the XML component or its children have the key focus, the `onKeyEvent()` function will be called whenever an unhandled key event bubbles up the focus chain to the XML component.

The `key` parameter contains a string, which is case-sensitive, that identifies which button was pressed. The `key` strings supported by the `onKeyEvent()` function, and the corresponding remote key, are as follows:

| String | Key | Appearance/Icon |
| --- | --- | --- |
| back | **Back** | left-pointing arrow at top of remote |
| up  | **Up** | up-pointing caret of remote directional pad |
| down | **Down** | down-pointing caret of remote directional pad |
| left | **Left** | left-pointing caret of remote directional pad |
| right | **Right** | right-pointing caret of remote directional pad |
| OK  | **OK** | key usually labeled **OK** near or in the center of remote directional pad |
| replay | **Replay** | key usually labeled with a circular-pointing arrow |
| play | **Play/Stop** | key usually labeled with a right-pointing triangle and two bars |
| playonly | _No physical key_ | sent instead of "play," in instances where media should strictly start playing (rather than toggle with play/stop) |
| rewind | **Rewind** | key usually labeled with two left-pointing triangles |
| fastforward | **Fast Forward** | key usually labeled with two right-pointing triangles |
| options | **Options** | key labeled with an asterisk |
| pause | _No physical key_ | Sent instead of "play," in instances where media should strictly pause (rather than toggle with play).  <br>  <br>Requires the `pause_aware` [manifest attribute](/docs/developer-program/getting-started/architecture/channel-manifest.md#special-purpose-attributes) to be set to `1`. |
| channelup | **Up** | For use in the TimeGrid node. Up-pointing caret of remote directional pad. |
| channeldown | **Down** | For use in the TimeGrid node. Down-pointing caret of remote directional pad. |

> There are one or more keys on any Roku remote control which are not handled by the `onKeyEvent()` function (or any Roku application event handler), such as the **Home** key. Presses of these keys are handled by the global Roku firmware event handler in a default manner that cannot be modified by application code.

The `press` parameter is a boolean value that is true if the key was pressed, and false if the key was released.

The `onKeyEvent()` function must return `true` if the XML component handled the event, or `false` if it did not handle the event. Returning `false` allows the event to continue bubbling up the focus chain so that ancestors of the XML component can handle the event. 

The behavior of the Roku Options overlay has been modified, such that the Options overlay now slides in whenever the **Options** button is pressed, the [Video node](/docs/references/scenegraph/media-playback-nodes/video.md) is in focus, and the app does not have its OnKeyEvent() handler fired. When the Video node is not in focus, the Options overlay does not slide in and the OnKeyEvent() handler is fired.

> Starting from Roku OS version 8.1, literal key keypress events (such as keyboard letters, and so forth) that are sent to via the mobile app or [ECP](/docs/developer-program/dev-tools/external-control-api.md) keydown/keyup commands, now go to the onKeyEvent() handler. Previously, only keys that corresponded to remote keys went to the onKeyEvent handler.

Such keys are now sent at "Lit\_" followed by the actual keypress ("A," "B," "C," etc.).

#### Example

The following `onKeyEvent()` example handles supported remote control key presses other than the **Back** key by displaying a warning message until the **OK** key is pressed.

**onKeyEvent() event handling example**

    function onKeyEvent(key as String, press as Boolean) as Boolean
      handled = false
      if press then
        if (key = "back") then
          handled = false
        else
          if (m.warninglabel.visible = false)
            m.warninglabel.visible="true"
          else
            if (key = "OK") then
              m.warninglabel.visible="false"
            end if
          end if
          handled = true
        end if
      end if
      return handled
    end function
    

See Events and Observers Markup for more details and a downloadable sample showing how to add key event support to an app.

roTimespan
==========

The Timespan object provides an interface to a simple timer for tracking the duration of activities. It's useful for tracking how an action has taken or if a specified time has elapsed from some starting event.

**Example: Timing an activity**

    REM ******************************************************
    REM Compute the number of millisecs to perform a task
    REM ******************************************************
    timer = CreateObject("roTimespan")
    timer.Mark()
    DoTimeConsumingTask()
    Print "Task took: " + timer.TotalMilliseconds().ToStr()
    
    REM ******************************************************
    REM Compute how many seconds until rental expires
    REM ******************************************************
    Function secondsLeft(String expirationDate) As Integer
        str = expirationDate
        if str = invalid return -1
        ts = CreateObject("roTimespan")
        seconds = ts.GetSecondsToISO8601Date(str)
        print "Expires: " + str + " secs: " + Stri(seconds)
        return seconds
    End Function
    

Supported interfaces
--------------------

*   [ifTimespan](/docs/references/brightscript/interfaces/iftimespan.md "ifTimespan")

Vector2DFieldInterpolator
=========================

Extends [**Node**](/docs/references/scenegraph/node.md)

Vector2DFieldInterpolator specifies a keyframe animation sequence to be applied to a pair Vector2D field of a node. Most typically, this is used to animate the (x,y) coordinates of a node's translation field.

All field interpolators include a set of key/keyValue pairs that define a keyframe of the animation. Field interpolators are generally used as children of an Animation node. As the animation progresses, it sets the fraction field of its field interpolators to a value between 0 and 1, indicating the percentage of the Animation's progress. The keyframes of the interpolator include a "key", the percentage where the keyframe should occur, and a "keyValue", the value that the field should have at that percentage.

For example, if a Vector2DFieldInterpolator had three keyframes, (0.0, \[0.0, 0.0\]), (0.4, \[500.0, 0.0\]) and (1.0, \[500, 200.0\]), then when the interpolator's fraction field was 0.0 (i.e. 0%), the field would be set to \[0.0, 0.0\]. When fraction was 0.4 (i.e. 40%), the field would be set to \[500.0, 0.0\]. When fraction was 1.0 (i.e. 100%), the field would be set to \[500.0, 200.0\].

For values of fraction between 0.0 and 0.4 (e.g. 0.2 or 20%), the field value is determined by linearly interpolating the keyValues for the first two keyframes. In this case, since the key of 0.2 is halfway between the key at 0.0 and the key at 0.4, the field would be set to \[250.0, 0.0\] (halfway between the point \[0.0, 0.0\] and \[200.0, 0.0\]. Similarly, when fraction is between the second and third keys (i.e. between 0.4 and 1.0), the field value is determined by linearly interpolating the keyValues of the second and third keyframes.

For this example, if the field being interpolated were the translation field of a Poster node parented to the Scene node, the Poster would originally be positioned with its top/left corner at the upper, left corner of the screen. As the animation proceeded from 0% to 40% complete, the Poster would slide horizontally to the right until it's top/left corner was at x=500.0, y=0.0. As the animation continued from 40% to 100% complete, the Poster would slide vertically down until its top/left corner was at x=500.0, y=200.0.

If the first keyframe has a key percentage greater than zero, then the field value will be equal to the keyValue of the first keyframe until fraction reaches the first keyframe's key percentage. Similarly, if the last keyframe has a key percentage less than one, the field value will be set to the keyValue of the last keyframe from when fraction equals the the last keyframe's key percentage and will not change as fraction increases from that value to 1.0.

> While linearly interpolation is used to compute the keyValue's for fraction values between successive keys, non-linear easing functions may be applied to the fraction values computed by the Animation node, so the overall animation may vary in speed.

### Example

The following scrolls the text string "Application Development Made Easy!" back and forth near the top of the display screen in 10 seconds, repeatedly.

#### Vector2DFieldInterpolator Node Class Example

    <?xml version="1.0" encoding="utf-8" ?>
    
    <!--********** Copyright 2015 Roku Corp.  All Rights Reserved. **********-->
    
    <component name="animationv2dtest" extends="Group" >
    
        <script type="text/brightscript" >
            <![CDATA[
                function init()
                    m.top.setFocus(true)
                end function
            ]]>
        </script>
    
    <children>
    
        <Label
            id="testLabel"
            height="44"
            width="0"
            font="font:MediumBoldSystemFont"
            text = "Application Development Made Easy!"
            horizAlign = "left"
            vertAlign = "center"
            translation="[318,8]" />
    
            <Animation
                id="testAnimation"
                duration="10"
                repeat="true"
                control="start"
                easeFunction="linear">
                <Vector2DFieldInterpolator
                    id = "testVector2D"
                    key="[0.0, 0.5, 1.0]"
                    keyValue="[ [318.0, 8.0], [656.0, 8.0], [318.0, 8.0] ]"
                    fieldToInterp="testLabel.translation"   />
    
            </Animation>
    </children>
    
    </component>
    

Fields
------

| Field | Type | Default | Access Permission | Description |
| --- | --- | --- | --- | --- |
| fieldToInterp | string | ""  | READ\_WRITE | Specifies the field to interpolate. The string should contain the ID of a node in the scene and the name of a field of that node, separated by a dot ".". For example, "title.width" would indicate that the interpolator should be applied to the width field of a node whose id field was "title". The specified field must be of type float |
| key | array of floats | \[ \] | READ\_WRITE | Specifies the key percentages for the interpolator's keyframes. Each key percentage should be a unique value from 0 to 1 indicating the percentage of the animation where the keyValue should occur. Behavior is undefined if the number of values in the key field does not match the number of values in the keyValue field |
| keyValue | array of vector2ds | \[ \] | READ\_WRITE | Specifies the key values or the interpolator's keyframes. Each value in the keyValue array corresponds to a value in the key field's array. The interpolator's behavior is undefined if the number of values in the key field does not match the number of values in the keyValue field |
| fraction | float | 0.0 | READ\_WRITE | Specifies the percentage to be used to compute a value for the field |
| reverse | boolean | false | READ\_WRITE | Enables animation to be played in reverse. |

Sample app
----------

[AnimationV2DExample](https://github.com/rokudev/samples/tree/master/ux%20components/animation/AnimationV2DExample) is a sample app demonstrating Vector2DfieldInterpolator in action.

ifArraySet
==========

The ifArraySet interface supports the array indexing operator \[\].

(See ArrayOperator)

Implemented by
--------------

| Name | Description |
| --- | --- |
| [roArray](/docs/references/brightscript/components/roarray.md "roArray") | An array stores an indexed collection of BrightScript objects. Each entry of an array can be a different type, or they may all of the same type |
| [roByteArray](/docs/references/brightscript/components/robytearray.md "roByteArray") | The byte array component is used to contain and manipulate an arbitrary array of bytes |
| [roList](/docs/references/brightscript/components/rolist.md "roList") | The list object implements the interfaces: ifList, ifArray, ifEnum and therefore can behave like an array that can dynamically add members |
| [roXMLList](/docs/references/brightscript/components/roxmllist.md "roXMLList") | Contains a list of roXML objects |

Supported methods
-----------------

### SetEntry(index As Integer, tvalue As Dynamic) As Void

#### Description

Sets an entry at a given index to the passed value. If index is beyond the bounds of the array, the array is expanded to accommodate it.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| index | Integer | The entry to be updated. |
| tvalue | Dynamic | The new value for the specified entry. |

Error handling in BrightScript
==============================

Formal support for error handling came to BrightScript in Roku OS 9.4, with the introduction of exception trapping. BrightScript's `TRY`/`CATCH`/`THROW` model may be familiar to developers who have worked with other popular programming languages, such as Java or Python. This article provides an overview of error handling under BrightScript, especially as achieved through the exception trapping feature. Detailed statement syntax is discussed in the Reference article about [Program statements](/docs/references/brightscript/language/program-statements.md#try-catch-variable-end-try).

Proper usage of exceptions
--------------------------

Exceptions are the _rare_ deviations from expected app behavior that are not easily handled (or which, for various reasons, cannot be handled at all) in regular code. Channels should be engineered to handle all foreseeable circumstances in regular code, proactively avoiding errors whenever possible. But some situations that can be anticipated, and certainly those that cannot be predicted, may best be handled by an approach of, "let the error happen and then recover from it." BrightScript's `TRY`/`CATCH`/`THROW` facilities exist to address such cases.

It is important for the developer to view BrightScript's exception trapping features as a last-recourse alternative to allow the app to recover and continue operating in the face of anomalous conditions. Use of exception trapping is ill-advised to deal with normal cases, where careful programming can prevent error. This is because, for example, the exception trapping process is not as efficient as regular code (the execution of which is optimized for performance). Furthermore, the performance of `TRY`/`CATCH` itself is optimized for the "no error" case. Thus, when a particular exception occurs more frequently than, say, once in a thousand attempts, an app may be more efficient if it deals with the problem directly, through "normal" code, rather than by relying on the "backstop" that is provided by the exception trapping mechanism.

_Catching_ an exception – providing a sequence of code that the system executes when something goes wrong – means an app _can_ safely recover and continue running when it would otherwise have crashed. _Throwing_ an exception – passing notification of an error condition to calling code (or to the system) – allows a problem to be handled, or reported clearly, instead of being silently ignored or resulting in more undesirable misbehavior, perhaps further along in execution, once information about the original anomaly is lost. The bulk of this article examines the catch and throw processes and associated mechanisms.

> When speaking of exceptions, "catching" and "trapping" are equivalent expressions. So are "throwing" and "raising."

Catching and handling exceptions
--------------------------------

The code that handles an exceptional situation resides in a `TRY`/`CATCH` block. Here is an example:

    PRINT "I'm about to try something that might not work"
    TRY
        do_something_that_might_throw_an_exception()
        PRINT "It worked!"
    CATCH e
        PRINT "It went wrong:",e.message
    END TRY
    PRINT "I've finished the attempt. (This is printed whether or not an exception was caught.)"
    

BrightScript will treat the block as follows:

*   Run the code which appears between the `TRY` and the `CATCH e.`
*   If no (system-recognized) error condition occurs, skip the code between `CATCH e` and `END TRY`. Continue at the line after the `END TRY.`
*   If a system-recognized error condition occurs, stop executing the code between `TRY` and the `CATCH e`. In that case, assign an exception object to `e`, and then execute the code between `CATCH e` and `END TRY`.

The exception object
--------------------

When an exception is caught, information concerning the circumstances is collected within an exception object, which is then assigned to the variable named in the relevant CATCH clause. The table here lists publicly available fields of an exception object, which are further explained below.

| Name | Type | Meaning |
| --- | --- | --- |
| number | Integer | The BrightScript error number |
| message | String | The error message text |
| backtrace | roArray | The location of the error |

### The error number

The number is the same as printed when a program crashes. For example, consider this code:

    SUB main()
        x = 1
        PRINT x.foo
    END SUB
    

Execution produces the following output, due to an exception that is _not_ caught:

    Syntax Error. (runtime error &h02) in /tmp/dev/example.brs(3)
    

Note that the system's standard error reporting format may not provide information that is most meaningful to the user, or present it in the most useful format. The following version of `main()` is written to catch exceptions and report them to the user in a form that the programmer has defined:

    SUB main()
        x = 1
        TRY
            PRINT x.foo
        CATCH e
            PRINT e.number,e.message
        END TRY
    END SUB
    

Here is the "programmer-approved" output produced by the enhanced `main()`:

    2              Syntax Error.
    

### The backtrace

The backtrace associative array contains information concerning the location of the code being executed when an exception occurred; it is primarily useful during diagnosis of problems in an app. The table below lists the keys of data items, which may be found in a backtrace array.

| Name | Type | Meaning |
| --- | --- | --- |
| function | String | The full prototype of the function containing the error |
| filename | String | The source file containing the error |
| line\_number | Integer | The line number within the source file |

Element 0 of the array is the outermost function; element `count()-1` is the innermost (i.e., the function that was directly executing when the exception occurred). This ordering corresponds to that used in a debugger or crash dump backtrace display.

The `function` prototype text ("signature") will be something like `"main() As Void"` or `"foo(x As Float, y As Float) As Float"`. Here is an example of custom error display code that extracts the function name for a more concise display:

    CATCH e
        prototype = e.backtrace[e.backtrace.count()-1].function
        name = LEFT(prototype,INSTR(prototype,"(")-1)
        PRINT "Error in function ";name
    END TRY
    

The collection of keys present in the backtrace array may vary. The function prototype will always be present (but, depending on the dynamic execution situation, the name may be a placeholder, e.g., the anonymous function name "`$anon_1`", which does not correspond to a programmer-chosen method name in app source code). Filename and line number will either both be present, or neither. Other items may be present, or could someday be added to this structure, but developers should only count on and use the ones documented here; others are for internal use only and their contents, meaning, and even continued existence are never guaranteed.

Throwing exceptions
-------------------

The app may _throw_ an exception to indicate something unexpected has gone wrong in app code. The simplest form is:

    THROW "One of the cross beams has gone out of skew on the treadle."
    

This causes an exception with error number `ERR_USER` (`&h28`) as the number, and the supplied string as the message. If not caught, it will reach the crash dump or debugger, as with any other error:

    Current Function:
    001:  SUB demo()
    002:*     THROW "One of the cross beams has gone out of skew on the treadle"
    003:  END SUB
    One of the cross beams has gone out of skew on the treadle (runtime error &h28) in /tmp/dev/example.brs(2)
    Backtrace:
    #1  Function demo() As Void
       file/line: /tmp/dev/example.brs(3)
    #0  Function main() As Void
       file/line: /tmp/dev/example.brs(6)
    Local Variables:
    global           &h0020 Interface:ifGlobal
    m                &h0010 roAssociativeArray refcnt=3 count:0
    
    Brightscript Debugger>
    

A `roAssociativeArray` that describes the exception is also an acceptable argument to `THROW`. Any missing fields will will be set with default values as shown in the table below:

| Name | Default |
| --- | --- |
| number | `ERR_USER` (`&h28`) |
| message | Look up the standard error message for the number |
| backtrace | The location of the `THROW`. |

Consider this example, which produces a division by zero error, along with a message that helpfully directs the user to the assumed source of fault:

    THROW {number: ERR_DIV_ZERO, message: "Division by zero in complex number library"}
    

The ability to `THROW` an associative array, coupled with the system's default assumptions about the values of missing elements in such arrays, implies that the two following `THROW` statements are equivalent:

    THROW "My error message"
    THROW {message: "My error message"}
    

In the second case, the system assumes that the value of `number` is `ERR_USER` (`&h28`), and supplies the appropriate `backtrace`, just as if it would have in the "string-only" case.

In constructing the `roAssociativeArray` to be used a `THROW` argument, one normally omits the `backtrace`, allowing BrightScript to supply accurate information automatically. Supplying a modified or constructed `backtrace` is not recommended, as malformed information may cause the system to treat a `THROW` as "invalid," while incorrect or (permissibly) omitted information may hamper the efforts of those charged with diagnosing problems in the code.

> BrightScript directly modifies the thrown exception object, rather than copying it. This should pose no difficulty in normal circumstances.

### Invalid throws

Attempts to `THROW` anything other than the acceptable arguments as defined here (including modified exception objects, which the system identifies as being improperly formed) will produce an `ERR_BAD_THROW` (`&h26`) error condition. This error is recoverable, however, and thoughtfully written code could deal intelligently with it.

Note that execution will _never_ continue past a `THROW`; the statement will either `THROW` what it is given or `ERR_BAD_THROW`.

The following are just a few examples of invalid throws:

    THROW 1
    THROW []
    THROW { number: "I am not a number!" }
    THROW { message: ["Two","Messages"] }
    THROW { backtrace: [ {} ] }   ' The function member in a backtrace entry is mandatory
    THROW { backtrace: [ {function: "main()", line_number: "Five"} ] }
    

### Custom fields in exception objects

Custom information fields can be added to an exception without invalidating the `THROW`, so long as system-defined fields are left undisturbed. The custom fields can then be read by the `CATCH`\-block that handles the exception. Roku recommends that any custom fields have names that begin with "`custom`"; fields with such names will not accidentally overwrite either existing system-defined fields, or any fields that Roku may eventually add to exception objects.

    TRY
        fetch_web_page()
    CATCH e
        IF e.custom_http_response_code = 404 THEN
            PRINT "The page didn't exist"
        ELSE
            THROW e      ' a re-throw – see relevant documentation for explanation
        END IF
    END TRY
    

### Re-throwing an exception

An exception object that has been caught is a valid argument to `THROW`. This is useful in some circumstances, for example:

#### Reacting to an error without handling it

    TRY
        IF m.already_failed_once <> TRUE THEN do_something_which_might_fail()
    CATCH e
        m.already_failed_once = TRUE
        THROW e
    END TRY
    

#### Handling only some errors

    LIBRARY "v30/bslCore.brs"
    
    SUB main()
        ERR = bslBrightScriptErrorCodes()
        TRY
            do_something_which_might_fail()
        CATCH e
            IF e.number = ERR.ERR_DIV_ZERO THEN
                PRINT "Divided by zero. A pity, but let's proceed."
            ELSE
                THROW e
            END IF
        END TRY
    END SUB
    

The above snippet handles only division by zero in `do_something_which_might_fail()`; all other errors are handled as though that `TRY`...`CATCH` were not there - either being handled by another `TRY`...`CATCH`, or terminating the program.

An exception is regarded as re-thrown if (and only if) the thrown exception object already contains a backtrace.

When an exception object with no backtrace is thrown:

*   `rethrown` is set false; and
*   `backtrace` is set to the location of the `THROW`.

When an exception object that contains a backtrace is thrown:

*   `rethrown` is set true;
*   `backtrace` is checked for validity, _but not modified;_ and
*   `rethrow_backtrace` is set to the location of the re-throw.

The `rethrown` field is _always_ overwritten, so can be relied upon as an authoritative indication of which backtrace was created by the runtime. In particular, if `rethrown` is true, then `rethrow_backtrace` has been freshly set (as of the time of most recent modification of the exception object) with the location of the re-throw.

Miscellaneous examples
----------------------

Following are several code snippets that illustrate interesting aspects of BrightScript error-handling.

For example, `TRY`/`CATCH` blocks can be nested arbitrarily to provide multiple layers of error protection and recovery.

Below, although calling `reciprocal(0)` causes a division by zero, the function handles that exception itself, so the `TRY`/`CATCH` block in `main` _never_ catches anything:

    FUNCTION reciprocal(x)
        TRY
            RETURN 1/x
        CATCH e
            RETURN 1e1000000  'This is so big it will be infinity
        END TRY
    END FUNCTION
    
    SUB main()
        PRINT "Starting"
        TRY
            FOR i = -10 TO +10
                PRINT "1/";i;"=";reciprocal(i)
            NEXT
        CATCH e
            PRINT "This never happens"
        END TRY
        PRINT "Ending"
    END SUB
    

Here is an alternative that calculates the reciprocal directly in `main`:

    SUB main()
        PRINT "Starting"
        TRY
            FOR i = -10 TO +10
                TRY
                    PRINT "1/";i;"=";1/i
            CATCH e
                PRINT "1/";i;" gives ";e.message
            END TRY
            NEXT
        CATCH e
            PRINT "This never happens"
        END TRY
        PRINT "Ending"
    END SUB
    

An outer `TRY`/`CATCH` block can handle errors caused in an inner `CATCH`:

    SUB main()
        PRINT "Starting"
        x = "I'm not an array"
        TRY
            TRY
                PRINT "x[0]*2=";x[0]*2
            CATCH e
                ' Spoiler: evaluating x[0] is about to cause an error
                PRINT "I think that failed because ";x[0];" isn't a number"
        END TRY
        CATCH e
            PRINT "Nope, I guessed wrong: ";e.message
        END TRY
        PRINT "Ending"
    END SUB
    

Here is a variation, in which a `CATCH` itself contains a `TRY`/`CATCH` block, which, in turn catches any errors that _it_ produces:

    SUB main()
        PRINT "Starting"
        x = "I'm not an array"
        TRY
            PRINT "x[0]*2=";x[0]*2
        CATCH e
            TRY
                PRINT "I think that failed because ";x[0];" isn't a number"
            CATCH e
                PRINT "Nope, I guessed wrong: ";e.message
            END TRY
        END TRY
        PRINT "Ending"
    END SUB
    

Extracting the diagnostic portion into a separate subroutine yields the same results:

    SUB diagnose(x)
        TRY
            PRINT "I think that failed because ";x[0];" isn't a number"
        CATCH e
            PRINT "Nope, I guessed wrong: ";e.message
        END TRY
    END SUB
    
    SUB main()
        PRINT "Starting"
        x = "I'm not an array"
        TRY
            PRINT "x[0]*2=";x[0]*2
        CATCH e
            diagnose(x)
        END TRY
        PRINT "Ending"
    END SUB

Deprecated APIs
===============

Roku periodically deprecates nodes, functions, fields, and attributes when releasing new or updated APIs.

Deprecated APIs should no longer be used because they may be removed from future Roku OS releases, and they may also cause your app to fail [certification testing](/docs/developer-program/certification/certification.md#using-current-apis). Proactively updating your app application code with the latest APIs ensures that your app is unaffected by the deprecation process.

The [Roku OS release notes](/docs/developer-program/release-notes/roku-os-release-notes.md) document which APIs are being deprecated with each release.

> Do not use deprecated APIs. Roku's [Static Analysis tool](/docs/developer-program/dev-tools/static-analysis-tool/static-analysis-tool.md), which is used for [certification testing](/docs/developer-program/certification/certification.md#using-current-apis) of apps, detects and reports any deprecated APIs in the app code as errors. All reported errors in the app code (including those resulting from the use of deprecated APIs) must be resolved to pass Static Analysis testing and publish the app.

### roAppManager.ShowChannelStoreSpringboard()

As of February 10, 2025, the **roAppManager.ShowChannelStoreSpringboard()** function is deprecated. Static Analysis will block the publishing of new or updated apps that use this function.

[run\_as\_process manifest attribute](/docs/developer-program/getting-started/architecture/channel-manifest.md)
---------------------------------------------------------------------------------------------------------------

As of Roku OS 12.5, all apps run in a separate process, regardless if the **run\_as\_process** attribute has been specified in the [manifest](/docs/developer-program/getting-started/architecture/channel-manifest.md).

[roUrlTransfer.enableFreshConnection()](/docs/references/brightscript/interfaces/ifurltransfer.md#enablefreshconnectionenable-as-boolean-as-boolean)
----------------------------------------------------------------------------------------------------------------------------------------------------

Since Roku OS 11.5 (September 2022), the Roku OS no longer supports the **roUrlTransfer.enableFreshConnection()** function. Apps should always reuse connections because it is more efficient (new connections impact app performance by increasing latency and consuming more CPU).

[Audio node Windows Media Audio](/docs/references/scenegraph/media-playback-nodes/audio.md#fields)
--------------------------------------------------------------------------------------------------

Since Roku OS 10.5 (September 2021), the Windows Media Audio (**wma**) and WMApro (**wmapro**) audio formats are no longer supported. Both formats were officially sunset as part of the Roku OS 12.5 release in September 2023. See the [Audio node](/docs/references/scenegraph/media-playback-nodes/audio.md) for the current list of audio formats supported by the Roku platform.

[Signal beacon SteadyMaxMemPoints](/docs/developer-program/performance-guide/measuring-channel-performance.md#viewing-channel-performance-metrics)
--------------------------------------------------------------------------------------------------------------------------------------------------

Since Roku OS 10.0 (April 2021), the **SteadyMaxMemPoints** metric has been removed from the signal beacon performance measurements. It is no longer reported in the debugging logs when an app is exited. Use the [**chanperf**](/docs/developer-program/debugging/debugging-channels.md#scenegraph-debug-server-port-8080-commands) SceneGraph debug console command to measure an app's memory consumption.

File:// URLs
------------

As of Roku OS 10.0 (April 2021), apps must replace all **file://** URLs with **pkg:/** URLs.

### Nielsen DAR APIs

Developers should use the [general audience measurement APIs](/docs/developer-program/advertising/raf-api.md#general-audience-measurement) instead of calling the enableNielsenDAR() and setNielsenProgramId() methods.

[SceneGraph Video node manifestData fields](/docs/references/scenegraph/media-playback-nodes/video.md#trickplay-fields)
-----------------------------------------------------------------------------------------------------------------------

Since Roku OS 9.4 (September 2020), the `manifestData[periods]` and `manifestData[mpd]` fields were deprecated. Those fields were replaced by `manifestData[xml],`which provided access to the same information and more. However, since then, access to the **Video.manifestData** field itself has been restricted and is no longer externally documented because it is not compatible across all device platforms (particularly, lower-end devices).

[Eval()](/docs/references/brightscript/language/runtime-functions.md#evalcode-as-string-as-dynamic)
---------------------------------------------------------------------------------------------------

Since Roku OS 9.3 (April 2020)**,** the [Eval()](/docs/references/brightscript/language/runtime-functions.md#evalcode-as-string-as-dynamic) function has been sunset and is no longer in the Roku OS. Do not use this function; it will cause compilation or runtime errors. This completes a deprecation process that began with the Roku OS 9.0 release (October 2018).

Developers using the **eval()** function to initialize data should use the [parseJSON()](/docs/references/brightscript/language/global-utility-functions.md#parsejsonjsonstring-as-string-as-object) function instead.

As described in [Manifest file](/docs/developer-program/getting-started/architecture/channel-manifest.md):

*   In Roku OS 9.0 with rsg\_version=1.2, use of the runtime function Eval() will result in a compile-time error.
*   In Roku OS 9.0 other usage of Eval() is not thread-safe and may result in runtime errors.

[DRM](/docs/specs/media/content-protection.md)
----------------------------------------------

The following DRMs are no longer supported:

*   Verimatrix DRM (deprecated in Roku OS 9.3).
*   Adobe DRM (deprecated in Roku OS 9.3).

Make sure that content in your app is protected using a Roku-supported DRM such as Widevine, PlayReady, or AES-128.

[roDeviceInfo.GetVersion()](/docs/references/brightscript/interfaces/ifdeviceinfo.md#getosversion-as-object)
------------------------------------------------------------------------------------------------------------

Use the [**roDeviceInfo.GetOsVersion()** function](/docs/references/brightscript/interfaces/ifdeviceinfo.md#getosversion-as-object) instead, which was introduced in Roku 9.2 OS (September 2019), to get the **major**, **minor**, **revision**, and **build** numbers of the Roku OS running on a device.

[ifDeviceInfo](/docs/references/brightscript/interfaces/ifdeviceinfo.md)
------------------------------------------------------------------------

### [GetConnectionInfo() MAC address field](/docs/references/brightscript/interfaces/ifdeviceinfo.md#getconnectioninfo-as-object)

The [roDeviceInfo.GetConnectionInfo()](/docs/references/brightscript/interfaces/ifdeviceinfo.md#getconnectioninfo-as-object) method no longer returns a device's MAC address (it returns a string of zeros). Developers can use the [roDeviceInfo.GetChannelClientId](/docs/references/brightscript/interfaces/ifdeviceinfo.md#getchannelclientid-as-string) method to uniquely identify devices.

### [isHDMIConnected()](/docs/references/brightscript/interfaces/ifdeviceinfo.md#ishdmiconnected-as-boolean)

The [roDeviceInfo.isHDMIConnected()](/docs/references/brightscript/interfaces/ifdeviceinfo.md#ishdmiconnected-as-boolean) method is deprecated. Use the [roHdmiStatus.IsConnected()](/docs/references/brightscript/interfaces/ifhdmistatus.md#isconnected-as-boolean) method instead.

### [GetAudioDecodeInfo()](/docs/references/brightscript/interfaces/ifdeviceinfo.md#getaudiodecodeinfo-as-object)

The [GetAudioDecodeInfo()](/docs/references/brightscript/interfaces/ifdeviceinfo.md#getaudiodecodeinfo-as-object) method is deprecated. Use the [CanDecodeAudio()](/docs/references/brightscript/interfaces/ifdeviceinfo.md#candecodeaudioaudio_format-as-object-as-object) method instead.

### Other deprecated ifDeviceInfo methods

Several properties of ifDeviceInfo were deprecated with the release of Roku OS 8.1 (May 2018) and were ultimately removed from the firmware in Roku OS 9.1 (April 2019).

Those deprecated methods of [ifDeviceInfo](/docs/references/brightscript/interfaces/ifdeviceinfo.md) were replaced with similar methods in Roku OS 8.1 (May 2018).

| **Deprecated method** | **Replacement method** |
| --- | --- |
| GetDrmInfo() | [GetDrmInfoEx()](/docs/references/brightscript/interfaces/ifdeviceinfo.md#getdrminfoex-as-object) |
| GetAdvertisingId() | [GetRIDA()](/docs/references/brightscript/interfaces/ifdeviceinfo.md#getrida-as-string) |
| IsAdIdTrackingDisabled() | [IsRIDADisabled()](/docs/references/brightscript/interfaces/ifdeviceinfo.md#isridadisabled-as-boolean) |
| GetClientTrackingId() | [GetChannelClientId()](/docs/references/brightscript/interfaces/ifdeviceinfo.md#getchannelclientid-as-string) |
| GetDeviceUniqueId() | [GetChannelClientId()](/docs/references/brightscript/interfaces/ifdeviceinfo.md#getchannelclientid-as-string) |
| GetVideoDecodeInfo() as Object | [CanDecodeVideo()](/docs/references/brightscript/interfaces/ifdeviceinfo.md#candecodevideovideo_format-as-object-as-object) |

### [ifUrlTransfer](/docs/references/brightscript/interfaces/ifurltransfer.md)

Deprecated prior to September 2018: UrlEncode(url as String)

### [roVideoPlayerEvent.IsStatusMessage() status values](/docs/references/brightscript/events/rovideoplayerevent.md#isstatusmessage-as-boolean)

The following status values returned by the [roVideoPlayerEvent.IsStatusMessage()](/docs/references/brightscript/events/rovideoplayerevent.md#isstatusmessage-as-boolean) method are deprecated:

*   "end of stream"
*   "end of playlist"

### [Content metadata](/docs/developer-program/getting-started/architecture/content-metadata.md)

Several attributes have been deprecated:

*   AudioLanguageSelected (deprecated in Roku OS 9.2). Users can select their preferred audio language on-device in the Settings > Audio > Audio Preferred Language screen.
*   AudioPIDPref. (users can select their preferred audio language on-device in the Settings > Audio > Audio Preferred Language screen).
*   PlayDuration (deprecated in Roku OS 8.1)
*   encodingKey (use licenseServerURL)
*   encodingType (use licenseServerURL)
*   "wmv" as a value for the streamformat field.

Consult the linked documentation page for details.

### [roScreen SD mode](/docs/references/brightscript/components/roscreen.md#sd-mode-screensizes)

Using the [roScreen](/docs/references/brightscript/components/roscreen.md) node in SD mode has been deprecated. Developers should develop games in HD mode.

### [Roku manifest](/docs/developer-program/getting-started/architecture/channel-manifest.md)

Several attributes have been deprecated; consult the linked documentation page for details.

### roAppInfo.getSubtitle()

**roAppInfo.getSubtitle()** function has been deprecated since around Roku OS 5.0.

Deprecated Components: January 1, 2018
--------------------------------------

As of this date, all newly published or re-published apps were required to use SceneGraph or Direct Publisher. Accordingly, all legacy visual screen components and associated event components were deprecated.

> These components were sunset as part of the Roku OS 11.5 release (September 12, 2022). The documentation for these components and events has been removed.

Below is the list of relevant sunset components and events:

| **Legacy component** | **Associated event** |
| --- | --- |
| roCaptionRenderer | roCaptionRendererEvent |
| roCodeRegistrationScreen | roCodeRegistrationScreenEvent |
| roFontMetrics |     |
| roGridScreen | roGridScreenEvent |
| roKeyboardScreen | roKeyboardScreenEvent |
| roImageCanvas | roImageCanvasEvent |
| roListScreen | roListScreenEvent |
| roMessageDialog | roMessageDialogEvent |
| roOneLineDialog | roOneLineDialogEvent |
| roParagraphScreen | roParagraphScreenEvent |
| roPinEntryDialog | roPinEntryDialogEvent |
| roPosterScreen | roPosterScreenEvent |
| roSearchHistory |     |
| roSearchScreen | roSearchScreenEvent |
| roSlideShow | roSlideShowEvent |
| roSpringboardScreen | roSpringboardScreenEvent |
| roTextScreen | roTextScreenEvent |
| roVideoScreen | roVideoScreenEvent |

Deprecated interfaces: July 1, 2017
-----------------------------------

Since July 1, 2017, the interfaces listed below have been deprecated and apps using them have been rejected during certification for publication or re-publication.

> These interfaces were sunset as part of the Roku OS 11.5 release (September 12, 2022). The documentation for these interfaces has been removed.

ifCaptionRenderer

ifCodeRegistrationScreen

ifFontMetrics

ifGridScreen

ifImageCanvas

ifKeyboardScreen

ifListScreen

ifMessageDialog

ifOneLineDialog

ifParagraphScreen

ifPinEntryDialog

ifPosterScreen

ifSearchHistory

ifSearchScreen

ifSlideShow

ifSpringboardScreen

ifTextScreen

ifVideoScreen

Text to speech
==============

> This feature is only available on the following devices: Roku Streaming Stick (3600X), Roku Express (3700X) and Express+ (3710X), Roku Premiere (4620X) and Premiere+ (4630X), Roku Ultra (4640X), and any Roku TV running Roku OS 7.2 and later.

* * *

Text to speech components
-------------------------

_Components available since Roku OS 7.2_

Text to speech (TTS) allows the developer to provide an audible spoken version of the strings shown to the user in the app. For platforms that are required to comply with the [FCC Communications and Video Accessibility Act of 2010 (CVAA)](https://www.fcc.gov/consumers/guides/21st-century-communications-and-video-accessibility-act-cvaa), this capability can be used as part of compliance with CVAA, and the current text to speech flite\_tts library is built into the image. The Roku text to speech capability supports different languages, voices, rates of speech, volume of speech, and other aspects of text to speech. Roku provides text to speech support in the following components, interfaces, and events:

*   [roTextToSpeech](/docs/references/brightscript/components/rotexttospeech.md)
*   [ifTextToSpeech](/docs/references/brightscript/interfaces/iftexttospeech.md)
*   [roTextToSpeechEvent](/docs/references/brightscript/events/rotexttospeechevent.md)

Components available since Roku OS 7.5

*   [roAudioGuide](/docs/references/brightscript/components/roaudioguide.md)
*   [ifAudioGuide](/docs/references/brightscript/interfaces/ifaudioguide.md)

Screen reader behavior for SceneGraph nodes
-------------------------------------------

*   **[ArrayGrid](/docs/references/scenegraph/abstract-nodes/arraygrid.md)**: speaks focused item ([ContentMetaData::TITLE](/docs/developer-program/getting-started/architecture/content-metadata.md#descriptive-attributes)), followed by navigation hint, then ContentMetaData::AUDIO\_GUIDE\_SUFFIX (if any).

*   **[Button](/docs/references/scenegraph/widget-nodes/button.md)**: text of button is spoken only if focused

*   **[ButtonGroup](/docs/references/scenegraph/layout-group-nodes/buttongroup.md#fields)**: speaks focused [Button](/docs/references/scenegraph/widget-nodes/button.md), followed by navigation hint (“button 1 of 4”), followed by button-specific hint, if any (Button-specific hint is spoken only for StarRatingButton).

*   **[CheckList](/docs/references/scenegraph/list-and-grid-nodes/checklist.md)**: speaks focused item (ContentMetaData::AUDIO\_GUIDE\_TEXT if any; otherwise [ContentMetaData::TITLE](/docs/developer-program/getting-started/architecture/content-metadata.md#descriptive-attributes)) followed by navigation hint (“checkbox, checked, 1 of 4”)

*   **[Dialog](/docs/references/scenegraph/dialog-nodes/dialog.md)**: speaks `title`, `message`, and `bulletText` (if any), then reads focused button

*   **[Keyboard](/docs/references/scenegraph/widget-nodes/keyboard.md)**: speaks hint about caps lock toggling (once), then speaks focused key

*   **[KeyboardDialog](/docs/references/scenegraph/standard-dialog-framework-nodes/standard-keyboard-dialog.md)**: speaks title, then keyboard

*   **[Label](/docs/references/scenegraph/label-nodes/label.md)**: speaks `text` field

*   **[LabelList](/docs/references/scenegraph/list-and-grid-nodes/labellist.md)**: speaks focused ContentMetaData::AUDIO\_GUIDE\_TEXT if any; otherwise speaks [ContentMetaData::TITLE](/docs/developer-program/getting-started/architecture/content-metadata.md#descriptive-attributes), followed by navigation hint.

*   **[MarkupGrid](/docs/references/scenegraph/list-and-grid-nodes/markupgrid.md)**: speaks focused ContentMetaData::AUDIO\_GUIDE\_TEXT if any; otherwise speaks [ContentMetaData::TITLE](/docs/developer-program/getting-started/architecture/content-metadata.md#descriptive-attributes), followed by navigation hint, then ContentMetaData::AUDIO\_GUIDE\_SUFFIX (if any), then MEDIA speech (see below)

*   **[MarkupList](/docs/references/scenegraph/list-and-grid-nodes/markuplist.md)**: speaks focused item ([ContentMetaData::TITLE](/docs/developer-program/getting-started/architecture/content-metadata.md#descriptive-attributes)), followed by navigation hint, then ContentMetaData::AUDIO\_GUIDE\_SUFFIX (if any).

*   **[MiniKeyboard](/docs/references/scenegraph/widget-nodes/minikeyboard.md)**: speaks focused key

*   **[PinDialog](/docs/references/scenegraph/standard-dialog-framework-nodes/standard-pinpad-dialog.md)**: speaks dialog title, whether in key pad, then focused key or button

*   **[PinPad](/docs/references/scenegraph/widget-nodes/pinpad.md)**: speaks focused key

*   **[Poster](/docs/references/scenegraph/renderable-nodes/poster.md)**: if focused, speaks `audioGuideText` field (if set)

*   **[PosterGrid](/docs/references/scenegraph/list-and-grid-nodes/postergrid.md)**: speaks focused item ([ContentMetaData::TITLE](/docs/developer-program/getting-started/architecture/content-metadata.md#descriptive-attributes)), followed by navigation hint.

*   **[ProgressDialog](/docs/references/scenegraph/dialog-nodes/progressdialog.md)**: speaks dialog `title`, `message`, and `bulletText` every 15 seconds. Speaks focused button if there is any.

*   **[RadioButtonList](/docs/references/scenegraph/list-and-grid-nodes/radiobuttonlist.md)**: speaks focused item (ContentMetaData::AUDIO\_GUIDE\_TEXT if any; otherwise, ContentMetaData::TITLE), followed by navigation and selection hint

*   **RenderableNode**: if speaking focused item (depends on context), will speak focused descendant; otherwise, will speak all descendants

*   **[RowList](/docs/references/scenegraph/list-and-grid-nodes/rowlist.md)**: speaks row label (when row becomes focused), then speaks focused **[PosterGrid](/docs/references/scenegraph/list-and-grid-nodes/postergrid.md)** or **[MarkupGrid](/docs/references/scenegraph/list-and-grid-nodes/markupgrid.md)** (MarkupGrid is used if itemComponentName is non-empty)

*   **[ScrollableText](/docs/references/scenegraph/typographic-nodes/scrollabletext.md)**: speaks `text` field

*   **[ScrollingLabel](/docs/references/scenegraph/typographic-nodes/scrollinglabel.md)**: speaks `text` field

*   **[Video](/docs/references/scenegraph/media-playback-nodes/video.md)**: speaks HUD if displayed by user

**Screen reader behavior for built-in SceneGraph panels and scenes:**

*   **[GridPanel](/docs/references/scenegraph/sliding-panels-nodes/gridpanel.md)**: speaks panel, then **leftLabel**

*   **[ListPanel](/docs/references/scenegraph/sliding-panels-nodes/listpanel.md)**: speaks panel, then **leftLabel**

*   **[PanelSet](/docs/references/scenegraph/sliding-panels-nodes/panelset.md)**:
    
    *   If left panel is focused, speaks focused left panel, then unfocused right panel (if any)
    *   If right panel is focused, speaks unfocused left panel, then focused right panel
    *   If no panel is focused, speaks unfocused left panel, then unfocused right panel (if any)

*   **[OverhangPanelSetScene](/docs/references/scenegraph/sliding-panels-nodes/overhangpanelsetscene.md)**: uses **[Overhang](/docs/references/scenegraph/sliding-panels-nodes/overhang.md)** title when speaking location

*   **[Scene](/docs/references/scenegraph/scene.md)**: speaks dialog (if any); otherwise speaks [PanelSet](/docs/references/scenegraph/sliding-panels-nodes/panelset.md) (if any); otherwise speaks as RenderableNode

**MEDIA speech is spoken in the following order:**

*   [ContentMetaData::TEXT](/docs/developer-program/getting-started/architecture/content-metadata.md#descriptive-attributes)
    
*   [ContentMetaData::DESCRIPTION](/docs/developer-program/getting-started/architecture/content-metadata.md#descriptive-attributes)
    
*   [ContentMetaData::DIRECTORS](/docs/developer-program/getting-started/architecture/content-metadata.md#descriptive-attributes)
    
*   [ContentMetaData::PRODUCERS](/docs/developer-program/getting-started/architecture/content-metadata.md#descriptive-attributes)
    
*   [ContentMetaData::ACTORS](/docs/developer-program/getting-started/architecture/content-metadata.md#descriptive-attributes)
    
    **There is no additional speech for the following nodes (they will behave the same as RenderableNode):**
    
*   [BifDisplay](/docs/references/scenegraph/media-playback-nodes/video.md#fields)
    
*   [BusySpinner](/docs/references/scenegraph/widget-nodes/busyspinner.md)
    
*   [LayoutGroup](/docs/references/scenegraph/layout-group-nodes/layoutgroup.md)
    
*   [Overhang](/docs/references/scenegraph/sliding-panels-nodes/overhang.md)
    
*   [Panel](/docs/references/scenegraph/sliding-panels-nodes/panel.md)
    
*   [ProgressBar](/docs/references/scenegraph/media-playback-nodes/video.md#fields)
    
*   [Rectangle](/docs/references/scenegraph/renderable-nodes/rectangle.md)
    
*   [TextEditBox](/docs/references/scenegraph/widget-nodes/texteditbox.md)
    
*   [TrickPlayBar](/docs/references/scenegraph/media-playback-nodes/video.md#fields)
    

Implementation tips
-------------------

### TTS interruptions

Many UI elements have default TTS behavior. It is possible that speech triggered by these implementations can interrupt your TTS implementation at times. You should keep track of the IDs of your TTS utterances, as returned by say() and silence(), and handle interruptions accordingly.

### Other TTS implementation changes

Other TTS implementations may change the current voice, the current language, the current volume, the current pitch, and/or the current speech rate. You should keep track of how these parameters might change.

### Long text delays

A long text string to be spoken by TTS may have a noticeable delay before starting the speech, at least for the first speech of the long string. For long text strings, you can break up the text string so that the first speech is a reasonably short sentence, followed by longer sentences as needed. You should not break up the long text string into individual words, as it will affect phrasing without improving the perceived delay in any noticeable way.

Roku's master UI
================

While developers have the ability to build and design their app to meet nearly any aesthetics they prefer, users will still be experiencing your app within the Roku UI experience. This Roku Master UI has its own set of conventions and system controls. Creating a level of harmony between these two linked spaces will benefit the user. Below is a list of considerations.

Pathways to the app
-------------------

There are several ways users can launch into your app from the Roku UI. Not all pathways lead users to your app's home page. This means your app's overall navigation scheme must be flexible enough to enable users to effectively start at any layer of your UI and move around from there.

*   **If your app is not already installed:**
    
    *   All pathways to your app will always lead to a sign-up/in flow first
*   **Ads:**
    
    *   Can launch and [deep link](/docs/developer-program/discovery/implementing-deep-linking.md) to almost any level of your app
        
        *   For example, launch and jump straight to a home page, a category or collection page, or a details page for a specific item
*   **Search and Follow:**
    
    *   If launching the app takes the user to the sign-up/in flow first, then immediately afterward the app should still remember to take users to the specific content that was selected and kicked off this whole process.
    *   Otherwise, Search and Follow can launch and deep-link to a specific piece of content.
        
        *   For example, a movie or TV episode details page, or a TV show season/episode collection page
*   **Streaming Store:**
    
    *   Can launch your app to its home page.
*   **Partner buttons:**
    
    *   Can launch your app to its home page.

Exiting the app
---------------

There are several ways users can exit the app. Some are immediate and beyond your control, and a few are more controlled. All forms of exit fall into one of two categories:

1.  Exit and take me to a new place (E.g., Home button).
2.  Exit and return me to where I was prior to launching your app (E.g., Back button).

* * *

*   RokuTVs may auto-power off after a certain amount of time of no user-activity.
    
*   Roku will launch a screensaver when there is no video playing and there is no user-activity.
    
*   Users can activate any of the following, which will immediately exit your app regardless of where the user was or what the user was doing:
    
    *   Roku remote's Home button
    *   Roku remote's Partner buttons (E.g., Netflix button)
    *   Selection of any app from Roku mobile app's "My Apps"
    *   Selection of any Roku mobile app function that will take over the TV screen (E.g., Miracast, Play on Roku, selection of a movie trailer, etc.)
*   Users can take any explicit exits you offer through your app's own UI.
    
*   Users must also be able to implicitly signal a desire to exit your app via the Roku remote's Back button:
    
    *   While Back is also a mechanism to navigate within your UI, there are specific conditions in which Back should exit.
    *   If users deep-link into your app, pressing Back could either exit your app back to the referring screen, or navigate them to your Home screen.
    *   From your app's home screen, pressing Back should either exit or offer a menu/opportunity for users to explicitly confirm and choose to exit.
*   On occasion, it's quite possible that users may accidentally exit your app. Hence, it's important for your app to save its state to make recovery easy for the returning user (E.g., Video-playback resume, recently watched, watchlist, etc.).
    

Settings
--------

*   There are values within Roku's settings that should be queried and leveraged by your app.
    
    *   **For example:**
        
        *   Closed Captions
        *   Language/Localization

Star/Options button
-------------------

Star/Options button is a great button to reveal menus and popup dialogs with contextual options. However, there is a restriction for this button:

*   Within your app, during full screen video playback, pressing the Roku remote's Star/Option button will reveal a Roku popup dialog offering users various standardized options (E.g, Closed captioning, audio tracks).
    
    *   This is necessary in part to comply with various regulations.
*   Do not design your app to use the Star/Option button during video playback.

Format strings
==============

A BrightScript Format string is a [printf-like](https://en.wikipedia.org/wiki/Printf) format string that is similar to that provided by C, C++, and other languages.

Format strings can be used by BrightScript calls [`<formatStr>.Format(args....)`](/docs/references/brightscript/interfaces/ifstringops.md) and for certain BrightScript data type calls [`<value>.ToStr(formatStr)`](/docs/references/brightscript/interfaces/iftostr.md).

The format string consists of ordinary characters (other than '%'), which are directly copied to the output string, and conversion specifications (which start with '%').

A conversion specification has the following syntax:

`%[flags][width][.precision]type`

The `flags`, `width`, and `precision` fields are optional, and they may control the conversion format.

##### Example

    "%02x%02x%02x".Format(255, 0, 128) ' returns "ff0080" 
    

See the [ifToStr interface](/docs/references/brightscript/interfaces/iftostr.md) for more examples.

type
----

The required type field specifies the type of conversion.

| Type Character | Description |
| --- | --- |
| %   | Use '%%' to encode a literal percent character. |
| d   | Signed decimal integer. |
| x, X | Unsigned hexadecimal integer. 'x' uses lowercase letters, 'X' uses uppercase. |
| o   | Unsigned octal integer |
| e, E | Floating point rounded and displayed as exponential format: \[-\]d.ddd(e/E)(+/-)dd. One digit is placed before the decimal point, and the 'precision' digits are placed after the decimal point.  <br>  <br>The default precision is 6. If the precision is 0, no decimal point character appears. |
| f, F | Floating point rounded and displayed in decimal format: \[-\].ddd.ddd: The number of digits after the decimal point is specified by 'precision'.  <br>  <br>The default precision is 6. If the precision is 0, no decimal point character appears. |
| g, G | Floating point rounded and displayed as either 'e'/'f' or 'E'/'F' corresponding to 'g'/'G'.  <br>  <br>The number of digits after the decimal point is specified by 'precision'.  <br>  <br>Precision defaults to 6 if not specified.Trailing zeros are removed from the fractional part. |
| s   | String. If precision is specified, a maximum number of that many characters is displayed. |
| c   | Character. This is specified as integer Unicode value. |

flags
-----

| Flag | Description |
| --- | --- |
| 0   | Zero-pads the value. For integer and floating point number conversions (d, o, x, X, e, E, f, F, g, and G), the converted value is padded on the left with zeros rather than blanks.  <br>  <br>If a precision is given with a numeric conversion (d, o, x, and X), the 0 flag is ignored. |
| +   | Inserts a sign ('+' or '-') before signed numbers. By default a sign is only placed before negative numbers. |
| \-  | Left adjusts the converted value on the field boundary (the default is right justification). |
| ' ' (space) | Inserts a blank before positive signed numbers. The '+' sign overrides a (space) if both are specified. |

width
-----

The width field is a decimal digit string (with non-zero first digit) that is used to specify a minimum field width.

If the formatted value has fewer characters than the field width, the value is padded according to the `type` and other flags.

precision
---------

Precision is a '.' (period) followed by an optional decimal digit string. This may also be specified as a '\*', in which case, the precision is read from the next integer parameter to the format call.

Roku Advertising Framework release notes
========================================

### Version 3.1 – 7/2022

*   For apps that collect explicit in-app consent for ad targeting (for example, to adhere to GDPR), a new [**setLimitAdTracking()**](/docs/developer-program/advertising/raf-api.md#setlimitadtrackingenabled-as-boolean) function that specifies the value of the ROKU\_ADS\_LIMIT\_TRACKING URL parameter macro to be passed into beacons and ad requests
*   Improved interactive ads capabilities
*   Deployed to devices on Roku OS 11.0 and above

### Version 2.18 – 2/2022

*   Support for new interactive ad experiences, improvements to existing templates
*   Improvements to [Roku ad watermark](/docs/developer-program/advertising/ad-watermark.md) feature
*   Multiple bug fixes and feature enhancements
*   Deployed to devices on Roku OS 10.5 and above

### Version 2.17 – 11/2021

*   Improvements to interactive ad rendering and operation
*   Multiple enhancements and bug fixes
*   Deployed to devices on Roku OS 10.5 and above

### Version 2.16 – 08/2021

*   Extended [Roku ad watermark](/docs/developer-program/advertising/ad-watermark.md) to support [Demand API](/docs/developer-program/advertising/demand-api.md) calls
*   Assorted bug fixes and enhancements to existing features
*   Deployed to devices on Roku OS 10.0 and above

### Version 2.15 – 05/2021

*   New Feature: Methods for accessing [Roku Demand API](/docs/developer-program/advertising/demand-api.md). Provides more efficient monetization by connecting to real-time ad demand, while preserving control of inventory allocation with publisher's ad server
*   New Feature: Initial implementation of watermarking for ad requests and impression pixels to combat ad fraud
*   Added Portuguese localization of the ad UI texts
*   Multitude of bug fixes and enhancements, notably [stitchedAdsInit()](/docs/developer-program/advertising/raf-api.md#stitchedadsinitadpodarray-as-roarray) now clears the ad badge if called mid-ad break (_early cue-in_ use case)
*   Deployed to devices on Roku OS 9.4 and above

### Version 2.14 – 12/2020

*   Added support for the characters **{|}"<>^\`** (which are neither reserved nor unreserved by [RFC-3986](https://tools.ietf.org/html/rfc3986)) by percent-encoding them in ad request and beacon URLs
*   New [`enableInPodStitching(isIPS as Boolean)`](/docs/developer-program/advertising/raf-api.md#enableinpodstitchingisips-as-boolean) method brings benefits from [CSAS API](/docs/developer-program/advertising/csas.md) to apps using the classic CSAI [showAds()](/docs/developer-program/advertising/raf-api.md#showadsads-as-object-ctx-as-object-view-as-object-as-boolean) by stitching together multiple video clips within a single ad break (no buffering between ads)
*   When parsing VAST, preserve the `id` attribute of `<MediaFile/>`
*   Added support for [getAds()](/docs/developer-program/advertising/raf-api.md#getadsmsg-as-string-as-object) parsing a local file from tmp:/ via e.g. [setAdURL("tmp:/myVASTorVMAPorSMRX.xml")](/docs/developer-program/advertising/raf-api.md#setadurlurl-as-string)
*   Multitude of bug fixes and enhancements
*   Deployed to devices on Roku OS 9.4 and above

### Version 2.13 – 7/2020

*   Multitude of bug fixes and enhancements, including
    
    *   Reduce [JIT pre-fetching](/docs/developer-program/advertising/raf-api.md#enablejitpodsenabled-as-boolean) to improve playback start time for [client-stitched](/docs/developer-program/advertising/csas.md) use case
    *   Fix regression of [fireRokuMarketingPixel()](/docs/developer-program/roku-pay/implementation/tracking-signup-abandonment.md#integrating-the-raf-firerokumarketingpixel-method-in-the-signup-workflow) not URL-encoding its arguments
    *   Fix errors on bad metadata (e.g. when parsing VAST, getting a single ad with yet having fallback\_index>0)
*   Improvements to interactive ads
*   Deployed to devices on Roku OS 9.2 and above

### Version 2.12 – 3/2020

*   New Voting Ad
*   Multitude of bug fixes and enhancements
*   Deployed to devices on Roku OS 9.2 and above

### Version 2.11 – 11/2019

*   New interactive ad features
*   Multitude of bug fixes and enhancements
*   Deployed to devices with Roku OS 9.2 or above

### Version 2.10 – 08/2019

*   Added handling of [voice ETC](/docs/developer-program/media-playback/voice-controls/transport-controls.md) for ads
*   Interactive ads improvements
*   Bug fixes and performance improvements
*   Deployed to devices with Roku OS 9.1 and above

### Version 2.9 – 06/2019

*   Added a [ROKU\_ADS\_LOCALE macro](/docs/developer-program/advertising/integrating-roku-advertising-framework.md#url-parameter-macros) which returns current locale in same format as [roDeviceInfo.getCurrentLocale()](/docs/references/brightscript/interfaces/ifdeviceinfo.md#getcurrentlocale-as-string) (e.g. "en\_US", "es\_ES")
*   Library manifests internally [rsg\_version=1.2](/docs/developer-program/getting-started/architecture/channel-manifest.md#special-purpose-attributes), which decreases memory use when RAF is included in complex apps. Note this is independent from the application-level _manifest_ file, where you may separately declare _rsg\_version=1.2_ (or assume the default 1.1 \[the default is now 1.2 as of Roku OS 9.3\])
*   New interactive ad features
*   Improved diagnostics. Of note, when detected a URL with invalid characters, RAF would print a warning:

    [RAF.err] roUrlTransfer.setURL("some invalid URL") rejected argument - invalid chars? (space and "<>\^`{|} must be %-encoded)
    

*   Bug fixes and performance improvements
*   Deployed to devices with Roku OS 9.1 and above

### Version 2.8 – 04/2019

*   New interactive ad units
*   Added support for expanding multiple RAF macros per single URL query parameter value. Consequently, now composite query parameters like FreeWheel's `flag` are supported in generic manner
*   Bug fixes and performance improvements
*   Deployed to devices with Roku OS 9.0 and above

### Version 2.7 – 01/2019

*   Release with a primary focus on Roku OS 9.0 compatibility
*   New interactive ad features
*   Bug fixes and performance improvements
*   Deployed to devices with Roku OS 9.0 and above

### Version 2.6 – 10/2018

*   RAF now shows test ads _only_ in side-loaded ("dev") and unpublished apps.
*   Added "In-Pod Stitching" capability for client-side ad-inserted (CSAI) apps, which provides an improved user experience that can eliminate buffering between multiple ads in an ad break. This can be enabled by developers for evaluation, and can by enabled in eligible production apps without the need for re-publishing.
*   Improved RAF diagnostic messages
*   Bug fixes and performance improvements
*   Deployed to devices with Roku OS 8.1 and above

### Version 2.5 – 05/2018

*   Major rework of RAF's diagnostic output to [BrightScript console](/docs/developer-program/debugging/debugging-channels.md#accessing-the-debug-console)
    
    *   Warning messages (prefixed with "\[RAF.err\]") are always printed for known potential problems. Note that these are just additional diagnostics - they do not change the library's behavior, as compared to previous versions.
    *   Substantially more information is printed when in setDebugOutput(true) mode: method call arguments and return values, [URL macros](/docs/developer-program/advertising/integrating-roku-advertising-framework.md#url-parameter-macros) expansion, ad XML/parsed, etc.
*   New interactive templates by BrightLine/Innovid
*   Deployed to devices with Roku OS 8.0 and above

### Version 2.4 – 03/2018

*   New feature: JIT ("Just In Time") ad resolution for VMAP, SmartXML to reduce overhead incurred by prefetching all ad pods before content playback starts
*   New feature: RIA ("Roku Interactive Ads") to allow rendering of Roku interactive ad overlays for OTT content (previously only available for ACR on linear content)
*   BrightLine bug fixes and performance improvements
*   Innovid bug fixes and new templates ("User Satisfaction Survey" and "Skippable" interactive ads)

### Version 2.3 – 10/2017

*   Add support for BrightLine interactive ads in SSAI+RSG use case
*   New interactive ad templates (Innovid)
*   Implement ad buffering limit
*   Add support for tracking beacons with HTTP → HTTPS redirects
*   General performance improvements and bug fixes
*   RAF 2.3 available in Roku OS 7.7 and above

### Version 2.2 – 07/2017

*   Added a native RSG renderer for Brightline interactive ads
*   Enabled the firing of tracking events on empty ad breaks (SmartXML and VMAP; relevant to FreeWheel forecasting)
*   Fixed the autoscaling of interactive ads for FHD-only RSG apps on a HD UI device
*   Fixed an error when the ad response is invalid XML
*   Improved the RIDA hashing when "limit ad tracking" is set
*   Improved the draining of pending beacons cache, to benefit low memory devices
*   Enhanced the handling of non-standard view sizes (RSG)
*   Fixed various minor issues

### Version 2.1 – 05/2017

*   Added support for comScore vCE campaign measurement service
*   Introducing a generalized audience measurement API (see [enableAdMeasurements()](/docs/developer-program/advertising/raf-api.md#general-audience-measurement) for details)
*   Support for a new TrueX SAB interactive ad template
*   Fix for a display resolution issue when a FHD-only RSG app was playing ad video on a HD UI device
*   Miscellaneous other fixes

### Version 2.0 – 03/2017

*   Support for RSG apps to use RAF from Task node
*   SceneGraph ad rendering support (video ads and Innovid interactive ads)
    
    *   New `view` parameter for [showAds()](/docs/developer-program/advertising/raf-api.md#client-ad-insertion), which is required for all SceneGraph applications
*   VAST 3.0 "ad buffet" support
*   Extended companion ad tag parsing from VAST to allow multiple ad renderers for different companion creatives
*   New interactive ad template support
*   New `adCompleted` return value for [`stitchedAdHandledEvent()`](/docs/developer-program/advertising/raf-api.md#server-stitched-ads)
*   New `provider` member for `companionAds` metadata in [Ad Structure](/docs/developer-program/advertising/integrating-roku-advertising-framework.md#ad-structure)
*   Fix in VAST parser to address problem with DFP waterfall containing invalid ads
*   Multiple bug fixes to address ad rendering in both SDK1 and RSG apps built with different combinations of supported `ui_resolutions`

### Version 1.9 – 11/2016

*   Freewheel SmartXML adReplica changes
    
    *   Improve forecasting by only resolving ad requests for wrapped creative renditions that are placed into ad slots
    *   Respect replicaId if specified in the adReference tag and a matching replica exists in the creativeRenditions, otherwise treat unwrapped renditions as alternate streams
*   When Limit Ad Tracking is set by the user, use a new time-scoped ID that is cycled every 30 days to provide the benefits of frequency capping while still respecting the user’s desire to avoid ad tracking
*   Added an optional new parameter to the setContentGenre() API to indicate whether content is targeted for kids
*   Added a new content macro, ROKU\_ADS\_KIDS\_CONTENT, and modified default/backfill URLs to use this new macro
*   Added a new API, getNielsenContentData(), that will return an encrypted N-RIDA parameter string for apps wishing to use Nielsen SDK for DCR measurements
*   New BrightLine template
*   Eclipse plugin compatibility fixes
*   Exit key handling fixes
*   TrueX and BrightLine bug fixes and enhancements
*   Added a fix for BrightLine ads to use cached ad position
*   Fixed 3rd-party tags that used improperly-encoded URL fragments by URL-encoding fragment contents
*   Modified garbage collection after interactive ad rendering to fix display issue with BrightLine ads

### Version 1.8 – 10/2016

*   Add missing tracking events for plain video ads in server-stitched streams: Impression, Pause, Resume
*   Add contextual info for complete tracking event
*   Add companion tracking metadata to Innovid ads, which do not explicitly have a CompanionAd tag to distinguish video ad tracking from microsite tracking
*   Add 303 error tracking when wrapped VAST returns no ads
*   New BrightLine templates
*   Merged Innovid renderer changes, including modifications to tracking pixel logic
*   New creativeAdId metadata field for ads
*   Fix crash when replacing RAF macros in URL containing query parameter values without a name
*   Correct pod-specific tracking for ad pods in server-stitched streams: PodComplete, PodStart
*   Disallow re-rendering of ad pod when pod cache has been updated while rendering the pod (e.g., for TrueX ads)
*   Re-purpose "Expand" and "Collapse" ad tracking to refer to microsite interactions for Innovid ads, which do not generally have a separate CompanionAd tag in the VAST representation for these additional tracking events
*   Ignore replicaId values when specified in SmartXML ad slots, since these always refer to the first replica
*   Treat multiple renditions of wrapped ads in SmartXML as replicas
*   Override any creative ID set from a wrapped ad with the creativeId attribute in SmartXML, since this is likely more meaningful to the app than the wrapped ID
*   Numerous TrueX/BrightLine bug fixes and feature changes
*   Track ad render position values to prevent spurious Complete/PodComplete events when exiting microsites (playback of stitched video can resume across ad boundary, resulting in extra tracking pixels being fired)

### Version 1.7 – 06/2016

*   New API: setContentMetaData(metaData): allows app to set information about the current content
*   Added new HLS MIME type: "application/vnd.apple.mpegurl"
*   Added "ai=ROKU\_ADS\_APP\_ID" to default and backfill ad URLs' cust\_params
*   Changed macro value of ROKU\_ADS\_LIMIT\_TRACKING to "1" or "0" instead of "true" or "false," to accommodate DFP's special LAT values
*   Changed handling of invalid messages passed to the event handler for stitched ads to return either the cached ad data if an ad is currently being rendered, or Invalid if no ad is being rendered to accommodate apps that erroneously pass Invalid messages to the handler
*   Prioritize MP4 over HLS ad creatives as HLS can take longer than the length of an ad to settle on an acceptable playback bitrate
*   Add support for TrueX ad experience and parse new TrueX VAST extensions
*   Invalidate rendering of current ad pod if pod cache has been updated
*   Parse "special" wrapped URLs inside <asset> tag in SmartXML
*   Numerous BrightLine changes to support rendering of choice cards, skip cards, managing ad pod cache when pods are skipped
*   Modified backfill URLs slotname parameter to use ROKU\_ADS\_APP\_ID as it was in v1.6
*   Merged Innovid's latest code containing important tracking fixes
*   Fix to the BrightLine code to address crashes on some devices still running 7.0 FW
*   Fix bug that caused lower ad fill rates for SmartXML responses that included erroneous or empty ad tags in a given ad pod
*   Fix construction of generic tracking events for SmartXML when quartile events are not specified

### Version 1.6 – 03/2016

*   Interactive ads on Server Stitched Ads
*   Support for DFP Waterfall
*   Customize Buffer Screens - static image only
*   Update LR tags to DFP tags
*   Innovid- Extender
*   New URL parameter macros: ROKU\_ADS\_LIMIT\_TRACKING, ROKU\_ADS\_APP\_VERSION, ROKU\_ADS\_LIB\_VERSION, ROKU\_ADS\_DEVICE\_MODEL
*   Loading message was not updating correctly for preroll/midroll/postroll ads
*   Pass the raw unchanged value in the ROKU\_ADS\_TRACKING\_ID macro
*   Macros were not expanded when held in the URL encoded section of the key/values
*   Pre-roll ad in 1080p HD TV didn’t display full screen
*   BrightScript log is displaying "ERROR: Runtime: FOR EACH value is "Invalid" when ad is playing fine

### Version 1.5 – 12/2015

*   Max URL transfer count bumped up from 40 to 300
*   If Nielsen impressions contained prior values for parameters that should not be substituted due to whitelisting or ad server blacklisting, remove those values from the URL
*   set maximum decode resolution on all rendered video ads to avoid memory issue due to buffering algorithm on lower end devices
*   Ensure that a properly-handled exit key exits the main video render loop
*   Add support for Freewheel "eventCallback"-style impression tracking
*   Issue with pressing "back" remote button on image canvas screen
*   Fixed VMAP Bug where ad breaks with the same offset were ignored
*   Ad Framework unable to parse response - Freewheel Promos
*   Fix edge case bug in URL regularization with path parameters
*   Fix "PodComplete" tracking sent when interactive ads are exited

### Version 1.4 – 10/2015

*   Ability for cross-promotion of apps/content
*   Ability to install an app from a video ad
*   Ability to follow content on an app from a video ad
*   Integration of BrightLine Interactive Ads
*   Integrate BrightLine Interactive ads to RAF
*   Updates to Innovid library (Use “Up” key instead of “\*" everywhere)
*   SmartXML parser changes
*   Support “slotImpression” beacon types
*   Enhanced Support for quartile tracking events in all scenarios
*   Additional attributes such as ad.Title, ad.CreativeId, ad.advertiser for VAST and FreeWheel ads
*   String Localization for core UI strings
*   SetContentLength API for Nielsen beacons
*   Midroll/postroll video playback issues on Roku TVs

Other inherited properties
==========================

In addition to inheriting a transform matrix from its parent, each node in the SceneGraph also inherits visibility and opacity information. (Opacity is the opposite of transparency: 75% opacity is the same as 25% transparency.) The visible field stores a Boolean value that provides a way to switch rendering of the node and all of its descendants on and off. The opacity field specifies an opacity value that is multiplied with the accumulated opacity of its parents to allow branches of the SceneGraph to fade in and out.

ifCECStatus
===========

Implemented by
--------------

| Name | Description |
| --- | --- |
| [roCECStatus](/docs/references/brightscript/components/rocecstatus.md "roCECStatus") | Identifies the active source status for set boxes. |

Supported methods
-----------------

### IsActiveSource() As Boolean

#### Description

Indicates whether the device is the active source.

#### Return Value

A flag indicating whether the device is the active source (true). If the device is not the active source, this flag is set to false.

TimeGrid
========

OTT providers can use the TimeGrid node to implement an Electronic Program Guide (EPG) in their apps. In an EPG, channels are represented as horizontal rows, one for each channel. Each row has an channel name on the left, and a set of programs airing on that app to the right. The size of each program depends on its duration. One of these programs has a remote control focus highlight indicator on it, and this highlight can be moved around using the remote control (as long as the TimeGrid node has remote control focus).

The TimeGrid node also features an alternative Now/Next view that lists only the programs currently airing and airing next, with their respective start times. See [Now/Next mode](/docs/references/scenegraph/list-and-grid-nodes/timegrid.md#nownext-mode) for more information.

![roku815px - time grid](https://image.roku.com/ZHZscHItMTc2/epg-standard.jpg "time grid")

Fields
------

### Content

The TimeGrid node has a **content** field that can be used to store the information for and programs displayed in the grid. This **content** field should have a single ContentNode that has one child ContentNode per app, and each app ContentNode should have one child ContentNode for each program, sorted by start time in ascending order (earliest programs first).

> For any program in any channel, the start time plus the duration of any program must be less than or equal to the start time of the next program.

#### App attributes

| Attribute | Type | Description |
| --- | --- | --- |
| TITLE | string | The name of this channel, to be visible only if HDSMALLICONURL is not set or if the icon failed to load. |
| HDSMALLICONURL | uri | The image file for the channel logo. |

#### Program attributes

| Attribute | Type | Description |
| --- | --- | --- |
| TITLE | string | Program title. |
| PLAYSTART | roDateTime | Start time for this program. |
| PLAYDURATION | roDateTime | Duration of this program. |
| HDSMALLICONURL | uri | The image file for an icon that appears beside the program title (optional). |

### General TimeGrid settings

The following fields are used to configure general time grid settings.

| Field | Type | Default | Description |
| --- | --- | --- | --- |
| maxDays | int | 7   | Specifies the total width of the time grid in days. |
| contentStartTime | roDateTime | 0   | The earliest time to which the time grid can be scrolled. The scrollable range of times is defined by the sum of the **contentStartTime** and **maxDays** fields. |
| duration | double | 9000 | Width (in seconds) of the visible section of the time grid.  <br>  <br>For example, setting this to 10800 will cause the time grid to display 3 hours of programs horizontally (10,800 = 3 hours \* 3,600 seconds per hour). |
| autoDismissTime | roDateTime | 0   | Specifies the time (in seconds) that the time grid will be displayed before automatically being hidden.  <br>  <br>Setting this field to 0 will cause the time grid to never be hidden. |
| ignoreTrickPlayKeys | boolean | FALSE | If set to true, ignores fast forward, rewind, and instant replay key events.  <br>  <br>Fast forward and rewind key presses normally page the time grid up and down. Instant replay key presses jump the grid to the current time. |
| overlayBitmapUri | uri | ""  | Specifies an overlay that is drawn on top of the entire time grid. This is used by default to make the bottom visible rows of the time grid appear to fade out, but could be used to add any overlay be drawn on top of the time grid. In most cases, this should be a 9-patch image that specifies expandable regions.  <br>  <br>Only set this field to specify a custom bitmap that differs in appearance from the default bitmap. The overlay bitmap is drawn over the full width of the time grid with its bottom aligned to the bottom of the time grid.  <br>  <br>If the **overlayHeight** field value is greater than 0 the image will be stretched to the specified height (that is from the bottom of the time grid to the specified height).  <br>  <br>If **overlayHeight** field value is set to 0 the bitmap will be drawn at its default height. |
| overlayHeight | float | 0   | Specifies the height of the overlay image (see the **overlayBitmapUri** field). If set to 0 the overlay image is drawn at its default height. |

### App settings

The following fields are used to configure and control app selection and focus.

| Field | Type | Default | Description |
| --- | --- | --- | --- |
| focusBitmapUri | uri | ""  | Specifies the bitmap file used for the focus indicator when the list has focus.  <br>  <br>In most cases, this should be a 9-patch image that specifies expandable regions. Only set this field to specify a custom bitmap that differs in appearance from the default bitmap. |
| animateToChannel | int | 0   | Write-only. Scrolls the grid so the row corresponding to the specified app index is on screen. When the scrolling ends, the program in that row at the current focus time will have focus. |
| jumpToChannel | int | 0   | Write-only. Jumps the grid so the row corresponding to the specified app index is on screen. After the jump, the program in that row at the current focus time will have focus. |
| jumpToTime | string | ""  | Write-only. Jumps the grid to the program at the specified time (in UTC format). After the jump, the time will be visible, and the program on the currently focused app will have focus. |
| leftEdgeTargetTime | roDateTime | none | When explicitly set, this triggers a horizontally scrolling animation so that the specified time is displayed at the left edge of the program grid.  <br>  <br>This field is also set by the firmware in response to remote control key presses that cause horizontal scrolling to provide feedback on the currently visible time range. |
| channelSelected | int | 0   | Read-only. Indicates the index of the selected app when the user makes a selection. |
| channelFocused | int | 0   | Read-only. Indicates the index of the focused app when a program in the app's row gains focus. |
| channelUnfocused | int | FALSE | Read-only. Indicates the index of the focused app when a program in the app's row loses focus. |

### Channel information column

The following fields are used to configure and control the channel information column on the left side of the EPG that lists the app names:

![roku815px - channel info column](https://image.roku.com/ZHZscHItMTc2/epg-channel-info.jpg "channel info column")

| Field | Type | Default | Description |
| --- | --- | --- | --- |
| channelInfoComponentName | roSGNode | Object | Uses the specified RSG component to display the data for each channel in the Channel Information column.  <br>  <br>An instance of this component is created on demand for each channel. The component must define a specific interface.  <br>  <br>Specifically, the **content** field of this component can be used to configure the data for the app information column (see [Specifying list and grid content](/docs/references/scenegraph/list-and-grid-nodes/overview.md#specifying-list-and-grid-content) for more information).  <br>  <br>Additionally, observer functions of the optional **width**, **height**, and **hasFocus** fields of the custom component can be used to customize the appearance (see [Custom item definitions and focus indicators](/docs/references/scenegraph/list-and-grid-nodes/overview.md#custom-item-definitions-and-focus-indicators) for more information).  <br>  <br>If this field is not specified, the default channel info will be displayed, which is an optional channel icon followed by a label containing the name of the app. The icon and label come from the app ContentNodes as described in the [Channel Attributes](/docs/references/scenegraph/list-and-grid-nodes/timegrid.md#fields) section. |
| channelInfoSelected | int | 0   | Read-only. Indicates the index of the selected app when the user selects an item in the Channel Information column. |
| channelInfoFocused | int | 0   | Read-only. Indicates the index of the app when an app in the Channel Information column gains focus. |
| channelInfoUnfocused | int | 0   | Read-only. Indicates the index of the app when an app in the Channel Information column loses focus. |
| channelInfoFocusable | boolean | false | Indicates whether the user can move focus into the Channel Information column. If this field is false, the Channel Info column in non-interactive. |
| jumpToChannelInfo | int | 0   | Write-only. Jumps the grid immediately to the app info column box of the specified channel index. The app row will be visible, and the app info box for the specified channel will have focus. If the **channelInfoFocusable** field is false, this field is ignored. |
| channelInfoWidth | float | system default | Width of the column showing the app names. |
| infoGridGap | float | 0   | Spacing between the Channel Information column and the main grid. |
| channelInfoColumnLabel | string | ""  | Specifies text used as a label for the header of the Channel Information column (the text displayed above the Channel Information column).  <br>  <br>If this is not specified, the label will show the day of the week that the left-hand edge of the time grid represents. |
| channelInfoTextColor | color | system default | Specifies the text color for the app names in the Channel Information column if the **channelInfoComponentName** field is not specified. |
| channelInfoFont | roFont | system default | Specifies the font for the app names if the **channelInfoComponentName** field is not specified. |
| channelInfoBackgroundBitmapUri | uri | ""  | Specifies the bitmap file to use as the background for the app names in the grid if the **channelInfoComponentName** field is not specified.  <br>  <br>In most cases, this should be a 9-patch image that specifies expandable regions. Only set this field to specify a custom bitmap that differs in appearance from the default bitmap. |
| channelInfoAlignment |     |     | "left" the channelInfo column is displayed on the left (default)  <br>"right" the channelInfo column on displayed on the right |

### Program grid

The following fields are used to configure and control the program titles and cells in the EPG:

![roku815px - program grid](https://image.roku.com/ZHZscHItMTc2/epg-program-grid.jpg "program grid")

| Field | Type | Default | Description |
| --- | --- | --- | --- |
| programTitleFocusedColor | color | system default | Specifies the text color for the program title that is focused. |
| programTitleColor | color | system default | Specifies the text color for program titles that are unfocused. |
| programTitleFont | roFont | system default | Specifies the font for the program titles |
| programSelected | int | 0   | Read-only. Indicates the index of the program in the currently focused channel row when the user selects a program. |
| programFocused | int | 0   | Read-only. Indicates the index of the program in the currently focused channel row when the program gains focus. |
| programUnfocused | int | 0   | Read-only. Indicates the index of the program in the currently focused channel row when the program loses focus. |
| programFocusedDetails | AssociativeArray |     | Read-only. Includes **focusChannelIndex** and **focusIndex** elements that indicate the app index and program index, respectively, when a program gains focus. This provides a single object that combines the values of the **channelFocused** and **programFocused** fields. |
| jumpToProgram | int | 0   | Write-only. Jumps the grid immediately to the program corresponding to the specified program index for the currently focused row. After jumping, the program will be visible and have focus. |
| programHorizMargin | float | 14  | Specifies the width of the left and right margins of program cell text. |
| programBackgroundBitmapUri | Uri | ""  | Specifies the bitmap file to use as the background for the program names in the grid.  <br>  <br>In most cases, this should be a 9-patch image that specifies expandable regions. Only set this field to specify a custom bitmap that differs in appearance from the default bitmap. |
| fillProgramGaps | boolean | false | Inserts a program with the "No Data Available" label if there is a gap between the program's start time and the previous program's end time |
| automaticLoadingDataFeedback | boolean | true | Enables the program data region of the grid to be automatically replaced with the loading message specified in the **loadingDataText** field whenever the content field has not been set or the user scrolls to a time where the content has not yet been loaded. |
| showLoadingDataFeedback | boolean | false | Replaces the program data region of the grid with the loading message specified in the **loadingDataText** field.  <br>  <br>This field enables you to explicitly control when the loading message is displayed instead of it being automatically shown when **automaticLoadingDataFeedback**is enabled.  <br>  <br>This field is ignored if **automaticLoadingDataFeedback**is true. |
| loadingDataText | string | " Loading Data…" " | The text to be displayed over the program grid whenever the loading message is to be shown. |
| channelNoDataText | string | "No Data Available" | Displays the specified text on each channel row if no data exists for a specific time (or if there is a gap in the program data). |

### Past Time Screen

The following fields are used to configure the appearance of the rectangle that is displayed as part of the background of all programs prior to the current time.

![roku815px - past time screen](https://image.roku.com/ZHZscHItMTc2/epg-past-time.jpg "past time screen")

| Field | Type | Default | Description |
| --- | --- | --- | --- |
| showPastTimeScreen | boolean | True | If true, enables drawing a solid color background behind all the programs in the grid airing before the current time. |
| pastTimeScreenBlendColor | color | 0xFFFFFFFF | Tints the past time screen by multiplying the color of each pixel by the specified value. If this value is not set to a value other than the default value, no color blending will be performed |
| pastTimeScreenBitmapUri | uri | ""  | Displays the specified bitmap file in the background of the past time screen. |

### Time Bar

The following fields are used to control and configure the time bar that is displayed horizontally above the program cells:

![roku815px - time bar](https://image.roku.com/ZHZscHItMTc2/epg-time-bar.jpg "time bar")

| Field | Type | Default | Description |
| --- | --- | --- | --- |
| timeBarHeight | float | 50  | Specifies the height of the region above the app grid where the time labels are displayed. |
| timeBarBitmapUri | uri | ""  | Specifies the bitmap file to use as the background of the time bar that appears above the time grid channel grid.  <br>  <br>In most cases, this should be a 9-patch image that specifies expandable regions. Only set this field to specify a custom bitmap that differs in appearance from the default bitmap. |
| timeLabelColor | color | 0xffffff99 | Specifies the text color for the time labels that are displayed in the time bar at the top of the TimeGrid. |
| timeLabelFont | font | system default | Specifies the font for the time labels that are displayed in the time bar at the top of the TimeGrid. |
| timeLabelOffset | float | 14  | Specifies the offset from the edge of the grid of the leftmost time label. |

### Now Bar

The following fields are used to enable the Now Bar, which is the thin vertical bar displayed at the current time.

![roku815px - Now Bar](https://image.roku.com/ZHZscHItMTc2/epg-now-bar.jpg "Now Bar")

| Field | Type | Default | Description |
| --- | --- | --- | --- |
| nowBarWidth | float | system default | Specifies the width of the Now Bar |
| nowBarHeight | float | system default | Specifies the height of the Now Bar |
| nowBarBitmapUri | uri | ""  | Specifies the bitmap file used for the Now Bar.  <br>  <br>In most cases, this should be a 9-patch image that specifies expandable regions. Only set this field to specify a custom bitmap that differs in appearance from the default bitmap. |
| nowBarBlendColor | color | system default | Tints the Now Bar by multiplying the color of each pixel by the specified value. If this value is not set to a value other than the default value, no color blending will be performed. |
| nowBarOffset | int | 0   | Specifies the number of pixels the left edge of the Now Bar is offset from the current time. |
| minimumNowBarOffset | roDateTime | 300 | Specifies (in seconds) the nearest that the Now Bar can be to the left-hand edge of the time grid. If the Now Bar advances to the **minimumNowBarOffset** field value plus 30 minutes the time grid will automatically scroll right 30 minutes. |

### Now/Next mode

When the TimeGrid is in Now/Next mode, the program grid only contains **Now** and **Next** columns listing the programs currently and subsequently airing on each channel, with their respective start times. The following fields are used to enable Now/Next mode, configure the Now and Next labels displayed above the program cells, and configure the program labels and cells while in this mode.

![roku815px - now-next-mode](https://image.roku.com/ZHZscHItMTc2/epg-now-next.jpg "now-next-mode")

| Field | Type | Default | Description |
| --- | --- | --- | --- |
| nowNextMode | boolean | False | When set to true, the time grid displays two vertical columns of programs showing Now and Next for each channel |
| nowBackgroundBitmapUri | Poster.uri | ""  | Displays the specified bitmap file in the background of the Now grid within the Now Bar |
| nextBackgroundBitmapUri | Poster.url | ""  | Displays the specified bitmap file in the background of the Next grid within the Now Bar |
| nowNextHideAmPm | boolean | False | Hides the AM/PM abbreviation next to the times in the Now Bar. |
| programNowNextTimeColor | color | 0xffffff99 | If Now/Next mode is true, specifies the text color for the time that appears in the now/next program cells when the program is unfocused |
| programNowNextTimeFocusedColor | color | 0x99 | If Now/Next mode is true, specifies the text color for the time that appears in the Now/Next program cells when the program is focused |
| programNowNextHorizMargin | float | 14  | Specifies the width of the left and right margins of program cell text in Now/Next mode. |
| programNowNextTimeTitleGap | float | 15  | Specifies the gap between the **Now** and **Next** entries |

Measuring EPG launch times
--------------------------

Apps with an EPG must fire signal beacons to measure the EPG launch time. Beacons must be fired when the user initiates a keypress to display the EPG (**EPGLaunchInitiate**) and when the EPG is fully rendered and navigable (**EPGLaunchComplete**). See [Measuring Channel Performance](/docs/developer-program/performance-guide/measuring-channel-performance.md) for more information.

Sample app
----------

You can download and install a [sample app](https://github.com/rokudev/SceneGraphDeveloperExtensions/tree/master/samples/TimeGridView) that demonstrates how to use the TimeGridView in the SceneGraph Developer Extensions (SGDEX) to create an EPG. This sample app uses a row-by-row loading model. In this model, a handler config running on the root node of a content tree creates a child node for each row in the EPG. Each of the row child nodes has a handler that creates a child node for each program that should be displayed on that row.

roHMAC
======

The HMAC component provides an interface to the OpenSSL HMAC functions. These functions generate a Message Authentication Code (MAC) based on a key, in such a way that no one without the key could plausibly generate the MAC. HMAC uses a digest (hash) algorithm to generate the MAC.

> For additional information on the OpenSSL HMAC functions, please see: [http://www.openssl.org/docs/crypto/hmac.html](http://www.openssl.org/docs/crypto/hmac.html)

**Supported Digest Algorithms**

The supported digest algorithms are the same as those supported by [roEVPDigest](/docs/references/brightscript/components/roevpdigest.md "roEVPDigest").

**Example**

    hmac = CreateObject("roHMAC")
    signature_key = CreateObject("roByteArray")
    signature_key.fromAsciiString(getKey())
    If hmac.setup("sha1", signature_key) = 0
        message = CreateObject("roByteArray")
        message.fromAsciiString(getMessage())
        result = hmac.process(message)
        print result.toBase64String()
    End If
    
    
    hmac = CreateObject("roHMAC")
    signature_key = CreateObject("roByteArray")
    signature_key.fromAsciiString(getKey())
    If hmac.setup("sha1", signature_key) = 0
        message1 = CreateObject("roByteArray")
        message1.fromAsciiString(getMessage1())
        hmac.update(message1)
        message2 = CreateObject("roByteArray")
        message2.fromAsciiString(getMessage2())
        hmac.update(message2)
        result = hmac.final()
        print result.toBase64String()
    End If
    

Supported interfaces
--------------------

*   [ifHMAC](/docs/references/brightscript/interfaces/ifhmac.md "ifHMAC")

SceneGraph data scoping
=======================

SceneGraph applications have data object scoping rules that are similar to traditional programming languages. You have:

*   _function scope_: objects that can only be accessed within the function in which they were defined
*   _component scope_: objects that can be accessed anywhere within a component XML file, similar to _file scope_ in traditional programming languages
*   _global scope_: objects that can be accessed anywhere within a SceneGraph application

These different levels of scoping are identified by the use of the `m` object reference which can be used to disambiguate and access objects at different levels, similar to the use of `m` in BrightScript.

* * *

Function scope
--------------

For creating objects with function scope, do not use the `m` object reference. For example, the following creates and defines several fields for a `dialog` object that can only be accessed within the function in which it is created and defined:

    dialog = createObject("RoSGNode","Dialog")  
    dialog.backgroundUri = "pkg:/images/sgetdialogbg.9.png"  
    dialog.title = "Example Dialog" 
    dialog.optionsDialog = true  
    dialog.message = "Press * To Dismiss"
    

Component scope
---------------

For creating objects with component scope, use the `m` object reference to identify objects that can be accessed anywhere within a component XML file. For example, if you wanted to create the same `dialog` object above in one function, but define it, or otherwise access it, in another function in the same component XML file:

    sub createdialog()  
    
        m.dialog = createObject("RoSGNode","Dialog")  
    
    end sub
    
    sub definedialog()
    
        m.dialog.backgroundUri = "pkg:/images/sgetdialogbg.9.png"  
    
        m.dialog.title = "ExampleDialog"  
    
        m.dialog.optionsDialog = true   
    
        m.dialog.message = "Press * To Dismiss" end sub
    

m.top component scope reference
-------------------------------

There is a special use of the `m` object reference in SceneGraph for identifying the _top_ of the SceneGraph tree for a component XML file. To do this, use the `m.top` object reference, which refers to the component itself. For example, to create the `dialog` object and assign it to the `dialog` field of a Scene node defined in a component XML file (which is the required usage of the Dialog node class), assign the `dialog` object to the `dialog` field using the `m.top` object reference:

    dialog = createObject("RoSGNode","Dialog")  
    
    dialog.backgroundUri = "pkg:/images/sgetdialogbg.9.png"  
    
    dialog.title = "Example Dialog" 
    
    dialog.optionsDialog = true  
    
    dialog.message = "Press * To Dismiss"
    
    m.top.dialog = dialog`
    

Likewise, if you want to use `findNode()` to find a SceneGraph node object anywhere in the SceneGraph tree for a component XML file, use the `m.top` reference to start at the top of the tree:

    m.categorieslist = m.top.findNode("categorieslist")
    

Global scope
------------

**Rules**

*   To declare a **data object** at **global scope**, store it in a field or child of the global node. This global node may be accessed from the entire SceneGraph application.
*   To access the **global node** in **components**, use the predefined `m.global`, much like `m.top`.
*   For access to the **global node** from **non-component** **script** as in `source/main.brs`, use **`getGlobalNode()`** called on the **`roSGScreen`** object.
*   In **non-component script**, where the global node is obtained using **`getGlobalNode()`**, you can store it in **`m.global`** so that the syntax for subsequent references to it matches that for components.

For example:

    screen = CreateObject("roSGScreen") 
    
    m.port = CreateObject("roMessagePort")  
    
    screen.setMessagePort(m.port) 
    
    m.global = screen.getGlobalNode()  
    
    m.global.id = "GlobalNode"
    

As noted, this is not necessary in component script, as `m.global` is predefined.

You can access and set the fields, or the children nodes, of the global node from anywhere in the SceneGraph application. In the non-component example above, the global node **`id`field** value is set to **`Global node`**. Likewise, you can access and set the fields for the global node from components by accessing the component **`m`** to get its special global element:

> Note that you cannot edit elements within [associative arrays](/docs/references/brightscript/components/roassociativearray.md).

You will need to take the associative array, modify it and save it back into the field.

    m.global.addFields( {red: &hff0000ff, green: &h00ff00ff, blue: &h0000ffff} ) 
    ... 
    
    m.rect = m.top.findNode("Rect1") 
    m.rect.color = m.global.red
    ... 
    
    color = m.rect.color  
    
    if m.rect.color = m.global.red  
      m.rect.color = m.global.green 
    
    else if m.rect.color = m.global.green 
      m.rect.color = m.global.blue 
    
    else 
      m.rect.color = m.global.red  
    
    end if

roEVPCipher
===========

The EVP Cipher component provides an interface to the OpenSSL EVP library of symmetric cipher commands. The EVP library provides a high-level interface to cryptographic functions to implement digital "envelopes".

These commands allow data to be encrypted or decrypted using various block and stream ciphers using keys based on passwords or explicitly provided.

Some of the ciphers do not have large keys and others have security implications if not used correctly. A beginner is advised to just use a strong block cipher in CBC mode such as bf or des3. All the block ciphers normally use PKCS#5 padding also known as standard block padding. If padding is disabled then the input data must be a multiple of the cipher block length.

> For additional information on the OpenSSL library of symmetric ciphers see: [https://www.openssl.org/docs/manmaster/man1/enc.html](https://www.openssl.org/docs/manmaster/man1/enc.html).

**List of supported ciphers**

| Name | Cipher | Key size (bits) | Block size (bits) |
| --- | --- | --- | --- |
| bf-cbc | Blowfish in CBC mode | 128 | 64  |
| bf  | Alias for bf-cbc | 128 | 64  |
| bf-cfb | Blowfish in CFB mode | 128 | 64  |
| bf-ecb | Blowfish in ECB mode | 128 | 64  |
| bf-ofb | Blowfish in OFB mode | 128 | 64  |
| des-cbc | DES in CBC mode | 56  | 64  |
| des | Alias for des-cbc | 56  | 64  |
| des-cfb | DES in CBC mode | 56  | 64  |
| des-ecb | DES in ECB mode | 56  | 64  |
| des-ofb | DES in OFB mode | 56  | 64  |
| des-ede-cbc | Two key triple DES EDE in CBC mode | 80  | 64  |
| des-ede | Two key triple DES EDE in ECB mode | 80  | 64  |
| des-ede-cfb | Two key triple DES EDE in CFB mode | 80  | 64  |
| des-ede-ofb | Two key triple DES EDE in OFB mode | 80  | 64  |
| des-ede3-cbc | Three key triple DES EDE in CBC mode | 112 | 64  |
| des-ede3 | Three key triple DES EDE in ECB mode | 112 | 64  |
| des3 | Alias for des-ede3-cbc | 112 | 64  |
| des-ede3-cfb | Three key triple DES EDE in CFB mode | 112 | 64  |
| des-ede3-ofb | Three key triple DES EDE in OFB mode | 112 | 64  |
| desx | DESX algorithm | approx. 119 | 64  |
| desx-cbc | DESX in CBC mode | approx. 119 | 64  |
| aes-\[128/192/256\]-cbc | 128/192/256 bit AES in CBC mode | 128,192,256 | 128 |
| aes-\[128/192/256\] | Alias for aes-\[128/192/256\]-cbc | 128,192,256 | 128 |
| aes-\[128/192/256\]-cfb | 128/192/256 bit AES in 128 bit CFB mode | 128,192,256 | 128 |
| aes-\[128/192/256\]-cfb1 | 128/192/256 bit AES in 1 bit CFB mode | 128,192,256 | 128 |
| aes-\[128/192/256\]-cfb8 | 128/192/256 bit AES in 8 bit CFB mode | 128,192,256 | 128 |
| aes-\[128/192/256\]-ecb | 128/192/256 bit AES in ECB mode | 128,192,256 | 128 |
| aes-\[128/192/256\]-ofb | 128/192/256 bit AES in OFB mode | 128,192,256 | 128 |

Supported interfaces
--------------------

*   [ifEVPCipher](/docs/references/brightscript/interfaces/ifevpcipher.md "ifEVPCipher")

Controlling screen program flow
===============================

SceneGraph applications can control the flow of screen elements in the following ways:

*   by responding to user remote control key press events
*   by responding to changes in data, including data that configures the screen elements
*   by changing the z-order of screen elements
*   by changing the parent-child relationships of screen elements
*   by creating and deleting screen elements
*   by making screen elements invisible and making other screen elements visible
*   by placing remote control focus on screen elements that may be currently off the screen or otherwise not visible

Many of the more complex SceneGraph node classes are designed to automatically respond to remote control key press events, and configure themselves in response to data changes.

Structuring your application and screen element components
----------------------------------------------------------

The SceneGraph API was designed to create components that encapsulate the appearance, behavior, and data of custom screen elements. These custom components can then be used in a Scene node program flow that creates the custom components as needed, in response to user selections, or changes in data received from and/or sent to a server. These custom components are analogous to BrightScript components with data interfaces that render screens and screen elements, such as roPosterScreen; in fact, the SceneGraph [PosterGrid](/docs/references/scenegraph/list-and-grid-nodes/postergrid.md) node class is itself very similar to the BrightScript component roPosterScreen. But by using the SceneGraph API, you can combine several node classes into a custom component with its own encapsulated behavior in response to user input and data received from your server.

As an example, for typical VOD applications, the following should drive the development of your custom SceneGraph components, and the program flow in the Scene node that displays these components as needed:

*   your current video content catalog database
*   the data requirements of allowing users to rent or purchase video items
*   the visual elements you choose to allow users to select video items

Creating custom components
--------------------------

To continue with a VOD application example, a typical VOD application will first offer a set of video content categories for user selection, such as "New Releases", "Drama", "Comedy", and so forth. This should drive the development of a SceneGraph custom component that displays these categories, which will read the data from your server that you make available to the component to display the categories, including icons, text, graphic images, in either JSON or XML format. The data provided for that component should also include data to pass to another custom component, through the [<interface>](/docs/references/scenegraph/xml-elements/interface.md) element or other means, to allow user selection of further sub-categories or video content items. All of the previous BrightScript component "screens", including "screens" for registration, search, license display, can be developed as encapsulated SceneGraph components, which can (and typically will and should) include their own components developed to provide specific appearance and functionality to several major components in your application.

The deciding factor to develop a custom component is whether it serves a discrete user interface purpose to display certain types of data to the user, and react to user selections and input related to the data. Again, as an example, the first component you might typically develop for a VOD application would be the first menu of video categories. As a user interface design choice, you may have decided to use a vertical list of text strings ("New Releases", "Drama", and so forth), each with a small icon representing each category to the left, and a larger poster graphic image to the right of an example video chosen at random to represent the category (for example, a poster image for the movie **Argo** for the "Drama" category). On your server, you must make available a JSON or XML file containing the necessary data and links to data and graphic images that you have written from your content catalog database to support the data needs of the component. The component itself will consist of the ability to access the required data, and the selected node classes and component behavior to display the data according your user interface design for that screen element.

This is how you might want the list to appear and behave, with the category poster appearing along with a red underline cursor under the focused item:

![roku815px - markuplistdesign](https://image.roku.com/ZHZscHItMTc2/markuplistdesign.jpg "markuplistdesign")

For the VOD category list example, the first step might be to write a SceneGraph component outline similar to the following:

    <component name = "VODCategoriesList" extends = "MarkupList">
    
    </component>
    

You can then select the nodes to comprise your custom component from the SceneGraph API node classes, to either create or modify them using BrightScript in the <script> element, and/or declare/define them in XML markup in the <children> element. For example, for a list of categories, you might want to use the [LabelList](/docs/references/scenegraph/list-and-grid-nodes/labellist.md) node class, or perhaps the [MarkupList](/docs/references/scenegraph/list-and-grid-nodes/markuplist.md) node class, since you intend to include graphic images as part of your list. You will also use two [Poster](/docs/references/scenegraph/renderable-nodes/poster.md) node classes somewhere in your component for your icon and poster graphic images, perhaps as part of another custom component that is the definition of the `itemComponentName` field of the MarkupList node. You complete the component by adding <interface> element fields as needed to get and set data that is either needed for the component, or passed to other components and/or the Scene node BrightScript program flow.

For the example VOD categories list, we should use a MarkupList node, because we want to use custom graphic images as part of each list item. So we need to start work on a custom item component for the MarkupList node `itemComponentName` field. This custom item component is where we will define the individual sub-elements that make up this screen element component, their SceneGraph node type and position, size, and other attributes, and how they will appear as focus moves from item to item. So we start with the following outline:

**MarkupList item component outline**

    <component name = "VODCategoriesListItem" extends = "Group" >
    
      <interface>
        <field id = "itemContent" type = "node" onChange = "showcontent" />
        <field id = "focusPercent" type = "float" onChange = "showfocus" />
      </interface>
    
      <script type="text/brightscript" >
    
        <![CDATA[
        sub init()
          m.itemicon = m.top.findNode("itemicon")
          m.itemlabel = m.top.findNode("itemLabel")
          m.itemcursor = m.top.findNode("itemcursor")
          m.itemposter = m.top.findNode("itemPoster")
        end sub
    
        sub showcontent()
          itemcontent = m.top.itemContent
          m.itemicon.uri = itemcontent.url
          m.itemlabel.text = itemcontent.title
          m.itemposter.uri = itemcontent.HDPosterUrl
        end sub
        ]]>
    
      </script>
    
      <children>
    
        <Group>
    
          <Poster
            id = "itemicon" />
          <Label
            id = "itemLabel" />
          <Rectangle
            id = "itemcursor" />
          <Poster
            id = "itemPoster" />
    
        </Group>
    
      </children>
    
    </component>
    

The outline includes the Poster nodes we will use for graphic images, a Label node for the item string, and a Rectangle node we will use as a cursor to indicate focus on the item. It also includes the <interface> `itemContent` field to set the Poster node URIs, and the text string for the Label node, with the `showcontent()` function in the <script> element setting the required fields for those nodes when the MarkupList node creates each instance of the item component.

To complete this component, you would need to specify the local coordinate locations of each of the renderable <children> nodes according to the design of the user interface, and any other behavior you want for each list item, such as when it becomes focused and/or unfocused. For this design, we want only the text of each item and the corresponding icon to be visible when the item is unfocused, and make the cursor appear below the item, and the corresponding poster appear to the right, when the item is focused. So, for example, we set the `itemPoster` sub-element in position in the item definition with an initial `opacity` field setting of 0.0 to make it invisible until focused:

    <Poster   
      id = "itemPoster"    
      width = "98"   
      height = "140
      opacity = "0.0"  
      translation = "[ 192, 4 ]"  />
    

Then we can write the <script> element callback function `showfocus()` to indicate focus when the `focusPercent` <interface> field changes:

    sub showfocus()  
      m.itemcursor.opacity = m.top.focusPercent    
      m.itemposter.opacity = m.top.focusPercent   
    end sub
    

Then you assign your item component to the `itemComponentName` field for your MarkupList node component, as part of completely defining your custom category list:

**MarkupList custom component outline**

    <component name = "VODCategoriesList" extends = "MarkupList" >
      <script type="text/brightscript" >
        <![CDATA[
    
        sub init()
          m.top.itemComponentName = "VODCategoriesListItem"
          m.top.itemSize = [ 294, 148 ]
          m.top.itemSpacing = [ 0, 10 ]
          m.top.drawFocusFeedback = false
          m.top.vertFocusAnimationStyle = "floatingFocus"
        end sub
    
        ]]>
      </script>
    
    </component>
    

[MarkupList](https://github.com/rokudev/samples/tree/master/ux%20components/lists%20and%20grids/MarkupListExample) is an example application of the completed custom list configuration. In the example application, note that the file `markuplistcontent.xml` is the ContentNode component that supplies the data to populate the list; normally this data would be in a XML/JSON file that would be downloaded from your server to the application and converted to a ContentNode using a Task node (or equivalent). Also note that the icon and poster files are included in the package `images` directory, rather than your server, and the `markuplistscene.xml` is only provided to allow the example to run as a standalone application.

Once you have developed the custom components, you can write a program flow in the Scene node to create/remove, make visible/invisible, and set the remote control key focus on the custom components as needed.

Custom component program flow examples
--------------------------------------

For an example application that uses three custom components, and creates and sets focus on the custom components as needed in reaction to user input in an OverhangPanelSetScene node, see [Sliding panels example](https://github.com/rokudev/samples/tree/master/ux%20components/sliding%20panels/OverhangPanelSetSceneExample).

There are two more examples that allow users to select and play videos from a custom RowList node:

*   [Simple\_Grid\_and\_Video](https://github.com/rokudev/samples/blob/master/ux%20components/lists%20and%20grids/Simple_Grid_and_Video)
*   [Simple\_Grid\_with\_Details\_and\_Video](https://github.com/rokudev/samples/blob/master/ux%20components/lists%20and%20grids/Simple_Grid_with_Details_and_Video)

These examples download and convert a MRSS XML feed containing all the data for the application to a ContentNode field added to the Scene node <interface> element. In this case, the data for the application is downloaded and converted in the `source/main.brs` file after the application Scene node is created but before it is shown, rather than using a Task node in the actual SceneGraph application.

MonospaceLabel
==============

_Available since Roku OS 14.0_

The **MonospaceLabel** node is used to draw a single line of text with all characters spaced at a fixed distance from each other. It transforms proportional fonts into monospaced fonts. It is a substitute for using a monospace font with the **Label** node.

**Fields**

| **Field** | **Type** | **Default** | **Access Permission** | **Description** |
| --- | --- | --- | --- | --- |
| text | string |     | READ\_WRITE | Specifies the text to be displayed |
| color | color | 0xddddddff | READ\_WRITE | Specifies the text color |
| font | Font | system default | READ\_WRITE | Specifies the Font node to be used |
| horizAlign | string | left | READ\_WRITE | See [Horizontal Alignment](/docs/references/scenegraph/typographic-nodes/scrollinglabel.md#alignment) |
| vertAlign | string | top | READ\_WRITE | See [Vertical Alignment](/docs/references/scenegraph/label-nodes/label-base.md#wrapping-text) |
| width | float | 0   | READ\_WRITE | Specifies the width of the label. If set to zero, the width of the label will be set automatically |
| height | float | 0   | READ\_WRITE | Specifies the height of the label. If set to zero, the height of the label will be set automatically |
| characterWidth | float | 0   | READ\_WRITE | Specifies the width of the label characters. If set to zero, width of font’s character 'M' will be used |
| ellipsizeOnBoundary | Boolean | false | READ\_WRITE | If the width field value is greater than zero, controls whether or not the last line of text displayed should be ellipsized if it extends beyond the specified width. It is ignored if the truncateOnDelimiter field value is set to a non-empty stringWhen set to true, text will be ellipsized by whole words. Example: "This is the last line of..."When set to false, text will be ellipsized by characters. Example: "This is the last line of tex..." |
| firstCharTrueLeftAlign | Boolean | false | READ\_WRITE | Forces the first character to left align completely instead of rendering centered in the character box. Subsequent characters are centered in their character box. If enabled monospace text strings with different first characters will shift around. This is primarily used for single characters strings |
| wordBreakChars | string |     | READ\_WRITE | By default, space and hyphen characters are used to determine where lines can be divided. In addition, this field can specify additional characters to be used to determine where the text can be broken into lines |
| isTextEllipsized | Boolean | false | READ | Tells whether or not currently displayed text is clipped. |

Ideal app features
==================

While attraction and retention of users primarily depends on the app content, the ability for the user to easily interact with your app creates a delightful association with the app and keeps the user coming back. Easy interactions go beyond the design of the UI and into features and capabilities. Below is a list of capabilities that users expect and features that will enhance the value of your app.

Finding content
---------------

*   **Browse**
    
    *   There are many different ways to organize and present your content. The key is to understand your audience and how they think about your content and how they would want to access it.
    *   Your app can offer a mix of organizational schemes. For example, one or more of the time sensitive and personal schemes, plus one consistent and predictable scheme as a fallback:
        
        *   Time based (Updated frequently):
            
            *   Showcase or featured (E.g., Curated topics or content, but it must be updated frequently)
            *   Time oriented (E.g., New releases, latest episodes, new this week, etc.)
            *   Popular or trending (E.g., Algorithm based content)
        *   Personal (Updated based on usage):
            
            *   Recommended
            *   Recently watched
            *   Watchlist
        *   Consistent and predictable (Updated based on library changes):
            
            *   Logical or categorical (E.g., Genres)
            *   Alphabetical (However, categorical browsing may be better/faster for large libraries)
*   **Search**
    
    *   If your content library exceeds 200 items, then your app should offer users the ability to search for content.
    *   Note, on-screen keyboards are tedious to use and so to help make it easier, we recommend:
        
        *   QWERTY key layout which is great for physical keyboards when touch-typing is possible. For on-screen keyboards, an alphabetic arrangement is preferred.
        *   Provide search results for every character typed in. So, to minimize typing, users can type until the result they're looking for appears. This implies that your app must return results very quickly.
    *   Be forgiving with the input search terms:
        
        *   Don't force users to key in "The" (E.g., "Walking Dead" should work as well as "The Walking Dead")
        *   Capitalization is not necessary
        *   Allow users to input any word or part of a phrase in any order (i.e., Don't require the phrase to be input in order - the first word first, etc.)
    *   Mixed search results (E.g., Combining movies and TV shows) are fine so long as you provide cues for users to tell items apart.

Pivoting
--------

*   Once users have found a piece of content or finished watching it, make it easier for them to pivot to and find similar or related content.
    
    *   For example, from the details page of a specific:
        
        *   TV episode, make it easy for users to get to all episodes and seasons
        *   Piece of content, make it easy for users to get to similar content (i.e., "more like this")
        *   Piece of mainstream content, make it easy for users to see the cast and crew and pivot to a specific cast member's filmography
*   Pivoting is a great way to keep users engaged with a topic in which they've already expressed interest.

Content bookmarking
-------------------

*   When users find content of interest, provide an easy and fast way for them to find it again.
    
    *   Common features that accomplish this include:
        
        *   Adding an item to a 'watch list'; for episodic content, make it easy to add the TV series, not just a specific episode
        *   A list of 'recently watched' items
        *   'Watch next' is great for episodic content (See below)
        *   'Resume watching' is great for unfinished content (See below). However, in order for 'resume watching' to work effectively, 'watch list' and/or 'recently watched' need to be offered as well.

Resuming video playback
-----------------------

*   Users may start a video and then stop it before finishing it. The app must make it easy for users to easily and quickly:
    
    *   Find this recently watched video again
    *   Resume playback from where they left off
    *   Restart playback from the beginning of the video (Without having to rewind)
*   Since Roku users tend to own more than one Roku player/TV, it is important that the information needed to support this capability be server-based so that it can be accessed and used regardless of the playback device being used.
*   When resuming playback, be sure to actually start the video a few seconds back from the actual resume point (E.g., 3-5 seconds back). This will help users identify a familiar scene and acknowledge that the system is truly picking up where they left off.

Playing the next logical item
-----------------------------

*   For any episodic content or playlist scenario, once the current video finishes, the system should make it super easy to watch the next episode or item in the playlist.
*   Many apps are seeing an increase in viewing hours and general app stickiness when providing this sort of functionality.
*   This is usually done in one of two ways:
    
    *   Auto-play
        
        *   Playlist scenarios: The app automatically begins playback of the next item in the playlist. In such cases, be sure the next video is introduced (E.g., Buffering or loading screen shows video title).
        *   Episodic content scenarios: The app provides information about the next episode to be played and a countdown timer. Users can exit back into the app's main UI, or press OK to accept and start playback of the next episode, or do nothing and let the timer expire so playback starts automatically.
    *   Play next
        
        *   Content finishes playing and users are returned to the UI and offered an easy way to play the next item.
            
            *   For example, users are returned to that content's details page which offers a simple option to play or go to the next episode, or go to the full list of episodes.
*   If your app offers episodic content, then it must show users which episodes have been watched already.
    
    *   Typical solution involves showing a progress bar with each episode.
    *   Users can see if they have watched an episode completely, partially, or not at all.
    *   This is an easy manual way for users to see which episode to watch next.

BIFs/Trick mode
---------------

*   When users are rewinding, fast-forwarding, or generally trying to move within a video playback, they are effectively doing a search to find that right point to resume watching.
    
*   Rewinding or fast-forwarding blindly with only a time marker is no longer an adequate solution. Instead, the experience can be more effective and satisfying as a 'visual search.'
    
*   To that end, all video navigation must be visual so users can actually see/preview the video they are navigating:
    
    *   [Enable video scrubbing](/docs/developer-program/media-playback/trick-mode.md)
        
    *   Show [BIFs](/docs/developer-program/media-playback/trick-mode.md#bif-file-creation-using-the-roku-bif-tool) or key-frames
        
        ![roku815px - trickmode](https://image.roku.com/ZHZscHItMTc2/trickmode.png "trickmode")
        

Instant replay
--------------

*   The ability to press a single button and have the system automatically skip back about 5-10 seconds and resume playback is a very convenient and loved feature.
*   Additionally, most use this feature because they did not hear a piece of dialog. Roku's closed-captioning's default setting is to show on instant replay. Activating instant replay enables the user to see/read what they may have not heard.

Simplified transactions
-----------------------

*   Requiring users to supply credit card information during your app's set up may cause some users to drop-out.
*   Waiting and asking users to supply credit card information right before a transaction (E.g., Movie rental) is a hurdle many are not willing to jump.
*   Obviously, you would be creating speed-bumps with either route, but there is a more simple and pain-free route for your audience; Roku Pay makes it as easy as one-click to set up an account, maximizing the number of users signing up and transacting.

ifVideoPlayer
=============

Implemented by
--------------

| Name | Description |
| --- | --- |
| [roVideoPlayer](/docs/references/brightscript/components/rovideoplayer.md "roVideoPlayer") | The roVideoPlayer component implements a video player with more programmatic control, but less user control than the roVideoScreen component |

Supported methods
-----------------

### SetContentList(contentList as Object) as Void

#### Description

Sets the content to be played by the roVideoPlayer.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| contentList | Object | An [roArray](/docs/references/brightscript/components/roarray.md "roArray") of [roAssociativeArray](/docs/references/brightscript/components/roassociativearray.md "roAssociativeArray") ([Content Meta-Data](/docs/developer-program/getting-started/architecture/content-metadata.md " Content Meta-Data") objects) representing the information for each stream to be played.  <br>  <br>If the player is currently playing the player will be stopped. Next, the current player position is reset so the next time Play() is called, playback will start at the first item of the content list (unless Seek() is called prior to Play()).  <br>  <br>roVideoPlayer prefetches the next item in the content list while the current item is playing. Given sufficient network throughput, there is no rebuffering when the player switches to the next item in the list. To signal the content transition, the player sends an isRequestSucceeded notification with the old content index and isListItemSelected notification with the new content index. |

### AddContent(contentItem as Object) as Void

#### Description

Adds a new [Content Meta-Data](/docs/developer-program/getting-started/architecture/content-metadata.md " Content Meta-Data") item to the end of the content list for the roVideoPlayer. roVideoPlayer playback buffers on each Content item transition.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| contentItem | Object | The [content metadata](/docs/developer-program/getting-started/architecture/content-metadata.md " Content Meta-Data") item to be added to the content list. |

### ClearContent() as Void

#### Description

Clears all content from the roVideoPlayer. If the player is currently playing, it stops. Next, the current player position is reset so the next time the [Play()](#play-as-boolean) method is called, playback starts at the first item of the content list (unless the [Seek()](#seekoffsetms-as-integer-as-boolean) method is called prior to Play()).

### PreBuffer() as Boolean

#### Description

Begins downloading and buffering of a video that may be selected by a user. This method can be used to reduce buffering delays after a user has selected a video for playback. It is typically called when the user is in the roSpringboardScreen (or equivalent), anticipating that the user will select a video on the springboard screen for download.

#### Return Value

A flag indicating whether the operation was successful.

### Play() as Boolean

#### Description

Puts the roVideoPlayer object into play mode starting at the beginning of the content list. This will stop any currently playing Content List.

If the [Seek()](#seekoffsetms-as-integer-as-boolean) method was called prior to this method, the player will start playing at the seek position. If Seek() was not called, the player advances its current position to the next item in the content list and starts playing that item.

#### Return Value

A flag indicating whether the operation was successful.

### Stop() as Boolean

#### Description

Stops playback and resets the seek position; keeps the player’s current position unchanged.

#### Return Value

A flag indicating whether the operation was successful.

### Pause() as Boolean

#### Description

Puts the roVideoPlayer object into pause mode. If the player is already in pause mode, this will generate an error.

#### Return Value

A flag indicating whether the operation was successful.

### Resume() as Boolean

#### Description

Puts the roVideoPlayer object into play mode starting from the pause point. This method must be called when the roVideoPlayer object is in pause mode; otherwise, it will generate an error.

#### Return Value

A flag indicating whether the operation was successful.

### SetLoop(loop as Boolean) as Void

#### Description

Automatically replays the content list. This method buffers on every loop to the beginning of the content list.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| loop | Boolean | Enables the automatic replaying of the content list. |

### SetNext(item as Integer) as Void

#### Description

Sets the next item in the Content List to be played.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| item | Integer | The unique ID of the content item to be played next. |

### setEnableAudio(enable as Boolean) as Void

#### Description

Mutes the audio during video playback. This is useful, for example, for implementing a video preview feature in an app.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| enable | Boolean | Mutes the audio during video playback. |

### Seek(offsetMs as Integer) as Boolean

#### Description

Sets the start point of playback for the current video to a specific offset.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| offsetMs | Integer | The number of milliseconds to offset the playback of the current content item. |

### SetPositionNotificationPeriod(period as Integer) as Void

#### Description

Sets the interval to receive playback position events from the roVideoPlayer.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| period | Integer | The notification period for receiving playback position events in seconds. Notification events sent to the script specify the position in seconds relative to the beginning of the stream. If the value is 0, position notifications are never sent. The default value is 0. |

### SetCGMS(level as Integer) as Void

#### Description

Sets CGMS (Copy Guard Management System) on analog outputs to the desired level.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| level | Integer | The level to which CGMS is set. This may be one of the following values:<br><br>*   0 - No Copy Restriction<br>*   1 - Copy No More<br>*   2 - Copy Once Allowed<br>*   3 – No Copying Permitted |

### SetDestinationRect(rect as Object) as Void

#### Description

Sets the target display window for the video.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| rect | Object | The parameters of the target display window, which include the x and y coordinates, width, and height {x:Integer, y:Integer, w:Integer, h:Integer}  <br>  <br>The default value is: {x:0, y:0, w:0, h:0}, which is full screen. |

### SetDestinationRect(x as Integer, y as Integer, w as Integer, h as Integer) as Void

#### Description

Sets the target display window for the video. This is similar to the [SetDestinationRect()](#setdestinationrectrect-as-object-as-void) function except that the values are specified as separate parameters.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| x   | Integer | The x coordinate of the target display window. |
| y   | Integer | The y coordinate of the target display window. |
| w   | Integer | The width of the target display window. |
| h   | Integer | The height coordinate of the target display window. |

### SetMaxVideoDecodeResolution(width as Integer, height as Integer) as Void

#### Description

Sets the max resolution required by your video.

Video decode memory is a shared resource with OpenGL texture memory. The BrightScript 2D APIs are implemented using OpenGL texture memory on Roku models that support the OpenGL APIs (please see [Roku Models and Features](/docs/specs/hardware.md#current-models "Roku Models and Features") for a list of these models). For models that do not support OpenGL APIs, this method exists for API compatibility but has no effect on actual memory allocations.

Video decode memory allocation is based on a resolution of 1920x1080 or 1280x720 as the maximum supported resolution for a particular Roku model (please see [Roku Models and Features](/docs/specs/hardware.md#current-models "Roku Models and Features") for a list of these models).

This API enables applications that want to use both the 2D APIs and video playback with a lower resolution than 1080p. Without this call, these applications are likely to not have enough memory for either video playback or roScreen rendering.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| width | Integer | The maximum height required by your video. |
| height | Integer | The maximum width required by your video. |

### GetPlaybackDuration() as Integer

#### Description

Returns the duration of the video, in seconds. This information may not be available until after the video starts playing.

#### Return Value

The duration of the video. A value of 0 is returned if the duration is unknown.

### GetAudioTracks() as Object

#### Description

Returns the audio tracks contained in the current stream.

#### Return Value

An roArray, where each element in the array represents a single audio track that contains the following attributes: ${getaudiotracksvalues}

AttributeTypeDescriptionLanguageStringLanguage code ("eng" for English, etc.)TrackStringAudio track identifierNameStringTrack nameFormatStringContains the format of the currently playing video stream.  
  

| Value | Meaning |
| --- | --- |
| ""  | No stream playing |
| none | Stream contains no playable video |
| unknown | Stream contains unknown video |
| hevc | ISO/IEC 23008-2, H.265, HEVC |
| hevc\_b | ISO/IEC 23008-2 Annex-B, H.265, HEVC |
| mpeg1 | ISO/IEC 11172-2, MPEG-1 part 2, H.261 |
| mpeg2 | ISO/IEC 13818-2, MPEG-2 part 2, H.262 |
| mpeg4\_2 | ISO/IEC 14496-2, MPEG-4 part 2, H.263 |
| mpeg4\_10b | ISO/IEC 14496-10, MPEG-4 part 10 Annex-B, H.264, vc-1 |
| mpeg4\_15 | ISO/IEC 14496-15, MPEG-4 part 15, H.264, vc-1 |
| AVC vc1 | vc-1 |
| wmv | Microsoft Windows Media Video |
| vp8 | VP8 codec |
| vp9 | VP9 codec |

HasAccessibi;ityDescriptionStringRepresents "public.accessibility.describes-music-and-sound.HasAccessibilityEAIStringDASH: Audio track contains an element for improved intelligibility of the dialogue \[Enhanced Audio Intelligibility\].

### ChangeAudioTrack(trackID as String) as Void

#### Description

Changes the currently playing audio track. For content with multiple audio tracks, the current track can be selected programmatically using this function.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| trackID | String | The audio track identifier returned by GetAudioTracks(). |

### SetTimedMetaDataForKeys(keys\[\] as Dynamic) as Void

#### Description

Specifies the timedMetaData keys that the BrightScript app is interested in receiving from the timedMetaData event.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| keys\[\] | Dynamic | An array of timedMetaData keys for the app to receive from the timedMetaData event.  <br>  <br>If the keys array is empty, all the timed metadata associated with the current stream is sent with the isTimedMetaData event. If the keys array is invalid, then do not return any keys to the BrightScript app. Any keys not specified with this method are deleted by the Roku OS and never returned to the BrightScript application. |

### GetCaptionRenderer() as Object

#### Description

This method returns the roCaptionRenderer instance associated with this roVideoPlayer.

Channels that render their own captions need to call this method to get the caption renderer for their video player. This is required for doing capture rendering. See roCaptionRenderer for details.

#### Return Value

The roCaptionRenderer instance associated with this roVideoPlayer.

### SetMacrovisionLevel(level as Integer) as Void

> This function is deprecated. Roku no longer supports Macrovision and this function exists as a no-op so that legacy scripts do not break.



ComponentLibrary
================

Extends [**Node**](/docs/references/scenegraph/node.md)

The ComponentLibrary node class downloads a library of custom SceneGraph components to be used in an application. The ComponentLibrary node should be used in a Scene node, such as Scene or OverhangPanelSetScene. One way to ensure that the library downloads before the SceneGraph application begins to compile the components for the application, is to begin the download in the main.brs file that creates the Scene node, by adding an `<interface>` field to the Scene node that can be used to monitor the download, and starts the application when the download is complete.

Loading Component Libraries
---------------------------

In addition to the custom components you create specifically for your application, you can also create custom component libraries that you can download as part of your application.

To do this, define a ComponentLibrary node in the Scene node for your application. Set the id field of the node to a unique library ID for your application, and specify the URL to download the library from in the uri field of the node. As the SceneGraph scene is constructed, the library will be downloaded from the specified URL, and component instances will be created as needed for the application.

> _Since Roku OS 9.4_, compilation info/failure messages for Roku SceneGraph component libraries when running side-loaded apps appear on the developer console, port 8085. (Previously, such messages were sent to port 8885.)

Component libraries can be packaged and signed the same way that apps are packaged and signed. You sideload your library, package it using the packaging tool, and then host it on the server of your choosing.

> Component libraries cannot be published to the Streaming Store for distribution.
> 
> Component libraries cannot be used to load the [Roku Advertising Framework (RAF) library](/docs/developer-program/advertising/integrating-roku-advertising-framework.md).

### Manifest

A component library must include a separate [manifest file](/docs/developer-program/getting-started/architecture/channel-manifest.md) in addition to the one for the app. The component library's manifest must include the [**rsg\_version** flag](/docs/developer-program/getting-started/architecture/channel-manifest.md#special-purpose-attributes) (`rsg_version=1.2`) to optimize app performance.

Using Library Components
------------------------

Components declared in a component library can be used inside the app just like custom components. Make sure to specify it in format _libraryName_:_componentName_. So say if a component named LoadingIndicator is defined in the SampleComponentLib library, then it may be used like this:

    <SampleComponentLib:LoadingIndicator imageUri="pkg:/images/loader.png" translation="[700, 200]"/>
    

Unsigned Component Libraries
----------------------------

Component libraries do not need to be packaged or signed with the same devid as the app. However, unsigned component libraries are required to be served over HTTPS before they can be accessed by published apps. See additional cases below:

*   Sideloaded apps can access unsigned component libraries over HTTP or HTTPS.
*   Published apps can only access unsigned component libraries over HTTPS.
*   Published apps can access signed component libraries over HTTP if the app and the library share the same devid.

Example
-------

[ComponentLibraryTestChannel](https://github.com/rokudev/samples/tree/master/utilities) is a test app that downloads the component library implemented from the source code in [ComponentLibrary](https://github.com/rokudev/samples/tree/master/utilities). The test app then creates an instance of the component implemented in the library.

Fields
------

FieldTypeDefaultAccess PermissionDescriptionloadStatusvalue string"none"READ\_ONLYIndicates the progress of the library download. The possible values are:

| Value | Meaning |
| --- | --- |
| none | The default if the library is not being downloaded |
| loading | Library is downloading |
| ready | Library has downloaded successfully |
| failed | Download of the library has failed |

idstringno defaultREAD\_WRITESet to a unique ID for the library for the applicationuriurino defaultREAD\_WRITEThe URL of the library to be downloaded

ifXMLList
=========

Implemented by
--------------

| Name | Description |
| --- | --- |
| [roXMLList](/docs/references/brightscript/components/roxmllist.md "roXMLList") | Contains a list of roXML objects |

Supported methods
-----------------

### GetNamedElements(name As String) As Object

#### Description

Returns a new XMLList that contains all roXMLElements that matched the passed in name (case-sensitive matching is used). This is the same as using the dot operator on an roXMLList.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| Name | String | The XML element to be used to find matches. |

#### Return Value

An XMLList that contains the matches.

### GetNamedElementsCi(name As String) As Object

#### Description

Returns a new XMLList that contains all roXMLElements that matched the passed in name (case-insensitive matching is used). This is the same as using the dot operator on an roXMLList.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| Name | String | The XML element to be used to find matches. |

#### Return Value

An XMLList that contains the matches.

### Simplify() As Object

#### Description

If the list contains exactly one item, this function returns that item. Otherwise, it returns itself.

#### Return Value

The object item.

### GetAttributes() As Object

#### Description

If the list contains exactly one item, this function returns the attributes of that item. Otherwise it returns invalid.

#### Return Value

The object item.

### GetText() As String

#### Description

If the list contains exactly one item, this function returns the text of that item. Otherwise, it returns an empty string.

#### Return Value

The object string.

### GetChildElements() As Object

#### Description

If the list contains exactly one item, this function returns the child elements of that item. Otherwise it returns invalid.

> This function does not return the items contained in the roXMLList. Use [ifList](/docs/references/brightscript/interfaces/iflist.md "ifList") functions to access those items.

#### Return Value

The object item.

ifMessagePort
=============

Implemented by
--------------

| Name | Description |
| --- | --- |
| [roMessagePort](/docs/references/brightscript/components/romessageport.md "roMessagePort") | A Message Port is the place messages (events) are sent |

Supported methods
-----------------

### WaitMessage(timeout as Integer) as Dynamic

#### Description

Waits until an event object is available or timeout milliseconds have passed.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| timeout | Integer | The number of milliseconds to wait for a message. If this parameter is set to 0, this method waits indefinitely for a message, with no timeout.  <br>  <br>The native [wait()](/docs/references/brightscript/language/global-utility-functions.md#waittimeout-as-integer-port-as-object-as-object) function can also be used to get the event object which WaitMessage() would return. This means that the following two statements have the same effect:  <br><br>    msg = port.WaitMessage(timeout)<br>    msg = wait(timeout, port) |

#### Return Value

If an event is available, it is returned. If the timeout expires, invalid is returned.

### GetMessage() as Dynamic

#### Description

If an event object is available, it is returned. Otherwise invalid is returned. The method returns immediately in either case and does not wait.

#### Return Value

An event object.

### PeekMessage() as Dynamic

#### Description

This method is similar to the [GetMessage()](#getmessage-as-dynamic) method, but the returned object (if not invalid) remains in the message queue. A later call to [WaitMessage()](#waitmessagetimeout-as-integer-as-dynamic), [GetMessage()](#getmessage-as-dynamic) or PeekMessage() will return the same message.

#### Return Value

An event object.

TargetGroup
===========

Extends [**Group**](/docs/references/scenegraph/layout-group-nodes/group.md "**Group**")

The TargetGroup node class associates a set of rectangular regions that children of the group will occupy. Like MarkupList, the TargetGroup has a content field containing the data for each item and an itemComponentName field that specifies an RSG component that will be used to render a content item. It also has a targetSet field that contains a [TargetSet](/docs/references/scenegraph/list-and-grid-nodes/targetset.md "TargetSet") that define a set of rectangular targets where children of the TargetGroup will be rendered.

The TargetGroup node is typically used to create a scrolling list (or row) of items where the focused item occupies more space than the other items.

For example, a TargetGroup could be used to create a full screen vertical scrolling list of item where the focused item is larger than the other items in the list. As the list items scroll, the appearance of the item moving into the focus region would be dynamically adjusted to fill the larger focus region. Simultaneously, the appearance of the item leaving the focus region would be dynamically adjust to return to the unfocused size. To set up this use case, you might set the targetSet field to a TargetSet node that specifies nine rectangles. The first rectangle would be specified to have the width and height of an unfocused item and be positioned so that it's bottom is above the top of the screen. The last rectangle would be specified to have the width and height of an unfocused item and be positioned so that's top is below the bottom of the screen. The remaining seven rectangles would define the rectangular regions of the onscreen items. Suppose the design calls for the focus item to be centered vertically at the center of the screen. To do that, you would specify the 5th rectangle to be larger than the other eight and position it so that it is centered vertically, you would specify the remaining rectangles to form a column of rectangular regions where the top three and bottom three visible items would be located.

The second step of setting up this use case would be to implement an RSG component that will be used to render each item. The TargetGroup node manages the creation of the items for the visible components, associates each with a ContentNode, and updates fields of the item component with information such as the current width and height of the item and the focus status of the item.

The TargetGroup's jumpToItem field is set to identify which content item is to be located at the TargetSet's targetRects field target rectangle identified by the TargetSet's focusindex field.

The final step of setting up this use case would be to create a VerticalList component that extends TargetGroup, sets up the TargetGroup's TargetSet node, and as the user presses up and down buttons on the remote, sets the TargetGroup's animateToTargetItem field to the prior or next index. Setting the animateToTargetItem field causes the displayed items to smoothly animate from their current target region to another target region, such that the specified index ends up at the TargetSet's target rectangle that is identified by the TargetSet's focusIndex field.

The above use case specifies the most common use case for the TargetGroup node, but only hints at the possible uses. For example, you could create your own RSG components with various custom behaviors. There might include:

*   A list where all the items are small when the list does not have the focus, but when the list receives the focus, all of the items smoothly adjust their size and position so that the focus item is largest, the items on either side of the focus item are slightly larger than the unfocused size and the remaining items remain the same size as the unfocused items. To do this, you would create two TargetSet's in your RSG component, one that defines the regions when the list is unfocused and one that defines the regions when the list is focused. Initially, the TargetGroup's targetSet field would be set to the unfocused TargetSet node. Then, when the list is focused, the targetSet's animateToTargetSet field would be set to the focused TargetSet node, causing all of the target regions to smoothly animate to their new size and position, taking along the associated item component's with them.
*   A horizontal scrolling list of items where the focused region floats across the screen as the user presses left/right until the focus region reaches the edge of the display, at which point the focus region remains stationary and the items scroll left or right. This would require the use of several TargetSet nodes (one for each possible position of the focus region). Initally, the TargetGroup's targetSet field would be set to one of these TargetSet's. Then while the focus region is not at one of the edges, key presses would set the animateToTargetSet field to animate the focus region to its next location. Once the focus region reaches an edge, another key press in the same direction would set the animateToTargetIndex field to cause the items to scroll so that the next content item occupies the focus region.
*   A list where when an item is selected, all of the items fly off the screen while the selected item zooms up and moves to the center of the screen. To set up this use case, you would specify a TargetSet for when the list items are onscreen and another TargetSet for the onscreen location of the focused item and the offscreen locations where each items will disappear.
*   A circular arrangement of a fixed number of items with the item at the 6 o'clock position being larger and having the focus. Note that in this case, no offscreen targets would be specified.

Fields
------

| Field | Type | Default | Access Permission | Description |
| --- | --- | --- | --- | --- |
| itemComponentName | string |     | READ\_WRITE | Specifies the name of a XML component for the group items. An instance of this component is created on demand for each visible item of the group. The XML component must define a specific interface as detailed in [TargetGroup XML Component](/docs/references/scenegraph/layout-group-nodes/targetgroup.md#targetgroup-xml-component "TargetGroup XML Component") below |
| content | ContentNode | none | READ\_WRITE | Specifies the content for the group. See [Data Bindings](/docs/references/scenegraph/layout-group-nodes/targetgroup.md#data-bindings "Data Bindings") below for more details |
| targetSet | TargetSet | invalid | READ\_WRITE | Specifies the TargetSet to use to define the target regions of the items in the group. When set or modified, the target regions are immediately adjusted to use the new values |
| defaultTargetSetFocusIndex | int | 0   | READ\_WRITE | For TargetSet's that do not specify a focusIndex, this value will be used as the index of the TargetSet where the focused item is located. If a TargetSet specifies any value for the focusIndex, that value will be used instead of defaultTargetSetFocusIndex |
| wrap | Boolean | false | READ\_WRITE | Specifies whether the content items wraparound at the end of the TargetGroup to fill all of the targets rectangles |
| duration | Time | 0.3 seconds | READ\_WRITE | Specifies the time, in seconds, to perform the animation when the animateToItem or animateToTargetSet fields are set |
| showTargetRects | Boolean | false | READ\_WRITE | Specifies whether the current target rectangles (as defined in the read-only currTargetSet field's TargetSet) are drawn or not. Typically this would only be set to true while debugging an app, although in some use cases its possible that you might want to display the current target rectangles. The rectangles are drawn using the color in the targetSet's TargetSet node's color field |
| currFocusItemIndex | float | \-1.0 | READ\_ONLY | As the TargetGroup animation occurs, this field is constantly updated to represent the index of the ContentNode currently occupying the focus target region. When currFocusItemIndex is an integer value, the specified ContentNode occupies the focus target. When currFocusItemIndex has a fractional part, the value indicates that an animation is in process. For example, a value of 5.7 would indicate that items 5 and 6 are currently overlapping the focus region, with item 6 occupying 70% and item 5 the other 30% |
| currTargetSet | TargetSet | invalid | READ\_ONLY | As the TargetGroup animation occurs that is initiated by setting the animateToTargetSet field, currTargetSet contains the current values of the target regions as the animation proceeds from the initial TargetSet's targets to the new TargetSet's targets |
| itemSelected | integer | 0   | READ\_ONLY | When a group item is selected, set to the index of the selected item |
| itemFocused | integer | 0   | READ\_ONLY | When a group item gains the key focus, set to the index of the focused item |
| itemUnfocused | integer | 0   | READ\_ONLY | When a group item loses the key focus, set to the index of the unfocused item |
| jumpToItem | integer | 0   | WRITE\_ONLY | When set to a valid item index, causes the group to immediately update so that the specified index moves to the target region specified by the TargetSet's focusIndex |
| animateToItem | integer | 0   | WRITE\_ONLY | When set to a valid item index, causes the group to quickly scroll so that the specified index moves into the to the target region specified by the TargetSet's focusIndex |
| animateToTargetSet | TargetSet | invalid | WRITE\_ONLY | When set to a valid TargetSet, causes the group to quickly animate so that the target regions of the initial TargetSet node are smoothly interpolated to the corresponding target regions of the new TargetSet node. If the two TargetSet's focusIndex fields are different, the focusIndex is also animated from the old to the new value |
| easeFunction | string | inOutCubic | READ\_WRITE | Specifies the interpolator used in TargetGroup animations between items. |
| advancing | boolean | false | READ\_WRITE | Forces the item index to be interpolated in an advanced manner when animating between items. This only has an effect when the **wrap** field is set to true. For example, when the number of items is 10 and we are interpolating from item 9 to item 0, not enabling this option will result in the following sequence: 9 -> 8 -> 7 -> … -> 0, rather than 9 -> 0. |
| reversing | boolean | false | READ\_WRITE | Force the item index to be interpolated in a reverse manner when animating between items. This only has an effect when the **wrap** field is set to true. For example, when the number of items is 10 and we are interpolating from item 0 to item 9, not enabling this option will result in the following sequence: 0 -> 1 -> … -> 9 rather than 0 -> 9. |

TargetGroup XML Component
-------------------------

The TargetGroup node itemComponentName field value should be set to the name of an XML component used to display each item in the grid. An instance of this component is created for each target region specified in the TargetSet's targetRects field.

If the XML component contains interface fields that match the names shown in the table below, those fields will be updated by the TargetGroup node. This allows the XML component to alter the item appearance based on changes to these interface fields.

Note that the fields are updated in the order presented in the table below. Any layout scripting you write based on these fields should be done in that order to avoid updating your layout based on a field that has not been updated yet.

| Field Name | Field Type | Access Permission | Description |
| --- | --- | --- | --- |
| currTarget | float | READ\_ONLY | Set to index of the current TargetSet's targetRect that should contain the item. If currTarget is an integer value, the item's currRect field will be the value of currTarget'th item in the TargetGroup node's currTargetSet field's targetRect's array. If currTarget is not an integer, it indicates that the item is animating from one targetRect index to another.  <br>  <br>For example, if the value is 5.7, the item is between the rectangles at index 5 and 6 of the TargetGroup node's currTargetSet's targetRect field. The item if 70% occupying the rectangle at index 6 and 30% occupying the rectangle at index 5. |
| currRect | rectangle | READ\_ONLY | Set to the rectangle that the item should occupy. The rectangle values can be accessed either as an associative array with "x", "y", "width" and "height" elements or as an array of four float's containing the x, y, width and height values of the rectangles.  <br>  <br>Note that the item will be automatically translated so that its origin is at the (x,y) location of this rectangle relative to the origin of the TargetGroup node. Typically, the width and height of currRect is used to dynamically adjust the size of the item as it animates from one target to another. |
| index | integer | READ\_ONLY | Set to the index of this item in the data model. |
| groupHasFocus | Boolean | READ\_ONLY | Set to true if the **TargetGroup** node has focus, false otherwise. |
| itemContent | **ContentNode** |     | Contains the data to be displayed by the group item. The relationship between data in the **ContentNode** node and the visual elements of the grid item is determined by the markup and scripts in the item XML component.  <br>  <br>Typically, an observer callback function of the `itemContent` field is used to update the grid item when the content changes. |
| focusPercent | float | READ\_ONLY | The fractional value, from 0.0 to 1.0, of a time delay after focus has moved from one item to the next.  <br>  <br>The fractional value increases incrementally from 0.0 to 1.0 for the newly-focused item, while simultaneously decreasing from 1.0 to 0.0 for the previously-focused item.  <br>  <br>This value can be used as a timing key to smoothly animate the appearance of the focused item as well as the previously-focused item, to indicate the movement of focus to the user. |
| itemHasFocus | Boolean | READ\_ONLY | Indicates whether the item component currently is the TargetGroup's focused item.  <br>  <br>When scrolling starts, the itemHasFocus field for the currently focused item is set to false. When scrolling ends, the itemHasFocus field for the newly focused item is set to true.  <br>  <br>During the scrolling animation, all itemHasFocus fields are set to false.Only one item component of any TargetGroup should have itemHasFocus set to true. If the TargetGroup does not focus, all itemHasFocus fields of their item components should be set to false. |

Data bindings
-------------

A TargetGroup node should have a single ContentNode as the root node in its content field. One child ContentNode should be added to the root node for each item in the group (these child nodes can be thought of as item nodes). Item nodes should contain the data required by the TargetGroup node's XML component.

The specific data fields in the ContentNode should match the values referenced by the TargetGroup node's XML component.

Sample apps
-----------

| Sample | Description |
| --- | --- |
| [FloatingFocusWrap](https://github.com/rokudev/samples/blob/master/ux%20components/screen%20elements/target_group/FloatingFocusWrap) | TargetGroup example demonstrating floating focus and wrapping from the first and last items. |
| [TwoRowFixedFocus](https://github.com/rokudev/samples/blob/master/ux%20components/screen%20elements/target_group/TwoRowFixedFocus) | A sample demonstrating an unfocused TargetList when more than one TargetList is present. |

roAudioPlayerEvent
==================

The roAudioPlayer sends the roAudioPlayerEvent with the following predicates that indicate its valid event types:

Supported methods
-----------------

### isListItemSelected() as Boolean

A stream has been selected to start playing.

### isStatusMessage() as Boolean

Status information is available.

### isFullResult() as Boolean

Audio playback completed at end of content.

### isPaused() as Boolean

Audio playback was paused by the user.

### isResumed() as Boolean

Audio playback has resumed

### isPartialResult() as Boolean

Audio playback was interrupted

### isRequestFailed() as Boolean

Audio playback failed due to an error

### isTimedMetaData() as Boolean

This event is fired when an ID3 timecode has passed with an event that includes key/value pairs for timed metadata that the Brightscript app is interested in.

All timed metadata is released after it is delivered to the Brightscript app. It is also released without delivery if the Brightscript app did not indicate it’s interest in the data with a SetTimedMetaDataForKeys() call.

### isRequestSucceeded() as Boolean

Stream playback has completed successfully.

#### GetMessage() as String

Returns the string "Timed Metadata"

#### GetInfo() as Object

Returns an associative array of key/value pairs of timedMetadata at the pts timecode specified in the index.

#### GetIndex() as Integer

Returns the index of the audio stream.

### isFormatDetected() as Boolean

Checks whether an event has been fired when the format of all tracks in the media stream have been identified.

Specific information about the event can be obtained by calling the GetMessages() and GetInfo() methods on the event.

#### GetMessage() as String

Returns a description of the message (for exampe, "Format Detected").

#### GetInfo() as Object

Returns information about the video player event. This method returns an roAssociativeArray that contains the following keys:

| Key | Value |
| --- | --- |
| audio | The format of the audio stream, if any |
| captions | The format of the captioning data, if any |
| video | The format of the video stream, if any |

### isSegmentDownloadStarted() as Boolean

Checks whether the individual segments in an HLS or smooth stream are about to be downloaded. This method returns true if segments in the stream are going to be downloaded; otherwise, it returns false.

Specific information about the event can be obtained by calling the GetMessages() and GetInfo() methods on the event.

#### GetMessage() as String

Returns a description of the message (for example, "Segment download started").

#### GetInfo() as Object

Returns an associative array containing the following information about the segment download event:

| Key | Value |
| --- | --- |
| Sequence | Stream segment sequence number |
| SegBitrate | Bitrate of the segment, in kilobits per second |
| StartTime | Timestamp of the start of the segment data |
| EndTime | Timestamp of the end of the segment data |

### isStreamSegmentInfo() as Boolean

Checks whether playback has begun of a segment in an HLS, DASH, or smooth stream. This method returns true if the playback of a segment in an HLS, DASH, or smooth stream has begun; otherwise, it returns false. Specific information about the event can be obtained by calling the GetMessage(), GetIndex() and GetInfo() methods on the event.

#### GetMessage() as String

Returns a description of the message (for example, "Stream segment info").

#### GetIndex() as Integer

Returns the segment start time in seconds.

#### GetInfo() as Object

Returns an associative array with the following information about the stream segment:

| Key | Value |
| --- | --- |
| StreamBandwidth | Bandwidth of the stream being played in kbps |
| SegStartTime | Segment start time (offset from start of stream) in milliseconds |
| Sequence | Stream segment sequence number |
| SegUrl | Stream segment URL (i.e., .ts file for HLS, stream fragment URL for smooth) |
| HdrMode | Indicates the HDR format of the content, which may be one of the following values:<br><br>*   0: UNKNOWN<br>*   1: NONE (SDR)<br>*   2: HDR10<br>*   3: DOLBY\_VISION<br>*   4: HLG10<br>*   5: HDR10\_PLUS<br>*   6: SL\_HDR2 |

### isDownloadSegmentInfo() as Boolean

Checks whether a segment in an adaptive stream (HLS, Smooth, or DASH) has been downloaded. This method returns true if a segment in an adaptive stream (HLS, Smooth, or DASH) has been downloaded; otherwise, it returns false. Specific information about the event can be obtained by calling the GetMessage(), GetIndex() and GetInfo() methods on the event.

#### GetMessage() as String

Returns a description of the message (for example, "Download segment info").

#### GetIndex() as Integer

Returns the segment sequence number.

#### GetInfo() as Object

Returns an associative array containing the following information about the segment download:

| Key | Value |
| --- | --- |
| Status | Status of the download: 0 = success, nonzero = error |
| Sequence | Stream segment sequence number (same as returned by GetIndex) |
| SegUrl | Stream segment URL (i.e., .ts file for HLS, stream fragment URL for smooth) |
| DownloadDuration | Amount of time spent downloading the segment, in milliseconds |
| SegSize | Segment size, in bytes |
| SegType | Type of data in the segment: 1=audio, 2=video, 3=captions, 0=mux |
| Bitrate | Bitrate of the segment, in bits per second |
| SegBitrate | Bitrate of the segment, in kilobits per second (equal to Bitrate / 1000) |

Font
====

Extends [**Node**](/docs/references/scenegraph/node.md)

The Font node class specifies the font to be used by a Label node, or any other nodes that render text.

Nodes that use fonts include a field that stores a Font node. The font to use is specified by creating a Font node, and setting its uri and size fields.

The uri field can be set to any TrueType/OpenType font file. For example, to specify a font in XML markup:

    <Label>
      <Font role = "font" uri = "pkg:/fonts/font.ttf" size = "24" />
    </Label>
    

A default system font can also be specified, such as in the following:

    <Label id = "myLabel"
      width = "200"
      height = "200"
      text = "Hello Label"
      font = "font:MediumBoldSystemFont" 
      />
    

Below is the list of all the possible system font values:

*   SmallestSystemFont
*   SmallestBoldSystemFont
*   SmallSystemFont
*   SmallBoldSystemFont
*   MediumSystemFont
*   MediumBoldSystemFont
*   LargeSystemFont
*   LargeBoldSystemFont

The font can also be specified in BrightScript, for example:

    label = CreateObject("roSGNode", "Label")
    font  = CreateObject("roSGNode", "Font")
    font.uri = "pkg:/fonts/font.ttf"
    font.size = 24
    label.font = font
    

Fields
------

| Field | Type | Default | Access Permission | Description |
| --- | --- | --- | --- | --- |
| uri | uri | ""  | READ\_WRITE | Specifies a TrueType or OpenType font file. Currently only font files included in the application can be specified |
| size | integer | 1   | READ\_WRITE | Specifies the size of the font in points |
| fallbackGlyph | string | ""  | READ\_WRITE | String representation of a Unicode character to display when an unsupported glyph is encountered. For example, "u0020" would render a space for any unrenderable characters |

StdDlgSideCardArea
==================

Extends [StdDlgAreaBase](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-area-base.md)

Description
-----------

The **StdDlgSideCardArea** node is used to add a freeform area to the right or left side of a custom standard framework dialog for displaying decorative images or annotative text.

This node can be displayed on either the left or right side of the vertical column that contains the dialog's child [StdDlgAreaBase](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-area-base.md) nodes ([TitleArea](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-title-area.md), [StdDlgContentArea(s)](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-content-area.md), and/or [StdDlgButtonArea](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-button-area.md)). The node can either extend to the edge of the dialog's background image or honor the background image's 9-patch boundaries.

The width of the vertical column containing the [StdDlgAreaBase](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-area-base.md) child nodes does not extend across the full width of the dialog as it does for dialogs that do not contain a **StdDlgSideCardArea** node.

A dialog may contain only a single **StdDlgSideCardArea** node, and that node must be a child of the dialog.

The **StdDlgSideCardArea** node never gains key focus; therefore, it should not contain any other nodes that require direct user interaction.

Fields
------

| Field | Type | Default | Access Permission | Description |
| --- | --- | --- | --- | --- |
| extendToDialogEdge | boolean | true | READ\_WRITE | Specifies whether the **StdDlgSideCardArea** node extends to the edge of the dialog's background image or respects the background image's 9-patch margins.  <br><br>*   **true**: The origin of the **StdDlgSideCardArea** node's coordinate system is set to the top/left edge of the dialog's background image.<br>*   **false**: The origin of the **StdDlgSideCardArea** node's coordinate system is based on the background image's 9-patch margins. |
| horizAlign | string | "right" | READ\_WRITE | Specifies on which side of the custom dialog the StdDlgSideCardArea node appears: "left" or "right". |
| showDivider | boolean | false | READ\_WRITE | Specifies whether a thin vertical divider line is displayed between the **StdDlgSideCardArea** and the vertical column that contains the dialog's child **StdDlgAreaBase** nodes ([TitleArea](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-title-area.md), [StdDlgContentArea(s)](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-content-area.md), and/or [StdDlgButtonArea](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-button-area.md)). The divider line, if shown, uses the **DialogSecondaryItemColor** field from the current [RSG palette](/docs/references/scenegraph/scene.md#fields). |
| width | float | 0.0f | READ\_WRITE | Specifies the width of the **StdDlgSideCardArea** node.  <br>  <br>If this field is set to its default value (0.0), the width is set to the width of the [**StdDlgContentArea**](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-content-area.md)) node's bounding rectangle (the union of the width of all of its child nodes).  <br>  <br>If set to a value greater than 0.0, the width of the **StdDlgSideCardArea** node is fixed to that explicit value.  <br>  <br>The height of **StdDlgSideCardArea** node is based on the StandardDialog layout logic. This sets the height to a maximum of the height of the **StdDlgSideCardArea** bounding rectangle and the height of the vertical column containing the dialog's child [**StdDlgAreaBase**](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-area-base.md) nodes. This is constrained by the maximum permissible height of the dialog such that it is fully visible onscreen. |

### Examples

The following examples demonstrate how to use the **StdDlgSideCardArea** node to display decorative images or annotative text.

#### Decorative

In this example, the **StdDlgSideCardArea** has a child **Poster** node with its **uri** field set to the URI of a mountain lake image. The height of the dialog is computed to equal the height of the mountain lake image \[800 (FHD), 300 (HD)\]. The mountain lake **Poster** node has a child **SimpleLabel** node positioned at 575, 775 to show the "PhotoCredit:Jeff Anderson" text on top of the Poster.

![roku815px - SideCardGlamourShot](https://image.roku.com/ZHZscHItMTc2/SideCardGlamourShot.jpg)

    <?xml version="1.0" encoding="utf-8" ?>
    
    <component name="SideCardGlamourShotDialog" extends="StandardDialog" initialFocus="buttonArea" >
    
    <script type="text/brightscript" >
    <![CDATA[
    function init()
        m.top.width  = "1380"
    
        m.buttonArea = m.top.findNode("buttonArea")
        m.top.observeFieldScoped("buttonFocused", "printFocusButton")
        m.top.observeFieldScoped("buttonSelected", "printSelectedButtonAndClose")
        m.top.observeFieldScoped("wasClosed", "wasClosedChanged")
    end function
    
    sub printFocusButton()
        print "m.buttonArea button ";m.buttonArea.getChild(m.top.buttonFocused).text;" focused"
    end sub
    
    sub printSelectedButtonAndClose()
        print "m.buttonArea button ";m.buttonArea.getChild(m.top.buttonSelected).text;" selected"
        m.top.close = true
    end sub
    
    sub wasClosedChanged()
        print "SideCardRightDialog Closed"
    end sub
    
    ]]>
    </script>
    
    <children>
      <StdDlgTitleArea primaryTitle="Glamour Shot Side Card" />
      <StdDlgContentArea>
         <StdDlgTextItem text="Lorem ipsum dolor sit amet, consectetur adipiscing elit. Suspendisse sapien massa, efficitur a accumsan a, commodo eget justo. In id ante elementum, posuere diam quis, lobortis magna." />
      </StdDlgContentArea>
      <StdDlgButtonArea id="buttonArea" >
        <StdDlgButton text="OK" />
        <StdDlgButton text="Cancel" />
      </StdDlgButtonArea>
      <StdDlgSideCardArea id="buttonArea" horizAlign="left" extendToDialogEdge="true" showDivider="false"  >
          <Poster id="sideCardPoster" loadSync="true" loadDisplayMode="limitSize" uri="pkg:/images/MountainLakeSideCard.jpg" translation="[0.0f, 0.0f]" />
          <SimpleLabel text="Photo Credit: Jeff Anderson" vertOrigin="bottom" horizOrigin="right" translation="[575, 775]" color="0xFFFFFFFF" fontUri="font:SystemFontFile" fontSize="24"/>        
      </StdDlgSideCardArea>
    </children>
    
    </component>
    

#### Annotative

In this example, the **StdDlgSideCardArea** has a child **Label** node ("Show the QR Code...") and a child **Poster** node to show the QR code below the Label. The height of the dialog is set to the maximum height of the bounding rectangle of the **StdDlgSideCardArea** and the vertical column that contains the dialog's child [StdDlgAreaBase](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-area-base.md) nodes ([TitleArea](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-title-area.md), [StdDlgContentArea(s)](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-content-area.md), and/or [StdDlgButtonArea](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-button-area.md)). In this case, the StdDlgSideCardArea is slightly taller; therefore, it's height is used.

![roku815px - SideCardAnnotation](https://image.roku.com/ZHZscHItMTc2/SideCardAnnotation.jpg)

    <component name="SideCardAnnotationDialog" extends="StandardDialog" initialFocus="buttonArea" >
    
    <script type="text/brightscript" >
    <![CDATA[
    function init()
        m.top.width  = "1380"
    
        m.buttonArea = m.top.findNode("buttonArea")
        m.top.observeFieldScoped("buttonFocused", "printFocusButton")
        m.top.observeFieldScoped("buttonSelected", "printSelectedButtonAndClose")
        m.top.observeFieldScoped("wasClosed", "wasClosedChanged")
    end function
    
    sub printFocusButton()
        print "m.buttonArea button ";m.buttonArea.getChild(m.top.buttonFocused).text;" focused"
    end sub
    
    sub printSelectedButtonAndClose()
        print "m.buttonArea button ";m.buttonArea.getChild(m.top.buttonSelected).text;" selected"
        m.top.close = true
    end sub
    
    sub wasClosedChanged()
        print "SideCardRightDialog Closed"
    end sub
    
    ]]>
    </script>
    
    <children>
      <StdDlgTitleArea primaryTitle="Annotation Side Card" />
      <StdDlgContentArea>
         <StdDlgTextItem text="Lorem ipsum dolor sit amet, consectetur adipiscing elit. Suspendisse sapien massa, efficitur a accumsan a, commodo eget justo. In id ante elementum, posuere diam quis, lobortis magna." />   
      </StdDlgContentArea>
      <StdDlgButtonArea id="buttonArea" >
        <StdDlgButton text="OK" />
        <StdDlgButton text="Cancel" />
      </StdDlgButtonArea>
      <StdDlgSideCardArea id="buttonArea" horizAlign="right" width="500" extendToDialogEdge="false" showDivider="true"  >
          <Label text="Scan the QR Code to get a bunch of free stuff" horizAlign="center" wrap="true" width="500" translation="[0, 0]" fontUri="font:SystemFontFile" fontSize="36"/>
          <Poster translation="[30, 120]" uri="pkg:/images/RokuQRCode441x441.png" />
      </StdDlgSideCardArea>
    </children>
    
    </component>
    

Sample app
----------

You can download and install a [sample app](https://github.com/rokudev/standard-dialog-framework) that demonstrates how to create a custom dialog that includes a sidecard area.

Top development tips
====================

*   Processing Power: If your app is experiencing low frame rate or laggy transitions, Processing Power is probably the culprit. The difference in CPU between the low end and high end Roku device is large, and will likely only continue to grow as new models are released. As such, it is important to keep in mind that the animation that runs smoothly on a Dallas might not look as good, or even work at all, on a Tyler. Developers should be conscious of CPU intensive tasks and their impact on older devices.

> Developers should be conscious of CPU intensive tasks and their impact on older devices.

*   Know the remote control codes for special screens:
    
    *   Dump Core: **Home 5x, Up, Rew 2x, FF 2x**
    *   Debug Info on screen: **Home 5x, Rew 3x, FF 2x**
    *   Channel Version Info: **Home 3x, Up 2x, Left, Right, Left, Right, Left**
    *   Developer Settings Page: **Home 3x, Up 2x, Right, Left, Right, Left, Right**

*   The Developer settings page is necessary for enabling developer mode on your box.

*   All file paths are prefixed by the device name and a colon: `pkg:/filename.txt`. See [File System](/docs/developer-program/getting-started/architecture/file-system.md) for more information.

*   Always use a screen facade object when launching your application so that it appears to the user that your app launches immediately and avoids screen flicker when exiting.

*   You can use the theme attributes of `roApplicationManager` (see [BrightScript Component Reference](/docs/references/brightscript/language/component-architecture.md)) to create a new UI skin for your app.

*   When using rendezvous style registration and account linking, be sure to store the linking information in the device registry and not on your servers. We require that users are able to do a "Factory Reset" and be confident that no personally identifiable information is associated with the device. This is not possible if you have saved permanent serial number information on your servers.

*   There are a limited number of video content and streaming formats supported on the Roku Streaming Player. See [Audio and Video Support](/docs/specs/media/streaming-specifications.md) for complete information on the supported formats.

*   We support `.mp3` audio files in the audio player.

*   Be sure to use a unique key for each application you publish and reuse this key each time you update your application using the "rekey" option. This ensures that all versions of your application will have access to the same registry data and avoid causing users to re-link after an update.

*   When using the slide show component, a high resolution image may take a while to download. A good trick to provide quick feedback to the user is to put an image in your package (so it's not downloading) that may have your logo, and informs the user that the slideshow is "Retrieving…". This slide could be the first slide in your slideshow so that feedback to the user is instant, and the slideshow never appears "hung".

*   We require that your web servers support range requests. If they do not, you may run into content that is not playable, or large images that do not display. The data will appear as a corrupted file format to our components, as the first block may be resent by the web server when we expect data at a particular range or offset.
    
*   The screens are displayed in a LIFO (stack) order. If this behavior is causing your screen to flicker (perhaps you wanted to pop two screens after you are done with the current one) there is a `Close()` method in the screen interface of all the screen and dialog components that deletes the screen out of the display stack. An example might be coming out of a Registration or Search page to a content springboard. From the content springboard, you might want to exit to your main screen, not the registration screen or search screen.

roSGNodeEvent
=============

An roSGNode object sends roSGNodeEvent messages to a specified port when changes occur in nodes. An roSGNodeEvent is also sent as the argument of field observer callback functions. Both of these cases allow a SceneGraph application to respond to events. roSGNodeEvent supports the following methods.

Supported methods
-----------------

### getData() as Dynamic

Retrieves the new field value at the time of the change.

### getField() as Dynamic

Retrieves the name of the field that changed.

### getRoSGNode() as Dynamic

Retrieves a pointer to the node. This can be used for nodes without an ID.

### getNode() as Dynamic

Retrieves the ID of the node that changed.

### getInfo() as Object

Retrieves an AA that contains the values of selected "context" fields, which were [specified in an earlier-executed call](/docs/references/brightscript/interfaces/ifsgnodefield.md#event-field-aggregation) to `observeField()` or `observeFieldScoped()`. (If no such "context" fields were designated previously, `getInfo()` returns an empty AA.) The array is keyed on the names of the "context" fields, and the entry values are the instantaneous values of the corresponding fields, at the point when the observed field changed.

Remote control buttons
======================

The Roku remote is unique to the platform, with a specific set of buttons each triggering different commands. Some buttons, like the dPad, are likely familiar to any user or developer. Other buttons, like the Instant Replay or Star buttons, might seem a little more unique. Below is an overview of the buttons on the Roku remote, how they work, and the standard behavior users expect when pressing them.

![roku600px - remote](https://image.roku.com/ZHZscHItMTc2/WMT-Roku-RSS-Remote-black-button-v2.png "remote")

4-way directional pad (dPad)
----------------------------

Conventional uses of the Roku remote's buttons:

*   **While on a standard UI screen:**
    
    *   Use the directional pad to move the onscreen focus highlight up/down/left/right from one screen element to another.
    *   Alternatively, in a "fixed-focus" model, use it to move the content or choices into the focus highlight.
*   **During video playback:**
    
    *   dPad left/right: Pauses the video, reveals a horizontal row of Roku BIF (Base Index Frame) files, HLS/DASH thumbnails, or video key-frames, and users can navigate backwards/left and forward/right through the video via these key-frames:
        
        ![roku815px - trickmode](https://image.roku.com/ZHZscHItMTc2/trickmode.png "trickmode")
        
    *   A single dPad pressed for left or right moves 1 key-frame in the corresponding direction. Continual press and hold of the left/right key scrolls horizontally through the row of key-frames. Pressing OK or Play/Pause resumes video playback from the key-frame in focus.
        
    *   dPad up/down: Some apps with playlists use up/down key to navigate to the previous or the next video.
        
        See [Trick Mode](/docs/developer-program/media-playback/trick-mode/trick-mode.md) for more information.
        
*   **During music playback**:
    
    *   Pressing left or right on the dPad skips to the previous or next track/item in the playlist.

OK
--

*   **While on a standard UI screen:**
    
    *   Selects or activates the item in focus.
*   **During video playback:**
    
    *   Preferred: OK button should reveal a Heads Up Display (HUD) containing video-relevant information and actions (which should dismiss when it times out or when the Back button is pressed).
    *   Alternative: Toggle between video play and pause.

Back
----

*   **While on a standard UI screen:**
    
    *   Navigate users to a previous screen. Note that there are at least two different back-navigation schemes:
        
        *   Hierarchical: Navigate to the screen that is one level up in the UI hierarchy.
        *   Historical: Navigate to the previously viewed screen, regardless of where that screen is within the UI's map/hierarchy.
        *   Users expect and more easily understand the 'historical' model. Where it is important to navigate to other screens or levels of the UI hierarchy, offer better on-screen navigation choices.
    *   While users can press the Back button to exit a popup dialog, Back is not used to navigate from a screen to a popup dialog.
*   **While on your app's home screen:**
    
    *   It is critical that people be allowed to exit your app via the remote's Back button. This ensures they can get to the original Roku UI screen from which they launched into your app.
    *   Consistent exit strategy: Users can press the Back button enough times to eventually get to your app's home screen. From there, one more press of the Back button should reveal an "exit opportunity". For example:
        
        *   A Popup Dialog asking for exit confirmation.
        *   A menu offering "exit" as a choice.
    *   Hence, pressing Back from your app's home screen should either exit your app or reveal a way to exit your app (E.g., A popup dialog confirming a user's intent to exit).
*   **During video playback:**
    
    *   Exit video playback and return to the referring screen (E.g., Content details page).

Instant replay/skip-back
------------------------

*   **While on a standard UI screen:**
    
    *   No system-response
*   **During video playback:**
    
    *   Auto rewind the video 10–25 seconds and resume playback.
    *   The amount of time required to rewind takes into account that users may need to reach for a remote, find, and then press the Instant Replay button.
    *   Note that within the Roku settings users can set Closed Captioning to be on during instant replay. The idea here is that most people skip back because they didn't hear what was said. Hence, when Instant Replay is pressed, the last 20 seconds are replayed with Closed Captioning on only during that replayed portion of the video.
    *   Some Roku remotes do not have an Instant Replay button. If you want the functionality to be available consistently, you could also offer it via the first dPad left press during video playback. If users press dPad left more than once in rapid succession, then revert to standard dPad behavior during video playback.
*   **During music playback:**
    
    *   Restart current track from beginning.

Star/Options
------------

*   **While on a standard UI screen:**
    
    *   It is used to access a popup menu of contextual and/or global options or information.
    *   Options can be contextual to the screen and/or the screen item in focus.
    *   Global options can be navigational (E.g., Home, Search) or features/settings.
    *   While the popup menu is visible, pressing the Star button again (or the Back button) should dismiss it.
*   **During full-screen video playback:**
    
    *   Only video is displayed:
        
        *   The Star button reveals a Roku options menu offering users standard options, like Closed Captioning, and audio tracks.
    *   App UI/HUDs displayed over video:
        
        *   The Star button is passed to the app to handle and decide what to do.
        *   For example, app is displaying a mini-EPG over a video, so the Star button press would be handled by the app.

Play/Pause
----------

*   **While on standard UI screen:**
    
    *   Can be used as a shortcut to activate or play something.
        
        *   For example, showing a featured item elsewhere on the screen and activating/selecting it without having to move the focus highlight to it.
        *   For example, when highlighting a movie poster within a grid, pressing OK would select it and take you to the movie's details page, but Play could just play the movie or its trailer.
*   **During content playback:**
    
    *   If the video is playing, a button press pauses the video (and reveals BIFs).
    *   If the video is paused, a button press resumes video playback.
    *   If the video is rewinding or fast-forwarding, pressing the Play button switches to video playback at the current rewind or fast-forward position.
*   **During audio playback:**
    
    *   A button press pauses the audio track.
    *   If the audio track is paused, a button press resumes audio playback.
*   **During ad video playback:**
    
    *   Allow users to play/pause advertisements.
    *   Play/pause behavior should be the same as with content video.

Rewind/Fast-forward
-------------------

*   **While on a standard UI screen:**
    
    *   When focus is on a vertical or horizontal list of text or images:
        
        *   Rewind: Vertical pages list up and horizontal pages list left.
        *   Fast-forward: Vertical pages list down and horizontal pages list right.
*   **During content video playback:**
    
    *   For long-form content (E.g., 30 minute TV show), usually 3 rewind/fast-forward speeds are offered.
    *   For short-form content, it's okay to reduce the number of speeds to 2 or just 1.
    *   Each press of the rewind button increments the rewinding speed by one step: Current state >> Rew x 1 >> Rew x 2 >> Rew x 3 >> Rew x 1 >> Rew x 2 >> etc.
    *   Each press of the fast-forward button increments the forwarding speed by one step: Current state >> Ffwd x 1 >> Ffwd x 2 >> Ffwd x 3 >> Ffwd x 1 >> Ffwd x 2 >> etc.
    *   Pressing and holding the rewind or the fast-forward button accelerates the video to the fastest speed: Current state >> Rew x 3 or Current state >> Ffwd x 3.
    *   Note that in all the cases above, the "current state" could be: video paused, video playing, rewinding, or fast-forwarding.
*   **During content music playback:**
    
    *   Pressing the rewind or fast-forward button skips to the previous or next track/item in the playlist.
*   **During ad playback:**
    
    *   Usually, users are not allowed to fast-forward an ad that is playing.
    *   Users should be allowed to rewind within an ad, and even rewind past the ad back into the content video.
    *   If users are rewinding or fast-forwarding from content video playback, they must be allowed to go past any point an ad would normally play. For example, users can fast-forward from the 5-minute mark to the 45-minute mark, passing by several ad play points.
    *   If they do fast-forward past an ad play point, when playback is resumed the system can play an ad first before resuming the content video (As compensation for having fast-forwarded over an ad).

DynamicMiniKeyboard
===================

Extends [DynamicKeyboardBase](/docs/references/scenegraph/dynamic-voice-keyboard-nodes/dynamic-keyboard-base.md "**DynamicKeyboardBase**")

The **DynamicMiniKeyboard** node is similar to the [legacy **MiniKeyboard** node](/docs/references/scenegraph/widget-nodes/minikeyboard.md), but with additional voice entry functionality. It enables text and voice entry of letters A-Z and digits 0-9. It is typically used for entering a search query.

The key layout is fixed based on the node's pre-built Key Definition File.

![roku815px - dynamic-mini-keyboard](https://image.roku.com/ZHZscHItMTc2/dynamic-mini-keyboard.jpg)

Fields
------

The DynamicMiniKeyboard node inherits all its fields from its parent [DynamicKeyboardBase](/docs/references/scenegraph/dynamic-voice-keyboard-nodes/dynamic-keyboard-base.md) node class. See the [DynamicKeyboardBase](/docs/references/scenegraph/dynamic-voice-keyboard-nodes/dynamic-keyboard-base.md) and its base classes ([Group](/docs/references/scenegraph/layout-group-nodes/group.md) and [Node](/docs/references/scenegraph/node.md)) for descriptions of the fields that can be configured.

Default VoiceTextEditBox settings
---------------------------------

| Field | Type | Default | Description |
| --- | --- | --- | --- |
| voiceEntryType | string | "alphanumeric" | The type of characters accepted via voice entry. |
| voiceEnabled | boolean | true | Specifies whether voice entry is enabled for the text edit box of the **DynamicMiniKeyboard**. |
| maxTextLength | integer | 75  | The maximum number of characters that may be entered into the text edit box of the **DynamicMiniKeyboard**. |

Sample app
----------

You can download and install a [sample app](https://github.com/rokudev/dynamic-voice-enabled-keyboards) that demonstrates how to create and configure a dynamic voice-enabled mini-keyboard.

RowList
=======

Extends [**ArrayGrid**](/docs/references/scenegraph/abstract-nodes/arraygrid.md)

The RowList node class provides a vertically-scrollable list, containing rows of independent horizontally-scrollable individual items. Each item in a row can include a poster, but can also include much more complex sub-elements defined in an item component file, in the same way that items are defined in the [MarkupList](/docs/references/scenegraph/list-and-grid-nodes/markuplist.md) and [MarkupGrid](/docs/references/scenegraph/list-and-grid-nodes/markupgrid.md) node classes. The RowList node class includes interface fields for customizing the appearance as the user scrolls up and down through the rows.

Like those node classes, the RowList node class provides special interface fields to the item components to allow custom appearance and animations as the user scrolls left and right through the items in a row.

> You can use the [ZoomRowList](/docs/references/scenegraph/list-and-grid-nodes/zoomrowlist.md) node class to enlarge the row in the RowList that currently has focus. In addition to providing a zoomed focus row, the ZoomRowList features custom row item and row decoration components, unique zooming amounts for individual rows, and separate heights for zoomed/unzoomed row items.

Guidelines
----------

The following are guidelines for use of rows and images.

*   The items in any single row must be the same size, however different rows in the list can have different item sizes (see sample image below).
*   Each row may include a left-justified title label at the top of the row, and a right-justified label at the top that displays a message of the format "_item\_number_ of _total\_number\_of\_items_", indicating which item in the row currently has focus.

#### Horizontal Row Scrolling

There are three horizontal item scrolling options for the RowList node class controlled by the `rowFocusAnimationStyle` field.

*   Setting the `rowFocusAnimationStyle` field to `floatingFocus` causes the focus indicator to float left or right until it reaches the end of the row, at which point the focus will stay fixed on the first or last item in the row, and the items will scroll left or right.
*   Setting the `rowFocusAnimationStyle` field to `fixedFocusWrap` causes each row to wrap around when navigation reaches the first or last item in the row, as long as the row contains enough items to fill the row. If the row does not contain enough items to fill the row, the focus will float left and right.
*   Setting the `rowFocusAnimationStyle` field to `fixedFocus` causes the focus to stay fixed on the first item in each row. As the user scrolls, the previous selected item goes off the screen. Scrolling continues until the last item is reached with no wrapping.

#### Vertical Row Scrolling

The vertical row scrolling options are controlled by the `vertFocusAnimationStyle` field, and behave in the same way for rows as they do for list items as described in [**ArrayGrid**](/docs/references/scenegraph/abstract-nodes/arraygrid.md).

The RowList node class supports two types of item definitions.

*   The first type provides a simple option for the common case where each item in each row is displayed as a single poster.
*   The second variation allows the contents of each item in each row to be an instance of a SceneGraph component that defines a set of interface fields that provide for communication between the RowList node and the items it displays (similar to that used by the MarkupList and MarkupGrid node classes).

Example
-------

The following is a sample screenshot of RowList based on SimpleRowlist sample code:

![roku815px - rowlist1](https://image.roku.com/ZHZscHItMTc2/rowlist1.png "rowlist1")

In the field descriptions below, the first type is referred to as _simple_, and the second type is referred to as _component_. Most of the field descriptions below apply to both simple and component types.

Behavior
--------

Whenever all the items in a RowList row are visible, the focus will step one-by-one across the items, rather than step once, then smooth scroll.

Each time the RowList focus animation completes a step, the RowList's rowItemFocused field will be set. This allows the Bob to be immediately updated. This will happen when long press scrolling after the initial step ends prior to the smooth scrolling. It will also happen when long press scrolling across a short RowList row as the focus now steps one-by-one across the items in a short row. Previously, the rowItemFocused field was only set once after a long press scrolling key release event.

Fields
------

FieldTypeDefaultAccess PermissionDescriptionitemComponentNamestringREAD\_WRITESpecifies the name of an XML component for the items in each row. An instance of this component is created on demand for each visible item of each row. The XML component must define a specific interface as detailed in [RowList XML Component](/docs/references/scenegraph/list-and-grid-nodes/rowlist.md#rowlist-xml-component) below.rowTitleComponentNamestringREAD\_WRITESpecifies the name of an XML component to render titles in place of the row label. This component must extend from [Group](/docs/references/scenegraph/layout-group-nodes/group.md). If this component defines a "content" field, it will be set to the row's content. If this component defines a "rowCounterVertAlign" field (possible values are "top", "center", and "bottom"), the row counter's vertical alignment is respective of the row title component.contentContentNodenoneREAD\_WRITESpecifies the content for the list. The content should be a single ContentNode that has one child ContentNode for each row. These child ContentNodes for each row should themselves contains child ContentNodes for each item in the row. See [Data Bindings](/docs/references/scenegraph/list-and-grid-nodes/rowlist.md#data-bindings) below for more details.itemSizevector2d\[0,0\]READ\_WRITESpecifies the width and height of rows in the list. Note that this the width of the entire row, not the width of the posters in the row.itemSpacingvector2d\[0,0\]READ\_WRITESpecifies the spacing between rows in the list. The y-dimension of the vector specifies the vertical spacing between rows, and the x-dimension is ignored.numRowsinteger0READ\_WRITESpecifies the number of visible rows in the list. Note that the actual number of rows may be more or less than the number of visible rows depending on the number of items in the list content.rowHeightsarray of floats\[ \]READ\_WRITESpecifies the heights of each row of the list. This allows the height of each row of the list to vary from row to row. The values override the height specified in the y-dimension value of the `itemSize` field. If the array contains fewer elements than the number of rows in the data model, the y-dimension value of the `itemSize` field is used as the height of the extra rows.rowSpacingsarray of floats\[ \]READ\_WRITESpecifies the spacing after each row of the list. This allows the spacing between rows to vary from row to row. The values override the vertical spacing specified in y-dimension value of the `itemSpacing` field. If the array contains fewer elements than the number of rows in the data model, the y-dimension value of the `itemSpacing` field is used as the spacing after the extra rows.rowItemSizearray of vector2d\[ \]READ\_WRITESpecifies the width and height of the items in each row. The array of values must include at least one element. If the array contains fewer elements than the number of rows in the data model, the last value in the array is used as the size for the extra rows.rowItemSpacingarray of vector2d\[ \]READ\_WRITESpecifies the spacing between items in each row. The x-dimension of each array value specifies the horizontal spacing between list items in the corresponding row. If the array contains fewer elements than the number of rows in the data model, the last value in the array is used as the spacing for the extra rows. If the array contains no values, no space will be included between list items in all rows.focusXOffsetarray of floats\[ \]READ\_WRITESpecifies the x-dimension offset of the first fully visible item in each row relative to the left edge of the list. In most cases, the first fully visible item in each row will be positioned at the left edge of the list, so this field does not need to be specified. If the array contains fewer elements than the number of rows in the data model, the last value in the array is used as the x-dimension offset for the extra rows. If the array contains no values, the default x-dimension offset of 0.0 is used.rowLabelOffsetarray of vector2d\[0,0\]READ\_WRITESpecifies the offset of the row label for each row. The x-dimension specifies the horizontal offset of the label from the left edge of the row. The y-dimension component specifies the vertical spacing between the label and the list items in the row. If the array contains fewer elements than the number of rows in the data model, the last value in the array is used as the offset for the labels of the extra rows. If the array specified contains no values, a default offset value of \[0,0\] is used.showRowLabelarray of Boolean\[ \]READ\_WRITESpecifies whether the row label on the left edge of each row is displayed. If the array contains fewer elements than the number of rows in the data model, the last value in array is used to control the display of the row label for the extra rows. If the array contains no values, no row labels are displayed.showRowCounterarray of Boolean\[ \]READ\_WRITESpecifies whether the "item\_number of total\_number\_of\_items" label on the right edge of each row is displayed. Note that the "item\_number of total\_number\_of\_items" label is only displayed for the focused row even if the `showRowCounter` field value for that row is set to true. If the array contains fewer elements than the number of rows in the data model, the last value in array is used to control the display of the "item\_number of total\_number\_of\_items" label for the extra rows. If the array contains no values, no "item\_number of total\_number\_of\_items" labels are displayed.indefiniteRowItemCountarray of Boolean\[ \]READ\_WRITEFor each row, a value of true indicates that a "+" character should be appended to the "total\_number\_of\_items" label in the UI (which should be the case when there are unfetched pages beyond what is currently accessible/visible, e.g., "Item 4 of 30+").variableWidthItemsarray of Boolean\[ \]READ\_WRITEThis field is only supported when `rowFocusAnimationStyle = "fixedFocusWrap"`  
  
By default, all items in a row of the RowList node have the same width and height. By setting `variableWidthItems` to true for a row, the items in the row will continue to have the same height, but the width will be taken from the `[SD/HD/FHD]ItemWidth` field of the ContentNode associated with each item. See [Data Bindings](/docs/references/scenegraph/list-and-grid-nodes/rowlist.md#data-bindings) below for more details.  
  
`variableWidthItems` is an array with one element per row in the RowList. If there are fewer elements than rows in the RowList, the last value in the array is repeated. If all rows of the RowList have variable widths, you can set `variableWidthItems="[true]"` or `variableWidthItems="true"`.  
  
The `[SD/HD/FHD]ItemWidth` values specified should match the `ui_resolutions` attribute in the manifest.  
  
Example: If you only specify `ui_resolutions=fhd`, you should only set `FHDItemWidth` and allow the device to autoscale when rendering for HD and SD display modes. If you specify `ui_resolutions=hd`,fhd, you can set `HDItemWidth` and `FHDItemWidth`.  
  
If any item does not specify the `[SD/HD/FHD]ItemWidth` in its ContentNode for a variable width row, the `x` value of the RowList's `rowItemSize` field for that row is used as the `width` for that item.rowFocusAnimationStyleoption stringfloatingFocusREAD\_WRITESpecifies the how the focus indicator moves in a row of items in response to the remote direction pad Left and Right key presses. The possible values are:  
  

| Option | Effect |
| --- | --- |
| floatingFocus | Causes the focus indicator to float left or right until it reaches the end of the row, at which point the focus indicator will stay fixed on the first or last item in the row, and the items will scroll left or right if there were items that were not visible. |
| fixedFocusWrap | Causes the row to wrap around when the focus indicator reaches the first or last item in the row, as long as the row contains enough items to fill the row. If the row does not contain enough items to fill the row, the focus indicator will float left and right. |
| fixedFocus | Causes the focus to stay fixed on the first item in each row. As the user scrolls, the previous selected item goes off the screen. Scrolling continues until the last item is reached with no wrapping. |

vertFocusAnimationStyleoption stringfixedFocusREAD\_WRITESpecifies the how the focus indicator moves in a list or a column of grid items in response to the remote direction pad Up and Down key presses. The possible values are:  
  

| Option | Effect |
| --- | --- |
| floatingFocus | Causes the focus indicator to float up or down until it reaches the end of the list, at which point the focus indicator will stay fixed on the first or last row in the list, and the rows will scroll up or down if there are rows that were not visible. |
| fixedFocusWrap | Causes the column to wrap around when the focus indicator reaches the first or last row in the list, as long as the list contains enough rows to fill the list. If the list does not contain enough rows to fill the list, the focus indicator will float up and down. |
| fixedFocus | Causes the focus to stay fixed on the upper row. As the user scrolls down, the row containing the previously selected item scrolls up off screen. Scrolling continues until the last row is reached. |

rowLabelColorcolor0xffffffffREAD\_WRITESpecifies the color of the row and "`item_number of total_number_of_items`" labels.rowLabelFontfontsystem defaultREAD\_WRITESpecifies the font for the row and "`item_number of total_number_of_items`" labels.rowCounterRightOffsetfloatREAD\_WRITEField provides greater control over the UX.  
  
When set, this value specifies the location of the right edge of the row counter relative to right edge of the RowList's clipping rectangle. If not set, the right edge of the row counter is positioned to equal the left offset of the row title.showRowCounterForShortRowsBooleantrueREAD\_WRITEField provides greater control over the UX.  
  
When set to true, the row counter is shown for all rows. When set to false, the row counter is not shown for rows where all items fit onscreen.fadeFocusFeedbackWhenAutoScrollingBooleanfalseREAD\_WRITEWhen set to true, the focus feedback indicator will quickly fade out when scrolling multiple items and fade back in when the scrolling ends. The focus feedback indicator will also after in and out when using the FFW/Rewind keys to scroll a page at a time.  
  
Note: This field is defined on [ArrayGrid](/docs/references/scenegraph/abstract-nodes/arraygrid.md) and thus is inherited by all of the following components: LabelList, MarkupList, PosterGrid, MarkupGrid, RowList, CheckList, and RadioButtonList.currFocusFeedbackOpacityfloatREAD\_ONLYThis field provides access to the current opacity of the focus feedback indicator. It can be used to have other items on the screen fade in/out when the focus feedback indicator fades in/out.  
  
Note: This field is defined on [ArrayGrid](/docs/references/scenegraph/abstract-nodes/arraygrid.md) and thus is inherited by all of the following components: LabelList, MarkupList, PosterGrid, MarkupGrid, RowList, CheckList, and RadioButtonList.drawFocusFeedbackOnTopBooleanfalseREAD\_WRITESpecifies whether the focus indicator bitmap is drawn below or on top of the list items.drawFocusFeedbackBooleantrueREAD\_WRITESpecifies whether or not the focus indicator bitmap is displayed.imageWellBitmapUriuriREAD\_WRITESpecifies the bitmap file to use to suggest where images would appear for empty lists.focusBitmapUriuriREAD\_WRITESpecifies the bitmap file used for the focus indicator when the list has focus. In most cases, this should be a [9-patch image](https://image.roku.com/ZHZscHItMTc2/focus-9.png) that specifies both expandable regions as well as margins. Only set this field to specify a custom bitmap that differs in appearance from the default bitmap.focusFootprintBitmapUriuriREAD\_WRITESpecifies the bitmap file used for the focus indicator when the list does not have focus. In most cases, this should be a 9-patch image that specifies both expandable regions as well as margins. Only set this field to specify a custom bitmap that differs in appearance from the default bitmap.focusBitmapBlendColorcolor0xFFFFFFFFREAD\_WRITEBlend the graphic image specified by `focusBitmapUri` with the specified color. If set to the default, 0xFFFFFFFF, no color blending will occur. Set this field to show a focus indicator graphic image with a different color than the image specified by `focusBitmapUri`.focusFootprintBlendColorcolor0xFFFFFFFFREAD\_WRITEBlend the graphic image specified by `focusFootprintBitmapUri` with the specified color. If set to the default, 0xFFFFFFFF, no color blending will occur. Set this field to show a focus footprint indicator graphic image with a different color than the image specified by `focusFootprintBitmapUri`.loadingBitmapUriuriREAD\_WRITESpecifies a bitmap file to display while a list item poster is loading.  
  
To execute a seamless cross-fade transition between posters, set the **loadingBitmapUri** of the next poster to be shown to the uri of the currently displayed poster.loadingBitmapOpacityfloat1.0READ\_WRITESpecifies an opacity value used to render the loading bitmap.failedBitmapUriuriREAD\_WRITESpecifies a bitmap file to display when a list item poster fails to load.failedBitmapOpacityfloat1.0READ\_WRITESpecifies an opacity value used to render the failed bitmap.wrapDividerBitmapUriuriREAD\_WRITESpecifies the bitmap file to use as a visual separator between the last and first list items when the list wraps. In most case, this should be a 9-patch image that specifies both expandable regions. Only set this field to specify a custom bitmap that differs in appearance from the default bitmap.wrapDividerHeightfloat0READ\_WRITESpecifies the height of the divider. The wrap divider bitmap will be scaled to this height. The width of the wrap divider is set to the width of the list items (that is, the x-dimension value of the `itemSize` field).rowItemSelectedarray of integer\[ \]READ\_ONLYWhen an item is selected, set to a 2-element array, where element 0 contains the index of the row containing the selected item, and element 1 contains the index of the selected item in that row.rowItemFocusedarray of integer\[ \]READ\_ONLYWhen an item gains the key focus, set to a 2-element array, where element 0 contains the index of the focused row, and element 1 contains the index of the focused item in that row.currFocusColumnfloat0.0READ\_WRITEIndicates which column of the currently focused row in a RowList component currently has focus. This field is typically used to implement a horizontal pagination mechanism for the currently focused row.  
  
If this value is set to 3.7, it means that item 3 occupies 30% of the currently focused row while item 4 occupies 70% of it.  
  
To maximize performance, the field should be kept to a minimum, as these scripts will run once during each render.itemSelectedinteger0READ\_ONLYWhen an item is selected, set to the index of the selected row.itemFocusedinteger0READ\_ONLYWhen a row gains the key focus, set to the index of the focused row.itemUnfocusedinteger0READ\_ONLYWhen a row loses the key focus, set to the index of the unfocused row.jumpToIteminteger0WRITE\_ONLYWhen set to a valid item index, causes the list to immediately update so that the specified row moves into the focus position.jumpToRowItemarray of integer\[ \]WRITE\_ONLYWhen set to a valid \[ row, col \] index pair, causes the list to immediately update so that the specified row, col item moves into the focus position.animateToIteminteger0WRITE\_ONLYWhen set to a valid item index, causes the list to quickly scroll so that the specified row moves into the focus position.

RowList XML component
---------------------

If the RowList node is to use an XML component, the `itemComponentName` field value should be set to the name of an XML component used to display each item in the row list. An instance of this component is created for each visible item in each row of the list.

If the XML component contains interface fields that match the names shown in the table below, those fields will be updated by the RowList node. This allows the XML component to alter the item appearance based on changes to these interface fields.

Note that the fields are updated in the order presented in the table below. Any layout scripting you write based on these fields should be done in that order to avoid updating your layout based on a field that has not been updated yet.

| Field Name | Field Type | Access Permission | Description |
| --- | --- | --- | --- |
| width | float | READ\_ONLY | Set to the width of the item. |
| height | float | READ\_ONLY | Set to the height of the item |
| index | integer | READ\_ONLY | Set to the data model index within the data for the row that contains this item. For example, if this appeared in row 2, then the field is set to 0 for the first item in row 2, 1 for the second item in row 2, and so on. |
| rowIndex | integer | READ\_ONLY | Set to the data model index of the row that contains this item |
| rowHasFocus | Boolean | READ\_ONLY | Set to true if the row that contains this item has focus, false otherwise. |
| rowListHasFocus | Boolean | READ\_ONLY | Set to true if the row list that contains this item has focus, false otherwise. |
| itemContent | ContentNode | READ\_WRITE | Contains the data to be displayed by the row list item. The relationship between data in the ContentNode and the visual elements of the row list item is determined by the scripts in the item XML component. Typically, an observer callback function of the `itemContent` field is used to update the row list item when the content changes. |
| focusPercent | Float | READ\_ONLY | The fractional value, from 0.0 to 1.0, of a time delay after focus has moved from one item in a row to the next. The fractional value increases incrementally from 0.0 to 1.0 for the newly-focused item, while simultaneously decreasing from 1.0 to 0.0 for the previously-focused item. This value can be used as a timing key to smoothly animate the appearance of the focused item as well as the previously-focused item, to indicate the movement of focus to the user. |
| rowFocusPercent | float | READ\_ONLY | The fractional value, from 0.0 to 1.0, of a time delay after focus has moved from an item in one row to an item in an adjacent row, either above or below the previously-focused row. The fractional value increases incrementally from 0.0 to 1.0 for the newly-focused row, while simultaneously decreasing from 1.0 to 0.0 for the previously-focused row. This value can be used as a timing key to smoothly animate the appearance of the focused row as well as the previously-focused row, to indicate the movement of focus to the user. |
| itemHasFocus | Boolean | READ\_ONLY | Indicates whether the item component currently is the RowList's focused item. When scrolling starts, the itemHasFocus field for the currently focused item is set to false. When scrolling ends, the itemHasFocus field for the newly focused item is set to true. During the scrolling animation, all itemHasFocus fields are set to false.  <br>  <br>Only one item component of any RowList should have itemHasFocus set to true. If the RowList does not focus, all itemHasFocus fields of their item components should be set to false. |

Data bindings
-------------

A RowList node should have a single ContentNode as the root node in its content field. One child ContentNode should be added to the root node for each row in the list (these nodes can be thought of as row nodes). Each row node should contain one child ContentNode for each item in the row (these nodes can be thought of as item nodes).

### Row node data bindings

| Attribute | Type | Description |
| --- | --- | --- |
| TITLE | string | The label for the row |

Item node data bindings
-----------------------

| Attribute | Type | Description |
| --- | --- | --- |
| FHDGRIDPOSTERURL / FHDPOSTERURL | uri | The image file for the item poster when the screen resolution is set to FHD. FHDGRIDPOSTERURL is used if non-empty. FHDPOSTERURL is used otherwise. |
| HDGRIDPOSTERURL / HDPOSTERURL | uri | The image file for the item poster when the screen resolution is set to HD. HDGRIDPOSTERURL is used if non-empty. HDPOSTERURL is used otherwise. |
| SDGRIDPOSTERURL / SDPOSTERURL | uri | The image file for the item poster when the screen resolution is set to SD. SDGRIDPOSTERURL is used if non-empty. SDPOSTERURL is used otherwise. |
| FHDItemWidth | float | The width for the FHD item. This value is used in conjunction with `variableWidthItems` and should only be set if the associated `ui_resolutions` attribute is also specified.  <br>  <br>This field must be added to the ContentNode via [addField()](/docs/references/brightscript/interfaces/ifsgnodefield.md#addfieldfieldname-as-string-type-as-string-alwaynotify-as-boolean-as-boolean) prior to setting a value. Ex. `ContentNode.addField("FHDItemWidth", "float", false)` |
| HDItemWidth | float | The width for the HD item. This value is used in conjunction with `variableWidthItems` and should only be set if the associated `ui_resolutions` attribute is also specified.  <br>  <br>This field must be added to the ContentNode via [addField()](/docs/references/brightscript/interfaces/ifsgnodefield.md#addfieldfieldname-as-string-type-as-string-alwaynotify-as-boolean-as-boolean) prior to setting a value. Ex. `ContentNode.addField("HDItemWidth", "float", false)` |
| SDItemWidth | float | The width for the SD item. This value is used in conjunction with `variableWidthItems` and should only be set if the associated `ui_resolutions` attribute is also specified.  <br>  <br>This field must be added to the ContentNode via [addField()](/docs/references/brightscript/interfaces/ifsgnodefield.md#addfieldfieldname-as-string-type-as-string-alwaynotify-as-boolean-as-boolean) prior to setting a value. Ex. `ContentNode.addField("SDItemWidth", "float", false)` |

RowList sample apps
-------------------

The follow sample apps can be installed on your local device for testing and reviewing the code.

| Sample download | Description |
| --- | --- |
| [SimpleRowList](https://github.com/rokudev/samples/tree/master/ux%20components/lists%20and%20grids) | Simple example app using the RowList node class. This sample creates a two row RowList node using an item component definition, that is, it specifies custom markup for the individual items in the row. |
| [RowListFocusStyleTest](https://github.com/rokudev/samples/tree/master/ux%20components/lists%20and%20grids) | A more complex example app that demonstrates a number of different focus styles, as well as ways to mix different sized images in different RowList rows. |
| [AdvancedRowList](https://github.com/rokudev/samples/tree/master/ux%20components/lists%20and%20grids) | Example demonstrating use of RowList in a PanelSet. This example includes RowList loading real data from a JSON file, mixed aspect ratio posters, and the use of focusPercent to overlay annotations. |
| [variableWidthRowList](https://github.com/rokudev/samples/tree/master/ux%20components/lists%20and%20grids) | A simple example demonstrating variable width items. The first row in the RowList contains large hero artwork and each subsequent row contains a mix of different aspect ratio posters for TV and Movie artwork. |

Sample app
----------

[RowListExample](https://github.com/rokudev/samples/tree/master/ux%20components/lists%20and%20grids/RowListExample) is a sample app demonstrating RowList in action.

roArray
=======

An array stores an indexed collection of BrightScript objects. Each entry of an array can be a different type, or they may all of the same type.

An roArray is created with two parameters:

**CreateObject("roArray", size as Integer, resize as Boolean)**

Size is the initial number of elements allocated for the array. If resize is true, the array will be resized if needed to accommodate more elements. If the array is large, this might be slow. The "dim" statement may be used instead of CreateObject to allocate a new array. Dim has the advantage in that it automatically creates arrays of arrays for multi-dimensional arrays.

Supported interfaces
--------------------

*   [ifArray](/docs/references/brightscript/interfaces/ifarray.md "ifArray")
*   [ifArrayGet](/docs/references/brightscript/interfaces/ifarrayget.md "ifArrayGet")
*   [ifArraySet](/docs/references/brightscript/interfaces/ifarrayset.md "ifArraySet")
*   [ifEnum](/docs/references/brightscript/interfaces/ifenum.md "ifEnum")
*   [ifArrayJoin](/docs/references/brightscript/interfaces/ifarrayjoin.md "ifArrayJoin")
*   [ifArraySort](/docs/references/brightscript/interfaces/ifarraysort.md "ifArraySort")
*   [ifArraySlice](/docs/references/brightscript/interfaces/ifarrayslice.md "ifArraySlice")

roAudioPlayer
=============

The Audio Player object provides the ability to setup the playing of a series of audio streams. The object accepts an array of content meta-data objects, describing the audio and providing URLs for accessing each stream. The component understands the following streamformat values: "mp3", "mp4", "hls", "es.aac-adts", "flac."

This object does not provide an interface to a screen. In order to get events both from the screen you are using and the Audio Player, you should use the same Message Port for both objects.

This object is created with no parameters:

`CreateObject("roAudioPlayer")`

**Example**

    Sub Main()
        audioPlayer = CreateObject("roAudioPlayer")
        port = CreateObject("roMessagePort")
        audioPlayer.SetMessagePort(port)
        song = CreateObject("roAssociativeArray")
        song.url = "https://file-examples.com/storage/feb401d325641db2fa1dfe7/2017/11/file_example_MP3_700KB.mp3"
        audioplayer.addcontent(song)
        audioplayer.setloop(false)
        audioPlayer.play()
        while true
                msg = wait(0, port)
                if type(msg) = "roAudioPlayerEvent"
                        if msg.isStatusMessage() then
                            print "roAudioPlayerEvent: "; msg.getmessage()
                            if msg.getmessage() = "end of playlist" return
                        endif
                endif
            end while
    End Sub
    

Supported interfaces
--------------------

*   [ifAudioPlayer](/docs/references/brightscript/interfaces/ifaudioplayer.md "ifAudioPlayer")
*   [ifHttpAgent](/docs/references/brightscript/interfaces/ifhttpagent.md "ifHttpAgent")
*   [ifSetMessagePort](/docs/references/brightscript/interfaces/ifsetmessageport.md "ifSetMessagePort")
*   [ifGetMessagePort](/docs/references/brightscript/interfaces/ifgetmessageport.md "ifGetMessagePort")

Supported events
----------------

*   [roAudioPlayerEvent](/docs/references/brightscript/events/roaudioplayerevent.md "roAudioPlayerEvent")

Enabling billing testing
========================

Developers can designate one public or beta app for "billing testing" to observe output from the SceneGraph ChannelStore node in the debug console when the app is sideloaded. The billing testing feature provides developers with visibility into the confirmations, error codes, and other transactional metadata related to purchases made with Roku Pay.

When an app enabled for "billing testing" is sideloaded, calls to the ChannelStore node will use the product catalog associated with that app. Developers should therefore upload a package file that reflects the actual app being tested. This is because the product catalog of the app designated for "billing testing" is always returned regardless of the actual UI or behavior the package that is sideloaded.

> Sideloaded "billing testing" apps make live calls to the ChannelStore node and thus generate actual billing transactions. Developers must therefore add themselves as Test Users to the "billing testing" app to avoid incurring any billing charges while testing the app.
> 
> To use an app for billing testing:
> 
> *   The app must be the only one in the developer's account designated for billing testing.
> *   The "billing testing" app may only be used by the [root account user](/docs/features/dashboard/user-access-management.md).
> *   The [root account user](/docs/features/dashboard/user-access-management.md) must be designated as a Test User.
> *   The Test User's Roku account must be linked to the Roku device on which the app is sideloaded.
> *   The app must be sideloaded on the Roku device.

Enabling billing testing with new app publishing workflow
---------------------------------------------------------

To enable billing testing on an app with the new app builder UI, follow these steps:

1.  In the [Developer Dashboard](https://developer.roku.com/developer), click **Public apps** or **Beta apps** for whichever app type you want to use for billing testing. You can only use one public or beta app at a time for billing testing.

2.  Confirm that no other app is currently being used for billing testing. An app designated for billing testing is a tagged with a "Billing Test" label and it is listed at the top.
    
    ![roku815px - stop-billing-testing](https://image.roku.com/ZHZscHItMTc2/billing-testing-enabled-label.png)
    

3.  If another app is being used for billing testing, click the shortcut menu for the app to the right, and then click **Stop using for billing testing**.
    
    ![roku815px - stop-billing-testing](https://image.roku.com/ZHZscHItMTc2/billing-testing-stop-blilling-testing.png)
    

4.  Click the shortcut menu for the app to be used for billing testing and then click **Use for billing testing**.
    
    ![roku815px - stop-billing-testing](https://image.roku.com/ZHZscHItMTc2/billing-testing-enable.png)
    

5.  The selected app is tagged with the "Billing Test" label and is ready to be used for testing.
    
    ![roku815px - stop-billing-testing](https://image.roku.com/ZHZscHItMTc2/billing-testing-enable-label.png)
    

Enabling billing testing with legacy app publishing workflow
------------------------------------------------------------

To enable billing testing on an app with the legacy app builder UI, follow these steps:

1.  In the [Developer Dashboard](https://developer.roku.com/developer), select **My Channels**.
    
    ![roku815px - manage-my-channels](https://image.roku.com/ZHZscHItMTc2/manage-my-channels-v2a.png)
    

2.  Confirm that no other apps are currently being used for billing testing ("designated for billing testing" is displayed in the app summary if billing testing is enabled on an app). If another app is being used for billing testing, click **Options** to the right of the app summary, and then click **Stop using for billing testing**.
    
    ![roku815px - stop-billing-testing](https://image.roku.com/ZHZscHItMTc2/stop-billing-testing-v4b.png)
    

3.  On the app to be used for billing testing, click **Options**, and then click **Use for billing testing**.
    
    ![roku815px - use-billing-testing](https://image.roku.com/ZHZscHItMTc2/use-billing-testing-v2a.png)

ifXMLElement
============

Implemented by
--------------

| Name | Description |
| --- | --- |
| [roXMLElement](/docs/references/brightscript/components/roxmlelement.md "roXMLElement") | roXMLElement is used to contain an XML tree |

Supported methods
-----------------

### Parse(xml as String) as Boolean

#### Description

Parses a string of XML.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| xml | String | The XML string to be parsed |

#### Return Value

A flag indicating whether the operation was successful. In that case, other methods below can then be used to extract information about the parsed element.

### GetBody() as Object

#### Description

Returns the body of the element. If the element contains child elements, `GetBody()` returns an [roXMLList](/docs/references/brightscript/components/roxmllist.md "roXMLList") representing those elements, like GetChildElements(). If there are no children but the element contains text, `GetBody()` returns an [roString](/docs/references/brightscript/components/rostring.md "roString") like `GetText()`. If the element is empty, `GetBody()` returns invalid.

#### Return Value

Object body.

### GetAttributes() as Object

#### Description

Returns the XML attributes of the element.

#### Return Value

An associative array representing the XML attributes of the element.

### GetName() as String

#### Description

Returns the name of the element.

#### Return Value

Element name.

### GetText() as String

#### Description

Returns any text contained in the element. This returns immediate body text only (for example, it does not include text from child elements).

#### Return Value

The text in the element.

### GetChildElements() as Object

#### Description

If this element contains any child elements, this method returns an [roXMLList](/docs/references/brightscript/components/roxmllist.md "roXMLList") representing those elements. If there are no child elements, returns invalid.

This function won't handle cases of mixed XML content, i.e., content with both child elements and text such as: Child TextMore Text. In this case `GetChildElements()` called with the top level as an argument would return an roXMLList containing only one item corresponding to the element. The body text "More Text" would be lost. To handle mixed content cases, use `GetChildNodes()`.

#### Return Value

An element list.

### GetChildNodes() as Object

#### Description

If this element contains any child elements, this method returns an [roList](/docs/references/brightscript/components/rolist.md "roList") representing those elements. If there are no child elements, returns invalid. The difference between this function and `GetChildElements()` is that `GetChildNodes()` handles the case of mixed XML content, i.e., content with both child elements and text such as: Child TextMore Text. In this case `GetChildNodes()` called with the top level as an argument would return an roList with two elements. The first element would be an `roXMLElement` containing the information about. The second would be an `roString` containing "More Text".

#### Return Value

An element list.

### GetNamedElements(name as String) as Object

#### Description

Returns an [roXMLList](/docs/references/brightscript/components/roxmllist.md "roXMLList") representing all child elements of this element whose case-sensitive name is specified. If only one element matches the name, an roXMLList containing one element is returned. If no elements match, an empty roXMLList is returned.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| name | String | The parent element containing the child elements to be listed. Matching of the parent element name is case-sensitive. |

#### Return Value

An element list.

### GetNamedElementsCi(name as String) as Object

#### Description

Returns an [roXMLList](/docs/references/brightscript/components/roxmllist.md "roXMLList") representing all child elements of this element whose case-insensitive name is specified. If only one element matches the name, an roXMLList containing one element is returned. If no elements match, an empty roXMLList is returned.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| name | String | The parent element containing the child elements to be listed. Matching of the parent element name is case-sensitive. |

#### Return Value

An element list.

### IsName(name as String) as Boolean

#### Description

Checks whether the element has the specified name.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| name | String | The element name to be verified. |

#### Return Value

A flag indicating whether the element has the specified name.

### HasAttribute(attr as String) as Boolean

Checks whether the element has the specified attribute.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| attr | String | The element attribute to be verified. |

#### Return Value

A flag indicating whether the element has the specified attribute.

### SetBody(body as Object) as Void

#### Description

Sets the element text from the specified string

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| body | Object | The string to be used to set the element text. |

### AddBodyElement() as Object

#### Description

Adds a new unnamed/empty child element and returns it. This should generally be followed by a call to the [SetName()](#setnamename-as-string-as-void) method of the child element. Alternatively, the [AddElement()](#addelementname-as-string-as-object) or [AddElementWidthBody()](#addelementwithbodyname-as-string-body-as-object-as-object) method can be used to combine this step with additional construction into one call.

#### Return Value

Object value.

### AddElement(name as String) as Object

#### Description

Adds a new child element with the specified name and returns the new element.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| name | String | The name of the child element to be added. |

#### Return Value

The new element added.

### AddElementWithBody(name as String, body as Object) as Object

#### Description

Adds a new child element with the specified name and text from the specified body string, and returns the new element.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| name | String | The name of the child element to be added. |
| body | Object | The text of the child element to be added (via the body string). |

#### Return Value

The new element added.

### AddText(text as String) as Void

#### Description

Adds text to the element.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| text | String | The text to be added to the element. |

### AddAttribute(attr as String, value as String) as Void

#### Description

Adds an attribute value to the element. If an attribute of the same name already exists it is replaced. XML attribute order is not preserved.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| attr | String | The name of the attribute to be added to the element. |
| value | Object | The value of the attribute being added to the element. |

### SetName(name as String) as Void

#### Description

Sets the name of the element.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| name | String | The name of the element. |

### GenXML(gen\_header as Boolean) as String

#### Description

Serializes the element to XML document text.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| gen\_header | Boolean | Specifies whether the output begins with a standard XML declaration specifying UTF-8 encoding. |

#### Return Value

A serialized string.

### GenXMLHdr(hdr as String) as String

#### Description

Serializes the element to XML document text. The specified header is used to begin the output (for example, as a custom XML declaration).

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| hdr | String | Specify the header with which the output begins. |

#### Return Value

A serialized string.

### Clear() as Void

#### Description

Removes all attributes and children from the element, as well as setting the name to empty.

ifSetMessagePort
================

Implemented by
--------------

| Name | Description |
| --- | --- |
| [roHdmiStatus](/docs/references/brightscript/components/rohdmistatus.md "roHdmiStatus") | The HDMI status component provides an interface to the current HDMI operational status |
| [roScreen](/docs/references/brightscript/components/roscreen.md "roScreen") | The roScreen component provides a full screen drawing surface that can be stacked and that you can receive input events from |
| [roUrlTransfer](/docs/references/brightscript/components/rourltransfer.md "roUrlTransfer") | A roUrlTransfer object transfers data to or from remote servers specified by URLs. It can perform mutual authentication with a web server |
| [roTextToSpeech](/docs/references/brightscript/components/rotexttospeech.md "roTextToSpeech") | The roTextToSpeech component provides text to speech capabilities to applications |

Supported methods
-----------------

### SetMessagePort(port as Object ) as Void

#### Description

Sets the [roMessagePort](/docs/references/brightscript/components/romessageport.md "roMessagePort") to be used for all events from the screen.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| Port | Object | The roMessagePort to be used for screen events. |

Timer
=====

Extends [**Node**](/docs/references/scenegraph/node.md)

The Timer node class generates an observable event after a specified amount of time has elapsed.

### Example

The following changes the text string on the display screen every five seconds as the Timer node generates a fire field observable event.

#### Timer Node Class Example

    <?xml version="1.0" encoding="utf-8" ?>
    
    <!--********** Copyright 2015 Roku Corp.  All Rights Reserved. **********-->
    
    <component   name="timertest"   extends="Group" >
    
    <script type="text/brightscript" >
    <![CDATA[
    
    sub init()
      m.testtimer = m.top.findNode("testTimer")
      m.testtimer.control = "start"
      m.defaulttext = "Wait for it, wait for it..."
      m.alternatetext = "Timer fired!!!"
    
      m.testtimerlabel = m.top.FindNode("testTimerLabel")
      m.testtimerlabel.text = m.defaulttext
      m.textchange = false
      m.testtimer.ObserveField("fire","changetext")
      m.top.setFocus(true)
    end sub
    
    sub changetext()
      if (m.textchange = false) then
        m.testtimerlabel.text = m.alternatetext
        m.textchange = true
       else
         m.testtimerlabel.text = m.defaulttext
         m.textchange = false
       end if
    end sub
    
    ]]>
    </script>
    
    <children>
    
    <Label
      id="testTimerLabel"
      width = "1280"
      translation = "[0,500]"
      horizAlign = "center"
      vertAlign = "center"
    />
    
    <Timer
      id="testTimer"
      repeat="true"
      duration="5"
    />
    
    </children>
    
    </component>
    

Fields
------

FieldTypeDefaultAccess PermissionDescriptioncontrolstringnoneREAD\_WRITEUsed to control the operation of the Timer node. Recognized values include:

| Value | Effect |
| --- | --- |
| none | No effect |
| start | Starts the **Timer** node operation |
| stop | Stops a running **Timer** node |

repeatBooleanfalseREAD\_WRITEIf set to true, the Timer node fires repeatedly, each time the specified duration field value elapses. If set to false, the Timer node only fires once until restarteddurationtime1READ\_WRITESpecifies the time in seconds before the Timer node fires after the control field value is set to start. To specify time values down to millisecond granularity, use a float type (0.001 equals one millisecond)fireEventN/AOBSERVE\_ONLYTriggers observer callback functions when the Timer node fires. Please note that the timer observer callback executes on the render thread

Sample app
----------

[TimerExample](https://github.com/rokudev/samples/tree/master/ux%20components/control/TimerExample) is a sample app demonstrating Timer in action.

StdDlgMultiStyleTextItem
========================

Extends [StdDlgItemBase](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-item-base.md)

Description
-----------

The **StdDlgMultiStyleTextItem** node enables developers to add a line of text with multiple styles to the content area of a custom dialog. A multi-style text item may include, for example, plain and bold characters, different fonts, multiple colors, and/or emojis.

*   The **drawingStyles** field contains one or more associative arrays that represent font styles. Each font style contains **fontSize**, **fontUri**, and **color** properties.
    
*   The **text** field uses a simple markup style. Markup tags with the names of the styles defined in the **drawingStyles** field are used to delineate the boundaries of the label text to be rendered in that specific style.
    

    msTextItem.drawingStyles = {
          "default": {
            "fontSize": {fhd:33,hd:22}
            "fontUri": "font:SystemFontFile"
            "color": "#EFEFEFFF"
          }
          "url": {
            "fontSize": {fhd:33,hd:22}
            "fontUri": "font:SystemFontFile"
            "color": "#00FF00FF"
          }
    }
    msTextItem.text = "This StdDlgMultiStyleTextItem renders the URL <url>http://www.roku.com</url> in bright green."
    

Fields
------

| Field | Type | Default | Access Permission | Description |
| --- | --- | --- | --- | --- |
| text | string | ""  | READ\_WRITE | Specifies the text to be displayed |
| drawingStyles | associative array of associative arrays | {}  | READ\_WRITE | Defines the size, URI, and color of a font style. This field may contain one or more font styles. |
| audioGuideText | string | ""  | READ\_WRITE | Specifies the string to be spoken when the screen reader reads the text item. By default, the screen reader reads the string specified in the **text** field. |

Example
-------

In this example, two drawing styles named "default" and "url" have been defined and assigned to the **drawingStyles** field of the **StdDlgMultiStyleTextItem** node. The roku.com URL is enclosed in tags, which renders the text with the "url" style defined in the **drawingStyles** field. The parts of the string that are not enclosed in the tags use the "default" drawing style. If no "default" **drawingStyle** had been defined, the system default drawing style would have been used.

![roku815px - StdDlgMultiStyleTextItemFHD](https://image.roku.com/ZHZscHItMTc2/StdDlgMultiStyleTextItemFHD.jpg)

    <?xml version="1.0" encoding="utf-8" ?>
    
    <component name="MultiStyleTextItemDialog" extends="StandardDialog" initialFocus="buttonArea" >
    
    <script type="text/brightscript" >
    <![CDATA[
    function init()
        m.top.width = {fhd:1380,hd:920}
    
        msTextItem = m.top.findNode("msTextItem")
    
        msTextItem.drawingStyles = {
          "default": {
            "fontSize": {fhd:33,hd:22}
            "fontUri": "font:SystemFontFile"
            "color": "#EFEFEFFF"
          }
          "url": {
            "fontSize": {fhd:33,hd:22}
            "fontUri": "font:SystemFontFile"
            "color": "#00FF00FF"
          }
        }
    
        msTextItem.text="This StdDlgMultiStyleTextItem renders the URL <url>http://www.roku.com</url> in bright green."
    
    end function
    
    sub printSelectedButtonAndClose()
        print "m.buttonArea button ";m.buttonArea.getChild(m.top.buttonSelected).text;" selected"
        m.top.close = true
    end sub
    
    ]]>
    </script>
    
    <children>
        <StdDlgTitleArea primaryTitle="StdDlgMultiStyleTextItem Example" />
        <StdDlgContentArea>
            <StdDlgMultiStyleTextItem id="msTextItem" />
        </StdDlgContentArea>
        <StdDlgButtonArea id="buttonArea">
            <StdDlgButton text="OK" />
        </StdDlgButtonArea>
    </children>
    
    </component>
    

Sample app
----------

You can download and install a [sample app](https://github.com/rokudev/standard-dialog-framework) that demonstrates how to create a custom dialog that includes a **StdDlgMultiStyleTextItem** node.

StdDlgBulletTextItem
====================

Extends [StdDlgItemBase](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-item-base.md "**StdDlgItemBase**")

The **StdDlgBulletTextItem** node is used to display a bulleted list of text in the dialog's content area. It should only be used as a child of a [**StdDlgContentArea**](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-content-area.md) node.

![roku815px - StdDlgBulletTextItem](https://image.roku.com/ZHZscHItMTc2/StdDlgBulletTextItem-v2.jpg)

Fields
------

| Field | Type | Default | Access Permission | Description |
| --- | --- | --- | --- | --- |
| bulletText | array of strings | \[ \] | READ\_WRITE | An array of strings displayed as a bulleted or numbered list. The list is displayed in the content area below the message and above the bottom message. |
| bulletType | string | "bullet" | READ\_WRITE | Specifies the type of list item delimiter, which may be one of the following:  <br><br>*   "bullet"<br>*   "numbered"<br>*   "lettered" |

Sample app
----------

You can download and install a [sample app](https://github.com/rokudev/standard-dialog-framework) that demonstrates how to create a custom dialog that uses the bullet text item.

roTextureRequest
================

An roTextureRequest is used to make requests to the roTextureManager.

An roTextureRequest object is created using the CreateObject() method and passing it a URI string:

`CreateObject("roTextureRequest", "pkg:/assets/comet.jpg")`

**Example: Requesting a URL from the roTextureManager**

    Sub Main()
        mgr = CreateObject("roTextureManager")
        msgport = CreateObject("roMessagePort")
        mgr.SetMessagePort(msgport)
    
        request = CreateObject("roTextureRequest","http://192.168.1.10/ball.png")
        mgr.RequestTexture(request)
    
        msg=wait(0, msgport)
        if type(msg)="roTextureRequestEvent" then
            print "request id";msg.GetId()
            print "request state:";msg.GetState()
            print "request URI:";msg.GetURI()
            state = msg.GetState()
            if state = 3 then
                bitmap = msg.GetBitmap()
                if type(bitmap)<>"roBitmap" then
                    print "Unable to create robitmap"
                    stop   ' stop exits to the debugger
                end if
            end if
       end if
    End Sub
    

**Example: Requesting a scaled image from the roTextureManager**

    Sub Main()
        mgr = CreateObject("roTextureManager")
        msgport = CreateObject("roMessagePort")
        mgr.SetMessagePort(msgport)
    
        request = CreateObject("roTextureRequest","pkg:/assets/ball.png")
        request.SetSize(100, 100)
        request.SetScaleMode(1)
        mgr.RequestTexture(request)
    End Sub
    

**Example: Making an HTTPS request from the roTextureManager**

    Sub Main()
        mgr = CreateObject("roTextureManager")
        msgport = CreateObject("roMessagePort")
        mgr.SetMessagePort(msgport)
    
        request = CreateObject("roTextureRequest","https://192.168.1.10/ball.png")
        request.SetCertificatesFile("common:/certs/ca-bundle.crt")
        request.InitClientCertificates()
    
        mgr.RequestTexture(request)
    End Sub
    

Supported interfaces
--------------------

*   [ifTextureRequest](/docs/references/brightscript/interfaces/iftexturerequest.md "ifTextureRequest ")
*   [ifHttpAgent](/docs/references/brightscript/interfaces/ifhttpagent.md "ifHttpAgent")

SceneGraph core concepts
========================

The SceneGraph framework is used for developing apps. This framework incorporates two key concepts:

*   SceneGraph rendering of the app screens
*   XML configuration of the SceneGraph screens

The goal of this programming framework is to speed app development time by reducing the amount of procedural code that must be written to render a screen display. Instead, the appearance of the screen can be configured as screen component attributes set in XML files. Much of the appearance and behavior of screen components has been coded into the SceneGraph components that Roku provides, allowing you to quickly select and set the attributes of each component to match the design of your app, and allowing easier development of more complex screen displays than were possible in previous Roku firmware.

In addition, the SceneGraph XML programming framework includes a new capability to design your app's user interface for specific screen display resolutions, but also with the flexibility to allow the user interface to render correctly on Roku players that do not support the intended display resolution.

Video lesson
------------

You can learn more about the SceneGraph development framework by watching the [Core concepts](/videos/courses/rsg/debugging.md) video lesson in Roku's [SceneGraph: Build a Channel online video course](https://developer.roku.com/videos/courses/rsg/overview.md).

This lesson reviews core concepts for Roku app app development. It explains the basic design principles and key concepts for developing on the Roku platform, outlines the contents and structure of Roku apps, and compares the programming languages used to build Roku apps: SceneGraph and BrightScript. It highlights the different types of SceneGraph components you can use to build the app UI.

The lesson continues by providing a high-level overview of several key topics such as threading, event handling, and data scoping. It concludes by explaining the importance of factoring graceful degradation in the app design.

PinDialog
=========

> Roku OS 10.0 introduced a new [StandardPinPadDialog node](/docs/references/scenegraph/standard-dialog-framework-nodes/standard-pinpad-dialog.md "**Standard PinPad Dialog**"), which features updated graphics, color palette support, and voice entry support. This enables developers to provide a consistent user experience across the PIN pad dialogs in their app, and help speed up customer sign-ups and sign-ins. Developers must replace the legacy PinDialog nodes in their app with the new [StandardPinPadDialog node](/docs/references/scenegraph/standard-dialog-framework-nodes/standard-pinpad-dialog.md "**Standard PinPad Dialog**").
> 
> To upgrade a legacy pinpad dialog to the standard version, prepend "Standard" to the node type. For example, change `pindialog = createObject("roSGNode", "PinDialog")` to `pindialog = createObject("roSGNode", "StandardPinDialog")`.

Extends [**Dialog**](/docs/references/scenegraph/dialog-nodes/dialog.md "**Dialog**")

The PinDialog node class is a special type of Dialog node that prompts the user to enter a numeric string. The PinDialog node class includes an internal [PinPad](/docs/references/scenegraph/widget-nodes/pinpad.md "PinPad") node to allow the user to input a numeric value, such as a PIN.

The PinDialog node class allows you to add a title (by setting the Dialog node title field), a message (by setting the Dialog node message field), and a set of action buttons (by setting the Dialog node buttons field). The bulletText and graphicUrl fields of the Dialog node should not be set. If those fields are set, the layout of the PinDialog node will likely not look correct.

Typically, you will want to set the Dialog node title field to prompt the user to enter a PIN, and add "OK" and "Cancel" buttons by setting the Dialog node buttons field to \[ "OK", "Cancel" \], then observe the Dialog node buttonSelected field to react when the user presses one of those buttons. At any time, the PinDialog node pin field can be accessed to obtain the PIN value entered by the user.

The PinDialog node displays a privacy hint at the bottom of the dialog instructing the user how to show/hide the PinPad node focus indicator with the Options remote key. This provides more privacy for the user when entering a PIN. You should not override this default behavior of the Options remote key in the PinDialog node.

Fields
------

| Field | Type | Default | Access Permission | Description |
| --- | --- | --- | --- | --- |
| pin | string | ""  | READ\_WRITE | Can be used to explicitly set the internal PinPad node PIN value, as well as to access the PIN value entered by the user |
| pinPad | PinPad node | system default | READ\_ONLY | Provides access to the PinDialog node internal PinPad node. The field is read-only, but the fields of the PinPad node it refers to can be read and written, allowing you to fully customize the PinPad node appearance and behavior |
| privacyHintColor | color | system default | READ\_WRITE | When set, the color of the privacy hint shown at the bottom of the dialog |
| pinPadFocused | boolean | true | READ\_WRITE | Specifies whether or not PinPad will be focused when PinDialog is created |

Sample app
----------

[PinDialogExample](https://github.com/rokudev/samples/tree/master/ux%20components/dialogs/PinDialogExample) is a sample app demonstrating PinDialog in action.

On-device upgrade and downgrade
===============================

Apps with Roku Pay integrations can implement on-device subscription upgrades and downgrades. By doing so, customers can seamlessly switch plans directly from their devices, and apps can ensure that they are billed properly. This enables apps to target different audiences with the best plan in order to maximize content monetization.

> Authenticated transactional apps (SVOD, TVOD, and other subscription services) must complete upgrades and downgrades on the device using Roku Pay, without visiting an external webpage, to pass [certification](/docs/developer-program/certification/certification.md#2-purchases).

Overview
--------

To understand how Roku's on-device upgrades and downgrades work, consider a customer who upgrades a subscription (switching to an annual plan, a premium ad-free plan, or a plan that offers ultra-high-definition \[UHD\] content).

To upgrade a plan, apps cancel the previous _base plan_ and completes the purchase of the _upgraded plan_ (causing a prorated service credit for the remaining balance on the base plan to be applied to the purchase of the upgraded plan).

To downgrade a plan, apps similarly check the expiration date of the _current plan_ being and then mark it for cancellation. A new transaction ID for the _downgraded plan_, which has a $0 price and the same expiration date as the current plan, is returned. On the expiration date, the downgrade is completed and a new transaction ID is created with the purchase price of the downgraded plan.

Apps must add a [product group](/docs/developer-program/roku-pay/quickstart/in-channel-products.md#adding-product-groups) in the Developer Dashboard to enable and facilitate upgrades and downgrades. A product group contains a set of two or more _mutually exclusive_ products, to which customers can upgrade or downgrade. For example, a product group may contain two products for a subscription service with different billing cycles (one that is billed monthly and another annually) or different ad support (one that is ad-based and another that is ad-free). Because they are defined as being mutually-exclusive by their membership in the same product group, Roku can automatically help ensure that the customer is only ever subscribed to one at a time.

> Subscription adjustments, such as upgrade and downgrade as described here, are only made available by the Roku system, to users whose subscriptions are _established and maintained_ via Roku Pay.
> 
> The app's on-device upgrade/downgrade flow should be blocked if the subscription was created through the publisher's system and the customer's sign-in does not match the Roku customer account linked to their device. This is because on-device upgrades/downgrades are automatically billed to the Roku customer account linked to the device, regardless of the authentication mechanism. Blocking the upgrade/downgrade flow in this case prevents the Roku Pay and the publisher services from becoming out of synch on the customer's current subscription plan.

Requirements
------------

Apps must complete the following steps to handle on-device upgrades and downgrades via Roku Pay:

1.  [Create a product group in the Developer Dashboard](/docs/developer-program/roku-pay/quickstart/in-channel-products.md#adding-product-groups) for the products customers can upgrade or downgrade.

2.  Apps using the [SceneGraph ChannelStore node (SDK 2)](/docs/references/scenegraph/control-nodes/channelstore.md): Set the `order.action` field to `Upgrade` or `Downgrade`, and then send a [**doOrder command**](/docs/references/scenegraph/control-nodes/channelstore.md#doorder) to complete the upgrade/downgrade.
    
    Apps using the [BrightScript roChannelStore node (SDK 1)](/docs/references/brightscript/interfaces/ifchannelstore.md): Call the [**SetOrder()** function](/docs/references/brightscript/interfaces/ifchannelstore.md#setorderorder-as-object-orderinfo-as-object-as-void) with the **action** field of the **orderInfo** parameter set to `Upgrade` or `Downgrade`.
    

3.  Call the [Roku Pay **validate transaction** API](/docs/developer-program/roku-pay/implementation/roku-web-service.md#validate-transaction) with the transaction ID from the `purchaseid` field of the [**doOrder command**](/docs/references/scenegraph/control-nodes/channelstore.md#doorder). Use the data returned by the API to update the backend system with the entitlements and expiration dates of the original and upgraded/downgraded plans. Apps subscribing to [push notifications](/docs/developer-program/roku-pay/implementation/push-notifications) will receive both [cancel](/docs/developer-program/roku-pay/implementation/push-notifications#cancellation) and [sale](/docs/developer-program/roku-pay/implementation/push-notifications#sale) notifications for upgrades and downgrades.

Handling upgrade/downgrade transactions
---------------------------------------

### Sending the upgrade/downgrade action

#### SceneGraph ChannelStore node (SDK 2)

To send a [**doOrder command**](/docs/references/scenegraph/control-nodes/channelstore.md#doorder) to upgrade or downgrade a plan with the SceneGraph ChannelStore node, follow these steps:

1.  Set the `order.action` field to `Upgrade` or `Downgrade` (the required values are case-sensitive; do not pass "upgrade" or "downgrade" in the `action` field).
    
        m.channelStore = CreateObject("roSGNode","ChannelStore")
        myOrder = CreateObject("roSGNode", "ContentNode")
        myItem = myOrder.createChild("ContentNode")
        myItem.addFields({ "code": "UPC2397", "qty": 1})
        m.channelStore.order = myOrder
        myOrder.action = "Upgrade"
        
    

2.  Send a [**doOrder** command](/docs/references/scenegraph/control-nodes/channelstore.md#doorder) to have the customer confirm the upgrade/downgrade.
    
        m.channelStore.command = "doOrder"
        
    

3.  The following occurs to the original base plan and the upgraded/downgraded plan based on the specified action.
    
    *   **Upgrade**. The base plan is canceled and the upgraded plan is purchased (a prorated service credit for the remaining balance on the base plan is applied to the upgrade purchase).
        
    *   **Downgrade**. The current plan is marked for cancellation on its expiration date. On the expiration date, the purchase of the downgrade is completed and the previous plan is canceled automatically. No service credit is issued as part of a downgrade.
        

#### BrightScript roChannelStore node (SDK 1)

To call the [**SetOrder()** function](/docs/references/brightscript/interfaces/ifchannelstore.md#setorderorder-as-object-orderinfo-as-object-as-void) to upgrade or downgrade a plan with the BrightScript roChannelStore node, follow these steps:

1.  Set the `orderInfo.action` field to `Upgrade` or `Downgrade` (the required values are case-sensitive; do not pass "upgrade" or "downgrade" in the `action` field).
    
        m.store = CreateObject("roChannelStore")​
        ' Populate myOrderItems
        myOrderInfo.action = "Upgrade"
        
    

2.  Call the [**SetOrder()** function](/docs/references/brightscript/interfaces/ifchannelstore.md#setorderorder-as-object-orderinfo-as-object-as-void) to have the customer confirm the upgrade/downgrade. The **myOrderItems** parameter specifies the in-channel product to which the customer is upgrading/downgrading; the **myOrderInfo** parameter whether the transaction is an upgrade or downgrade.
    
        m.store.setOrder(myOrderItems, myOrderInfo)
        
    

3.  The following occurs to the original base plan and the upgraded/downgraded plan based on the specified action.
    
    *   **Upgrade**. The base plan is canceled and the upgraded plan is purchased (a prorated service credit for the remaining balance on the base plan is applied to the upgrade purchase).
        
    *   **Downgrade**. The current plan is marked for cancellation on its expiration date. On the expiration date, the purchase of the downgrade is completed and the previous plan is canceled automatically. No service credit is issued as part of a downgrade.
        

### Calling the Roku Pay validate transaction API

In order to support upgrade and downgrade transactions, the [**validate transaction** API](/docs/developer-program/roku-pay/implementation/roku-web-service.md#validate-transaction) includes the following fields in the response:

*   **purchaseType**: The `purchaseType` indicates whether the transaction was an `UPGRADE` or `DOWNGRADE`.
    
*   **cancelledTransactionIds**: The `cancelledTransactionIds` field contains the original transaction ID of the base/current plan, that the upgrade or downgrade replaces.
    
*   **originalTransactionId**: The `OriginalTransactionId` field contains the new transaction ID generated for the upgraded/downgraded plan purchased.
    
*   **purchaseStatus**: The `purchase_status` field corresponds with definite states of the `isEntitled` and `cancelled` fields, as shown in the following chart:
    

| purchase\_ status | isEntitled | cancelled |
| --- | --- | --- |
| Active | true | false |
| Inactive | false | true |
| Pending\_Active | true | false |
| Pending\_Inactive | true | true |

Once an upgrade or downgrade has been completed on-device, apps should call the [**validate transaction** API](/docs/developer-program/roku-pay/implementation/roku-web-service.md#validate-transaction) with the transaction ID from the `purchaseid` field of the `doOrder` command to update their system.

The API responses for the original purchase and upgrades/downgrades are as follows:

#### Upgrades

After an upgrade has been completed on-device, responses to [**validate transaction** API](/docs/developer-program/roku-pay/implementation/roku-web-service.md#validate-transaction) calls made with the transaction IDs of the original base plan and the upgrade will result in the following:

**Original base plan purchase**. The `cancelled` field is set to true (no renewal will therefore happen); the `expirationDate` field remains unchanged.

#### JSON

    {
       "errorCode":null,
       "errorDetails":null,
       "errorMessage":"",
       "status":0,
       "OriginalTransactionId":"b0f7e477-e89e-48d0-aa13-abad017d4ee9",
       "amount":2.99,
       "cancelled":true,
       "cancelledTransactionIds":null,
       "channelId":000000,
       "channelName":"ESPRIMU",
       "couponCode":null,
       "currency":"usd",
       "expirationDate":"\/Date(1588892898000+0000)\/",
       "isEntitled":true,
       "originalPurchaseDate":"\/Date(1588288095000+0000)\/",
       "partnerReferenceId":"1969",
       "productId":"KFevcXDIo96kmmsy9wh7_MonthlySubFreeTrial",
       "productName":"KFevcXDIo96kmmsy9wh7_MonthlySubFreeTrial",
       "purchaseDate":"\/Date(1588288095000+0000)\/",
       "purchaseStatus":"PendingInactive",
       "purchaseType":null,
       "quantity":1,
       "rokuCustomerId":"99999999999999999999999999999999",
       "tax":0.0000,
       "total":0.0000,
       "transactionId":"b0f7e477-e89e-48d0-aa13-abad017d4ee9"
    }
    

#### XML

    <result xmlns="http://api.roku.com/transaction" xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
      <errorCode/>
      <errorDetails/>
      <errorMessage></errorMessage>
      <status>0</status>
      <OriginalTransactionId>b0f7e477-e89e-48d0-aa13-abad017d4ee9</OriginalTransactionId>
      <amount>2.99</amount>
      <cancelled>true</cancelled>
      <cancelledTransactionIds/>
      <channelId>0</channelId>
      <channelName>ESPRIMU</channelName>
      <couponCode/>
      <currency>usd</currency>
      <expirationDate>/Date(1588892898000+0000)/</expirationDate>
      <isEntitled>true</isEntitled>
      <originalPurchaseDate>/Date(1588288095000+0000)/</originalPurchaseDate>
      <partnerReferenceId>1969</partnerReferenceId>
      <productId>KFevcXDIo96kmmsy9wh7_MonthlySubFreeTrial</productId>
      <productName>KFevcXDIo96kmmsy9wh7_MonthlySubFreeTrial</productName>
      <purchaseDate>/Date(1588288095000+0000)/</purchaseDate>
      <purchaseStatus>PendingInactive</purchaseStatus>
      <purchaseType/>
      <quantity>1</quantity>
      <rokuCustomerId>99999999999999999999999999999999</rokuCustomerId>
      <tax>0</tax>
      <total>0</total>
      <transactionId>b0f7e477-e89e-48d0-aa13-abad017d4ee9</transactionId>
    </result>
    

In case of upgrades when _no_ free trial is offered with the upgrade subscription then the original subscription is cancelled immediately and the `purchase_status`' is set to `Inactive`.

When a free trial _is_ offered with the upgrade subscription, the `purchase_status` of the original subscription becomes `pending_inactive`. Should the user cancel the upgrade subscription, the original subscription will be reinstated (but _will not renew_ after the entitlement period). Upon the first successful renewal of the upgraded subscription, the original subscription will be set to `Inactive`.

**Upgrade plan purchase**. The `creditsApplied` field is set to the prorated balance from the base plan; the `expirationDate` is set to the applicable expiration date (for example, if a customer switched from a monthly to an annual plan, the expiration date would be set to one year later).

#### JSON

    {
       "errorCode":null,
       "errorDetails":null,
       "errorMessage":"",
       "status":0,
       "OriginalTransactionId":"a800b907-55be-491d-821a-abad017d6674",
       "amount":4.99,
       "cancelled":false,
       "cancelledTransactionIds":[
          "b0f7e477-e89e-48d0-aa13-abad017d4ee9"
       ],
       "channelId":000000,
       "channelName":"ESPRIMU",
       "couponCode":null,
       "currency":"usd",
       "expirationDate":"\/Date(1588892919000+0000)\/",
       "isEntitled":true,
       "originalPurchaseDate":"\/Date(1588288117000+0000)\/",
       "partnerReferenceId":"1969",
       "productId":"Y6ZFym7Xl2agLakTcxMB_MonthlySubFreeTrial",
       "productName":"Y6ZFym7Xl2agLakTcxMB_MonthlySubFreeTrial",
       "purchaseDate":"\/Date(1588288117000+0000)\/",
       "purchaseStatus":"Active",
       "purchaseType":"UPGRADE",
       "quantity":1,
       "rokuCustomerId":"99999999999999999999999999999999",
       "tax":0.0000,
       "total":0.0000,
       "transactionId":"a800b907-55be-491d-821a-abad017d6674"
    }
    

#### XML

    <result xmlns="http://api.roku.com/transaction" xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
      <errorCode/>
      <errorDetails/>
      <errorMessage></errorMessage>
      <status>0</status>
      <OriginalTransactionId>a800b907-55be-491d-821a-abad017d6674</OriginalTransactionId>
      <amount>4.99</amount>
      <cancelled>false</cancelled>
      <cancelledTransactionIds>b0f7e477-e89e-48d0-aa13-abad017d4ee9</cancelledTransactionIds>
      <channelId>0</channelId>
      <channelName>ESPRIMU</channelName>
      <couponCode/>
      <currency>usd</currency>
      <expirationDate>/Date(1588892919000+0000)/</expirationDate>
      <isEntitled>true</isEntitled>
      <originalPurchaseDate>/Date(1588288117000+0000)/</originalPurchaseDate>
      <partnerReferenceId>1969</partnerReferenceId>
      <productId>Y6ZFym7Xl2agLakTcxMB_MonthlySubFreeTrial</productId>
      <productName>Y6ZFym7Xl2agLakTcxMB_MonthlySubFreeTrial</productName>
      <purchaseDate>/Date(1588288117000+0000)/</purchaseDate>
      <purchaseStatus>Active</purchaseStatus>
      <purchaseType>UPGRADE</purchaseType>
      <quantity>1</quantity>
      <rokuCustomerId>99999999999999999999999999999999</rokuCustomerId>
      <tax>0</tax>
      <total>0</total>
      <transactionId>a800b907-55be-491d-821a-abad017d6674</transactionId>
    </result>
    

#### Downgrades

After a downgrade has been completed on-device, responses to [**validate transaction** API](/docs/developer-program/roku-pay/implementation/roku-web-service.md#validate-transaction) calls made with the transaction IDs of the original plan and the downgrade will result in the following:

**Original plan purchase**. The `cancelled` field is set to true (no renewal will therefore happen); the `expirationDate` field remains unchanged.

#### JSON

    {
       "errorCode":null,
       "errorDetails":null,
       "errorMessage":"",
       "status":0,
       "OriginalTransactionId":"03c3ac6f-5086-4601-b87a-abac0165abed",
       "amount":4.99,
       "cancelled":true,
       "cancelledTransactionIds":null,
       "channelId":000000,
       "channelName":"ESPRIMU",
       "couponCode":null,
       "currency":"usd",
       "expirationDate":"\/Date(1588801334000+0000)\/",
       "isEntitled":true,
       "originalPurchaseDate":"\/Date(1588196534000+0000)\/",
       "partnerReferenceId":"1969",
       "productId":"QynVhYtdThAg7wcfTkgi_MonthlySubFreeTrial",
       "productName":"QynVhYtdThAg7wcfTkgi_MonthlySubFreeTrial",
       "purchaseDate":"\/Date(1588196534000+0000)\/",
       "purchaseStatus":"Active",
       "purchaseType":null,
       "quantity":1,
       "rokuCustomerId":"99999999999999999999999999999999",
       "tax":0.0000,
       "total":0.0000,
       "transactionId":"03c3ac6f-5086-4601-b87a-abac0165abed"
    }
    

#### XML

    <result xmlns="http://api.roku.com/transaction" xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
      <errorCode/>
      <errorDetails/>
      <errorMessage></errorMessage>
      <status>0</status>
      <OriginalTransactionId>03c3ac6f-5086-4601-b87a-abac0165abed</OriginalTransactionId>
      <amount>4.99</amount>
      <cancelled>true</cancelled>
      <cancelledTransactionIds/>
      <channelId>0</channelId>
      <channelName>ESPRIMU</channelName>
      <couponCode/>
      <currency>usd</currency>
      <expirationDate>/Date(1588801334000+0000)/</expirationDate>
      <isEntitled>true</isEntitled>
      <originalPurchaseDate>/Date(1588196534000+0000)/</originalPurchaseDate>
      <partnerReferenceId>1969</partnerReferenceId>
      <productId>QynVhYtdThAg7wcfTkgi_MonthlySubFreeTrial</productId>
      <productName>QynVhYtdThAg7wcfTkgi_MonthlySubFreeTrial</productName>
      <purchaseDate>/Date(1588196534000+0000)/</purchaseDate>
      <purchaseStatus>Active</purchaseStatus>
      <purchaseType/>
      <quantity>1</quantity>
      <rokuCustomerId>99999999999999999999999999999999</rokuCustomerId>
      <tax>0</tax>
      <total>0</total>
      <transactionId>03c3ac6f-5086-4601-b87a-abac0165abed</transactionId>
    </result>
    

**Downgrade plan purchase**. The `expirationDate` is based on that of the original plan; the `total` field is set to 0.00 because there is no actual charge. On the expiration date, the customer will be charged for the renewal of the downgraded plan.

#### JSON

    {
       "errorCode":null,
       "errorDetails":null,
       "errorMessage":"",
       "status":0,
       "OriginalTransactionId":"e8515e53-8c2b-4e9e-9039-abac0165b4e1",
       "amount":2.99,
       "cancelled":false,
       "cancelledTransactionIds":[
          "03c3ac6f-5086-4601-b87a-abac0165abed"
       ],
       "channelId":000000,
       "channelName":"ESPRIMU",
       "couponCode":null,
       "currency":"usd",
       "expirationDate":"\/Date(1588801334000+0000)\/",
       "isEntitled":true,
       "originalPurchaseDate":"\/Date(1588196542000+0000)\/",
       "partnerReferenceId":"1969",
       "productId":"ZTtL0DvuGNX1sO4tJGNp_MonthlySubFreeTrial",
       "productName":"ZTtL0DvuGNX1sO4tJGNp_MonthlySubFreeTrial",
       "purchaseDate":"\/Date(1588196542000+0000)\/",
       "purchaseStatus":"PendingActive",
       "purchaseType":"DOWNGRADE",
       "quantity":1,
       "rokuCustomerId":"99999999999999999999999999999999",
       "tax":0.0000,
       "total":0.0000,
       "transactionId":"e8515e53-8c2b-4e9e-9039-abac0165b4e1"
    }
    

Since the "downgrade" subscription will be activated sometime in the future (i.e., the expiration date of the original plan), `purchase_status` status of the downgrade is set `pending_active`. The status will be set to `valid` at the time of activation.

#### XML

    <result xmlns="http://api.roku.com/transaction" xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
      <errorCode/>
      <errorDetails/>
      <errorMessage></errorMessage>
      <status>0</status>
      <OriginalTransactionId>e8515e53-8c2b-4e9e-9039-abac0165b4e1</OriginalTransactionId>
      <amount>2.99</amount>
      <cancelled>false</cancelled>
      <cancelledTransactionIds>03c3ac6f-5086-4601-b87a-abac0165abed</cancelledTransactionIds>
      <channelId>0</channelId>
      <channelName>ESPRIMU</channelName>
      <couponCode/>
      <currency>usd</currency>
      <expirationDate>/Date(1588801334000+0000)/</expirationDate>
      <isEntitled>true</isEntitled>
      <originalPurchaseDate>/Date(1588196542000+0000)/</originalPurchaseDate>
      <partnerReferenceId>1969</partnerReferenceId>
      <productId>ZTtL0DvuGNX1sO4tJGNp_MonthlySubFreeTrial</productId>
      <productName>ZTtL0DvuGNX1sO4tJGNp_MonthlySubFreeTrial</productName>
      <purchaseDate>/Date(1588196542000+0000)/</purchaseDate>
      <purchaseStatus>PendingActive</purchaseStatus>
      <purchaseType>DOWNGRADE</purchaseType>
      <quantity>1</quantity>
      <rokuCustomerId>99999999999999999999999999999999</rokuCustomerId>
      <tax>0</tax>
      <total>0</total>
      <transactionId>e8515e53-8c2b-4e9e-9039-abac0165b4e1</transactionId>
    </result>
    

### Receiving push notifications for upgrades and downgrades

When a customer upgrades or downgrades a subscription, a new purchase is made and the original one is cancelled. As a result, a pair of push notifications are sent: a sale for the new transaction (`UpgradeSale` or `DowngradeSale`), and a cancellation for the original transaction (`UpgradeCancellation` or `DowngradeCancellation`).

The `transactionType` field in the push notification indicates the upgrade/downgrade event associated with the notification. This makes it easy to identify the reason for purchases and cancellations related to upgrades/downgrades.

For example, if a customer upgrades from a monthly to an annual subscription, the following two notifications are sent: (1) an `UpgradeSale`notification for the purchase of the annual subscription, and (2) an `UpgradeCancellation` notification for the cancellation of the monthly subscription. The following table summarizes the transaction types for the notifications sent for upgrades and downgrades.

|     | Transaction Type |     |
| --- | --- | --- |
| **Action** | **Sale** | **Cancellation** |
| **Upgrade** | UpgradeSale | UpgradeCancellation |
| **Downgrade** | DowngradeSale | DowngradeCancellation |

The following sample demonstrates an **UpgradeSale** notification:

#### JSON

    {
       "customerId":"ab080b5f1c5650d9ae0d7f595d0be886",
       "transactionType":"UpgradeSale",
       "transactionId":"187fb8f7b3a24883a245ab5d0171fadd",
       "channelId":"713788",
       "channelName":"Roku Channel",
       "productCode":"5tahs9bYB9jM5FJtz3DW_YearlySub",
       "productName":"5tahs9bYB9jM5FJtz3DW_YearlySub",
       "price":13.99,
       "tax":0.0,
       "total":13.99,
       "currency":"usd",
       "isFreeTrial":false,
       "expirationDate":"2021-02-10T22:27:03.7657086Z",
       "originalTransactionId":"187fb8f7-b3a2-4883-a245-ab5d0171fadd",
       "comments":"New order processed.",
       "eventDate":"2020-02-10T22:27:03.8597086Z",
       "responseKey":"ce5e3c2ae1c242c2bfd136ac36580112"
    }
    

#### XML

    <result xmlns="http://api.roku.com/transaction" xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
        <customerId>ab080b5f1c5650d9ae0d7f595d0be886</customerId>
      <transactionType>UpgradeSale</transactionType>
      <transactionId>187fb8f7b3a24883a245ab5d0171fadd</transactionId>
      <channelId>713788</channelId>
      <channelName>Roku Channel</channelName>
      <productCode>5tahs9bYB9jM5FJtz3DW_YearlySub</productCode>
      <productName>5tahs9bYB9jM5FJtz3DW_YearlySub</productName>
      <price>13.99</price>
      <tax>0</tax>
      <total>13.99</total>
      <currency>usd</currency>
      <isFreeTrial>false</isFreeTrial>
      <expirationDate>2021-02-10T22:27:03.7657086Z</expirationDate>
      <originalTransactionId>187fb8f7-b3a2-4883-a245-ab5d0171fadd</originalTransactionId>
      <comments>New order processed.</comments>
      <eventDate>2020-02-10T22:27:03.8597086Z</eventDate>
      <responseKey>ce5e3c2ae1c242c2bfd136ac36580112</responseKey>
    </result>
    

Sample app
----------

The file [upgrade-downgrade-sample](https://github.com/rokudev/samples/tree/master/roku%20pay/upgrade-downgrade-sample) is a sample app that allows you to experiment with the upgrade-downgrade feature. This package file can be sideloaded directly into your Roku device. Consult the `Readme.md` file that is in the zipped package for operating instructions and other information.

roRegex
=======

The roRegex component provides the powerful regular expression processing of the PCRE library to Brightscript strings.

> Please see the PCRE documentation ([http://www.pcre.org/](http://www.pcre.org/)) for documentation on the PCRE library used for regular expression matching. See the [perlre documentation](http://perldoc.perl.org/perlre.html) for complete documentation of the possible regular expressions this library can parse and match. In general, most Perl compatible regular expressions are supported.

This object is created with a string that represents the matching-pattern and a string to indicate flags that modify the behavior of the matching operation(s):

`CreateObject("roRegex", "[a-z]+", "i")`

The match string ("\[a-z\]+" in the example above, which matches all lowercase letters) can include most Perl compatible regular expressions documented in the PCRE documentation ([http://www.pcre.org/](http://www.pcre.org/)).

Any combination of the following behavior flags ("i" in the example above which modifies to match upper and lowercase letters) is supported:

*   "i" Case insensitive match
*   "m" Multiline mode. The start of line "^" and end of line "$" constructs match immediately following or before any newline in the subject string as well as the very start and end of the string. Normally, just the start and end of the string would match.
*   "s" Sets dot-all mode that includes newline in the ".\*" regular expression. This modifier is equivalent to Perl's /s modifier.
*   "x" Sets extended mode that ignores whitespace characters except when escaped or inside a character class. Characters between an unescaped # outside a character a character class and the next newline character, inclusive, are also ignored. This modifier is equivalent to Perl's /x modifier.

Supported interfaces
--------------------

*   [ifRegex](/docs/references/brightscript/interfaces/ifregex.md "ifRegex")

BusySpinner
===========

Extends [**Group**](/docs/references/scenegraph/layout-group-nodes/group.md)

The BusySpinner node class is a simple widget that displays a continuously rotating bitmap. Since the BusySpinner node class uses an internal Poster node instance, the busy spinner bitmap can be specified by setting the internal Poster node uri field.

[SimpleBusySpinner](https://github.com/rokudev/samples/tree/master/ux%20components/widgets) is a sample app that demonstrates usage of the BusySpinner.

> Not all Roku Player hardware versions support arbitrary rotations. In particular, some hardware versions only support 90 degree rotation increments. In those cases, the icon will step through 90 degree, 180 degree, 270 degree and back to 0 degree rotations, rather than spin smoothly.

Fields
------

FieldTypeDefaultAccess PermissionDescriptionposterPoster nodeinternal instance defaultREAD\_WRITESet the uri field of the Poster node to select the bitmap for the busy spinnercontroloption stringnoneREAD\_WRITESets the operational state of the busy spinner

| Option | Effect |
| --- | --- |
| none | No operational state set. The busy spinner will run if not set to `"stop"`. |
| start | Starts the busy spinner if not running |
| stop | Stops the busy spinner if running |

clockwiseBooleantrueREAD\_WRITESpecifies whether the bitmap rotates in a clockwise or counterclockwise directionspinIntervaltime2READ\_WRITEThe number of seconds to complete a 360-degree rotation of the spinner image. A value of 0 will cause the spinner to remain stationary and not spin

Sample app
----------

[BusySpinnerExample](https://github.com/rokudev/samples/tree/master/ux%20components/widgets/BusySpinnerExample) is a sample app demonstrating BusySpinner in action.

Key Design Principles
=====================

A UI is invisible when users remain focused on their goal of navigating and watching the content instead of figuring out how to use or operate the UI. An invisible UI never draws any unnecessary attention to itself; it's effortless to use because everything about it is evident, requiring very little learning or energy.

Constantly ask these key questions about your UI as you're designing and reviewing it.

*   **Is your UI getting in the way?** TV viewers want to relax, have a beer in one hand, and a remote in the other. Then with as few actions and decisions as possible, watch something great. No one wants to use a UI; they just want to watch something entertaining. The app UI hence needs to be a delightful and useful tool.

*   **Is it easy to use?** The most common design mistake is making the UI too complicated. Users not only need to operate the individual onscreen UI elements (micro-usability) smoothly but be able to accomplish their goals (macro-usability) easily. Users need to know where they're at and where to go next which means the navigation must be simple and obvious. Reducing complexity is more important than reducing the number of steps. Simplicity trumps speed.

*   **Is it snappy?** The system must respond immediately to every user action with clear and distinct feedback. The UI needs to be highly responsive; otherwise, interactions can be frustrating. Transitions, animations, and load times must all be optimized for performance.

*   **Is it easy to learn?** No one expects or wants training on how to use their TV. Instructions on how to use the UI are usually a sign of a weak design. Patterns and consistency mean actions and outcomes are predictable, which enables users to carry what they learn from one screen to other screens. Can you describe how to use your UI with the fewest number of "always true, simple rules"? The more exceptions there are to the general behavior of your system, the more complicated it is to learn and use.

*   **Does it look simple?** The look of a UI also contributes significantly to its delight and ease of use. Ensure people can easily tell where the focus highlight is and where it can go. Create visual hierarchy so what's important has prominence and what's secondary is pushed back, demanding less attention. Keep screen information density low; blank space is essential, giving screen elements room to breathe and reducing a user's anxiety.
    
*   **Is there too much?** More is not always better; more features, more choices, more information can lead to more work, noise, and complexity. Start with less to keep it simple and approachable; focus on the few things that have a significant impact and are relevant to users and their tasks. Eliminate all others. Later, look for signs or evidence of what more is needed.
    

*   **Does it flow?** Not only does the app need to ensure that the sequence of steps a user must take from screen to screen flows in a logical and predictable order, but there should also be a consistent and natural flow on the screen itself. Avoid screen designs in which users must jump their gaze and focus all over in an unorganized or poorly choreographed order. A single pass top-down, left-right flow is the best when it comes to the final actions towards the right and/or bottom of the screen. The size, color, contrast, and placement of each element work together, creating a clear path to understanding the app interface.

*   **Is it seamless?** Jumping or cutting from one state to another forces people to re-evaluate the new state and re-orient themselves. Use simple, clean, and minimal animations to help users see and follow the system's transition from one state to another. However, never make a user and their interactions with the system wait on animations (UI animations should not act as a governor to throttle the pace of the interaction). As your UI transitions from screen to screen, ensure a relevant element from the first screen carries over to the next screen for continuity of the context.

*   **Is it focused?** To ensure better clarity and simplicity for any given screen, design each screen to have one specific purpose and make sure everything on that screen serves that single purpose. Don't overload screens and try to do too much at once. One screen, one purpose.

*   **Is it forgiving?** No matter how clear your design is, people will make mistakes. You should handle user errors with as much attention to simplicity as the rest of the UI. Ensure users can easily back up, resume, and avoid dead-ends; always provide a way forward. Use error messages as a teachable moment and avoid technical language, placing blame, or making users feel stupid. Users must have a sense of comfort and trust at every step.

*   **Is it entertaining and engaging?** The app should create an entertainment experience, in such a way that the UI itself should also be engaging and a joy to use. Be more visual and celebrate artwork and images, like movie posters, and make them big. Keep the UI experience human, approachable, light-hearted and comfortable throughout the screen. Pay attention to the tone and the wording of the text. Users are particularly unobservant when playing games; they don't worry about breaking it. We too are creating an entertainment experience, and our system needs to be as approachable and forgiving as possible.

*   **Is it legible?** Users sit an average distance of 10 feet (3 meters) from their TV screen. While the TV screen may seem like a large display with plenty of UI screen real estate, from 10 feet away, the relative size of the TV screen can be smaller than a phone held 1 foot away from your face. Therefore, ensure everything is easy to read with high contrast and large text. The larger text has the added benefit of forcing you to be concise and reduce the total amount of information shown (information density) to just what's important.

*   **Is it overscan safe?** TVs were made of cathode ray tubes (CRT) in anticipation of overscan that produced inconsistent images across TV sets, especially along the screen edges. To compensate, CRT TVs used overscan, which slightly enlarged the image itself so those bad screen edges would be outside the viewing area. The app should avoid showing any critical information too close to the edge of the TV screen. Since overscan still exists even on HDTVs, Roku recommends that the app sets at least a 5% margin within which to keep all of the UI to ensure its visibility. For a standard HDTV with 1920x1080 pixel resolution, this means having a 90 pixel left/right side margin and a 60 pixel top/bottom margin.

Creating a content feed
=======================

Every Roku app has a content feed. The content feed is a cloud-hosted file that typically contains hundreds to thousands of titles in a publisher's catalog and detailed metadata about each title such as its unique ID, name, description, artwork, and URL.

The content metadata in the feed is used to transfer the video and audio content from your catalog to your Roku app. It tells your app where to find the movie, television show, or song to be played, and the title, description, artwork, and other information to be used when displaying it.

The following example demonstrates the types of metadata included in the feed for a single content item:

    {
        "id": "dev-summit-21-keynote-welcome-address",
        "title": "Keynote - Welcome address",
        "shortDescription": "The Roku content team recaps the past year in streaming and highlights key industry trends for the upcoming year.",
        "longDescription": "The Roku content team recaps the past year in streaming and highlights key industry trends for the upcoming year.",
        "thumbnail": "https://my-roku-image.com/dev-summit-21-welcome.png",
        "releaseDate": "2021-10-26",
        "genres": [
            "educational"
        ],
        "tags": [
            "dev-summit-21"
        ],
        "content": {
            "duration": 699,
            "videos": [{
                "videoType": "MP4",
                "url": "https://my-roku-video.com/2-keynote-address.mp4",
                "quality": "HD"
            }],
            "language": "en-us",
            "rating": {
                "rating": "G",
                "ratingSource": "USA_PR"
            },
            "dateAdded": "2021-10-26T00:00:00Z"
        }
    }
    

Configuring the content feed
----------------------------

To create the content feed, you first want to determine which metadata you want to surface to users. Consider which metadata items are the most important for users to find and select content in your app. You should also review the [Content Metadata documentation](/docs/developer-program/getting-started/architecture/content-metadata.md) for the descriptive, playback, and DRM fields you might want to include. Use your analysis to create a template with the selected metadata fields.

Hosting the content feed
------------------------

When you are done creating the feed, you need to host it on your website, a content delivery network (CDN), online video platform (OVP), or other hosting solution. You can also [contact one of Roku's preferred feed creation partners](https://developer.roku.com/feed/partners) to create and host your feed.

### Content Delivery Networks (CDNs)

Content is typically hosted on a CDN, which is a group of servers located around the world. Using a CDN ensures that your content can be streamlined to many users at different locations at the same time without any bottlenecks. Apps can use any CDN that is able to stream content. The following list includes some of the CDNs that publishers have used to host content for their Roku apps:

*   AdvergentCDN
*   Akamai
*   Amazon Web Services (AWS)
*   BitGravity
*   Boxcast
*   Brightcove
*   Comcast Technology Solutions
*   EdgeCast
*   Level 3
*   Limelight Networks
*   Scale Engine

### Online Video Platforms (OVPs)

Content may also be hosted in an OVP, which partner with CDNs to provide hosting, but also provide specialized, easy-to-use tools for managing video content. The following list includes some of the OVPs that publishers have used to host content for their Roku apps:

*   Brightcove
*   Kaltura
*   Ooyala
*   Vimeo Pro
*   Wistia
*   Zype

Using the content feed to link your catalog to your app
-------------------------------------------------------

You can use the content metadata in your feed to programmatically populate your app UI with the titles in your catalog. To do this, you create a [ContentNode](https://developer.roku.com/docs/references/scenegraph/control-nodes/contentnode.md), set its attributes to the metadata in your feed, and then add the ContentNode to the SceneGraph UI components in your app. For example, to populate a grid on your app's home page with your movie catalog, you would do the following:

*   create a single root [ContentNode](https://developer.roku.com/docs/references/scenegraph/control-nodes/contentnode.md).
*   iterate through the content feed to add the row title and then thumbnail image, title, description, and other descriptive attributes for each movie in the row to a series of child content nodes.
*   Add the root content node to the grid.

roCECStatusEvent
================

The roCECStatusEvent determines the active source status for set boxes. Apps subscribing to the roCECStatusEvent are notified when the active-source status of the device changes per the CEC message traffic.

To use the roCECStatusEvent, follow the steps below:

1.  Connect a Roku STB to a TV which transmits and receives CEC messages.
    
2.  Select the HDMI input to which the STB is connected.
    
3.  Switch away and then back to the STB's HDMI input.
    

Supported methods
-----------------

### GetMessage() as String

Returns the string "CECStatus".

### GetIndex() as Integer

The index value of this event is not used and is always set to 0.

### GetInfo() as Object

Returns an associative array with the following key/value pairs:

| Name | Type | Description |
| --- | --- | --- |
| active | Boolean | Indicates whether the device is the active source (true if it is the active source; otherwise, false). |

Subscription
------------

A BrightScript app subscribes to roCECStatusEvent by creating an "roCECStatus" object. For example:

    cecstatus = CreateObject("roCECStatus")
    m.port = CreateObject("roMessagePort")
    cecstatus.SetMessagePort(m.port)
    ...
    msg = wait(0, m.port)
    msgType = type(msg)
    if msgType = "roCECStatusEvent"
        info = msg.GetInfo()
        active = info["Active"]
        ...
    end if
    

Expected Results
----------------

Apps subscribing to the event are notified when the active-source status of the device changes.

ArrayGrid
=========

Extends [**Group**](/docs/references/scenegraph/layout-group-nodes/group.md "**Group**")

The ArrayGrid node class is an abstract base class that provides functionality to the list and grid node classes that are extended from ArrayGrid. The field value settings and their effect in this abstract base class depend in many cases on whether a list, or a grid, node class is extended from ArrayGrid, and the specific type of list or grid.

The following node classes extended from ArrayGrid derive their basic functionality from the ArrayGrid abstract node class:

*   [LabelList](/docs/references/scenegraph/list-and-grid-nodes/labellist.md "LabelList")
*   [MarkupList](/docs/references/scenegraph/list-and-grid-nodes/markuplist.md "MarkupList")
*   [PosterGrid](/docs/references/scenegraph/list-and-grid-nodes/postergrid.md "PosterGrid")
*   [MarkupGrid](/docs/references/scenegraph/list-and-grid-nodes/markupgrid.md "MarkupGrid")
*   [RowList](/docs/references/scenegraph/list-and-grid-nodes/rowlist.md "RowList")

> ArrayGrid is not meant to be instantiated directly by app code

### Data Bindings

Each node class extended from the ArrayGrid abstract node class will have custom data bindings.

Fields
------

FieldTypeDefaultAccess PermissionDescriptioncontentContentNodenoneREAD\_WRITESpecifies the content meta-data for the list or grid. This field must be set with a ContentNode that specifies the content meta-data for the list or grid in order for the list or grid to be displayed. See the Data Bindings section of each list or grid reference description for details on the content meta-data that must be specified in the ContentNodeitemSizevector2d\[0,0\]READ\_WRITESpecifies the width and height of each item in the list or grid. For list or grid items that are posters, itemSize is the value of a basePosterSize field and any sub-elements included with the posteritemSpacingvector2d\[0,0\]READ\_WRITESpecifies the horizontal and vertical spacing between the list or grid items. For lists, the vector2d Y-value specifies the vertical spacing between items in the list, and the vector2d X-value is ignorednumRowsinteger0READ\_WRITESpecifies the number of visible rows displayed. Note that the actual number of rows may be more or less than the number specified depending on the number of items in the list or grid contentnumColumnsinteger0READ\_WRITESpecifies the number of columns in a grid. This field is not used for listsfocusRowinteger0READ\_WRITESpecifies the row that will have fixed focus if the vertFocusAnimationStyle field value is set to fixedFocusWrapfocusColumninteger0READ\_WRITESpecifies the column that will have fixed focus for grids if the horizFocusAnimationStyle field value is set to fixedFocusWrap. This field is not used for listshorizFocusAnimationStyleoption stringfloatingFocusREAD\_WRITESpecifies the how the focus indicator moves in a row of grid items in response to the remote direction pad Left and Right key presses. This field is not used for lists. The possible values are:

| Option | Effect |
| --- | --- |
| floatingFocus | Causes the focus indicator to float left or right until it reaches the end of the row, at which point the focus indicator will stay fixed on the first or last item in the row, and the items will scroll left or right if there were items that were not visible. |
| fixedFocusWrap | Causes the row to wrap around when the focus indicator reaches the first or last item in the row, as long as the row contains enough items to fill the row. If the row does not contain enough items to fill the row, the focus indicator will float left and right. |

vertFocusAnimationStyleoption stringfloatingFocusREAD\_WRITESpecifies the how the focus indicator moves in a list or a column of grid items in response to the remote direction pad Up and Down key presses. The possible values are:

| Option | Effect |
| --- | --- |
| floatingFocus | Causes the focus indicator to float up or down until it reaches the end of the list or grid column, at which point the focus indicator will stay fixed on the first or last item in the list or grid column, and the items will scroll up or down if there are items that were not visible. Note that when this style is set, section dividers are not rendered. |
| fixedFocusWrap | Causes the column to wrap around when the focus indicator reaches the first or last item in the list or grid column, as long as the list or grid column contains enough items to fill the list or grid column. If the list or grid column does not contain enough items to fill the list or grid column, the focus indicator will float up and down. |
| fixedFocus | Causes the focus to stay fixed on the upper leftmost item. As the user scrolls down, the row containing the previously selected item scrolls up off screen. Scrolling continues until the last row is reached. |

drawFocusFeedbackOnTopBooleanfalseREAD\_WRITEIf the drawFocusFeedback field value is set to true, specifies whether the specified focus indicator bitmap is drawn on top of the focused list or grid items. The default value draws the specified focus indicator bitmap below the focused list or grid itemdrawFocusFeedbackBooleantrueREAD\_WRITECauses a specified bitmap to be drawn on list or grid items to indicate focus has moved to that itemfadeFocusFeedbackWhenAutoScrollingBooleanfalseREAD\_WRITEWhen set to true, the focus feedback indicator will quickly fade out when scrolling multiple items and fade back in when the scrolling ends. The focus feedback indicator will also after in and out when using the FFW/Rewind keys to scroll a page at a time. Additionally, the focus behavior has been modified for situations where all the items in a RowList row are visible on screen at once. In the past, the focus would step once, then begin to scroll smoothly. Now, the focus steps one-by-one through each item.itemcurrFocusFeedbackOpacityFloat0READ\_WRITEThis field provides access to the current opacity of the focus feedback indicator. It can be used to have other items on the screen fade in/out when the focus feedback indicator fades in/out. Additionally, the focus behavior has been modified for situations where all the items in a RowList row are visible on screen at once. In the past, the focus would step once, then begin to scroll smoothly. Now, the focus steps one-by-one through each item.currFocusFeedbackOpacityfloat0READ\_ONLYThis field provides access to the current opacity of the focus feedback indicator. It can be used to have other items on the screen fade in/out when the focus feedback indicator fades in/out.focusBitmapUriuriREAD\_WRITEIf the drawFocusFeedback field value is set to true, specifies a custom bitmap to be drawn on list or grid items to indicate the focus has moved to that item. Only set this field to use a bitmap with a different appearance than the system default. In most cases, you will want to use a 9-patch PNG bitmap with both expandable regions as well as margins to fit around the item, which is the type of bitmap used as the system defaultfocusFootprintBitmapUriuriREAD\_WRITEIf the drawFocusFeedback field value is set to true, specifies a custom bitmap to be drawn on list or grid items to indicate focus on that item, when the list or grid itself does not have focus. Only set this field to use a bitmap with a different appearance than the system default. In most cases, you will want to use a 9-patch PNG bitmap with both expandable regions as well as margins to fit around the item, which is the type of bitmap used as the system defaultfocusBitmapBlendColorcolor0xFFFFFFFFREAD\_WRITEBlend the graphic image specified by focusBitmapUri with the specified color. If set to the default, 0xFFFFFFFF, no color blending will occur. Set this field to show a focus indicator graphic image with a different color than the image specified by focusBitmapUrifocusFootprintBlendColorcolor0xFFFFFFFFREAD\_WRITEBlend the graphic image specified by focusFootprintBitmapUri with the specified color. If set to the default, 0xFFFFFFFF, no color blending will occur. Set this field to show a focus footprint indicator graphic image with a different color than the image specified by focusFootprintBitmapUriskipFocusAnimationsBooleanfalseREAD\_WRITESpecifies whether changes in the focus item should be animated. If this field is set to true, any scrolling or repositioning/scaling of the focus indicator occurs without an animation. This causes fields reflecting the focus status (itemFocused, currFocusRow, currFocusColumn) to be updated instantly and not transition smoothly between old and new values. For example, currFocusRow will go directly from 3.0 to 4.0 instead of taking on values between 3.0 and 4.0.wrapDividerBitmapUriuriREAD\_WRITEIf the vertFocusAnimationStyle field value is set to fixedFocusWrap, specifies a custom bitmap to use as a visual divider between the last and first list or grid items, when the list or grid wraps. Only set this field to use a bitmap with a different appearance than the system default. In most cases, you will want to use a 9-patch PNG bitmap with both expandable regions, which is the type of bitmap used as the system defaultwrapDividerWidthfloat0READ\_WRITEAdditionally, the focus behavior has been modified for situations where all the items in a RowList row are visible on screen at once. In the past, the focus would step once, then begin to scroll smoothly. Now, the focus steps one-by-one through each item.If the vertFocusAnimationStyle field value is set to fixedFocusWrap, specifies the width of a bitmap used as a visual divider between the last and first list or grid items when the list or grid wraps. Only set this field to use a value with a different appearance than the system defaultwrapDividerHeightfloat36READ\_WRITEIf the vertFocusAnimationStyle field value is set to fixedFocusWrap, specifies the height of a bitmap used as a visual divider between the last and first list or grid items, when the list or grid wraps. Only set this field to use a value with a different appearance than the system defaultfixedLayoutBooleanfalseREAD\_WRITESpecifies that a grid will have a layout of items of different widths configured by parameters included in a ContentNode for the grid. This field is not used by listsnumRenderPassesinteger1READ\_WRITESpecifies the number of rendering operations to display a complex list or grid. This allows you to achieve a performance increase by specifying that individual sub-elements of the list or grid items occur on sequential rendering operations, rather than all of the item sub-elements being rendered in one rendering operation, which is the default. If you set this field to a value greater than 1, you must specify the rendering operation number for each of the item sub-elements as the renderPass field value for that sub-element. No sub-element that has a renderPass field value of 0 (the default), or has a renderPass field value greater than the value of the numRenderPasses field, will renderrowHeightsarray of floats\[\]READ\_WRITESpecifies differing heights for each list or grid row, to allow the height of each row to vary from row to row. The specified values override the itemSize field vector2d Y-value for each list or grid row corresponding to its position in the array, in top to bottom order. If the array contains fewer elements than the number of rows needed to display all the items in the list or grid, the itemSize field vector2d Y-value is used for any unspecified rowscolumnWidthsarray of floats\[\]READ\_WRITESpecifies differing widths for each grid column, to allow the width of each column to vary from column to column. This field is not used by lists. The specified values override the itemSize field vector2d X-value for each grid column corresponding to its position in the array, in left to right order. If the array contains fewer elements than the number of columns needed to display all the items in the grid, the itemSize field vector2d X-value is used for any unspecified columnsrowSpacingsarray of floats\[\]READ\_WRITESpecifies differing spaces between each list or grid row, to allow the spacing between rows to vary from row to row. The specified values override the itemSpacing field vector2d Y-value for each list or grid row corresponding to its position in the array, in top to bottom order. If the array contains fewer elements than the number of rows needed to display all the items in the list or grid, the itemSpacing field vector2d Y-value is used for any unspecified rowscolumnSpacingsarray of floats\[\]READ\_WRITESpecifies differing spaces between each grid column, to allow the spacing between columns to vary from column to column. This field is not used by lists. The specified values override the itemSpacing field vector2d X-value for each grid column corresponding to its position in the array, in left to right order. If the array contains fewer elements than the number of columns needed to display all the items in the grid, the itemSpacing field vector2d X-value is used for any unspecified columnssectionDividerBitmapUriuriREAD\_WRITEIf the ContentNode specifies sections for a list or grid, specifies a custom bitmap to use as a visual divider between the sections of the list or grid. Only set this field to use a bitmap with a different appearance than the system default. For sections that do not include an icon or a title, the system default or custom bitmap specified as the wrapDividerBitmapUri field value is used for the section dividers. In most cases, you will want to use a 9-patch PNG bitmap with both expandable regions, which is the type of bitmap used as the system defaultsectionDividerFontfontsystem defaultREAD\_WRITEIf the ContentNode specifies sections for a list or grid, specifies a custom font to use for the section title text. Only set this field to use a different font than the system defaultsectionDividerTextColorcolorsystem defaultREAD\_WRITEIf the ContentNode specifies sections for a list or grid, specifies a custom color to use for the section title text. Only set this field to use a different text color than the system defaultsectionDividerSpacingfloat0.0READ\_WRITEIf the ContentNode specifies sections for a list or grid, and the section dividers are specified to include an icon and/or a label, specifies the spacing between the icon, label, and section divider bitmapsectionDividerWidthfloat0.0READ\_WRITEIf the ContentNode specifies sections for a list or grid, specifies the width of the section divider bitmapsectionDividerHeightfloat0.0READ\_WRITEIf the ContentNode specifies sections for a list or grid, specifies the height of the section divider bitmapsectionDividerMinWidthfloat0.0READ\_WRITEIf the ContentNode specifies sections for a list or grid, specifies the minimum width of the section divider bitmapsectionDividerLeftOffsetfloat0.0READ\_WRITEIf the ContentNode specifies sections for a list or grid, specifies the left offset of the section divider from the list or griditemClippingRectrect2d\[ 0.0, 0.0, 0.0, 0.0 \]READ\_WRITESpecifies a clipping region for the list or grid itemsitemSelectedinteger0READ\_ONLYWhen a list or grid item is selected, set to the index of the selected itemitemFocusedinteger0READ\_ONLYWhen focus moves to a list or grid item, set to the index of the focused itemitemUnfocusedinteger0READ\_ONLYWhen focus moves away from a list or grid item, set to the index of the unfocused itemjumpToIteminteger0WRITE\_ONLYWhen set to a valid item index, causes the list or grid to immediately update so that the item at the specified index moves into focus, or focus moves to the itemanimateToIteminteger0WRITE\_ONLYWhen set to a valid item index, causes the list or grid to quickly scroll so that the item at the specified index moves into focus, or focus moves to the itemcurrFocusRowfloat0.0READ\_WRITEGives access to which row of a grid is in the focus position as the items scrolling around. So, currFocusRow = 3.7 would mean that item 3 occupies 30% of the focus position while item 4 occupies 70% of the focus position. To maximize performance, the field should be kept to a minimum, as these scripts will run once during each rendercurrFocusColumnfloat0.0READ\_WRITEGives access to which column of a grid is in the focus position as the items scrolling around. So, currFocusColumn = 3.7 would mean that item 3 occupies 30% of the focus position while item 4 occupies 70% of the focus position. To maximize performance, the field should be kept to a minimum, as these scripts will run once during each rendercurrFocusSectionfloat0.0READ\_WRITEGives access to which section of a grid is in the focus position as the items scrolling around. So, currFocusSection = 3.7 would mean that item 3 occupies 30% of the focus position while item 4 occupies 70% of the focus position. To maximize performance, the field should be kept to a minimum, as these scripts will run once during each render

StandardDialog
==============

Extends [Group](/docs/references/scenegraph/layout-group-nodes/group.md "**Group**")

The **StandardDialog** node is the base for Roku's pre-built standard message, keyboard, pinpad, and progress dialogs. It can also be used directly with a custom dialog structure built with the **StdDialogItem** nodes.

Fields
------

FieldTypeDefaultAccess PermissionDescriptionwidthfloat0.0fREAD\_WRITESets the width of the dialog:  

*   If set to 0, the standard system dialog width is used (1038 for FHD, 692 for HD). If the title or any button text is too wide to fit within the standard width, the dialog width will be automatically increased to show the full title or button text up to a preset maximum (1380 for FHD and 920 for HD).
*   If set to greater than 0, the specified width is used as the overall width of the dialog.

heightfloat0.0fREAD\_WRITESets the height of the dialog.  
  
If this field is set to greater than 0, and the layout of the dialog for the specified width results in a dialog with a height less than the value of this field, the dialog layout is increased so that the dialog height matches the value of this field. In this case, the button area is moved to the bottom of the dialog and a blank region exists between the content area and the button area.buttonSelectedint0READ\_ONLYIndicates the index of the selected button when the user selects one of the buttons in the button area.buttonFocusedint0READ\_ONLYIndicates the index of the button that gained focus when the user moved the focus onto one of the buttons in the button area.paletteRSGPalette nodenot setREAD\_WRITESets the color palette for the dialog's background, text, buttons, and other elements.  
  
By default, no palette is specified; therefore, the dialog inherits the color palette from the nodes higher in the scene graph (typically, from the dialog's [Scene](/docs/references/scenegraph/scene.md) node, which has a **palette** field that can be used to consistently color the standard dialogs and keyboards in the app).  
  
The RSGPalette color values used by the StandardDialog node are as follows:  

| Palette Color Name | Usages |
| --- | --- |
| DialogBackgroundColor | Blend color for dialog's background bitmap. |
| DialogItemColor | Blend color for the following items:  <br><br>*   [StdDlgProgressItem's](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-progress-item.md) spinner bitmap<br>*   [StdDlgDeterminateProgressItem's](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-determinate-progress-item.md) graphic |
| DialogTextColor | Color for the text in the following items:  <br><br>*   [StdDlgTextItem](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-text-item.md) and [StdDlgGraphicItem](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-graphic-item.md) if the **namedTextStyle** field is set to "normal" or "bold".<br>*   All [content area items](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-item-base.md), except for [StdDlgTextItem](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-text-item.md) and [StdDlgGraphicItem](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-graphic-item.md).<br>*   [Title area](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-title-area.md#fields). Unfocused button. |
| DialogFocusColor | Blend color for the following:  <br><br>*   The [button area](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-button-area.md#fields) focus bitmap.<br>*   The focused scrollbar thumb. |
| DialogFocusItemColor | Color for the text of the focused button. |
| DialogSecondaryTextColor | Color for the text of in the following items:  <br><br>*   [StdDlgTextItem](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-text-item.md) and [StdDlgGraphicItem](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-graphic-item.md) if the **namedTextStyle** field is set to "secondary".<br>*   Disabled button. |
| DialogSecondaryItemColor | Color for the following items:  <br><br>*   The divider displayed below the title area.<br>*   The unfilled portion of the [StdDlgDeterminateProgressItem's](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-determinate-progress-item.md) graphic. |
| DialogInputFieldColor | The blend color for the text edit box background bitmap for keyboards used inside dialogs. |
| DialogKeyboardColor | The blend color for the keyboard background bitmap for keyboards used inside dialogs |
| DialogFootprintColor | The blend color for the following items:  <br><br>*   The button focus footprint bitmap that is displayed when the [button area](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-button-area.md#fields) does not have focus.<br>*   Unfocused scrollbar thumb and scrollbar track. |

closebooleanfalseWRITE\_ONLYDismisses the dialog. The dialog is dismissed whenever the close field is set, regardless of whether the field is set to true or false.wasClosedeventN/AREAD\_ONLYAn event that indicates the dialog was dismissed. This event is triggered when one of the following occurs:  

*   The **close** field is set.
*   The Back, Home, or Options key is pressed.
*   Another dialog is displayed.

Closed caption
==============

The Roku platform supports the following closed caption formats:

*   SMPTE-TT
*   EIA-608/708
*   WebVTT

Overview
--------

SMPTE-TT uses TTML formatted data either in an external file or embedded into the video stream to carry the caption text, timing, and format information. With EIA-608/708, caption information can only be embedded into the video stream. Adding support for either of these formats to your app is straightforward. SMPTE-TT and EIA-608 caption formats are not supported on legacy Roku platforms where the device is running Roku OS version 3.1. These platforms are limited to the use of SRT subtitles.

Closed caption tracks specification
-----------------------------------

Use the **SubtitleTracks** [content metadata](/docs/developer-program/getting-started/architecture/content-metadata.md) property to specify the language, description, and track name for each subtitle track. Do not use the **SubtitleConfig** property unless you are overriding the caption track that is automatically selected based on user caption language preference. When specifying a track in SubtitleConfig, be sure to also specify it in SubtitleTracks so that the language and description are clear. Omitting the description will cause the UI to display the language in the closed caption menu. A description should at least contain the language.

See the [Video node documentation](/docs/references/scenegraph/media-playback-nodes/video.md#closed-caption-fields) for additional fields related to closed captioning.

Certification requirements
--------------------------

### Packaged control settings

In accordance with our certification requirements, Roku’s Video node automatically handles:

*   closed captioning,
*   language selection, and
*   instant replay

![roku815px - CCSupport](https://image.roku.com/ZHZscHItMTc2/CCSupport.png "CCSupport")

Unless the app overrides it, all Roku players will launch an **Options overlay menu** when the ![roku815px - CCSupport2](https://image.roku.com/ZHZscHItMTc2/CCSupport2.png "CCSupport2")key is pressed during playback of full-screen videos.

However, this only works if the app does not have its [OnKeyEvent()](/docs/references/scenegraph/component-functions/onkeyevent.md) handler fired, and the **[Video node](/docs/references/scenegraph/media-playback-nodes/video.md)** is playing full screen and setFocus is enabled i.e., the Video node is in focus, as displayed in the following code example:

    sub init()
        m.top.setFocus(true)
        setVideo()
    end sub
    

**Note:** When a full-screen video is playing, the user will expect the \* key to work as expected. The app must not override it in cases where there are no other UI elements showing with associated actions for the \* key.

### Custom control settings

#### Certification requirements

Per Roku's [certification requirements](/docs/developer-program/certification/certification.md#4-channel-operation) Apps must support the following closed captioning settings in the Options menu: On, Off, On instant replay, and On mute (Roku TVs only).

For VOD content, apps must synchronize the captions with the audio.

#### Recommendations

*   Apps should provide all available closed captioning tracks, but do not need to handle track selection. The Roku OS selects a closed caption track based on the preferred caption language selection in the system preferences. When the selected language is not available, it defaults to the system's UI language.
    
*   The global **closedCaptionMode** method of the [Video node](/docs/references/scenegraph/media-playback-nodes/video.md) object is how you turn on and off closed captioning of the current playing video. The global settings can be read and set in the [roDeviceInfo](/docs/references/brightscript/interfaces/ifdeviceinfo.md) object. These affect the same system setting. Whenever the user switches on/off closed caption, it is expected that the global setting will be adjusted accordingly. Therefore setting the global setting every time you adjust a local setting is required.
    
*   The **audio track** and the **subtitle track** (for Multilanguage subtitles) can be set using the **VideoNode.audioTrack** and **VideoNode.subtitleTrack** respectively. The available tracks can be found with **VideoNode.availableAudioTracks** and **VideoNode.availableSubtitleTracks**. Another useful item is **rodeviceinfo.GetCurrentLocale**, which returns the current locale set on the device, which is based on the user's language setting.
    
*   If you are using the **roVideoScreen** or **roVideoPlayer**, you should be rewriting your application in **[SceneGraph](/docs/developer-program/core-concepts/core-concepts.md)** as the older technologies are being dropped from the Roku OS.
    

### Star button

**Important notes about \* button**

All Roku devices handle the \* button.

The options overlay slides in whenever the \* button is pressed, the Video node is in focus, and the OnKeyEvent() handler is fired. When the Video node is not in focus, the options overlay does not slide in and the OnKeyEvent() handler is fired.

### Instant replay button

![roku815px - CCSupport3](https://image.roku.com/ZHZscHItMTc2/CCSupport3.png "CCSupport3")

Similarly, for closed captioning, Roku recommends that you allow us to handle use of the instant replay button ![roku815px - CCSupport4](https://image.roku.com/ZHZscHItMTc2/CCSupport4.png "CCSupport4") in the firmware itself. However, if you decide to override our built-in functionality, then your app must offer equal levels of functionality.

While playing video, pressing will move the play head back 10–25 seconds and resume playing. If the closed caption setting is set to “On-replay,” then closed captioning will appear for the duration of time until playback reaches the position where the user presses \*.

The replay button events can be received like any other [events](/docs/developer-program/core-concepts/event-loops.md).

The Roku OS automatically enables the closed captions during the replay interval.

Pressing \* multiple times should move the play head and changes the demarcation point accordingly (only the most recent replay applies). For live linear content, you can stop seeking back if the play head hit the end of the live window.

### Additional considerations

Although **Closed captioning** and **Subtitles** are two different things, and server separate functions, both functions reside within the [Video node](/docs/references/scenegraph/media-playback-nodes/video.md).

One important consideration with the rules outlined above is that the [Roku Advertising Framework](/docs/developer-program/advertising/roku-advertising-framework.md) (RAF) will turn off **trickplay** and the **instant replay** for the duration of an ad. If you are using server-stitched ads, you must disable this with the [**Video.enableUI** field](/docs/references/scenegraph/media-playback-nodes/video.md#ui-fields).

![roku815px - Roku-remote-control-4-button](https://image.roku.com/ZHZscHItMTc2/Roku-remote-control-4-button.png "Roku-remote-control-4-button")

Finally, note that the **fast forward**, **rewind**, and the **left** & **right** arrows on the direction pad should move the play head.

Use the [**Video.notificationInterval**](/docs/references/scenegraph/media-playback-nodes/video.md#trickplay-fields) field to simplify the app logic around this. This field lets you set the number of seconds that observers of the position field should receive notifications.

Non-legacy platforms
--------------------

The non-legacy Roku platforms also include a closed captions setting menu (under the Settings menu option) which allows Roku users to control how closed captions are rendered on the device. These settings let users turn closed captions on and off, and to customize various caption properties such as font size, color, etc. These settings are available to developers via APIs defined on the roDeviceInfo component. It is not necessary for apps to implement their own closed caption settings UI, as the state of the global settings can be queried using these new API functions. Details of the global closed caption settings APIs can be found [here](/docs/references/scenegraph/media-playback-nodes/video.md).

SMPTE-TT
--------

Roku has partially implemented the SMPTE-TT TTML spec that can be referenced here: [http://www.w3.org/TR/ttaf1-dfxp/](http://www.w3.org/TR/ttaf1-dfxp/). Roku makes no claim of even minimal compliance. The link to the TTML spec is provided only for discussion on features we have implemented. Roku's TTML parser will recognize regions, styles, and spans. The captions are recognized as "p" paragraph elements with a "begin" and "end" time.

Roku's caption rendering will always use a build in Gotham font regardless of any font specified in the TTML. Likewise, some font styles may also be ignored. However, the Roku caption rendering will make the best guess effort at choosing the corresponding font size in the system Gotham font using the specified font size in the TTML.

Roku's TTML parser recognizes sufficient stylings to render colors, positions, and alignments either on an absolute or percentage offset. Namespaces do not cause a problem for the parser, but they are not validated either.

The Roku TTML parser recognizes the following elements from Section 7 of the TTML spec that specify the structure and principal content aspects of a document instance:

*   [**7.1.1:** tt](http://www.w3.org/TR/ttaf1-dfxp/#document-structure-vocabulary-tt)
    
*   [**7.1.2:** head](http://www.w3.org/TR/ttaf1-dfxp/#document-structure-vocabulary-head)
    
*   [**7.1.3:** body](http://www.w3.org/TR/ttaf1-dfxp/#document-structure-vocabulary-body)
    
*   [**7.1.4:** div](http://www.w3.org/TR/ttaf1-dfxp/#content-vocabulary-div)
    
*   [**7.1.5:** p](http://www.w3.org/TR/ttaf1-dfxp/#content-vocabulary-p)
    
*   [**7.1.6:** span](http://www.w3.org/TR/ttaf1-dfxp/#content-vocabulary-span)
    

The Roku TTML parser recognizes the following elements from Section 8 of the TTML spec that specify the structure and principal styling aspects of a document instance:

*   [**8.1.1** Styling](http://www.w3.org/TR/ttaf1-dfxp/#styling-vocabulary-styling)
    
*   [**8.1.2** Style](http://www.w3.org/TR/ttaf1-dfxp/#styling-vocabulary-style)
    

The Roku TTML parser recognizes the following styling elements from Section 8.2 of the TTML spec:

*   [**8.2.2** backgroundColor](http://www.w3.org/TR/ttaf1-dfxp/#style-attribute-backgroundColor)
    
*   [**8.2.3** color](http://www.w3.org/TR/ttaf1-dfxp/#style-attribute-color)
    
*   [**8.2.6** displayAlign](http://www.w3.org/TR/ttaf1-dfxp/#style-attribute-displayAlign)
    
*   [**8.2.7** extent](http://www.w3.org/TR/ttaf1-dfxp/#style-attribute-extent)
    
*   [**8.2.9** fontSize](http://www.w3.org/TR/ttaf1-dfxp/#style-attribute-fontSize)
    
*   [**8.2.14** origin](http://www.w3.org/TR/ttaf1-dfxp/#style-attribute-origin)
    
*   [**8.2.18** textAlign](http://www.w3.org/TR/ttaf1-dfxp/#style-attribute-textAlign)\*\*
    

The Roku TTML parser recognizes the following layout elements from Section 9 of the TTML spec:

*   [**9.1.1** layout](http://www.w3.org/TR/ttaf1-dfxp/#layout-vocabulary-layout)
    
*   [**9.1.2** region](http://www.w3.org/TR/ttaf1-dfxp/#layout-vocabulary-region)
    

The Roku TTML parser recognizes the following basic timing attributes for use with timed elements:

*   [**10.2.1** begin](http://www.w3.org/TR/ttaf1-dfxp/#timing-attribute-begin)
    
*   [**10.2.2** end](http://www.w3.org/TR/ttaf1-dfxp/#timing-attribute-end)\*\*
    

EIA-608
-------

Roku supports EIA-608 closed caption data (analog TV format) encapsulated within a EIA-708 container (digital TV) in an H.264 elementary stream and HEVC. EIA-608 captions are delivered as part of the video stream itself. One benefit of this caption format is that there can be multiple “channels” of captions within the stream. These separate channels could be used for different languages, for example, English captions on one channel, Spanish on another, and so forth.

To render EIA-608 captions from within BrightScript, simply set the TrackName attribute of the SubtitleConfig content metadata parameter to “eia608/n” where n is the caption channel. Also, add it to SubtitleTracks to specify the correct language.

WebVTT
------

Roku supports WebVTT captions if embedded in HLS streams or manifests. As with the other closed caption formats, an app specifies WebVTT captions in the SubtitleTracks metadata. The **TrackName** property is set to "webvtt/track" where **track** specifies the index of the caption track to render.

Roku also supports WebVTT captions in DASH as per the DASH-IF IOP guidelines. The WebVTT content can be specified as mimetype “application/mp4” and codecs parameter “wvtt” for Fragmented MP4 content. For WebVTT captions carried as text, mimetype “text/vtt” is supported.

Closed caption support summary
------------------------------

Below is a summary of the closed caption formats supported by the various video streaming technologies on Roku devices.

|     | SMPTE-TT | EIA-608 | WebVTT |
| --- | --- | --- | --- |
| MP4 VOD | Yes (external file only) | Yes (in stream only for all manifests containing AVC streams) | No  |
| HLS VOD | Yes (external file only) | Yes (in stream only for all manifests containing AVC streams) | Yes (in a separate stream described in the manifest (playlist for hls) |
| HLS Live | No  | Yes (in stream only for all manifests containing AVC streams) | Yes (in a separate stream described in the manifest (playlist for hls) |
| Smooth VOD | Yes (in stream or external file) | Yes (in stream only for all manifests containing AVC streams) | No  |
| Smooth Live | Yes (in stream only) | Yes (in stream only for all manifests containing AVC streams) | No  |
| DASH VOD | Yes (external file only) | Yes (in stream only for all manifests containing AVC streams) | Yes |
| DASH Live | Yes (in stream or external file) | Yes (in stream only for all manifests containing AVC streams) | Yes |

roHdmiStatusEvent
=================

The roHdmiStatus sends the roHdmiStatusEvent with the following predicates that indicate its valid event types:

Supported methods
-----------------

### isHdmiStatus() as Boolean

Checks if an HDMI status event has occurred. This method returns true if an HDMI status event has occurred; otherwise, it returns false.

#### GetMessage() as String

Returns the string "HdmiHotPlug".

#### GetInfo() as Object

Retrieves the HDMI information. This method returns an associative array with the following key/value pairs:

| Key | Type | Value |
| --- | --- | --- |
| PortType | string | “Rx” for input ports and “Tx” for output ports |
| PortNumber | integer | The HDMI input or output port number starting from 0 |
| Plugged | Boolean | True if an HDMI device is plugged in, and false of the port is unplugged |

#### GetIndex() as Integer

The index value of this event is not used and is always set to 0.

ifHdmiStatus
============

Implemented by
--------------

| Name | Description |
| --- | --- |
| [roHdmiStatus](/docs/references/brightscript/components/rohdmistatus.md "roHdmiStatus") | The HDMI status component provides an interface to the current HDMI operational status of Roku streaming players (or set-top boxes \[STBs\]). This interface is not applicable for Roku TVs. |

Supported methods
-----------------

### IsConnected() as Boolean

#### Description

Checks whether the HDMI or MHL output is connected to an HDMI device.

#### Return Value

A flag indicating whether the HDMI or MHL output is connected to an HDMI device.

### GetHdcpVersion() as String

#### Description

Returns the version number of the currently established HDCP link.

#### Return Value

The version number of the HDCP link: 1.4 or 2.2.

If an empty string is returned, HDCP is disabled. In this case, videos that require HDCP encryption cannot be played. Videos not requiring encryption should still be playable.

> For code demonstrating how to check whether a Roku device (STB or TV) can play 4K content, see the [streaming specification](/docs/specs/media/streaming-specifications.md#4k-uhd-video-streaming-requirements).

### IsHdcpActive(version as String) as Boolean

#### Description

Checks if the current established HDCP link is the specified version or higher

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| version | String | The HDCP link version to be checked (for example, "1.4" or "2.2"). |

#### Return Value

A flag indicating whether the current established HDCP link is the specified `version`.

StdDlgActionCardItem
====================

Extends [StdDlgItemBase](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-item-base.md)

Description
-----------

The **StdDlgActionCardItem** is used to highlight the [StdDlgItemBase](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-item-base.md) child nodes in the content area of a custom dialog. This node enables developers to add a "more info" arrow icon, radio button icon, or check box icon to the items in the content area. Developers can leverage these icons to enhance the check box and radio button functionality in their custom dialogs.

The icons and the StdDlgItemBase child nodes are drawn on top of a rectangular background that is tinted using the RSGPalette's **DialogFootprintColor** field.

When the StdDlgActionCardItem node has focus, the icons themselves are tinted using the [RSGPalette's](/docs/references/scenegraph/scene.md#fields) **DialogFocusItemColor** field. When the node does not have focus, the icons are tinted using the **DialogTextColor** field.

The **StdDlgActionCardItem** node is designed to be focusable; therefore, it may receive key events.

Fields
------

FieldTypeDefaultAccess PermissionDescriptioniconStatusboolfalseREAD\_WRITEIndicates whether the **StdDlgActionCardItem** node is in the checked or unchecked state when the **iconType** field is set to "checkbox" or "radiobutton".  
  
The icon shown for an action card is based on the value of this field.iconTypestring"none"READ\_WRITESpecifies the icon used for a **StdDlgActionCardItem** node. This may be one of the following values:

| Value | Type | Description |
| --- | --- | --- |
| none | string | No icon is shown. |
| more\_info | string | A right arrow icon is displayed to the right of the **StdDlgActionCardItem** child nodes. This icon is typically used to indicate that more information will be shown when the action card is selected. Typically, this additional content is displayed in another dialog. |
| checkbox | string | A checkbox icon is shown to the left of the StdDlgActionCardItem child nodes.When the **iconStatus** field is set to "true", this adds a checkmark inside the box.When the **iconStatus** field is set to "false", an empty box icon is displayed. |
| radiobutton | string | A radio button icon is shown to the left of the StdDlgActionCardItem child nodes.When the **iconStatus** field is set to "true", this adds a filled circle inside the box.When the **iconStatus** field is set to "false", an empty circle icon is displayed. |

Examples
--------

### Mixed iconTypes

In this example, the dialog has a **StdDlgContentArea** node with a StdDlgTextItem node ("Here are some nice action cards"), and it has the following three **StdDlgActionCardItem** nodes (listed in order):

*   A **SimpleLabel** child node that displays the text "Normal Action Card". The **iconType** field is set to "none".

*   A **LayoutGroup** child node that has its **layoutDirection** field set to "vert" and contains four **SimpleLabel** nodes for displaying an address. The **iconType** field is set to "more\_info, resulting in the display of a right arrow.

*   A **SimpleLabel** child node that displays the text "Check Box Action Card". The **iconType** field is set to "checkbox", resulting in the display of a check box.

![roku815px - actionCards-normal](https://image.roku.com/ZHZscHItMTc2/actionCards-normal.jpg)

    <?xml version="1.0" encoding="utf-8" ?>
    
    <component name="ActionCardsDialog" extends="StandardDialog" initialFocus="buttonArea" >
    
    <script type="text/brightscript" >
    <![CDATA[
    function init()
        print "Creating ActionCards"
    
        setUpPalette()
    
        m.buttonArea = m.top.findNode("buttonArea")
        m.top.observeFieldScoped("buttonFocused", "printFocusButton")
        m.top.observeFieldScoped("buttonSelected", "printSelectedButtonAndClose")
        m.top.observeFieldScoped("wasClosed", "wasClosedChanged")
    
        m.top.findNode("actionCardNormal").observeField("selected", "handleActionCardNormal")
        m.top.findNode("actionCardMoreInfo").observeField("selected", "handleActionCardMoreInfo")
        m.top.findNode("actionCardCheckBox").observeField("selected", "handleActionCardCheckBox")
    end function
    
    sub setUpPalette()
        ' set a default palette to access the DialogTextColor to use
        ' for the color of text of the SimpleLabel node's that are
        ' children of the StdDlgActionItem's
    
        m.top.palette = createObject("roSGNode", "RSGPalette")
    
        m.top.palette.colors = {    DialogBackgroundColor: "0x002040FF",
                                    DialogItemColor: "0x007FEFFF",
    '                                DialogTextColor: "0x007FEFFF",
                                    DialogTextColor: "0xC0C0C0FF",
    '                                DialogFocusColor: "0x007FEFFF",
                                    DialogFocusColor: "0xC0C0C0FF",
                                    DialogFocusItemColor: "0x003E7EFF",
                                    DialogSecondaryTextColor: "0x007FEF66",
                                    DialogSecondaryItemColor: "0x807FFF4D",
                                    DialogInputFieldColor: "0x807FFF80",
                                    DialogKeyboardColor: "0x807FFF4D",
                                    DialogFootprintColor: "0x807FFF4D" }
    
        dialogTextColor = m.top.palette.colors["DialogTextColor"]
    
        ' set all SimpleLabel colors to use the palette's dialogTextColor
        m.top.findNode("noneLabel").color = dialogTextColor
        m.top.findNode("moreInfoLabel1").color = dialogTextColor
        m.top.findNode("moreInfoLabel2").color = dialogTextColor
        m.top.findNode("moreInfoLabel3").color = dialogTextColor
        m.top.findNode("moreInfoLabel4").color = dialogTextColor
        m.top.findNode("checkboxLabel").color = dialogTextColor
    end sub
    
    sub printFocusButton()
        print "m.buttonArea button ";m.buttonArea.getChild(m.top.buttonFocused).text;" focused"
    end sub
    
    sub printSelectedButtonAndClose()
        print "m.buttonArea button ";m.buttonArea.getChild(m.top.buttonSelected).text;" selected"
        m.top.close = true
    end sub
    
    sub wasClosedChanged()
        print "ActionCards Closed"
    end sub
    
    sub handleActionCardNormal()
        print "Normal Action Card Selected"
        m.top.close = true
    end sub
    
    sub handleActionCardMoreInfo()
        print "More Info Action Card Selected"
    end sub
    
    sub handleActionCardCheckBox()
        print "Check Box Action Card Selected"
        actionCard = m.top.findNode("actionCardCheckBox")
        actionCard.iconStatus = not actionCard.iconStatus
    end sub
    
    ]]>
    </script>
    
    <children>
        <StdDlgTitleArea primaryTitle="Action Cards" />
        <StdDlgContentArea>
            <StdDlgTextItem text="Here are some nice action cards." />
            <StdDlgActionCardItem id="actionCardNormal" iconType = "none">
                <SimpleLabel id="noneLabel" text="Normal Action Card" />
            </StdDlgActionCardItem>
            <StdDlgActionCardItem id="actionCardMoreInfo" iconType = "more_info">
                <LayoutGroup itemSpacings="[20,10]" layoutDirection="vert">
                    <SimpleLabel id="moreInfoLabel1" text="Address" />
                    <SimpleLabel id="moreInfoLabel2" text="Darth Vader" />
                    <SimpleLabel id="moreInfoLabel3" text="42 Deeth Drive" />
                    <SimpleLabel id="moreInfoLabel4" text="Starr Valley AZ 85541" />
                </LayoutGroup>
            </StdDlgActionCardItem>
            <StdDlgActionCardItem id="actionCardCheckBox" iconType = "checkbox">
                <SimpleLabel id="checkboxLabel" text="Check Box Action Card" />
            </StdDlgActionCardItem>
        </StdDlgContentArea>
        <StdDlgButtonArea id="buttonArea">
            <StdDlgButton text="OK" />
        </StdDlgButtonArea>
    </children>
    
    </component>
    

### radiobutton iconType

In this example, the dialog has a **StdDlgContentArea** node a **StdDlgItemGroup** node. The **StdDlgItemGroup** node contains three **StdDlgActionCardItem** nodes with their **iconType** field set to "radiobutton". Observe that the vertical spacing between the three **StdDlgActionCardItem** nodes is smaller to visually enforce that they are part of a group. Below the **StdDlgItemGroup** is another **StdDlgActionCardItem** with its **iconType** field set to "checkbox".

The **StdDlgItemGroup** node enforces the rule that when multiple items **StdDlgActionCardItem** nodes have their **iconType** field set to "radiobutton", only one may have its **selected** status be set to "true".

This example configures an [**RSGPalette** node](/docs/references/scenegraph/standard-dialog-framework-nodes/standard-dialog.md) for the dialog, and then it uses the "DialogTextColor" from that palette as the colors for the **SimpleLabel** children of the **StdDlgActionCardItem** node.

![roku815px - actionCards-radio-checkbox-items](https://image.roku.com/ZHZscHItMTc2/actionCards-radio-checkbox-items.jpg)

    <?xml version="1.0" encoding="utf-8" ?>
    
    <component name="RadioButtonActionCardsDialog" extends="StandardDialog" initialFocus="buttonArea" >
    
    <script type="text/brightscript" >
    <![CDATA[
    function init()
        print "Creating RadioButtonActionCards"
    
        setUpPalette()
    
        m.buttonArea = m.top.findNode("buttonArea")
        m.top.observeFieldScoped("buttonFocused", "printFocusButton")
        m.top.observeFieldScoped("buttonSelected", "printSelectedButtonAndClose")
        m.top.observeFieldScoped("wasClosed", "wasClosedChanged")
    
        m.top.findNode("actionCardRadioButtons").observeField("itemSelected", "handleActionCardRadioButtons")
        m.top.findNode("actionCardCheckBox").observeField("selected", "handleActionCardCheckBox")
    end function
    
    sub setUpPalette()
        ' set a default palette to access the DialogTextColor to use
        ' for the color of text of the SimpleLabel node's that are
        ' children of the StdDlgActionItem's
    
        m.top.palette = createObject("roSGNode", "RSGPalette")
    
        m.top.palette.colors = {    DialogBackgroundColor: "0x002040FF",
                                    DialogItemColor: "0x007FEFFF",
    '                                DialogTextColor: "0x007FEFFF",
                                    DialogTextColor: "0xC0C0C0FF",
    '                                DialogFocusColor: "0x007FEFFF",
                                    DialogFocusColor: "0xC0C0C0FF",
                                    DialogFocusItemColor: "0x003E7EFF",
                                    DialogSecondaryTextColor: "0x007FEF66",
                                    DialogSecondaryItemColor: "0x807FFF4D",
                                    DialogInputFieldColor: "0x807FFF80",
                                    DialogKeyboardColor: "0x807FFF4D",
                                    DialogFootprintColor: "0x807FFF4D" }
    
        dialogTextColor = m.top.palette.colors["DialogTextColor"]
    
        ' set all SimpleLabel colors to use the palette's dialogTextColor
        m.top.findNode("radioLabel1").color = dialogTextColor
        m.top.findNode("radioLabel2").color = dialogTextColor
        m.top.findNode("radioLabel3").color = dialogTextColor
        m.top.findNode("checkboxLabel").color = dialogTextColor
    end sub
    
    sub printFocusButton()
        print "m.buttonArea button ";m.buttonArea.getChild(m.top.buttonFocused).text;" focused"
    end sub
    
    sub printSelectedButtonAndClose()
        print "m.buttonArea button ";m.buttonArea.getChild(m.top.buttonSelected).text;" selected"
        m.top.close = true
    end sub
    
    sub wasClosedChanged()
        print "ActionCards Closed"ac
    end sub
    
    sub handleActionCardRadioButtons()
        actionCard = m.top.findNode("actionCardRadioButtons")
        print "Radio Button Group Action Card "; actionCard.itemSelected; " selected"
    end sub
    
    sub handleActionCardCheckBox()
        print "Check Box Action Card Selected"
        actionCard = m.top.findNode("actionCardCheckBox")
        actionCard.iconStatus = not actionCard.iconStatus
    end sub
    
    ]]>
    </script>
    
    <children>
        <StdDlgTitleArea primaryTitle="RadioButton and Checkbox Items" />
        <StdDlgContentArea>
            <StdDlgItemGroup id="actionCardRadioButtons">
                <StdDlgActionCardItem iconType = "radiobutton">
                    <SimpleLabel id="radioLabel1" text="First Choice" />
                </StdDlgActionCardItem>
                <StdDlgActionCardItem iconType = "radiobutton">
                    <SimpleLabel id="radioLabel2" text="Second Choice" />
                </StdDlgActionCardItem>
                <StdDlgActionCardItem iconType = "radiobutton">
                    <SimpleLabel id="radioLabel3" text="Third Choice" />
                </StdDlgActionCardItem>
            </StdDlgItemGroup>
            <StdDlgActionCardItem id="actionCardCheckBox" iconType = "checkbox">
                <SimpleLabel id="checkboxLabel" text="Check Box Action Card" />
            </StdDlgActionCardItem>
        </StdDlgContentArea>
        <StdDlgButtonArea id="buttonArea">
            <StdDlgButton text="OK" />
            <StdDlgButton text="Cancel" />
        </StdDlgButtonArea>
    </children>
    
    </component>
    

Sample app
----------

You can download and install a [sample app](https://github.com/rokudev/standard-dialog-framework) that demonstrates how to create a custom dialog that includes action card items.

Roku Advertising Framework overview
===================================

The Roku Advertising Framework (RAF) enables the seamless integration of video advertising into your apps. The RAF library, which is built directly into the Roku SDK, includes the following features that make it easy to provide a consistent ad experience across apps:

*   Parsing of ads in [VAST2](https://www.iab.com/guidelines/digital-video-ad-serving-template-vast-2-0/), [VAST3](https://www.iab.com/guidelines/digital-video-ad-serving-template-vast-3-0/), [VMAP](https://www.iab.com/guidelines/digital-video-multiple-ad-playlist-vmap-1-0-1/), and FreeWheel's SmartXML formats (see the table [below](#supported-features-of-popular-ad-formats) for details).

*   Built-in solution for displaying client-side (CSAI) video ads that works with Google Ad Manager (formerly known as DFP), FreeWheel, SpotX, and other 3rd-party servers.

*   Playback control for server-stitched ads.

*   Client-side handling of tracking events that is aligned with the IAB/MRC's [impression measurement guidelines](%5Bhttps://mediaratingcouncil.org/sites/default/files/Standards/Digital%20Video%20Served%20Impression%20Measurement%20Guidelines%20%28MMTF%20June%202018%29.pdf).

*   Audience measurement via [Nielsen DAR](https://www.nielsen.com/hk/en/solutions/capabilities/digital-ad-ratings/)/[DCR](/docs/developer-program/advertising/nielsen-dcr.md), [Comscore vCE](https://www.comscore.com/Products/Ratings-and-Planning/Campaign-Ratings), and other platforms.

> Per [Roku's certification requirements](/docs/developer-program/advertising/ad-requirements.md#ads-3-ad-tracking-requirements), all ad measurement beacons must be fired directly by RAF client-side (they may not be wrapped). This is required to apply the [Roku Advertising Watermark](/docs/developer-program/advertising/ad-watermark.md) to the beacons.

*   Interactive ads through Innovid, BrightLine, and Roku.

*   Client-side solutions to minimize buffering between ads and content.

*   Samples for implementing server-side ad insertion (SSAI) with Verizon Media Services, Adobe, Brightcove, Yospace, AWS Elemental MediaTailor servers, and Google Ad Manager Dynamic Ad Insertion (DAI).

Certification requirement
-------------------------

Per [Roku's certification criteria](/docs/developer-program/certification/certification.md#1-advertising), all apps that monetize advertising must integrate RAF to pass certification.

Getting started
---------------

To get started with your RAF integration, do the following:

*   If you don't have an ad server, contact [adsupport@roku.com](mailto:adsupport@roku.com) for recommendations or alternative ad serving solutions.

*   Read [monetizing an app with video advertisements](/docs/features/monetization/video-advertisements.md) for monetization options.

*   Read the [certification requirements for ad-supported apps](/docs/developer-program/certification/certification.md#1-advertising).

*   Review the [RAF integration guide](/docs/developer-program/advertising/integrating-roku-advertising-framework.md).

Supported features of popular ad formats
----------------------------------------

| VAST 2.0 Feature | Supported |
| --- | --- |
| Linear Ads | Yes |
| Wrapper and Inline Ads | Yes |
| Tracking Events | Yes |
| ClickThrough (interactive ads) | Yes |
| Companion Ads | _apiFramework_ handled:<br><br>*   "innovid"<br>*   "brightline"<br>*   "brightline\_RSG" |
| MediaFile type | *   "video/mp4"<br>*   "video/x-mp4"<br>*   "video/mp4-h264"<br>*   "application/x-mpegurl"<br>*   "application/vnd.apple.mpegurl"<br>*   "application/json" |
| Extension elements | *   DFP waterfall<br>*   TrueX |
| Non-Linear Ads | No  |
| VAST 3.0 Feature | Supported |
| Ad pods via sequence attribute | Yes |
| Extended error tracking | Yes |
| VAST tracking macros | Yes |
| Ad “buffet” selection | Yes |
| Skippable linear ads | No  |
| OBA industry icon | No  |
| VMAP Feature | Supported |
| Ad pods playlists | Yes |
| Tracking events | Yes |
| ‘repeatAfter’ AdBreak attribute | No  |
| Extension elements | No  |

RAF video lesson
----------------

You can learn how to implement RAF in order to display video ads in your app by watching the [Displaying video ads](/videos/courses/rsg/video-ads.md) video lesson in Roku's [SceneGraph: Build a channel online video course](https://developer.roku.com/videos/courses/rsg/overview.md).

This lesson describes how to implement RAF in order to seamlessly insert video ads into content. It highlights the different client and server-side ad insertion and stitching solutions provided by RAF, and explains how to get started with RAF in order to display video ads in your app.

Fast video start
================

Fast video start is a user interface design technique for apps that reduces the amount of time apparent to the user that the video stream buffers before actual playback begins.

All digital video requires some time after a video is selected to begin playback, and video files streamed over HTTP add network transfer rates to this buffering time. Typically, to play back a video, the content meta-data for a video is set, and an roSpringboardScreen component (or equivalent) is shown to the user with descriptive details about the video. When the user actually selects the video for playback, calling play() on the roVideoScreen or roVideoPlayer object shows a "loading" screen before actual playback, while the video stream is buffering. **"Fast start"** allows this video stream buffering to take place _before_ the user has actually selected a video for playback, by initiating the buffering process while the user is deciding whether to play a certain video.

To implement fast video start, you create a roVideoScreen or roVideoPlayer component prior to showing a roSpringboardScreen (or equivalent) for a video, and call Prebuffer(). The video stream will buffer for as long as the user is reading the description of the video on the screen. Then when the user actually selects the video for playback, call play(). Depending on how much time the user spent reading the video description, the video may begin actual playback immediately, or with a much reduced amount of time that the "loading" screen is shown.

Calling Prebuffer() starts buffering the video specified by a previous SetContentList() (for roVideoPlayer) or SetContent() (for roVideoScreen) call. If the video has not been specified in one of these ways, calling Prebuffer() has no effect.

> SceneGraph apps use the [Video node](/docs/references/scenegraph/media-playback-nodes/video.md) control field prebuffer option to implement Fast Video Start. See [Fast start media playback](/docs/developer-program/core-concepts/playing-videos.md#fast-start-media-playback) for information on implementing Fast Video Start in a SceneGraph app.

roVideoPlayer use cases
-----------------------

### Prebuffer before playback

The following code demonstrates this use case.

    port = CreateObject( "roMessagePort" )
    
    content = {
      Stream: { url : "http://play.this.url.com/video.m3u8" }
      StreamFormat: "hls"
    }
    
    ' First   create the player and set content list
    player = CreateObject( "roVideoPlayer" )
    player.setMessagePort( port )
    player.setContentList( content )
    ' Prebuffer the data
    player.Prebuffer()
    
    ' Show the content springboard screen and wait for an event
    ' from user asking to playback the content
    while true
      msg = wait( 0, port)
      ' break out if correct message is received
    end while
    
    ' Start   playback now
    player.play()
    
    ' Handle user requests here
    while true
      msg = wait( 0, port )
      ' process msg here
    end while
    

For this use case, the video player event handling has to occur in two event loops, one while prebuffering from a content springboard screen, and one during playback. This is necessary since the firmware may encounter errors during prebuffer that should be handled by the app.

### Playback canceled after/while prebuffering

If the app calls Stop() while prebuffering, prebuffered video data is discarded. The app can subsequently call SetContentList(), Prebuffer() and Play() to play back a new video.

Additional considerations
-------------------------

To make use of the "fast start" feature, when an app enters the springboard (or movie details) screen, it must create a roVideoPlayer or roVideoScreen, and prebuffer the video. There are a few things to consider.

### Prebuffer position

Apps may have multiple play options on the springboard screen, including resuming playback and playback from start. A bookmarked position may be set in content meta-data to indicate the playback start position. Each play option will have a different play position associated with it. The bookmark position will have to default to one of the play positions and prebuffer the content from here. If the user selects the other play option, the data must be buffered again.

### Resuming playback

A user may exit playback to go back to the springboard screen, and then resume playback of the same video. Since the roVideoPlayer will have buffered the data, the app will ideally just resume playback. When going back to the springboard screen, Roku recommends that playback should be paused on roVideoPlayer. A user request to resume playback will take effect instantaneously. If the user starts playback from the beginning, then the roVideoPlayer must be stopped first, the BOOKMARKPOSITION modified in content meta-data, and a new playback session started.

roDouble
========

roDouble is the object equivalent for intrinsic type 'Double'.

It is a legacy object name, corresponding to the intrinsic Double object. Applications should use Double literal values and/or Double-typed variables directly.

Supported interfaces
--------------------

*   [ifDouble](/docs/references/brightscript/interfaces/ifdouble.md "ifDouble")
*   [ifToStr](/docs/references/brightscript/interfaces/iftostr.md "ifToStr")

<interface>
===========

The <interface> element defines a set of fields to be exposed by a component, to allow instances of the component to be manipulated externally to the component, while hiding details of the component implementation, in much the same way that C++ classes provide a public interface to objects. For example, a XML component might define a sprite object, and have an integer interface field that specifies which sprite bitmap to be displayed.

The <interface> element may include one or more <field> XML elements. Each <field> XML element defines a top-level field for the XML component. These top-level fields define an interface that allow users of the component to read, write, and observe the fields.

As of the 7.5 Roku OS release, the <interface> element may also include one or more <function> elements. This provides a mechanism for Roku apps to call functions synchronously, directly from a component. See [Functional Fields](/docs/developer-program/core-concepts/handling-application-events.md#HandlingApplicationEvents-FunctionalFields) for more details.

Attributes
----------

The following attributes define each XML element:

AttributeRequiredDescriptionidrequiredA string containing the name of the fieldtyperequiredA case-insensitive string containing the type of the field. The allowable types are BrightScript fundamental types, a SceneGraph node object reference, and a URL identifier type, as follows:  

| Type | Description |
| --- | --- |
| integer, int | BrightScript integer type |
| longinteger | BrightScript longinteger type |
| float | BrightScript float type |
| string, str | BrightScript string type |
| Boolean, bool | BrightScript Boolean type |
| vector2d | X/Y coordinate array |
| color | Color type |
| time | Time type |
| uri | A URL identifier |
| node | SceneGraph node object reference |
| floatarray | Array of float |
| intarray | Array of integer |
| boolarray | Array of Boolean |
| stringarray | array of strings |
| vector2darray | Array of vector2d |
| colorarray | Array of color |
| timearray | Array of time |
| nodearray | Array of SceneGraph node object reference |
| assocarray | Associative array |
| array | Array of objects - type specifier can be either array or roArray |
| rect2D | An associative array with 4 float values: (x, y, width, height)  <br>  <br>x and y represent the coordinates of the top left corner of the rectangle |
| rect2DArray | Array of rect2D associative arrays |

  
The type for an XML element is case insensitive. For example, "Boolean" or "boolean" may be used in a type declaration.aliasoptionalAllows a top-level component field to be declared as an alias of a field in one of the component child nodes. This allows a field of an internal component node to be exposed to users of the component. The attribute is set to a string with format `_node_._field_`, where _`node`_ is the ID of a SceneGraph node element, and _`field`_ is the name of one of the node fields. The type of the component child node field must match the `type` attribute.valueoptionalA string representing the initial value of the top-level field. If not specified, the default value for the field type is used (such as, zero for numeric fields, an empty string to string fields, and so forth).onChangeoptionalSets an observer call-back function to be added for the top-level field. The value of the attribute is a call-back function name in BrightScript code associated with the component. This attribute is provided as a quick way to set up an observer call-back function for top-level fields. It is equivalent to calling the ifSGNodeField `observeField()` method in BrightScript code associated with the component as follows:  
  
`m.top.ObserveField(fieldName, functionName)`alwaysNotifyoptionalA string with the value true or false that indicates whether the field observer functions should be notified every time the field value is set, or only when the field value changes. By default, the attribute is false, so the observer functions are only notified when the field value changes. Set this attribute to true if the observer function should be notified every time the field value is set even though it doesn't necessarily change.

The following attributes define each <function> XML element:

| Attribute | Required | Description |
| --- | --- | --- |
| name | required | A string containing the name of the function which can be called using the [callFunc() function](/docs/references/brightscript/interfaces/ifsgnodedict.md#callfunc). |

Examples
--------

The following adds two fields as the interface to a component: a `uri` field, and a SceneGraph node object reference.

**<interface> element example**

    <interface>
        <field id="contenturi" type="uri" />
        <field id="content" type="node" />
    </interface>
    

The following defines a function named 'doSomething' on the corresponding component interface.

    <interface>
        <function name="doSomething" />
    </interface>

roString
========

roString is the object equivalent for intrinsic type 'String'.

This is useful in the following situations:

*   When an object is needed, instead of an intrinsic value. For example, "roList" maintains a list of objects. If an String is added to roList, it will be automatically wrapped in an roString by the language interpreter. When a function that expects a BrightScript Component as a parameter is passed a string, BrightScript automatically creates the equivalent BrightScript Component.
    
*   If any object exposes the ifString interface, that object can be used in any expression that expects an intrinsic value.
    

Supported interfaces
--------------------

*   [ifString](/docs/references/brightscript/interfaces/ifstring.md "ifString")
*   [ifStringOps](/docs/references/brightscript/interfaces/ifstringops.md "ifStringOps")
*   [ifToStr](/docs/references/brightscript/interfaces/iftostr.md "ifToStr")

ifLongInt
=========

Implemented by
--------------

| Name | Description |
| --- | --- |
| [roLongInteger](/docs/references/brightscript/components/rolonginteger.md "roLongInteger") | Object equivalent for intrinsic type LongInteger |

Supported methods
-----------------

### GetLongInt() As LongInteger

#### Description

Gets the longinteger value stored in the calling Longinteger object.

#### Return Value

The longinteger value stored in the calling Loninteger object.

### SetLongInt(value As LongInteger) As Void

#### Description

Sets the calling Longinteger object to the specified longinteger value.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| value | Longinteger | The longinteger value to be set on the calling Longinteger object. |

ifArrayGet
==========

The ifArrayGet interface supports the array indexing operator \[ \]

(See [Array Operator](/docs/references/brightscript/language/expressions-variables-types.md#effects-of-type-conversions-on-accuracy "Array Operator"))

Implemented by
--------------

| Name | Description |
| --- | --- |
| [roArray](/docs/references/brightscript/components/roarray.md "roArray") | An array stores an indexed collection of BrightScript objects. Each entry of an array can be a different type, or they may all of the same type |
| [roByteArray](/docs/references/brightscript/components/robytearray.md "roByteArray") | The byte array component is used to contain and manipulate an arbitrary array of bytes |
| [roList](/docs/references/brightscript/components/rolist.md "roList") | The list object implements the interfaces: ifList, ifArray, ifEnum and therefore can behave like an array that can dynamically add members |
| [roXMLList](/docs/references/brightscript/components/roxmllist.md "roXMLList") | Contains a list of roXML objects |

Supported methods
-----------------

### GetEntry(index As Integer) As Dynamic

#### Description

Returns an array entry based on the provided index.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| index | Integer | The index of the array entry to be returned. |

#### Return Value

The array entry corresponding to the provided index, or invalid if the entry has not been set.

StdDlgTitleArea
===============

Extends [StdDlgAreaBase](/docs/references/scenegraph/standard-dialog-framework-nodes/std-dlg-area-base.md "**StdDlgAreaBase**")

The **StdDlgTitleArea** node contains the dialog's title information, which is always displayed at the top of the dialog. The title area may also include optional icons that appear left or right justified. The **StdDlgTitleArea** should only be used as a child node of a [**StandardDialog**](/docs/references/scenegraph/standard-dialog-framework-nodes/standard-dialog.md).

A dialog may contain a single title area, and the title area is optional (but is typically used in nearly all cases)

![roku815px - title-area-icon](https://image.roku.com/ZHZscHItMTc2/title-area-icon.jpg)

Fields
------

| Field | Type | Default | Access Permission | Description |
| --- | --- | --- | --- | --- |
| primaryTitle | string | ""  | READ\_WRITE | Specifies the title to be displayed in the dialog's title area. |
| primaryIcon | URL | ""  | READ\_WRITE | Specifies a bitmap to be displayed at the left edge of the dialog's title area (to the left of dialog's primary title). |
| primaryIconVertOffset | float | 0.0f | READ\_WRITE | Adjusts the vertical position of the primary icon relative to the baseline of the dialog's primary title. By default, the bottom of the primary icon is aligned with the primary title's baseline. |
| secondaryIcon | URL | ""  | READ\_WRITE | Specifies a bitmap to be displayed at the right edge of the dialog's title area. |
| secondaryIconVertOffset | float | 0.0f | READ\_WRITE | Adjusts the vertical position of the secondary icon relative to the baseline of the dialog's primary title. By default, the bottom of the secondary icon is aligned with the primary title's baseline. |

ifSocketCastOption
==================

Implemented by
--------------

| Name | Description |
| --- | --- |
| [roDataGramSocket](/docs/references/brightscript/components/rodatagramsocket.md "roDataGramSocket") | The roDataGramSocket component enables Brightscript apps to send and receive UDP packets |

Supported methods
-----------------

Only the [roDataGramSocket](/docs/references/brightscript/components/rodatagramsocket.md "roDataGramSocket") component supports the ifSocketCastOption multicast interface. The [roStreamSocket](/docs/references/brightscript/components/rostreamsocket.md "roStreamSocket") component does not support multicast.

### GetBroadcast() as Boolean

#### Description

Checks whether broadcast messages may be sent or received.

#### Return Value

A flag indicating whether broadcast messages may be sent or received.

### SetBroadcast(enable as Boolean) as Boolean

#### Description

Enables broadcast messages to be sent or received.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| enable | Boolean | A flag specifying whether broadcast messages may be sent or received. |

#### Return Value

A flag indicating whether this operation succeeded.

### JoinGroup(ipAddress as Object) as Boolean

#### Description

Joins a specific multicast group.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| ipAddress | Object | An [roSocketAddress](/docs/references/brightscript/components/rostreamsocket.md "roSocketAddress") representing the group to be joined. IPV4 multicast addresses are in the range of 224.0.0.0 through 239.255.255.255. |

#### Return Value

A flag indicating whether this operation was successful.

### DropGroup(ipAddress as Object) as Boolean

#### Description

Drops out of a specific multicast group.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| ipAddress | Object | An [roSocketAddress](/docs/references/brightscript/components/rostreamsocket.md "roSocketAddress") representing the group to leave. IPV4 multicast addresses are in the range of 224.0.0.0 through 239.255.255.255. |

#### Return Value

A flag indicating whether this operation was successful.

### GetMulticastLoop() as Boolean

#### Description

Checks whether multicast messages are enabled for local loopback.

#### Return Value

A flag indicating whether multicast messages are enabled for local loopback. If this flag is true, multicast message sent locally are to be received locally.

### SetMulticastLoop(enable as Boolean) as Boolean

#### Description

Enables local loopback of multicast messages.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| enable | Boolean | A flag specifying whether local loopback of multicast messages; otherwise do not send or receive broadcast messages. |

#### Return Value

A flag indicating whether this operation was successful.

### GetMulticastTTL() as Integer

#### Description

Returns the TTL integer value for multicast messages. This is the number of hops a packet is allowed before a router drops the packet.

#### Return Value

The multicast messages value.

### SetMulticastTTL(ttl as Integer) as Boolean

#### Description

Sets the TTL integer value for multicast messages.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| ttl | Integer | The number of hops a packet is allowed before a router drops the packet |

#### Return Value

A flag indicating whether the TTL value was successfully set.

roBitmap
========

The roBitmap component contains image data and provides an interface (ifDraw2D) for drawing. Bitmaps can be used for a variety of purposes, such as for sprites, compositing, or as double buffers.

It stores four color apps: red, green, blue, and alpha, with 32-bits per pixel. They can be any arbitrary size up to 2048x2048. However, the maximum size bitmap uses 16MB of memory, so there are practical memory limitations which would compel smaller bitmap sizes. Coordinates (x,y) for 2D bitmaps have an origin (0,0) at the top left. roBitmap is always offscreen. The top roScreen is the only ifDraw2D surface which is displayed. roBitmap represents something that can be drawn onto, as well as something that can be drawn.

Drawing operations into a roBitmap (or other surface with ifDraw2D interface, such as an [roScreen](/docs/references/brightscript/components/roscreen.md "roScreen")) are clipped so the only the part that is within its bounds is rendered. X,Y coordinates that specify a location in a bitmap to render to (for example, as used by DrawObject() or DrawText() ) may be positive or negative. Negative implies that the left and top of the rendered object will be clipped.The same bitmap cannot be used as a source and a destination in a single DrawObject() call.

There are limitations when using the onscreen bitmap as a source. For example, Alpha blending may not work.

An empty roBitmap object can be created with CreateObject():

`CreateObject("roBitmap", bitmapProps As Object)`

bitmapProps is an roAssociativeArray with Integers width (Integer), height (Integer), and AlphaEnable (Boolean), and name (String) parameters. The contents of an empty RoBitmap are initialized to zero (transparent black).

Example: `CreateObject("roBitmap", {width:10, height:10, AlphaEnable:false, name:"MyBitmapName"})`

An roBitmap can also load its image data from a file:

`CreateObject("roBitmap", String filename)`

**Example**

    ' Draw three bitmaps as fast as we can
    '
    Screen=CreateObject("roScreen")
    bm1=CreateObject("roBitmap", "pkg:/images/myphoto1.jpg")
    bm2=CreateObject("roBitmap", "pkg:/images/myphoto2.jpg")
    bm3=CreateObject("roBitmap", "pkg:/images/myphoto3.jpg")
    bmarray=[bm1, bm2, bm3]
    While true
        For each bitmap in bmarray
            Screen.DrawObject(0,0, bitmap)
            Screen.Finish()
        End for
    End While
    

**Example: Double buffering with roBitmap**

    screen1=CreateObject("roScreen")
    off=CreateObject("roBitmap", {width:1280, height:720, AlphaEnable:false})
    off.Clear(white)
    dfDrawImage(off, "pkg:/images/myimage.png", 50, 50)
    off.DrawRect(150, 150, 200, 200, &hFF) ' black, alpha: all source
    screen1.DrawObject(0, 0, off)
    Screen1.Finish()
    

Supported image formats
-----------------------

See the [Roku streaming specification](/docs/specs/media/streaming-specifications.md#supported-image-formats) for the image formats supported by this component.

Supported interfaces
--------------------

*   [ifDraw2D](/docs/references/brightscript/interfaces/ifdraw2d.md "ifDraw2D")

ifTextureManager
================

Implemented by
--------------

| Name | Description |
| --- | --- |
| [roTextureManager](/docs/references/brightscript/components/rotexturemanager.md "roTextureManager") | The Texture Manager provides a set of API's for managing an roBitmap cache |

Supported methods
-----------------

### RequestTexture(req as Object) as Void

#### Description

Makes a request for an roBitmap with the attributes specified by the roTextureRequest. The roTextureManager will pass an roTextureRequestEvent to the message port when completed.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| req | Object | The roTextureRequest |

### CancelRequest(req as Object) as Void

#### Description

Cancels the request specified by req, which should be an roTextureRequest previously passed to the [RequestTexture()](#requesttexturereq-as-object-as-void) method.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| req | Object | The previoulsy passed roTextureRequest to be cancelled. |

### UnloadBitmap(url as String) as Void

#### Description

Removes a bitmap from the roTextureManager with the specified URL.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| url | String | The URL of the bitmap to be removed from the roTextureManager |

### Cleanup() as Void

#### Description

Removes all bitmaps from the roTextureManager.

DynamicKeyboardBase
===================

Extends [**Group**](/docs/references/scenegraph/layout-group-nodes/group.md "**Group**")

> Apps must use Roku voice keyboards for [email](/docs/references/scenegraph/dynamic-voice-keyboard-nodes/dynamic-keyboard.md), [PIN](/docs/references/scenegraph/dynamic-voice-keyboard-nodes/dynamic-pinpad.md), [password](/docs/references/scenegraph/dynamic-voice-keyboard-nodes/dynamic-keyboard.md) entry to pass [certification](/docs/developer-program/certification/certification.md#4-channel-operation).

The DynamicKeyboardBase is an abstract class that provides the functionality for dynamic voice-enabled keyboards. It combines [**DynamicKeyGrid**](/docs/references/scenegraph/dynamic-voice-keyboard-nodes/dynamic-key-grid.md) and [**VoiceTextEditBox**](/docs/references/scenegraph/dynamic-voice-keyboard-nodes/voice-text-edit-box.md) nodes to provide a single node that supports text entry in multiple languages and voice entry in English and Spanish.

*   The [**DynamicKeyGrid**](/docs/references/scenegraph/dynamic-voice-keyboard-nodes/dynamic-key-grid.md) provides keyboard functionality. The layout of the keyboard is based on a JSON-formatted Key Definition File.
    
    The classes derived from DynamicKeyboardBase (DynamicKeyboard, DynamicPinPad, and DynamicMiniKeyboard) have built-in Key Definition Files. For example, the DynamicKeyboard node uses a Key Definition File that matches the key layout of the [legacy Keyboard node](/docs/references/scenegraph/widget-nodes/keyboard.md).
    
    The [**DynamicCustomKeyboard** node](/docs/references/scenegraph/dynamic-voice-keyboard-nodes/dynamic-custom-keyboard.md) enables developers to define a custom Key Definition File in order to configure the key layout. In the Key Definition File, the developer specifies the keys in each section and row of the keyboard. The keys support the characters in the Basic Latin, Latin 1 Supplement, Latin Extended-A, and Latin Extended-B blocks. This provides support for most Western European languages, including English, French, German, Italian, Portuguese, and Spanish.
    

*   The [**VoiceTextEditBox**](/docs/references/scenegraph/dynamic-voice-keyboard-nodes/voice-text-edit-box.md) displays the text that has been entered or spoken. This node supports multiple voice entry modes for entering email addresses, passwords, street addresses, and PINs. This node currently supports voice entry in English and Spanish.

> Developers should upgrade the [legacy keyboards](/docs/references/scenegraph/widget-nodes/keyboard.md) in their apps to dynamic voice-enabled keyboards in order to leverage the following benefits:
> 
> *   **Faster on-device sign-ups and sign-ins.** Enable customers to use voice entry to provide their information when subscribing to apps and logging in.
>     
> *   **Localized in-app search**: Enable customers to search for content in their native language.
>     
> *   **Localized customer information entry**: Enable customers to enter their personal information in their native language.
>     

Fields
------

| Field | Type | Default | Access Permission | Description |
| --- | --- | --- | --- | --- |
| text | string | ""  | READ\_WRITE | Contains the string of characters that has been entered. The text written to this field may also be displayed in the VoiceTextEditBox. |
| textEditBox | [**VoiceTextEditBox** node](/docs/references/scenegraph/dynamic-voice-keyboard-nodes/voice-text-edit-box.md) | The VoiceTextEditBox associated with the keyboard | READ | The internal [VoiceTextEditBox node](/docs/references/scenegraph/dynamic-voice-keyboard-nodes/voice-text-edit-box.md) used by this DynamicKeyboardBase node.  <br>  <br>Do not set this field to null or to a different VoiceTextEditBox node; this field should be used only to access the fields of this node's internal VoiceTextEditBox node. |
| hideTextBox | boolean | false | READ\_WRITE | Hides the keyboard's internal **VoiceTextEditBox**, and renders the keyboard's **DynamicKeyGrid** at the top of the node. |
| keyGrid | **[DynamicKeyGrid node](/docs/references/scenegraph/dynamic-voice-keyboard-nodes/dynamic-key-grid.md)** | The DynamicKeyGrid associated with the keyboard | READ | The internal [DynamicKeyGrid node](/docs/references/scenegraph/dynamic-voice-keyboard-nodes/dynamic-key-grid.md) used by this DynamicKeyboardBase node.  <br>  <br>Do not set this field to null or to a different DynamicKeyGrid node; this field should be only used to access the fields of this node's internal DynamicKeyGrid node, such as the mode or horizWrapping fields. |
| domain | string | "generic" | READ\_WRITE | The keyboard mode, which may be one of the following:  <br><br>*   "email": letter-by-letter dictation for emails.<br>*   "numeric": letter-by-letter dictation for PIN codes, zip codes, and other numeric input.<br>*   "alphanumeric": letter-by-letter dication for street addresses or other sequences of numbers and letters.<br>*   "generic": Full word input for search queries or other sequences of numbers, letters and symbols.<br>*   "password": letter-by-letter dication for passwords.<br><br>  <br>The domain may be used to:  <br><br>*   Set options for the speech recognition system.<br>*   Identify when a complete string has been entered (for example, an email address).<br>*   Specify whether the entered string is displayed as a single string or a discrete sequence of characters (for example, a PIN code).<br>*   Enable key suggestions (for example, a pop-up for the ampersand key (&) to provide common email choices). |

UX recommendations
------------------

1.  Do not show hint text in the [VoiceTextEditBox](/docs/references/scenegraph/dynamic-voice-keyboard-nodes/voice-text-edit-box.md).
2.  Display secondary text under the title.
3.  Show the horizontal blinking cursor when the focus is on the [VoiceTextEditBox](/docs/references/scenegraph/dynamic-voice-keyboard-nodes/voice-text-edit-box.md) and vertical blinking cursor when the focus is on the keyboard buttons.

![roku815px - email-keyboard](https://image.roku.com/ZHZscHItMTc2/email-keyboard.png)

![roku815px - email-keyboard](https://image.roku.com/ZHZscHItMTc2/email-keyboard-2.png)

Sample app
----------

You can download and install a [sample app](https://github.com/rokudev/dynamic-voice-enabled-keyboards) that demonstrates how to create and configure dynamic voice-enabled keyboards. The sample app includes a voice-enabled keyboard, PIN pad, mini-keyboard, and custom keyboard (an address keyboard form).

BrightScript support
====================

Several BrightScript functions and components cannot be used in SceneGraph component scripts. Many of the BrightScript components that cannot be used provide duplicate rendering functionality as SceneGraph nodes, and cannot be used for that reason. You should use the equivalent SceneGraph nodes instead, if available. Other BrightScript functions and components can only be used in SceneGraph applications in a [Task](/docs/references/scenegraph/control-nodes/task.md) node.

The following are the BrightScript functions and components that cannot or should not be used in the component scripts of a SceneGraph application, with additional information for many, such as:

*   SceneGraph nodes to use instead, if available
*   a function or component that can only be used in a Task node

| BrightScript | Notes |
| --- | --- |
| ParseJson() | Should only be used in a **Task** node |
| parseXml() | Should only be used in a **Task** node |
| ReadAsciiFile() | Should only be used in a **Task** node. |
| roAppManager | User interface component, cannot be used in a SceneGraph application |
| roAudioMetadata | Should only be used in a **Task** node. |
| roAudioPlayer | Cannot be used in a SceneGraph application |
| roAudioResource | Cannot be used in a SceneGraph application |
| roChannelStore | Can only be used in a **Task** node or in the main BrightScript thread |
| roCompositor | User interface component, cannot be used in a SceneGraph application |
| roDatagramSocket | Can only be used in a **Task** node |
| roFileSystem | Can only be used in a **Task** application |
| roFont | Use the SceneGraph **Font** node instead |
| roFontRegistry | Cannot be used in a SceneGraph application |
| roImageMetadata | Should only be used in a **Task** node. |
| roMessagePort | This can be used when the SceneGraph application is launched, but not within the application component scripts |
| roPinEntryScreen | Use a SceneGraph PinPad instead |
| roRegion | User interface component, cannot be used in a SceneGraph application |
| roScreen | User interface component, cannot be used in a SceneGraph application |
| roSocketAddress | Can only be used in a **Task** node |
| roSprite | User interface component, cannot be used in a SceneGraph application |
| roStreamSocket | Can only be used in a **Task** node |
| roSystemLog | Cannot be used in a SceneGraph application |
| roTextureManager | User interface component, cannot be used in a SceneGraph application |
| roTextureRequest | User interface component, cannot be used in a SceneGraph application |
| roUrlTransfer | Can only be used in a **Task** node |
| roVideoPlayer | Use the SceneGraph **Video** node instead |

ButtonGroup
===========

Extends [**LayoutGroup**](/docs/references/scenegraph/layout-group-nodes/layoutgroup.md "**LayoutGroup**")

The ButtonGroup node class manages the layout, visual attributes, and focus management of a vertical list of Button nodes. When the ButtonGroup node has focus, it sets the key focus on a single one of its child Button nodes.

*   The buttons can be easily created using default button appearances by setting the buttons field to an array of strings containing the labels for each button.
*   A single observer can watch for any of the Button nodes in the group to be selected by observing the buttonSelected field.
*   By default, Button nodes added to the group will have the default button appearance. Several fields exist that allow you to change an attribute of the appearance of all Button nodes in the group.

Fields
------

| Field | Type | Default | Access Permission | Description |
| --- | --- | --- | --- | --- |
| textColor | color | 0xffffffff | READ\_WRITE | Specifies the button label color for all unfocused Button nodes in the group. Only set to override the system default |
| focusedTextColor | color | 0xffffffff | READ\_WRITE | Specifies the button label color for the Button node that has focus, if any. Only set to override the system default |
| textFont | Font | system: MediumSystemFont | READ\_WRITE | Specifies the [Font](/docs/references/scenegraph/typographic-nodes/font.md "Font") node for all unfocused Button nodes in the group. Only set to override the system default. See Font for a list of all system fonts available |
| focusedTextFont | Font | system: MediumBoldSystemFont | READ\_WRITE | Specifies the [Font](/docs/references/scenegraph/typographic-nodes/font.md "Font") node for the Button node that has focus, if any. Only set to override the system default. See Font for a list of all system fonts available |
| focusBitmapUri | uri |     | READ\_WRITE | Specifies the bitmap to be used as the background for the Button node that has focus. Only set to override the system default |
| focusFootprintBitmapUri | uri |     | READ\_WRITE | Specifies the bitmap to be used as the focus footprint background, when focus is not on the ButtonGroup node. The focus footprint is a visual indicator of the button that will take focus when focus moves back onto the ButtonGroup node. Only set to override the system default |
| iconUri | uri |     | READ\_WRITE | Specifies the bitmap for the button icon for all unfocused Button nodes in the group. Only set to override the system default |
| focusedIconUri | uri |     | READ\_WRITE | Specifies the bitmap for the focused button icon. Only set to override the system default |
| minWidth | float | 0   | READ\_WRITE | Specifies the minimum width for the Button nodes in the group. The minWidth field must be less than or equal to the maxWidth field. Only set to override the system default |
| maxWidth | float | 32767 | READ\_WRITE | When set, specifies the maximum width for the Button nodes in the group. The maxWidth field must be greater than or equal to the minWidth field |
| buttonHeight | float | 0   | READ\_WRITE | Specifies the height of each Button node in the group. Only set to override the system default |
| rightJustify | Boolean | false | READ\_WRITE | Specifies whether the button labels and icons should be right- or left-justified. When right-justified and there is an icon, it appears to the right of the button label |
| buttonSelected | integer | 0   | READ\_ONLY | Set to the index of the selected button whenever the user selects a button in the group |
| buttonFocused | integer | 0   | READ\_ONLY | Set to the index of the focused button whenever a button in the group receives the key focus |
| focusButton | integer | 0   | WRITE\_ONLY | Causes the button with the specified index to receive the focus when the ButtonGroup node has the key focus. Note that if the ButtonGroup node does not have the key focus when the focusButton field is set, the specified button will display the focus "footprint" as its background |
| buttons | array of strings | \[ \] | WRITE\_ONLY | Allows a set of Button nodes to be easily created by providing an array of button labels. Each string in the array will result in a Button node to be added to the ButtonGroup node, using the string as the button label |

Sample app
----------

[ButtonGroupExample](https://github.com/rokudev/samples/tree/master/ux%20components/widgets/ButtonGroupExample) is a sample app demonstrating ButtonGroup in action.

roTextureRequestEvent
=====================

The [roTextureManager](/docs/references/brightscript/components/rotexturemanager.md "roTextureManager") sends the roTextureRequestEvent after completing a request.

Supported methods
-----------------

### GetId() as Integer

Returns the unique id of the request.

### GetState() as Integer

Returns the state of the request. See [ifTextureRequest](/docs/references/brightscript/interfaces/iftexturerequest.md "ifTextureRequest").GetState() for the list of states.

### GetURI() as String

Returns the URI of the request.

### GetBitmap() as Object

Returns an roBitmap from the request if the state is ready.

Continue Watching
=================

Continue Watching is a content category row within the **What to Watch** home screen navigation on Roku devices and on the Home screen of the Roku mobile app. It displays content from participating apps that customers have already started watching, which empowers customers with the speed and convenience of a single location from which they can resume content from different apps on any Roku device linked to their account. Publishers can integrate into this feature to make their content more accessible to customers, drive users to their apps, and increase engagement. Overall, this helps publishers promote their content in order to retain customers and reduce churn.

![roku815px - continue watching row](https://image.roku.com/ZHZscHItMTc2/continue-watching-ui-v2.png)

> The Continue Watching feature is available on all Roku devices running Roku OS 11.0 or higher in the United States, Canda, United Kingdom, Germany, Mexico, Chile, Argentina, and Colombia.
> 
> Apps in the U.S. Streaming Store that have streamed more than an average of 5 million hours per month over the last three months must participate in Roku’s Continue Watching program to pass [certification](/docs/developer-program/certification/certification.md#4-channel-operation). This requirement also applies to new apps projected to reach the specified streaming hours threshold shortly after launch. TVOD, live linear, and made-for-kids apps are excluded from this requirement.
> 
> Continue Watching only supports long-form content such as movies and television episodes. Short-form content (standalone content that is 15 minutes or less that is not a movie or TV show) is not supported.

Overview
--------

From the Roku home screen, customers can scroll down to the **What to Watch** screen. This screen features a **Continue Watching** row with content from participating apps, including movies and TV shows that the customer needs to finish, live linear apps that the customer was watching, and the next episodes in a television series. The Continue Watching row contains a maximum of 40 tiles, which are ordered based on Roku-proprietary algorithms that use various signals, including recency.

> The Continue Watching row is also available on the Home screen of the Roku mobile app.

As customers browse content, metadata for the item with focus is displayed. This includes the publisher's logo, title, release date, rating, and duration. In addition, if the app supports user profiles, a label indicates the user that was watching that content item. A progress bar indicates the approximate playback position of the content item.

When the customer selects a movie, TV show, or TV episode, it launches directly into playback (apps may not launch into a profile selection screen, content details screen, or any other screen when content is selected from the Continue Watching row). For customers with multiple Roku devices linked to their account, Continue Watching resumes playback at the bookmarked position on any of their devices.

Prerequisites
-------------

Apps must have completed the following integrations to participate in Roku Continue Watching:

1.  [Roku Search](/docs/developer-program/discovery/search/implementing-search.md). Enables customers to find content on your app.
2.  [Deep linking](/docs/developer-program/discovery/implementing-deep-linking.md). Enables the requested content to be launched directly into playback on your app.
3.  [Bookmarking](/docs/developer-program/media-playback/bookmarking.md). Resumes playback of the requested content at its last watched position.

Getting started
---------------

To get started with the Continue Watching integration, follow these steps:

1.  Verify that your app meets the listed [prerequisites](#prerequisites).

2.  Contact the [Roku Partner Success team](https://developer.roku.com/contact). They will determine whether your app is eligible for Continue Watching and enable your app to access the Continue Watching service endpoints.

3.  Request device tokens for testing the Continue Watching integration in a sideloaded environment. Provide Roku Partner Engineering with the serial numbers of the Roku devices to be used for testing during development. Upon receiving the device tokens, install them on their respective test devices by entering the following cURL command in a terminal application:
    
    `curl --data-binary @<token-file> http://<Roku_IP>:8060/token/install`
    
    The response from the terminal application should be as follows:
    
         <TokenCmdResponse>
             <Command>Install</Command>
             <Response>Success</Response>
         </TokenCmdResponse>
        
    
4.  Once development has been completed, request authentication tokens for testing the Continue Watching integration in a beta environment. This enables you to complete QA testing before releasing your updated app to production. Provide Roku Partner Engineering with the list of the app IDs to be used for QA testing. Upon receiving the app token, add it to the [manifest](/docs/developer-program/getting-started/architecture/channel-manifest.md) (channel\_token=). The **channel authentication token** will also be used in your production application.
    

Integrating into Continue Watching
----------------------------------

Integrating into Continue Watching entails calling the Roku Continue Watching APIs when a playback event occurs. Playback events occur when the customer exits the video player or finishes watching content. Sending events identifies which content the customers can keep watching and where to resume playback. Publishers can use the Roku Continue Watching APIs to add, update, and remove content items. The workflow is illustrated and summarized as follows:

![roku815px - cw-api-flow](https://image.roku.com/ZHZscHItMTc2/continue-watching-api-flow-v1.jpeg)

| Step | API | Description |
| --- | --- | --- |
| **Retrieve bookmarks when app is launched** | Publisher backend system | The publisher maintains the playback position of content. Roku does not maintain bookmarks because content may be watched across multiple platforms (for example, web and Roku). This ensures that deep links from the Continue Watching row return the customer to the actual playback position. |
| **Update bookmark** | PUT request to Continue Watching API | Once the publisher retrieves the current playback position from their backend system, the app makes a **PUT** request to update the Continue Watching row with that bookmark. |
| **Add content to Continue Watching row when content playback starts** | POST request to Continue Watching API | The publisher controls how long content has been watched (for example, one minute) before it is added to the Continue Watching row. Once the publisher-configured interval has been reached, the app makes a POST request to add the content to the Continue Watching row.  <br><br>During playback, do not make Continue Watching API calls to update the playback position. The main purpose of the Continue Watching user experience is to aggregate in-progress content and streamline resumption. The progress bar used to reflect the current bookmark in the Continue Watching row is an approximation. If the customer presses the Home button after the POST request has been sent, the content will still be listed in the Continue Watching row, which is the primary goal of the feature. |
| **Update content playback position when content playback ends** | POST request to Continue Watching API | Once the customer stops content playback, the app makes a **POST** request to update the Continue Watching row the current bookmark for that content. |
| **Remove content from Continue Watching row when content has been completed** | DELETE request to Continue Watching API | The publisher controls what constitutes the completion of content (for example, end credits are shown). Once content has been completed, the app makes a DELETE request to remove the content from the Continue Watching row. |

### API Reference

The following table summarizes the basic information for the Continue Watching RESTful web services:

| Item | Description |
| --- | --- |
| **Endpoint** | The base URLs for the Continue Watching APIs are as follows:  <br><br>*   [https://userdata.sr.roku.com/user-data/v1/content/continueWatching](https://userdata.sr.roku.com/user-data/v1/content/continueWatching)<br>*   [https://userdata.sr.roku.com/user-data/v1/profile/{**profileId**}/content/continueWatching](https://userdata.sr.roku.com/user-data/v1/profile/%7B**profileId**%7D/content/continueWatching) (use this endpoint if your app has a profile selection screen and the content being passed is specific to the provided **profileId** (the unique user ID \[UUID\] of the user profile). The **profileId** is passed back to the app in a deep link request from the Continue Watching feature. |
| **Protocol** | Continue Watching API calls may only be sent using HTTPS. |
| **Methods** | The Continue Watching APIs support the following REST methods for adding, retrieving, updating, and deleting content items:  <br><br>*   **POST**. Add one or more new content items; update existing items.<br>*   **GET**. Retrieve the existing list of content items.<br>*   **PUT**. Replace the entire existing list of content items. When making this request, include all the content that should remain in the Continue Watching row (for example, a PUT request with a single item replaces the current list with that one item). Passing an empty body removes all content from the list.<br>*   **DELETE**. Remove one or more content items. |
| **Header** | Requests to the Continue Watching APIs require the following headers (the Roku OS automatically populates the headers with empty string values):<br><br>*   **Content-Type:** application/json<br>*   **x-roku-reserved-jwt**: ""<br>*   **x-roku-reserved-channel-id**: "" (the production app ID is required to sideload and test the app during development because it is linked to the search feed. In production, the Roku OS will override this value, which means you can continue passing it after development has been completed).<br>*   **x-roku-reserved-channel-store-code**: ""<br>*   **x-roku-reserved-virtual-user-id**: ""<br>*   **x-roku-reserved-device-id**: ""<br>*   **x-roku-reserved-serial-number**: ""<br><br>> See [Appendix A](#appendix-a-sample-brightscript-code-for-adding-http-headers) for sample BrightScript code that demonstrates how to add these headers to your app application. Do not use the [roHttpAgent.setHeaders()](/docs/references/brightscript/interfaces/ifhttpagent.md#setheadersnamevaluemap-as-object-as-boolean) function to pass the headers. |
| **Response** | The Continue Watching APIs return one of the following response codes:  <br><br>*   **200**: OK<br>*   **204**: No content (DELETE requests only)<br>*   **400**: Bad request (required fields are missing from the payload; a description of the error is returned)<br>*   **401**: Unauthorized (DELETE requests only)<br>*   **403**: Forbidden (if an invalid partner) |

### Add API

To add new content items and update existing ones to the Continue Watching row, send a **POST** request to the Continue Watching API with the following parameters in the JSON body:

ParameterTypeRequired/OptionalDescriptioncontentIdStringRequiredThe ASCII string (maximum 255 characters) used to uniquely identify the content in your app.  
  
This maps directly to the playID (contentId) field in the [Roku Search feed specification](/docs/specs/search/search-feed.md) or contentId for any search implementations using externalId providers.  
  
For a TV series, the seriesId maps to the corresponding seriesId field in Search feed spec.  

> For a TV series, you must pass (1) the seriesId (the ID of series asset) in the **contentId** field and (2) the playID of the episode in the **episodeId** field.

episodeIdStringOptionalIf the content is a TV episode that is part of a series, pass the following:  

*   contentId: Pass the **seriesId** in this field. This should be the same as the seriesId in the app's Roku Search feed.
*   episodeId: Pass the **episodeId** in this field. This should be the same as the "playId" in the app's Roku Search Feed, or "contentId" in externalID implementations

  
This enables Roku to enhance the UX presentation of the series resume point.  
  
If the **waitForNextEpisodeAvailability** field is set to true, the series will only be shown in the Continue Watching row after the subsequent episode is available in the app's search feed.waitForNextEpisodeAvailabilityBooleanOptionalThis field is used for episodic content. Set it to **true** when an episode has been completed and the next episode has not been released yet; otherwise, set it to **false**.  
  
Roku can use this information to show the content in the Continue Watching row whenever the next episode becomes available.  
  
This feature requires a [search feed](https://developer.roku.com/docs/specs/search/search-feed.md) that lists "serial" and "episode" assets.  
  
The following matrix demonstrates how to use this field. In this example, E1 and E2 are available, but E3 has not been released yet.  

| Event | episodeId value | waitForNextEpisodeAvailability flag | Episode shown in Continue Watching row |
| --- | --- | --- | --- |
| Start E1 | E1  | false | E1  |
| Complete E1 | E1  | true | E2  |
| Start E2 | E2  | false | E2  |
| Complete E2 | E2  | true | none |
| E3 becomes available later | \-  | \-  | E3  |
| Start E3 | E3  | false | E3  |
| Complete E3 | E3  | true | none |

profileLabelStringOptionalEnables Roku to label content in the Continue Watching row to identify which profile was watching the content item (this is different than the profileId in the endpoint URL, which is the UUID of the profile used to watch the content).lastInteractionTimeIntegerRequiredThe unix timestamp of the playback event. This is used to help determine the ordering of items in the Continue Watching row. If data is unavailable, use the current epoch time.positionIntegerOptionalThe timestamp of the content item (in seconds) when the playback event occurred.  
  
Providing the **position** and **duration** enables a progress bar that approximates the playback position to be displayed on the content thumbnail in the Continue Watching row (as long as playback has started, but not completed).durationIntegerOptionalTotal running time of the content (in seconds).

#### Example

**URL**:

*   POST [https://userdata.sr.roku.com/user-data/v1/content/continueWatching](https://userdata.sr.roku.com/user-data/v1/content/continueWatching)
*   POST [https://userdata.sr.roku.com/user-data/v1/profile/{profileId}/content/continueWatching](https://userdata.sr.roku.com/user-data/v1/profile/%7BprofileId%7D/content/continueWatching) (app has a profile selection screen)

**JSON body**:

    {
      "items": [
        {
          "contentId": "abc123",
          "episodeId": "def123",
          "lastInteractionTime": 123456,
          "position": 854,
          "duration": 1678,
          "waitForNextEpisodeAvailability": true
        }
      ]
    }
    

### Retrieve API

To retrieve the list of content items in the Continue Watching row, send a **GET** request to the Continue Watching API:

**URL**:

*   GET [https://userdata.sr.roku.com](https://userdata.sr.roku.com/)/user-data/v1/content/continueWatching
*   GET [https://userdata.sr.roku.com](https://userdata.sr.roku.com/)/user-data/v1/profile/{profileId}/content/continueWatching (app has a profile selection screen)

### Update API

To replace the list of content items in the Continue Watching row with a new list, send a **PUT** request to the Continue Watching API with a JSON body containing the same parameters listed in the [Add API section](#add-api):

### Delete API

To remove content items from the Continue Watching row, send a **DELETE** request to the Continue Watching API with a JSON body containing the **contentId** of the item to be removed.

#### Example

**URL**:

*   DELETE [https://userdata.sr.roku.com/user-data/v1/content/continueWatching](https://userdata.sr.roku.com/user-data/v1/content/continueWatching)
*   DELETE [https://userdata.sr.roku.com/user-data/v1/profile/{profileId}/content/continueWatching](https://userdata.sr.roku.com/user-data/v1/profile/%7BprofileId%7D/content/continueWatching) (app has a profile selection screen)

**JSON body**:

    {
      "items": [
        {
          "contentId": "abc123"
        }
      ]
    }
    

Managing user consent
---------------------

If publishers require explicit consent from customers before adding their watched content to the Continue Watching row, it is the publisher's responsibility to implement this. Roku does not provide any mechanisms or APIs for handling user consent for the Continue Watching integration.

Handling deep links from Continue Watching
------------------------------------------

Handling deep links sent to your app from the Continue Watching row is essentially the same as documented [here](/docs/developer-program/discovery/implementing-deep-linking.md). The deep links sent to your app include a **contentId** field with your unique ID for the content to be played, the **mediaType**, which dictates the playback experience, and the user's **profileId** (if your app has a profile selection screen).

**Syntax:**

    http://<roku-device-ip-address>:8060/launch|input/<channelId>?contentId=<contentIdValue>&mediaType=<mediaTypeValue>&profileId=<profileIdValue>
    

**Example:**

    http://192.168.1.4:8060/input/581251?contentId=dev-summit-21-keynote&mediaType=movie&profileId=12345
    

Appendix A: Sample BrightScript code for adding HTTP headers
------------------------------------------------------------

To call the Continue Watching APIs, the app must include BrightScript code that adds the following HTTP headers (see the [**ifHttpAgent.addHeader()** function](/docs/references/brightscript/interfaces/ifhttpagent.md#addheadername-as-string-value-as-string-as-boolean) for more information). You must set the endpoint first before providing the headers.

    'SetUrl needs to be called first
    request.SetUrl("https://userdata.sr.roku.com/user-data/v1/content/continueWatching");
    request.AddHeader("Content-Type","application/json")
    request.AddHeader("x-roku-reserved-jwt", "")
    request.AddHeader("x-roku-reserved-channel-id", "<production app ID>") 'pass the production app ID
    request.AddHeader("x-roku-reserved-channel-store-code", "")
    request.AddHeader("x-roku-reserved-virtual-user-id", "")
    request.AddHeader("x-roku-reserved-device-id", "")
    request.AddHeader("x-roku-reserved-serial-number", "")
    

Appendix B: Integration testing notes
-------------------------------------

Developers can test the Continue Watching integration in both sideloaded and beta environments. Testing should verify that each step in the [integration workflow](#integrating-into-continue-watching) is completed successfully.

#### End-to-end testing

When doing end-to-end testing, launching content from the Continue Watching row will always launch the production app instead of the sideloaded or beta version—even if the production version is not currently integrated with Continue Watching. This is because the app's search feed, which is used by Roku to load content into the Continue Watching row, is always associated with the production app. Testing therefore should focus on adding content to the Continue Watching row when playback starts, updating bookmarks as users stop and resume watching, and removing content when it has been completed.

#### Activating the Continue Watching row on new test devices

When using a Roku device that has not previously been used for testing the Continue Watching integration, the Continue Watching row is not displayed on the **What to Watch** screen until content on the app has been watched. The required watch time for adding the first content item to the Continue Watching row and therefore activating the feature on a new test device is as follows:

*   If the app has a pixel-sharing agreement with Roku, you can watch a few minutes of content. The Continue Watching row should be active after 24 hours.

*   If the app does not have a pixel-sharing agreement with Roku, you should watch two hours of content. The Continue Watching row should be active after 24 hours.

Once the Continue Watching row has displayed the first content item on that device, it will subsequently be updated as different content is watched.

Remote control events
=====================

The SceneGraph architecture supports a notion of remote control key focus. At any time, any node in the SceneGraph node tree can be assigned the remote control key focus. The node with key focus is unique, so when focus is assigned to a node, the currently focused node loses the key focus.

![roku815px - remote-control-events-1](https://image.roku.com/ZHZscHItMTc2/remote-control-events-1-v2.png "remote-control-events-1")

The node with the key focus is given the first opportunity to handle a key event. If that node does not handle the key event, the event is passed up the SceneGraph node tree to the node parent. This continues until a parent node handles the event, or the event moves up to the root of the SceneGraph node tree (that is, a [**Scene**](/docs/references/scenegraph/scene.md) node). The path from the node that has the remote control key focus up to the root of the SceneGraph node tree is referred to as the _focus chain_.

![roku815px - remote-control-events-2](https://image.roku.com/ZHZscHItMTc2/remote-control-events-2-v2.png "remote-control-events-2")

In many cases, there are default remote key event handlers built into the node classes supplied by Roku, and there are default event handlers that are not accessible by application developers as part of the Roku player firmware. If these default event handlers are called at any time as the event moves up the focus chain, the event is considered to have been handled, and a message to that effect is returned to the Roku OS, and no further action to handle the event will take place. For other events that are not handled by default, you have the option of handling the event, or allowing the event to move up the focus chain, and possibly not be handled at all.

Since they are derived from [**roSGNode**](/docs/references/brightscript/components/rosgnode.md), each node includes the [**ifSGNodeFocus**](/docs/references/brightscript/interfaces/ifsgnodefocus.md) interface functions for querying and manipulating the current remote control key focus status of the node. A special function is included in the SceneGraph API, **`onKeyEvent()`**, that allows you handle events, and return a message to the Roku OS that the event has been handled. These two features of the SceneGraph API allow you to selectively control the remote control key focus, and handle remote key press events, as needed for your application. See [**Handling Remote Control Key Presses**](/docs/developer-program/core-concepts/handling-application-events.md#handling-remote-control-key-presses) for complete information on using these features to handle remote control key events.

ifArraySlice
============

Implemented by
--------------

| Name | Description |
| --- | --- |
| [roArray](/docs/references/brightscript/components/roarray.md "roArray") | An array stores an indexed collection of BrightScript objects. Each entry of an array can be a different type, or they may all of the same type. |
| [roByteArray](/docs/references/brightscript/interfaces/ifbytearray.md) | The byte array component is used to contain and manipulate an arbitrary array of bytes |

Supported methods
-----------------

### Slice(\[start\_pos as Integer\[, end\_pos as Integer\]\]) As Object

#### Description

Returns a new array object with a shallow copy of the specified portion of the array.

The **start\_pos** and **end\_pos** fields specify the 0-based indices of items in the array, where the **end\_pos** field represents the position **past** the last element to be copied.

#### Parameters

| Name | Type | Description |
| --- | --- | --- |
| start\_pos | Integer | The 0-based index of first element to copy. A negative index specifies an offset from the end of the array. The default value is 0. |
| end\_pos | Integer | The 0-based index past last element to copy. A negative index indicates an offset from the end of the array. The default value is the array length. |

#### Examples

    '      0       1     2      3      4      5
    arr = ["ape", "bat", "cow", "dog", "elk"]
    
    ' get the 3rd (index 2) and subsequent elements
    arr2 = arr.Slice(2)
    ? FormatJSON(arr2)
    ' => ["cow","dog","elk"]
    
    ' get the 2nd (index 1) through 3rd (index 2) elements
    arr2 = arr.Slice(1, 3)
    ? FormatJSON(arr2)
    ' => ["bat","cow"]
    
    ' get the last 2 elements
    arr2 = arr.Slice(-2)
    ? FormatJSON(arr2)
    ' => ["dog","elk"]
    
    ' empty range
    arr2 = arr.Slice(1, 1)
    ? FormatJSON(arr2)
    ' => []

Developing SceneGraph applications
==================================

Package files should include all the XML components they define in a top level directory named `components` (the top level directory in the app package contains the `manifest` file, the `source` directory, and so forth). When the app is launched all the files with extension `.xml` in the `components` directory are loaded and added to the available types of nodes that can be created.

Currently, packages must include all of the XML component XML files that they use. In the future, we may provide a library of useful XML components for developers as well.

Set up the application directory
--------------------------------

Create an application directory with the following minimum subdirectories and files:

*   `manifest` file
*   `source` directory
*   `components` directory
*   `images` directory

Name this directory for the application it will contain, such as VideoStore. In most cases you will probably just copy an existing application directory (such as provided for the [SceneGraph XML Tutorial](https://github.com/rokudev/samples/tree/master/getting%20started/SceneGraphTutorial)), and modify, add, and rename files and directories for your new application, as described below.

Create or modify a manifest file
--------------------------------

The `manifest` file contains the following fields:

    title=application_title
    subtitle=application_subtitle
    major_version=major_version_number
    minor_version=minor_version_number
    build_version=build_version_number
    
    mm_icon_focus_fhd=FHD_focus_graphic_file_URI``mm_icon_focus_hd=HD_focus_graphic_file_URI
    mm_icon_side_hd=HD_side_graphic_file_URI
    mm_icon_focus_sd=SD_focus_graphic_file_URI
    mm_icon_side_sd=SD_side_graphic_file_URI
    
    splash_screen_sd=SD_splash_screen_graphic_file_URI
    splash_screen_hd=HD_splash_screen_graphic_file_URI
    splash_screen_fhd=HD_splash_screen_graphic_file_URI
    splash_color=color_specifier
    splash_min_time=milliseconds
    

Many of the fields of the `manifest` file are optional or not required for the application to run. The `title` and `subtitle` fields can be useful for debugging, as are the `_version` fields. These can be set to aid debugging various versions of your application, but are not required.

The various _\_graphic\_file\_URI_ field values are used to specify a graphic that allows a user to select your application, and a "splash" screen that appears briefly before the application begins to run, often used while it is still loading.

The four application selection graphic files consist of two files each for both HD and SD user displays, "focus" and "side". These two files are specified in a SceneGraph `manifest` file only for backwards compatibility with past application selection user interfaces. The current SceneGraph application selection user interface only uses the focus graphic file.

The two application splash screen graphic files are for SD and HD user displays. Splash screens are not required but are recommended for your application. The `color_specifier` field value sets a default or opening display screen color before the splash screen loads, or if splash screen graphic files are not specified. The `splash_min_time` field sets the time in milliseconds that the splash screen should be displayed regardless of the load status of the application.

The graphics files specified in the manifest file should be included in the application package `images` directory, so the URI to set the path to the files should use `pkg:` resource prefix, such as `pkg:/images/splash_sd.jpg`. More information about the requirements and recommendations for the graphics files included in the application package can be found in [Set up the images directory](/docs/developer-program/core-concepts/developing-scenegraph-applications.md#set-up-the-images-directory).

The following is an example of a `manifest` file.

**Manifest file example**

    title=Test Application
    subtitle=A SceneGraph Test
    major_version=1
    minor_version=1
    build_version=00001
    
    mm_icon_focus_hd=pkg:/images/MainMenu_Icon_Center_HD.png
    mm_icon_side_hd=pkg:/images/MainMenu_Icon_Side_HD.png
    mm_icon_focus_sd=pkg:/images/MainMenu_Icon_Center_SD43.png
    mm_icon_side_sd=pkg:/images/MainMenu_Icon_Side_SD43.png
    
    splash_screen_sd=pkg:/images/splash_sd.jpg
    splash_screen_hd=pkg:/images/splash_hd.jpg
    splash_color=#000000
    splash_min_time=1000
    

Set up the source directory
---------------------------

The source directory contains BrightScript code for the main applications execution thread, with the extension `.brs`. Since applications including SceneGraph scenes allow BrightScript code to either be embedded in, or used by, an XML component file in a <script> element, for many SceneGraph applications this directory will only contain a `main.brs` file to start the application. The `main.brs` file only need have enough BrightScript code to start the application by creating and displaying the scene specified in the SceneGraph scene.

The following shows a `main.brs` file that starts the application by creating and showing the scene defined in the SceneGraph scene named `rectangleScene` (the `rectangleScene` scene is defined in an XML component file in the `components` directory as described in [Set up the components directory](/docs/developer-program/core-concepts/developing-scenegraph-applications.md#set-up-the-components-directory)).

**Example main.brs file**

    sub Main()
      showChannelSGScreen()
    end sub
    
    sub showChannelSGScreen()
      print "in showChannelSGScreen"
      screen = CreateObject("roSGScreen")
      m.port = CreateObject("roMessagePort")
      screen.setMessagePort(m.port)
      scene = screen.CreateScene("rectangleScene")
      screen.show()
    
      while(true)
        msg = wait(0, m.port)
        msgType = type(msg)
    
        if msgType = "roSGScreenEvent"
        if msg.isScreenClosed() then return
        end if
      end while
    end sub
    

You can use this example `main.brs` file for your SceneGraph applications simply by adding the name of a Screen Graph scene defined in an XML component file, such as `posterScene`, as follows:

`scene = screen.CreateScene("my_scene")`

For example:

`scene = screen.CreateScene("posterScene")`

Similarly, you can control the flow of scenes through your application by creating and showing scenes as needed:

    screen = CreateObject("roSGScreen")
    m.port = CreateObject("roMessagePort")
    screen.setMessagePort(m.port)
    scene = screen.CreateScene("another_scene")
    screen.show()
    

Set up the components directory
-------------------------------

The `components` directory contains all the XML component and associated BrightScript code files needed for your SceneGraph scene. The XML files must have the extension `.xml`, and as usual, BrightScript code files must have the extension `.brs`.

Each XML component file contains a single <component> element that contains a specific SceneGraph node/element tree defining that component.

For example:

**Example SceneGraph XML component file**

    <?xml version="1.0" encoding="utf-8" ?>
    
    <component name="rectangleScene" extends="Scene" >
    
    <script type="text/brightscript" >
    <![CDATA[
    
    
    sub init()
      m.top.setFocus(true)
    end sub
    ]]>
    </script>
    
    <children>
    <Rectangle
      id="bottomRectangle"
      color="0x0000FFFF"
      width="1280"
      height="60"
      translation="[0,620]"
    />
    </children>
    
    </component>
    

In the above example, the SceneGraph component is a definition of a Scene node class named `rectangleScene`. The component definition consists of a <script> element, which defines some BrightScript code to be used to initialize `rectangleScene`, and a Rectangle node definition, that defines the location, size, and color of a rectangle to be shown on the display screen, with a node ID of `bottomRectangle`.

Complete information on creating XML component files and associated BrightScript code for your SceneGraph application can be found in:

*   [SceneGraph core concepts](/docs/developer-program/core-concepts/core-concepts.md)
*   [SceneGraph Samples](https://github.com/rokudev/samples/tree/master/ux%20components)
*   [SceneGraph API reference](/docs/references/scenegraph/component-functions/init.md)

Set up the images directory
---------------------------

Any graphic image files to be included in the application package itself should be copied into the `images` directory. As a minimum, the `images` directory _must_ contain the application selection and splash screen graphic files described in [Create or modify a manifest file](/docs/developer-program/core-concepts/developing-scenegraph-applications.md#create-or-modify-a-manifest-file) above. Other graphic files used in the application that will not be downloaded from your server should also be copied into the `images` directory.

roPath
======

The roPath component provides developers an easy way to create valid file system paths.

The roPath component is a convenience class that implements [ifString](/docs/references/brightscript/interfaces/ifstring.md "ifString") while providing additional validation and path inspection functionality. See [File System](/docs/developer-program/getting-started/architecture/file-system.md "File System") for more information about valid path names.

This object is created with a string that represents the initial path:

`CreateObject("roPath", "ext1:/vid")`

**Example**

    path = CreateObject("roPath", filename)
    parts = path.Split()
    if parts.phy = "tmp:" then print "this is a temp file"
    if parts.extension = ".bmp" then print "this is a bitmap file"
    

Supported interfaces
--------------------

*   [ifPath](/docs/references/brightscript/interfaces/ifpath.md "ifPath")
*   [ifString](/docs/references/brightscript/interfaces/ifstring.md "ifString")

roDataGramSocket
================

The roDataGramSocket component enables Brightscript apps to send and receive UDP packets. The interface is modeled on and works much like standard Berkeley sockets.

This object is created without any arguments:

`CreateObject("roDataGramSocket")`

**Example**

    ' UDP 2-way peer-to-peer asynchronous comm on port 54321
    ' periodically sends out a message to a specific address and port
    ' prints any message it receives
    Function UDPPeer()
        msgPort = createobject("roMessagePort")
        udp = createobject("roDatagramSocket")
        udp.setMessagePort(msgPort) 'notifications for udp come to msgPort
        addr = createobject("roSocketAddress")
        addr.setPort(54321)
        udp.setAddress(addr) ' bind to all host addresses on port 54321
        addr.SetHostName("10.1.1.1")
        udp.setSendToAddress(addr) ' peer IP and port
        udp.notifyReadable(true)
        timeout = 1 * 10 * 1000 ' ten seconds in milliseconds
        deviceName = Createobject("roDeviceInfo").GetFriendlyName()
        message = "Datagram from " + deviceName
        udp.sendStr(message)
        continue = udp.eOK()
        While continue
            event = wait(timeout, msgPort)
            If type(event)="roSocketEvent"
            If event.getSocketID()=udp.getID()
                    If udp.isReadable()
                        message = udp.receiveStr(512) ' max 512 characters
                        print "Received message: '"; message; "'"
                    End If
                End If
            Else If event=invalid
                print "Timeout"
                udp.sendStr(message) ' periodic send
            End If
        End While
        udp.close() ' would happen automatically as udp goes out of scope
    
    End Function
    

> GetDeviceUniqueId() was deprecated in Spring OS 2019.

Supported interfaces
--------------------

*   [ifSocket](/docs/references/brightscript/interfaces/ifsocket.md "ifSocket")
*   [ifSocketAsync](/docs/references/brightscript/interfaces/ifsocketasync.md "ifSocketAsync")
*   [ifSocketStatus](/docs/references/brightscript/interfaces/ifsocketstatus.md "ifSocketStatus")
*   [ifSocketOption](/docs/references/brightscript/interfaces/ifsocketoption.md "ifSocketOption")
*   [ifSocketCastOption](/docs/references/brightscript/interfaces/ifsocketcastoption.md "ifSocketCastOption ")

> Some legacy Roku OS versions may implement ifSocketCastOption as ifSocketCast.

Supported events
----------------

*   [roSocketEvent](/docs/references/brightscript/events/rosocketevent.md "roSocketEvent ")

DynamicKeyGrid
==============

Extends [**Group**](/docs/references/scenegraph/layout-group-nodes/group.md "**Group**")

The **DynamicKeyGrid** node implements a grid of keys that are defined and organized in a [Key Definition File](/docs/references/scenegraph/dynamic-voice-keyboard-nodes/key-definition-file.md). It is typically used in a subclass of the [DynamicKeyboardBase](/docs/references/scenegraph/dynamic-voice-keyboard-nodes/dynamic-keyboard-base.md) node (DynamicKeyboard, DynamicPinPad, and DynamicMiniKeyboard) to display the string of characters entered via text or voice entry. It may also be used as an individual node.

Fields
------

FieldTypeDefaultAccess PermissionDescriptionkeyDefinitionUriuri""READ\_WRITESpecifies the [Key Definition File](/docs/references/scenegraph/dynamic-voice-keyboard-nodes/key-definition-file.md) to use to define the key layout metadata.modestring""READ\_WRITESpecifies the keyboard mode. When set, the value is used to select which Grid of each Section is used, based on the grid's mode as specified in the Key Definition File.focusVisiblebooleantrueREAD\_WRITEEnables the grid's focus indicator to be hidden. This option is typically used in PinPads to hide the entered characters.horizWrapbooleanfalseREAD\_WRITESpecifies whether the key grid uses horizontal wrapping.  

*   **true**: A horizontal arrow keypress causes the focus to wrap from the key at the left (or right) edge of the grid to the key at the right (or left) edge.
*   **false**: The horizontal arrow keypress is not handled by the DynamicKeyGrid node; it is propagated up the scene graph so that it can be handled by one of its ancestor nodes.

vertWrapbooleanfalseREAD\_WRITESpecifies whether the key grid uses vertical wrapping.  

*   **true**: A vertical arrow keypress causes the focus to wrap from the key at the top (or bottom) edge of the grid to the key at the bottom (or top) edge.
*   **false**: The vertical arrow key press is not be handled by the DynamicKeyGrid node; it is propagated up the scene graph so that it can be handled by one of its ancestor nodes.

paletteRSGPalette nodenot setREAD\_WRITEThe [RSGPalette node](/docs/references/scenegraph/scene.md) contains the set of color values used by this DynamicKeyGrid node. By default, no RSGPalette is specified; therefore, the RSGPalette colors are inherited from the ancestor nodes in the scene graph.  
  
If the DynamicKeyboardBase node is used within a StandardDialog node, the following rules determine the color palette used by the keyboard:  

*   If the **palette** field is set, the key grid uses it.
*   If the **palette** field is not set, the key grid looks up the scene graph until it finds a **PaletteGroup** node with its **palette** field set. This may be found in a **DynamicKeyboard** node, a **StandardDialog** node, or the **Scene** itself.
*   If no node has its **palette** field set, the key grid uses the default palette (gray background/white text).

  
The RSGPalette color values used by the DynamicKeyboardBase are as follows:  

| Palette Color Name | Usages |
| --- | --- |
| KeyboardColor | Blend color for key background bitmap. |
| PrimaryTextColor | Text color used for non-focused keys.  <br>Blend color for the icons of non-focused keys.  <br>Text color for the label of focused key suggestion items. |
| SecondaryItemColor | Text color for disabled keys.  <br>Blend color for the icons of disabled keys. |
| FocusColor | Blend color for the focus indicator.  <br>Blend color for the background of key suggestion pop-us. |
| FocusItemColor | Text color for the label of the focused key.  <br>Blend color for the icons of the focused key and the focus indicator in key suggestion pop-ups.  <br>Text color for the labels of non-focused key suggestion items. |

keyFocusedstring""READSpecifies the appearance of a key when it receives focus, based on the key's **strOut** value.  

*   If the key's **strOut** value (as specified in the Key Definition File) is non-empty, this field is set to the **strOut** value.
*   If **strOut** is an empty string, this field is set to the key's label string.

keySelectedstring""READSpecifies the appearance of a key when it is selected, based on the key's **strOut** value.  

*   If the key's **strOut** value (as specified in the Key Definition File) is non-empty, this field is set to the **strOut** value.
*   If **strOut** is an empty string, this field is set to the key's label string.

jumpToKeyarray of integersN/AWRITEJumps the grid to the key to the coordinates specified in the provided array. The array must contain a valid section, row and key index for the current keyboard mode. If the array specifies an invalid key, no jump occurs.disableKeystring""WRITE-ONLYDraws the key's label or icon with a disabled appearance and prevents the key from gaining focus.  
  
If the key has focus when it becomes disabled, the focus is automatically moved to an adjacent key that is not disabled (the key above the disabled key is checked first, then the key below, to the right, and then to the left).  
  
To disable/enable a key, set the respective field to the key's **label** or **StrOut** value as defined in the Key Definition File. For example, to disable the "backspace" key, which typically has a delete icon displayed on the keyboard, enter the following: m.keyboard.keyGrid.disableKey = "backspace".  
  
Multiple keys may be disabled at any time by setting the write-only **disableKey** field once for each key to be disabled.enableKeystring""WRITE-ONLYDraws the key's label or icon with an enabled appearance and allows the key to gain focus.  
  
To disable/enable a key, set the respective field to the key's **label** or **StrOut** value as defined in the KDF file. For example, to enable the "backspace" key, which typically has a delete icon displayed on the keyboard, enter the following: m.keyboard.keyGrid.enableKey = "backspace".  
  
Multiple disabled keys may be re-enabled at any time by setting the write-only **enableKey** field once for each key to be enabled.

